[{"idx": "cosqa-train-16000", "doc": "how to hidden controls of frame in python", "code": "def hide(self):\n        \"\"\"Hides the main window of the terminal and sets the visible\n        flag to False.\n        \"\"\"\n        if not HidePrevention(self.window).may_hide():\n            return\n        self.hidden = True\n        self.get_widget('window-root').unstick()\n        self.window.hide()", "code_tokens": "def hide ( self ) : if not HidePrevention ( self . window ) . may_hide ( ) : return self . hidden = True self . get_widget ( 'window-root' ) . unstick ( ) self . window . hide ( )", "docstring_tokens": "Hides the main window of the terminal and sets the visible flag to False .", "label": 1}, {"idx": "cosqa-train-16001", "doc": "python release memory after function call", "code": "def close( self ):\n        \"\"\"\n        Close the db and release memory\n        \"\"\"\n        if self.db is not None:\n            self.db.commit()\n            self.db.close()\n            self.db = None\n\n        return", "code_tokens": "def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return", "docstring_tokens": "Close the db and release memory", "label": 0}, {"idx": "cosqa-train-16002", "doc": "how to hide comment in python", "code": "def strip_comment_marker(text):\n    \"\"\" Strip # markers at the front of a block of comment text.\n    \"\"\"\n    lines = []\n    for line in text.splitlines():\n        lines.append(line.lstrip('#'))\n    text = textwrap.dedent('\\n'.join(lines))\n    return text", "code_tokens": "def strip_comment_marker ( text ) : lines = [ ] for line in text . splitlines ( ) : lines . append ( line . lstrip ( '#' ) ) text = textwrap . dedent ( '\\n' . join ( lines ) ) return text", "docstring_tokens": "Strip # markers at the front of a block of comment text .", "label": 0}, {"idx": "cosqa-train-16003", "doc": "python remove all element in dictionary whose", "code": "def filter_dict_by_key(d, keys):\n    \"\"\"Filter the dict *d* to remove keys not in *keys*.\"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": "def filter_dict_by_key ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "docstring_tokens": "Filter the dict * d * to remove keys not in * keys * .", "label": 0}, {"idx": "cosqa-train-16004", "doc": "how to identify columsn with missing data in python 3", "code": "def table_nan_locs(table):\n    \"\"\"\n    from http://stackoverflow.com/a/14033137/623735\n    # gets the indices of the rows with nan values in a dataframe\n    pd.isnull(df).any(1).nonzero()[0]\n    \"\"\"\n    ans = []\n    for rownum, row in enumerate(table):\n        try:\n            if pd.isnull(row).any():\n                colnums = pd.isnull(row).nonzero()[0]\n                ans += [(rownum, colnum) for colnum in colnums]\n        except AttributeError:  # table is really just a sequence of scalars\n            if pd.isnull(row):\n                ans += [(rownum, 0)]\n    return ans", "code_tokens": "def table_nan_locs ( table ) : ans = [ ] for rownum , row in enumerate ( table ) : try : if pd . isnull ( row ) . any ( ) : colnums = pd . isnull ( row ) . nonzero ( ) [ 0 ] ans += [ ( rownum , colnum ) for colnum in colnums ] except AttributeError : # table is really just a sequence of scalars if pd . isnull ( row ) : ans += [ ( rownum , 0 ) ] return ans", "docstring_tokens": "from http : // stackoverflow . com / a / 14033137 / 623735 # gets the indices of the rows with nan values in a dataframe pd . isnull ( df ) . any ( 1 ) . nonzero () [ 0 ]", "label": 1}, {"idx": "cosqa-train-16005", "doc": "python remove all files not in a list", "code": "def strip_sdist_extras(filelist):\n    \"\"\"Strip generated files that are only present in source distributions.\n\n    We also strip files that are ignored for other reasons, like\n    command line arguments, setup.cfg rules or MANIFEST.in rules.\n    \"\"\"\n    return [name for name in filelist\n            if not file_matches(name, IGNORE)\n            and not file_matches_regexps(name, IGNORE_REGEXPS)]", "code_tokens": "def strip_sdist_extras ( filelist ) : return [ name for name in filelist if not file_matches ( name , IGNORE ) and not file_matches_regexps ( name , IGNORE_REGEXPS ) ]", "docstring_tokens": "Strip generated files that are only present in source distributions .", "label": 0}, {"idx": "cosqa-train-16006", "doc": "how to increase coverage in unit testing python", "code": "def coverage(ctx, opts=\"\"):\n    \"\"\"\n    Execute all tests (normal and slow) with coverage enabled.\n    \"\"\"\n    return test(ctx, coverage=True, include_slow=True, opts=opts)", "code_tokens": "def coverage ( ctx , opts = \"\" ) : return test ( ctx , coverage = True , include_slow = True , opts = opts )", "docstring_tokens": "Execute all tests ( normal and slow ) with coverage enabled .", "label": 0}, {"idx": "cosqa-train-16007", "doc": "python remove all zeros from a list", "code": "def _remove_blank(l):\n        \"\"\" Removes trailing zeros in the list of integers and returns a new list of integers\"\"\"\n        ret = []\n        for i, _ in enumerate(l):\n            if l[i] == 0:\n                break\n            ret.append(l[i])\n        return ret", "code_tokens": "def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret", "docstring_tokens": "Removes trailing zeros in the list of integers and returns a new list of integers", "label": 0}, {"idx": "cosqa-train-16008", "doc": "how to inspect a function python", "code": "def init_checks_registry():\n    \"\"\"Register all globally visible functions.\n\n    The first argument name is either 'physical_line' or 'logical_line'.\n    \"\"\"\n    mod = inspect.getmodule(register_check)\n    for (name, function) in inspect.getmembers(mod, inspect.isfunction):\n        register_check(function)", "code_tokens": "def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )", "docstring_tokens": "Register all globally visible functions .", "label": 1}, {"idx": "cosqa-train-16009", "doc": "python remove any white spaces from string", "code": "def unpunctuate(s, *, char_blacklist=string.punctuation):\n    \"\"\" Remove punctuation from string s. \"\"\"\n    # remove punctuation\n    s = \"\".join(c for c in s if c not in char_blacklist)\n    # remove consecutive spaces\n    return \" \".join(filter(None, s.split(\" \")))", "code_tokens": "def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "docstring_tokens": "Remove punctuation from string s .", "label": 0}, {"idx": "cosqa-train-16010", "doc": "how to interpolate logarithmic in python", "code": "def interpolate_logscale_single(start, end, coefficient):\n    \"\"\" Cosine interpolation \"\"\"\n    return np.exp(np.log(start) + (np.log(end) - np.log(start)) * coefficient)", "code_tokens": "def interpolate_logscale_single ( start , end , coefficient ) : return np . exp ( np . log ( start ) + ( np . log ( end ) - np . log ( start ) ) * coefficient )", "docstring_tokens": "Cosine interpolation", "label": 0}, {"idx": "cosqa-train-16011", "doc": "python remove comma from list", "code": "def __normalize_list(self, msg):\n        \"\"\"Split message to list by commas and trim whitespace.\"\"\"\n        if isinstance(msg, list):\n            msg = \"\".join(msg)\n        return list(map(lambda x: x.strip(), msg.split(\",\")))", "code_tokens": "def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = \"\" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( \",\" ) ) )", "docstring_tokens": "Split message to list by commas and trim whitespace .", "label": 1}, {"idx": "cosqa-train-16012", "doc": "how to keep prompt in python", "code": "def _normal_prompt(self):\n        \"\"\"\n        Flushes the prompt before requesting the input\n\n        :return: The command line\n        \"\"\"\n        sys.stdout.write(self.__get_ps1())\n        sys.stdout.flush()\n        return safe_input()", "code_tokens": "def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "docstring_tokens": "Flushes the prompt before requesting the input", "label": 0}, {"idx": "cosqa-train-16013", "doc": "python remove commas from list string", "code": "def _str_to_list(s):\n    \"\"\"Converts a comma separated string to a list\"\"\"\n    _list = s.split(\",\")\n    return list(map(lambda i: i.lstrip(), _list))", "code_tokens": "def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "docstring_tokens": "Converts a comma separated string to a list", "label": 0}, {"idx": "cosqa-train-16014", "doc": "how to limit a float in python", "code": "def open01(x, limit=1.e-6):\n    \"\"\"Constrain numbers to (0,1) interval\"\"\"\n    try:\n        return np.array([min(max(y, limit), 1. - limit) for y in x])\n    except TypeError:\n        return min(max(x, limit), 1. - limit)", "code_tokens": "def open01 ( x , limit = 1.e-6 ) : try : return np . array ( [ min ( max ( y , limit ) , 1. - limit ) for y in x ] ) except TypeError : return min ( max ( x , limit ) , 1. - limit )", "docstring_tokens": "Constrain numbers to ( 0 1 ) interval", "label": 0}, {"idx": "cosqa-train-16015", "doc": "python remove dictionary element", "code": "def pop (self, key):\n        \"\"\"Remove key from dict and return value.\"\"\"\n        if key in self._keys:\n            self._keys.remove(key)\n        super(ListDict, self).pop(key)", "code_tokens": "def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )", "docstring_tokens": "Remove key from dict and return value .", "label": 0}, {"idx": "cosqa-train-16016", "doc": "how to limit the decimals in python", "code": "def roundClosestValid(val, res, decimals=None):\n        \"\"\" round to closest resolution \"\"\"\n        if decimals is None and \".\" in str(res):\n            decimals = len(str(res).split('.')[1])\n\n        return round(round(val / res) * res, decimals)", "code_tokens": "def roundClosestValid ( val , res , decimals = None ) : if decimals is None and \".\" in str ( res ) : decimals = len ( str ( res ) . split ( '.' ) [ 1 ] ) return round ( round ( val / res ) * res , decimals )", "docstring_tokens": "round to closest resolution", "label": 1}, {"idx": "cosqa-train-16017", "doc": "python remove dictionary object if has attribute", "code": "def _remove_dict_keys_with_value(dict_, val):\n  \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"\n  return {k: v for k, v in dict_.items() if v is not val}", "code_tokens": "def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "docstring_tokens": "Removes dict keys which have have self as value .", "label": 0}, {"idx": "cosqa-train-16018", "doc": "how to linear fit in python for some points", "code": "def apply_fit(xy,coeffs):\n    \"\"\" Apply the coefficients from a linear fit to\n        an array of x,y positions.\n\n        The coeffs come from the 'coeffs' member of the\n        'fit_arrays()' output.\n    \"\"\"\n    x_new = coeffs[0][2] + coeffs[0][0]*xy[:,0] + coeffs[0][1]*xy[:,1]\n    y_new = coeffs[1][2] + coeffs[1][0]*xy[:,0] + coeffs[1][1]*xy[:,1]\n\n    return x_new,y_new", "code_tokens": "def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "docstring_tokens": "Apply the coefficients from a linear fit to an array of x y positions .", "label": 0}, {"idx": "cosqa-train-16019", "doc": "python remove files by extension", "code": "def clean_py_files(path):\n    \"\"\"\n    Removes all .py files.\n\n    :param path: the path\n    :return: None\n    \"\"\"\n\n    for dirname, subdirlist, filelist in os.walk(path):\n\n        for f in filelist:\n            if f.endswith('py'):\n                os.remove(os.path.join(dirname, f))", "code_tokens": "def clean_py_files ( path ) : for dirname , subdirlist , filelist in os . walk ( path ) : for f in filelist : if f . endswith ( 'py' ) : os . remove ( os . path . join ( dirname , f ) )", "docstring_tokens": "Removes all . py files .", "label": 0}, {"idx": "cosqa-train-16020", "doc": "how to list the properties of a variable in python", "code": "def get_param_names(cls):\n        \"\"\"Returns a list of plottable CBC parameter variables\"\"\"\n        return [m[0] for m in inspect.getmembers(cls) \\\n            if type(m[1]) == property]", "code_tokens": "def get_param_names ( cls ) : return [ m [ 0 ] for m in inspect . getmembers ( cls ) if type ( m [ 1 ] ) == property ]", "docstring_tokens": "Returns a list of plottable CBC parameter variables", "label": 0}, {"idx": "cosqa-train-16021", "doc": "how to load a dot max file into python", "code": "def graph_from_dot_file(path):\n    \"\"\"Load graph as defined by a DOT file.\n    \n    The file is assumed to be in DOT format. It will\n    be loaded, parsed and a Dot class will be returned, \n    representing the graph.\n    \"\"\"\n    \n    fd = file(path, 'rb')\n    data = fd.read()\n    fd.close()\n    \n    return graph_from_dot_data(data)", "code_tokens": "def graph_from_dot_file ( path ) : fd = file ( path , 'rb' ) data = fd . read ( ) fd . close ( ) return graph_from_dot_data ( data )", "docstring_tokens": "Load graph as defined by a DOT file . The file is assumed to be in DOT format . It will be loaded parsed and a Dot class will be returned representing the graph .", "label": 0}, {"idx": "cosqa-train-16022", "doc": "python remove html from string", "code": "def strip_html(string, keep_tag_content=False):\n    \"\"\"\n    Remove html code contained into the given string.\n\n    :param string: String to manipulate.\n    :type string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    :rtype: str\n    \"\"\"\n    r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE\n    return r.sub('', string)", "code_tokens": "def strip_html ( string , keep_tag_content = False ) : r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE return r . sub ( '' , string )", "docstring_tokens": "Remove html code contained into the given string .", "label": 1}, {"idx": "cosqa-train-16023", "doc": "how to load a string file in python", "code": "def load_feature(fname, language):\n    \"\"\" Load and parse a feature file. \"\"\"\n\n    fname = os.path.abspath(fname)\n    feat = parse_file(fname, language)\n    return feat", "code_tokens": "def load_feature ( fname , language ) : fname = os . path . abspath ( fname ) feat = parse_file ( fname , language ) return feat", "docstring_tokens": "Load and parse a feature file .", "label": 1}, {"idx": "cosqa-train-16024", "doc": "python remove item from heap", "code": "def pop(h):\n    \"\"\"Pop the heap value from the heap.\"\"\"\n    n = h.size() - 1\n    h.swap(0, n)\n    down(h, 0, n)\n    return h.pop()", "code_tokens": "def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )", "docstring_tokens": "Pop the heap value from the heap .", "label": 0}, {"idx": "cosqa-train-16025", "doc": "how to load data from url with python", "code": "def get(url):\n    \"\"\"Recieving the JSON file from uulm\"\"\"\n    response = urllib.request.urlopen(url)\n    data = response.read()\n    data = data.decode(\"utf-8\")\n    data = json.loads(data)\n    return data", "code_tokens": "def get ( url ) : response = urllib . request . urlopen ( url ) data = response . read ( ) data = data . decode ( \"utf-8\" ) data = json . loads ( data ) return data", "docstring_tokens": "Recieving the JSON file from uulm", "label": 1}, {"idx": "cosqa-train-16026", "doc": "python remove legend from plot", "code": "def remove_legend(ax=None):\n    \"\"\"Remove legend for axes or gca.\n\n    See http://osdir.com/ml/python.matplotlib.general/2005-07/msg00285.html\n    \"\"\"\n    from pylab import gca, draw\n    if ax is None:\n        ax = gca()\n    ax.legend_ = None\n    draw()", "code_tokens": "def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )", "docstring_tokens": "Remove legend for axes or gca .", "label": 0}, {"idx": "cosqa-train-16027", "doc": "how to log errors in python", "code": "def print_log(text, *colors):\n    \"\"\"Print a log message to standard error.\"\"\"\n    sys.stderr.write(sprint(\"{}: {}\".format(script_name, text), *colors) + \"\\n\")", "code_tokens": "def print_log ( text , * colors ) : sys . stderr . write ( sprint ( \"{}: {}\" . format ( script_name , text ) , * colors ) + \"\\n\" )", "docstring_tokens": "Print a log message to standard error .", "label": 1}, {"idx": "cosqa-train-16028", "doc": "python remove linebreak inside string", "code": "def replaceNewlines(string, newlineChar):\n\t\"\"\"There's probably a way to do this with string functions but I was lazy.\n\t\tReplace all instances of \\r or \\n in a string with something else.\"\"\"\n\tif newlineChar in string:\n\t\tsegments = string.split(newlineChar)\n\t\tstring = \"\"\n\t\tfor segment in segments:\n\t\t\tstring += segment\n\treturn string", "code_tokens": "def replaceNewlines ( string , newlineChar ) : if newlineChar in string : segments = string . split ( newlineChar ) string = \"\" for segment in segments : string += segment return string", "docstring_tokens": "There s probably a way to do this with string functions but I was lazy . Replace all instances of \\ r or \\ n in a string with something else .", "label": 0}, {"idx": "cosqa-train-16029", "doc": "how to loop through python iterator without stopiteration error", "code": "def next(self):\n        \"\"\"Provides hook for Python2 iterator functionality.\"\"\"\n        _LOGGER.debug(\"reading next\")\n        if self.closed:\n            _LOGGER.debug(\"stream is closed\")\n            raise StopIteration()\n\n        line = self.readline()\n        if not line:\n            _LOGGER.debug(\"nothing more to read\")\n            raise StopIteration()\n\n        return line", "code_tokens": "def next ( self ) : _LOGGER . debug ( \"reading next\" ) if self . closed : _LOGGER . debug ( \"stream is closed\" ) raise StopIteration ( ) line = self . readline ( ) if not line : _LOGGER . debug ( \"nothing more to read\" ) raise StopIteration ( ) return line", "docstring_tokens": "Provides hook for Python2 iterator functionality .", "label": 0}, {"idx": "cosqa-train-16030", "doc": "python remove new line character from string\\", "code": "def replaceNewlines(string, newlineChar):\n\t\"\"\"There's probably a way to do this with string functions but I was lazy.\n\t\tReplace all instances of \\r or \\n in a string with something else.\"\"\"\n\tif newlineChar in string:\n\t\tsegments = string.split(newlineChar)\n\t\tstring = \"\"\n\t\tfor segment in segments:\n\t\t\tstring += segment\n\treturn string", "code_tokens": "def replaceNewlines ( string , newlineChar ) : if newlineChar in string : segments = string . split ( newlineChar ) string = \"\" for segment in segments : string += segment return string", "docstring_tokens": "There s probably a way to do this with string functions but I was lazy . Replace all instances of \\ r or \\ n in a string with something else .", "label": 1}, {"idx": "cosqa-train-16031", "doc": "how to make a character in dot format python", "code": "def _dotify(cls, data):\n    \"\"\"Add dots.\"\"\"\n    return ''.join(char if char in cls.PRINTABLE_DATA else '.' for char in data)", "code_tokens": "def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )", "docstring_tokens": "Add dots .", "label": 0}, {"idx": "cosqa-train-16032", "doc": "python remove non english letter", "code": "def clean(self, text):\n        \"\"\"Remove all unwanted characters from text.\"\"\"\n        return ''.join([c for c in text if c in self.alphabet])", "code_tokens": "def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )", "docstring_tokens": "Remove all unwanted characters from text .", "label": 0}, {"idx": "cosqa-train-16033", "doc": "how to make a histogram in python multiple datasets", "code": "def PyplotHistogram():\n    \"\"\"\n    =============================================================\n    Demo of the histogram (hist) function with multiple data sets\n    =============================================================\n\n    Plot histogram with multiple sample sets and demonstrate:\n\n        * Use of legend with multiple sample sets\n        * Stacked bars\n        * Step curve with no fill\n        * Data sets of different sample sizes\n\n    Selecting different bin counts and sizes can significantly affect the\n    shape of a histogram. The Astropy docs have a great section on how to\n    select these parameters:\n    http://docs.astropy.org/en/stable/visualization/histogram.html\n    \"\"\"\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    np.random.seed(0)\n\n    n_bins = 10\n    x = np.random.randn(1000, 3)\n\n    fig, axes = plt.subplots(nrows=2, ncols=2)\n    ax0, ax1, ax2, ax3 = axes.flatten()\n\n    colors = ['red', 'tan', 'lime']\n    ax0.hist(x, n_bins, normed=1, histtype='bar', color=colors, label=colors)\n    ax0.legend(prop={'size': 10})\n    ax0.set_title('bars with legend')\n\n    ax1.hist(x, n_bins, normed=1, histtype='bar', stacked=True)\n    ax1.set_title('stacked bar')\n\n    ax2.hist(x, n_bins, histtype='step', stacked=True, fill=False)\n    ax2.set_title('stack step (unfilled)')\n\n    # Make a multiple-histogram of data-sets with different length.\n    x_multi = [np.random.randn(n) for n in [10000, 5000, 2000]]\n    ax3.hist(x_multi, n_bins, histtype='bar')\n    ax3.set_title('different sample sizes')\n\n    fig.tight_layout()\n    return fig", "code_tokens": "def PyplotHistogram ( ) : import numpy as np import matplotlib . pyplot as plt np . random . seed ( 0 ) n_bins = 10 x = np . random . randn ( 1000 , 3 ) fig , axes = plt . subplots ( nrows = 2 , ncols = 2 ) ax0 , ax1 , ax2 , ax3 = axes . flatten ( ) colors = [ 'red' , 'tan' , 'lime' ] ax0 . hist ( x , n_bins , normed = 1 , histtype = 'bar' , color = colors , label = colors ) ax0 . legend ( prop = { 'size' : 10 } ) ax0 . set_title ( 'bars with legend' ) ax1 . hist ( x , n_bins , normed = 1 , histtype = 'bar' , stacked = True ) ax1 . set_title ( 'stacked bar' ) ax2 . hist ( x , n_bins , histtype = 'step' , stacked = True , fill = False ) ax2 . set_title ( 'stack step (unfilled)' ) # Make a multiple-histogram of data-sets with different length. x_multi = [ np . random . randn ( n ) for n in [ 10000 , 5000 , 2000 ] ] ax3 . hist ( x_multi , n_bins , histtype = 'bar' ) ax3 . set_title ( 'different sample sizes' ) fig . tight_layout ( ) return fig", "docstring_tokens": "============================================================= Demo of the histogram ( hist ) function with multiple data sets =============================================================", "label": 0}, {"idx": "cosqa-train-16034", "doc": "python remove space multiple", "code": "def normalize_value(text):\n    \"\"\"\n    This removes newlines and multiple spaces from a string.\n    \"\"\"\n    result = text.replace('\\n', ' ')\n    result = re.subn('[ ]{2,}', ' ', result)[0]\n    return result", "code_tokens": "def normalize_value ( text ) : result = text . replace ( '\\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result", "docstring_tokens": "This removes newlines and multiple spaces from a string .", "label": 1}, {"idx": "cosqa-train-16035", "doc": "how to make a max heap in python heapq", "code": "def _heappush_max(heap, item):\n    \"\"\" why is this not in heapq \"\"\"\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap) - 1)", "code_tokens": "def _heappush_max ( heap , item ) : heap . append ( item ) heapq . _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "docstring_tokens": "why is this not in heapq", "label": 0}, {"idx": "cosqa-train-16036", "doc": "python remove stopwords from a dictionary", "code": "def _remove_keywords(d):\n    \"\"\"\n    copy the dict, filter_keywords\n\n    Parameters\n    ----------\n    d : dict\n    \"\"\"\n    return { k:v for k, v in iteritems(d) if k not in RESERVED }", "code_tokens": "def _remove_keywords ( d ) : return { k : v for k , v in iteritems ( d ) if k not in RESERVED }", "docstring_tokens": "copy the dict filter_keywords", "label": 0}, {"idx": "cosqa-train-16037", "doc": "python remove whitespace line", "code": "def clean(s):\n  \"\"\"Removes trailing whitespace on each line.\"\"\"\n  lines = [l.rstrip() for l in s.split('\\n')]\n  return '\\n'.join(lines)", "code_tokens": "def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\\n' ) ] return '\\n' . join ( lines )", "docstring_tokens": "Removes trailing whitespace on each line .", "label": 1}, {"idx": "cosqa-train-16038", "doc": "how to make a scrollbar in python tkinter", "code": "def __grid_widgets(self):\n        \"\"\"Places all the child widgets in the appropriate positions.\"\"\"\n        scrollbar_column = 0 if self.__compound is tk.LEFT else 2\n        self._canvas.grid(row=0, column=1, sticky=\"nswe\")\n        self._scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")", "code_tokens": "def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = \"nswe\" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = \"ns\" )", "docstring_tokens": "Places all the child widgets in the appropriate positions .", "label": 0}, {"idx": "cosqa-train-16039", "doc": "python repalce all backslash characters", "code": "def unescape(str):\n    \"\"\"Undoes the effects of the escape() function.\"\"\"\n    out = ''\n    prev_backslash = False\n    for char in str:\n        if not prev_backslash and char == '\\\\':\n            prev_backslash = True\n            continue\n        out += char\n        prev_backslash = False\n    return out", "code_tokens": "def unescape ( str ) : out = '' prev_backslash = False for char in str : if not prev_backslash and char == '\\\\' : prev_backslash = True continue out += char prev_backslash = False return out", "docstring_tokens": "Undoes the effects of the escape () function .", "label": 0}, {"idx": "cosqa-train-16040", "doc": "how to make a sentence into underscores with python", "code": "def us2mc(string):\n    \"\"\"Transform an underscore_case string to a mixedCase string\"\"\"\n    return re.sub(r'_([a-z])', lambda m: (m.group(1).upper()), string)", "code_tokens": "def us2mc ( string ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , string )", "docstring_tokens": "Transform an underscore_case string to a mixedCase string", "label": 1}, {"idx": "cosqa-train-16041", "doc": "python repeat try catch block", "code": "def retry_call(func, cleanup=lambda: None, retries=0, trap=()):\n\t\"\"\"\n\tGiven a callable func, trap the indicated exceptions\n\tfor up to 'retries' times, invoking cleanup on the\n\texception. On the final attempt, allow any exceptions\n\tto propagate.\n\t\"\"\"\n\tattempts = count() if retries == float('inf') else range(retries)\n\tfor attempt in attempts:\n\t\ttry:\n\t\t\treturn func()\n\t\texcept trap:\n\t\t\tcleanup()\n\n\treturn func()", "code_tokens": "def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )", "docstring_tokens": "Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate .", "label": 1}, {"idx": "cosqa-train-16042", "doc": "how to make a str all lowercasein python", "code": "def to_camel(s):\n    \"\"\"\n    :param string s: under_scored string to be CamelCased\n    :return: CamelCase version of input\n    :rtype: str\n    \"\"\"\n    # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups\n    return re.sub(r'_([a-zA-Z])', lambda m: m.group(1).upper(), '_' + s)", "code_tokens": "def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "docstring_tokens": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str", "label": 1}, {"idx": "cosqa-train-16043", "doc": "python replace keyword in input file", "code": "def replace_all(filepath, searchExp, replaceExp):\n    \"\"\"\n    Replace all the ocurrences (in a file) of a string with another value.\n    \"\"\"\n    for line in fileinput.input(filepath, inplace=1):\n        if searchExp in line:\n            line = line.replace(searchExp, replaceExp)\n        sys.stdout.write(line)", "code_tokens": "def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )", "docstring_tokens": "Replace all the ocurrences ( in a file ) of a string with another value .", "label": 1}, {"idx": "cosqa-train-16044", "doc": "how to make a str an int python", "code": "def str2int(num, radix=10, alphabet=BASE85):\n    \"\"\"helper function for quick base conversions from strings to integers\"\"\"\n    return NumConv(radix, alphabet).str2int(num)", "code_tokens": "def str2int ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . str2int ( num )", "docstring_tokens": "helper function for quick base conversions from strings to integers", "label": 1}, {"idx": "cosqa-train-16045", "doc": "python replace multiple occurancew of text", "code": "def _sub_patterns(patterns, text):\n    \"\"\"\n    Apply re.sub to bunch of (pattern, repl)\n    \"\"\"\n    for pattern, repl in patterns:\n        text = re.sub(pattern, repl, text)\n    return text", "code_tokens": "def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text", "docstring_tokens": "Apply re . sub to bunch of ( pattern repl )", "label": 1}, {"idx": "cosqa-train-16046", "doc": "how to make a string into a dictionary in python", "code": "def string_to_identity(identity_str):\n    \"\"\"Parse string into Identity dictionary.\"\"\"\n    m = _identity_regexp.match(identity_str)\n    result = m.groupdict()\n    log.debug('parsed identity: %s', result)\n    return {k: v for k, v in result.items() if v}", "code_tokens": "def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "docstring_tokens": "Parse string into Identity dictionary .", "label": 1}, {"idx": "cosqa-train-16047", "doc": "python replace nan with missing value", "code": "def _replace_nan(a, val):\n    \"\"\"\n    replace nan in a by val, and returns the replaced array and the nan\n    position\n    \"\"\"\n    mask = isnull(a)\n    return where_method(val, mask, a), mask", "code_tokens": "def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "docstring_tokens": "replace nan in a by val and returns the replaced array and the nan position", "label": 0}, {"idx": "cosqa-train-16048", "doc": "how to make a table in python with given columns", "code": "def adapter(data, headers, **kwargs):\n    \"\"\"Wrap vertical table in a function for TabularOutputFormatter.\"\"\"\n    keys = ('sep_title', 'sep_character', 'sep_length')\n    return vertical_table(data, headers, **filter_dict_by_key(kwargs, keys))", "code_tokens": "def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )", "docstring_tokens": "Wrap vertical table in a function for TabularOutputFormatter .", "label": 0}, {"idx": "cosqa-train-16049", "doc": "python request information from usb", "code": "async def sysinfo(dev: Device):\n    \"\"\"Print out system information (version, MAC addrs).\"\"\"\n    click.echo(await dev.get_system_info())\n    click.echo(await dev.get_interface_information())", "code_tokens": "async def sysinfo ( dev : Device ) : click . echo ( await dev . get_system_info ( ) ) click . echo ( await dev . get_interface_information ( ) )", "docstring_tokens": "Print out system information ( version MAC addrs ) .", "label": 1}, {"idx": "cosqa-train-16050", "doc": "how to make arraybuffer from bytes in python", "code": "def _arrayFromBytes(dataBytes, metadata):\n    \"\"\"Generates and returns a numpy array from raw data bytes.\n\n    :param bytes: raw data bytes as generated by ``numpy.ndarray.tobytes()``\n    :param metadata: a dictionary containing the data type and optionally the\n        shape parameter to reconstruct a ``numpy.array`` from the raw data\n        bytes. ``{\"dtype\": \"float64\", \"shape\": (2, 3)}``\n\n    :returns: ``numpy.array``\n    \"\"\"\n    array = numpy.fromstring(dataBytes, dtype=numpy.typeDict[metadata['dtype']])\n    if 'shape' in metadata:\n        array = array.reshape(metadata['shape'])\n    return array", "code_tokens": "def _arrayFromBytes ( dataBytes , metadata ) : array = numpy . fromstring ( dataBytes , dtype = numpy . typeDict [ metadata [ 'dtype' ] ] ) if 'shape' in metadata : array = array . reshape ( metadata [ 'shape' ] ) return array", "docstring_tokens": "Generates and returns a numpy array from raw data bytes .", "label": 0}, {"idx": "cosqa-train-16051", "doc": "python requests check if url exists", "code": "def dir_exists(self):\n        \"\"\"\n        Makes a ``HEAD`` requests to the URI.\n\n        :returns: ``True`` if status code is 2xx.\n        \"\"\"\n\n        r = requests.request(self.method if self.method else 'HEAD', self.url, **self.storage_args)\n        try: r.raise_for_status()\n        except Exception: return False\n\n        return True", "code_tokens": "def dir_exists ( self ) : r = requests . request ( self . method if self . method else 'HEAD' , self . url , * * self . storage_args ) try : r . raise_for_status ( ) except Exception : return False return True", "docstring_tokens": "Makes a HEAD requests to the URI .", "label": 1}, {"idx": "cosqa-train-16052", "doc": "how to make csv as table in python", "code": "def csv_matrix_print(classes, table):\n    \"\"\"\n    Return matrix as csv data.\n\n    :param classes: classes list\n    :type classes:list\n    :param table: table\n    :type table:dict\n    :return:\n    \"\"\"\n    result = \"\"\n    classes.sort()\n    for i in classes:\n        for j in classes:\n            result += str(table[i][j]) + \",\"\n        result = result[:-1] + \"\\n\"\n    return result[:-1]", "code_tokens": "def csv_matrix_print ( classes , table ) : result = \"\" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + \",\" result = result [ : - 1 ] + \"\\n\" return result [ : - 1 ]", "docstring_tokens": "Return matrix as csv data .", "label": 0}, {"idx": "cosqa-train-16053", "doc": "python requests disable ssl checks", "code": "def disable_insecure_request_warning():\n    \"\"\"Suppress warning about untrusted SSL certificate.\"\"\"\n    import requests\n    from requests.packages.urllib3.exceptions import InsecureRequestWarning\n    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)", "code_tokens": "def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )", "docstring_tokens": "Suppress warning about untrusted SSL certificate .", "label": 0}, {"idx": "cosqa-train-16054", "doc": "how to make functions static in python", "code": "def getFunction(self):\n        \"\"\"Called by remote workers. Useful to populate main module globals()\n        for interactive shells. Retrieves the serialized function.\"\"\"\n        return functionFactory(\n            self.code,\n            self.name,\n            self.defaults,\n            self.globals,\n            self.imports,\n        )", "code_tokens": "def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "docstring_tokens": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function .", "label": 0}, {"idx": "cosqa-train-16055", "doc": "python requests passing json payload", "code": "def make_post_request(self, url, auth, json_payload):\n        \"\"\"This function executes the request with the provided\n        json payload and return the json response\"\"\"\n        response = requests.post(url, auth=auth, json=json_payload)\n        return response.json()", "code_tokens": "def make_post_request ( self , url , auth , json_payload ) : response = requests . post ( url , auth = auth , json = json_payload ) return response . json ( )", "docstring_tokens": "This function executes the request with the provided json payload and return the json response", "label": 1}, {"idx": "cosqa-train-16056", "doc": "how to make functions that returns a function python", "code": "def apply(filter):\n    \"\"\"Manufacture decorator that filters return value with given function.\n\n    ``filter``:\n      Callable that takes a single parameter.\n    \"\"\"\n    def decorator(callable):\n        return lambda *args, **kwargs: filter(callable(*args, **kwargs))\n    return decorator", "code_tokens": "def apply ( filter ) : def decorator ( callable ) : return lambda * args , * * kwargs : filter ( callable ( * args , * * kwargs ) ) return decorator", "docstring_tokens": "Manufacture decorator that filters return value with given function .", "label": 1}, {"idx": "cosqa-train-16057", "doc": "python requests session auth basic access", "code": "def login(self, username, password=None, token=None):\n        \"\"\"Login user for protected API calls.\"\"\"\n        self.session.basic_auth(username, password)", "code_tokens": "def login ( self , username , password = None , token = None ) : self . session . basic_auth ( username , password )", "docstring_tokens": "Login user for protected API calls .", "label": 0}, {"idx": "cosqa-train-16058", "doc": "how to make image height and width equal in python", "code": "def scale_image(image, new_width):\n    \"\"\"Resizes an image preserving the aspect ratio.\n    \"\"\"\n    (original_width, original_height) = image.size\n    aspect_ratio = original_height/float(original_width)\n    new_height = int(aspect_ratio * new_width)\n\n    # This scales it wider than tall, since characters are biased\n    new_image = image.resize((new_width*2, new_height))\n    return new_image", "code_tokens": "def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image", "docstring_tokens": "Resizes an image preserving the aspect ratio .", "label": 1}, {"idx": "cosqa-train-16059", "doc": "python requests session mount", "code": "def requests_request(method, url, **kwargs):\n    \"\"\"Requests-mock requests.request wrapper.\"\"\"\n    session = local_sessions.session\n    response = session.request(method=method, url=url, **kwargs)\n    session.close()\n    return response", "code_tokens": "def requests_request ( method , url , * * kwargs ) : session = local_sessions . session response = session . request ( method = method , url = url , * * kwargs ) session . close ( ) return response", "docstring_tokens": "Requests - mock requests . request wrapper .", "label": 1}, {"idx": "cosqa-train-16060", "doc": "how to make parts of word lowercase in python", "code": "def to_camel(s):\n    \"\"\"\n    :param string s: under_scored string to be CamelCased\n    :return: CamelCase version of input\n    :rtype: str\n    \"\"\"\n    # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups\n    return re.sub(r'_([a-zA-Z])', lambda m: m.group(1).upper(), '_' + s)", "code_tokens": "def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "docstring_tokens": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str", "label": 0}, {"idx": "cosqa-train-16061", "doc": "python reset all variables to initial values", "code": "def reset_params(self):\n        \"\"\"Reset all parameters to their default values.\"\"\"\n        self.__params = dict([p, None] for p in self.param_names)\n        self.set_params(self.param_defaults)", "code_tokens": "def reset_params ( self ) : self . __params = dict ( [ p , None ] for p in self . param_names ) self . set_params ( self . param_defaults )", "docstring_tokens": "Reset all parameters to their default values .", "label": 0}, {"idx": "cosqa-train-16062", "doc": "how to make post requst in python", "code": "def make_post_request(self, url, auth, json_payload):\n        \"\"\"This function executes the request with the provided\n        json payload and return the json response\"\"\"\n        response = requests.post(url, auth=auth, json=json_payload)\n        return response.json()", "code_tokens": "def make_post_request ( self , url , auth , json_payload ) : response = requests . post ( url , auth = auth , json = json_payload ) return response . json ( )", "docstring_tokens": "This function executes the request with the provided json payload and return the json response", "label": 0}, {"idx": "cosqa-train-16063", "doc": "python reshape array into single array", "code": "def arr_to_vector(arr):\n    \"\"\"Reshape a multidimensional array to a vector.\n    \"\"\"\n    dim = array_dim(arr)\n    tmp_arr = []\n    for n in range(len(dim) - 1):\n        for inner in arr:\n            for i in inner:\n                tmp_arr.append(i)\n        arr = tmp_arr\n        tmp_arr = []\n    return arr", "code_tokens": "def arr_to_vector ( arr ) : dim = array_dim ( arr ) tmp_arr = [ ] for n in range ( len ( dim ) - 1 ) : for inner in arr : for i in inner : tmp_arr . append ( i ) arr = tmp_arr tmp_arr = [ ] return arr", "docstring_tokens": "Reshape a multidimensional array to a vector .", "label": 0}, {"idx": "cosqa-train-16064", "doc": "how to make python display maximum and minimum number", "code": "def _digits(minval, maxval):\n    \"\"\"Digits needed to comforatbly display values in [minval, maxval]\"\"\"\n    if minval == maxval:\n        return 3\n    else:\n        return min(10, max(2, int(1 + abs(np.log10(maxval - minval)))))", "code_tokens": "def _digits ( minval , maxval ) : if minval == maxval : return 3 else : return min ( 10 , max ( 2 , int ( 1 + abs ( np . log10 ( maxval - minval ) ) ) ) )", "docstring_tokens": "Digits needed to comforatbly display values in [ minval maxval ]", "label": 1}, {"idx": "cosqa-train-16065", "doc": "python reshape multiple columns", "code": "def sf01(arr):\n    \"\"\"\n    swap and then flatten axes 0 and 1\n    \"\"\"\n    s = arr.shape\n    return arr.swapaxes(0, 1).reshape(s[0] * s[1], *s[2:])", "code_tokens": "def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "docstring_tokens": "swap and then flatten axes 0 and 1", "label": 0}, {"idx": "cosqa-train-16066", "doc": "how to make python give out a random integer", "code": "def positive_integer(anon, obj, field, val):\n    \"\"\"\n    Returns a random positive integer (for a Django PositiveIntegerField)\n    \"\"\"\n    return anon.faker.positive_integer(field=field)", "code_tokens": "def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )", "docstring_tokens": "Returns a random positive integer ( for a Django PositiveIntegerField )", "label": 1}, {"idx": "cosqa-train-16067", "doc": "python retrieve func name", "code": "def get_func_name(func):\n    \"\"\"Return a name which includes the module name and function name.\"\"\"\n    func_name = getattr(func, '__name__', func.__class__.__name__)\n    module_name = func.__module__\n\n    if module_name is not None:\n        module_name = func.__module__\n        return '{}.{}'.format(module_name, func_name)\n\n    return func_name", "code_tokens": "def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name", "docstring_tokens": "Return a name which includes the module name and function name .", "label": 1}, {"idx": "cosqa-train-16068", "doc": "how to make raise custom errors in python", "code": "def fix_call(callable, *args, **kw):\n    \"\"\"\n    Call ``callable(*args, **kw)`` fixing any type errors that come out.\n    \"\"\"\n    try:\n        val = callable(*args, **kw)\n    except TypeError:\n        exc_info = fix_type_error(None, callable, args, kw)\n        reraise(*exc_info)\n    return val", "code_tokens": "def fix_call ( callable , * args , * * kw ) : try : val = callable ( * args , * * kw ) except TypeError : exc_info = fix_type_error ( None , callable , args , kw ) reraise ( * exc_info ) return val", "docstring_tokens": "Call callable ( * args ** kw ) fixing any type errors that come out .", "label": 1}, {"idx": "cosqa-train-16069", "doc": "python return a list with one item removed", "code": "def distinct(l):\n    \"\"\"\n    Return a list where the duplicates have been removed.\n\n    Args:\n        l (list): the list to filter.\n\n    Returns:\n        list: the same list without duplicates.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return (_ for _ in l if not (_ in seen or seen_add(_)))", "code_tokens": "def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )", "docstring_tokens": "Return a list where the duplicates have been removed .", "label": 0}, {"idx": "cosqa-train-16070", "doc": "how to measure the execute time in python", "code": "def print_result_from_timeit(stmt='pass', setup='pass', number=1000000):\n    \"\"\"\n    Clean function to know how much time took the execution of one statement\n    \"\"\"\n    units = [\"s\", \"ms\", \"us\", \"ns\"]\n    duration = timeit(stmt, setup, number=int(number))\n    avg_duration = duration / float(number)\n    thousands = int(math.floor(math.log(avg_duration, 1000)))\n\n    print(\"Total time: %fs. Average run: %.3f%s.\" % (\n        duration, avg_duration * (1000 ** -thousands), units[-thousands]))", "code_tokens": "def print_result_from_timeit ( stmt = 'pass' , setup = 'pass' , number = 1000000 ) : units = [ \"s\" , \"ms\" , \"us\" , \"ns\" ] duration = timeit ( stmt , setup , number = int ( number ) ) avg_duration = duration / float ( number ) thousands = int ( math . floor ( math . log ( avg_duration , 1000 ) ) ) print ( \"Total time: %fs. Average run: %.3f%s.\" % ( duration , avg_duration * ( 1000 ** - thousands ) , units [ - thousands ] ) )", "docstring_tokens": "Clean function to know how much time took the execution of one statement", "label": 0}, {"idx": "cosqa-train-16071", "doc": "python return location of substring", "code": "def _find(string, sub_string, start_index):\n    \"\"\"Return index of sub_string in string.\n\n    Raise TokenError if sub_string is not found.\n    \"\"\"\n    result = string.find(sub_string, start_index)\n    if result == -1:\n        raise TokenError(\"expected '{0}'\".format(sub_string))\n    return result", "code_tokens": "def _find ( string , sub_string , start_index ) : result = string . find ( sub_string , start_index ) if result == - 1 : raise TokenError ( \"expected '{0}'\" . format ( sub_string ) ) return result", "docstring_tokens": "Return index of sub_string in string .", "label": 1}, {"idx": "cosqa-train-16072", "doc": "how to modify print function in python", "code": "def _show(self, message, indent=0, enable_verbose=True):  # pragma: no cover\n        \"\"\"Message printer.\n        \"\"\"\n        if enable_verbose:\n            print(\"    \" * indent + message)", "code_tokens": "def _show ( self , message , indent = 0 , enable_verbose = True ) : # pragma: no cover if enable_verbose : print ( \"    \" * indent + message )", "docstring_tokens": "Message printer .", "label": 1}, {"idx": "cosqa-train-16073", "doc": "python return only letters from string", "code": "def return_letters_from_string(text):\n    \"\"\"Get letters from string only.\"\"\"\n    out = \"\"\n    for letter in text:\n        if letter.isalpha():\n            out += letter\n    return out", "code_tokens": "def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "docstring_tokens": "Get letters from string only .", "label": 1}, {"idx": "cosqa-train-16074", "doc": "how to move a sprite in python 3", "code": "def move_back(self, dt):\n        \"\"\" If called after an update, the sprite can move back\n        \"\"\"\n        self._position = self._old_position\n        self.rect.topleft = self._position\n        self.feet.midbottom = self.rect.midbottom", "code_tokens": "def move_back ( self , dt ) : self . _position = self . _old_position self . rect . topleft = self . _position self . feet . midbottom = self . rect . midbottom", "docstring_tokens": "If called after an update the sprite can move back", "label": 1}, {"idx": "cosqa-train-16075", "doc": "python return the index of an element in a list", "code": "def binSearch(arr, val):\n  \"\"\" \n  Function for running binary search on a sorted list.\n\n  :param arr: (list) a sorted list of integers to search\n  :param val: (int)  a integer to search for in the sorted array\n  :returns: (int) the index of the element if it is found and -1 otherwise.\n  \"\"\"\n  i = bisect_left(arr, val)\n  if i != len(arr) and arr[i] == val:\n    return i\n  return -1", "code_tokens": "def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "docstring_tokens": "Function for running binary search on a sorted list .", "label": 0}, {"idx": "cosqa-train-16076", "doc": "how to move an item in a list to front python", "code": "def list_move_to_front(l,value='other'):\n    \"\"\"if the value is in the list, move it to the front and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.insert(0,value)\n    return l", "code_tokens": "def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "docstring_tokens": "if the value is in the list move it to the front and return it .", "label": 0}, {"idx": "cosqa-train-16077", "doc": "python return the index of the minimum value in an numpy array", "code": "def find_nearest_index(arr, value):\n    \"\"\"For a given value, the function finds the nearest value\n    in the array and returns its index.\"\"\"\n    arr = np.array(arr)\n    index = (abs(arr-value)).argmin()\n    return index", "code_tokens": "def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index", "docstring_tokens": "For a given value the function finds the nearest value in the array and returns its index .", "label": 0}, {"idx": "cosqa-train-16078", "doc": "python return the two closest numbers to a value in an array", "code": "def closest(xarr, val):\n    \"\"\" Return the index of the closest in xarr to value val \"\"\"\n    idx_closest = np.argmin(np.abs(np.array(xarr) - val))\n    return idx_closest", "code_tokens": "def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "docstring_tokens": "Return the index of the closest in xarr to value val", "label": 0}, {"idx": "cosqa-train-16079", "doc": "how to normalise a matrix in python'", "code": "def v_normalize(v):\n    \"\"\"\n    Normalizes the given vector.\n    \n    The vector given may have any number of dimensions.\n    \"\"\"\n    vmag = v_magnitude(v)\n    return [ v[i]/vmag  for i in range(len(v)) ]", "code_tokens": "def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]", "docstring_tokens": "Normalizes the given vector . The vector given may have any number of dimensions .", "label": 0}, {"idx": "cosqa-train-16080", "doc": "python reverse map dict", "code": "def invertDictMapping(d):\n    \"\"\" Invert mapping of dictionary (i.e. map values to list of keys) \"\"\"\n    inv_map = {}\n    for k, v in d.items():\n        inv_map[v] = inv_map.get(v, [])\n        inv_map[v].append(k)\n    return inv_map", "code_tokens": "def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "docstring_tokens": "Invert mapping of dictionary ( i . e . map values to list of keys )", "label": 1}, {"idx": "cosqa-train-16081", "doc": "how to open a pkl file in python", "code": "def load(filename):\n    \"\"\"\n    Load the state from the given file, moving to the file's directory during\n    load (temporarily, moving back after loaded)\n\n    Parameters\n    ----------\n    filename : string\n        name of the file to open, should be a .pkl file\n    \"\"\"\n    path, name = os.path.split(filename)\n    path = path or '.'\n\n    with util.indir(path):\n        return pickle.load(open(name, 'rb'))", "code_tokens": "def load ( filename ) : path , name = os . path . split ( filename ) path = path or '.' with util . indir ( path ) : return pickle . load ( open ( name , 'rb' ) )", "docstring_tokens": "Load the state from the given file moving to the file s directory during load ( temporarily moving back after loaded )", "label": 0}, {"idx": "cosqa-train-16082", "doc": "python rotation matrix 2 euler", "code": "def rotation_matrix(sigma):\n    \"\"\"\n\n    https://en.wikipedia.org/wiki/Rotation_matrix\n\n    \"\"\"\n\n    radians = sigma * np.pi / 180.0\n\n    r11 = np.cos(radians)\n    r12 = -np.sin(radians)\n    r21 = np.sin(radians)\n    r22 = np.cos(radians)\n\n    R = np.array([[r11, r12], [r21, r22]])\n\n    return R", "code_tokens": "def rotation_matrix ( sigma ) : radians = sigma * np . pi / 180.0 r11 = np . cos ( radians ) r12 = - np . sin ( radians ) r21 = np . sin ( radians ) r22 = np . cos ( radians ) R = np . array ( [ [ r11 , r12 ] , [ r21 , r22 ] ] ) return R", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-16083", "doc": "how to open file only as ascii in python", "code": "def readme(filename, encoding='utf8'):\n    \"\"\"\n    Read the contents of a file\n    \"\"\"\n\n    with io.open(filename, encoding=encoding) as source:\n        return source.read()", "code_tokens": "def readme ( filename , encoding = 'utf8' ) : with io . open ( filename , encoding = encoding ) as source : return source . read ( )", "docstring_tokens": "Read the contents of a file", "label": 0}, {"idx": "cosqa-train-16084", "doc": "python round not showing correct number of decimal places", "code": "def _saferound(value, decimal_places):\n    \"\"\"\n    Rounds a float value off to the desired precision\n    \"\"\"\n    try:\n        f = float(value)\n    except ValueError:\n        return ''\n    format = '%%.%df' % decimal_places\n    return format % f", "code_tokens": "def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f", "docstring_tokens": "Rounds a float value off to the desired precision", "label": 1}, {"idx": "cosqa-train-16085", "doc": "how to open gz files in python", "code": "def bin_open(fname: str):\n    \"\"\"\n    Returns a file descriptor for a plain text or gzipped file, binary read mode\n    for subprocess interaction.\n\n    :param fname: The filename to open.\n    :return: File descriptor in binary read mode.\n    \"\"\"\n    if fname.endswith(\".gz\"):\n        return gzip.open(fname, \"rb\")\n    return open(fname, \"rb\")", "code_tokens": "def bin_open ( fname : str ) : if fname . endswith ( \".gz\" ) : return gzip . open ( fname , \"rb\" ) return open ( fname , \"rb\" )", "docstring_tokens": "Returns a file descriptor for a plain text or gzipped file binary read mode for subprocess interaction .", "label": 0}, {"idx": "cosqa-train-16086", "doc": "python round number ndarray", "code": "def round_array(array_in):\n    \"\"\"\n    arr_out = round_array(array_in)\n\n    Rounds an array and recasts it to int. Also works on scalars.\n    \"\"\"\n    if isinstance(array_in, ndarray):\n        return np.round(array_in).astype(int)\n    else:\n        return int(np.round(array_in))", "code_tokens": "def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "docstring_tokens": "arr_out = round_array ( array_in )", "label": 1}, {"idx": "cosqa-train-16087", "doc": "how to output symbols in python", "code": "def jsonify(symbol):\n    \"\"\" returns json format for symbol \"\"\"\n    try:\n        # all symbols have a toJson method, try it\n        return json.dumps(symbol.toJson(), indent='  ')\n    except AttributeError:\n        pass\n    return json.dumps(symbol, indent='  ')", "code_tokens": "def jsonify ( symbol ) : try : # all symbols have a toJson method, try it return json . dumps ( symbol . toJson ( ) , indent = '  ' ) except AttributeError : pass return json . dumps ( symbol , indent = '  ' )", "docstring_tokens": "returns json format for symbol", "label": 0}, {"idx": "cosqa-train-16088", "doc": "python round to int numpy", "code": "def round_array(array_in):\n    \"\"\"\n    arr_out = round_array(array_in)\n\n    Rounds an array and recasts it to int. Also works on scalars.\n    \"\"\"\n    if isinstance(array_in, ndarray):\n        return np.round(array_in).astype(int)\n    else:\n        return int(np.round(array_in))", "code_tokens": "def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "docstring_tokens": "arr_out = round_array ( array_in )", "label": 1}, {"idx": "cosqa-train-16089", "doc": "how to output the number of characters in something in python", "code": "def _visual_width(line):\n    \"\"\"Get the the number of columns required to display a string\"\"\"\n\n    return len(re.sub(colorama.ansitowin32.AnsiToWin32.ANSI_CSI_RE, \"\", line))", "code_tokens": "def _visual_width ( line ) : return len ( re . sub ( colorama . ansitowin32 . AnsiToWin32 . ANSI_CSI_RE , \"\" , line ) )", "docstring_tokens": "Get the the number of columns required to display a string", "label": 1}, {"idx": "cosqa-train-16090", "doc": "python rounding decimals places", "code": "def price_rounding(price, decimals=2):\n    \"\"\"Takes a decimal price and rounds to a number of decimal places\"\"\"\n    try:\n        exponent = D('.' + decimals * '0')\n    except InvalidOperation:\n        # Currencies with no decimal places, ex. JPY, HUF\n        exponent = D()\n    return price.quantize(exponent, rounding=ROUND_UP)", "code_tokens": "def price_rounding ( price , decimals = 2 ) : try : exponent = D ( '.' + decimals * '0' ) except InvalidOperation : # Currencies with no decimal places, ex. JPY, HUF exponent = D ( ) return price . quantize ( exponent , rounding = ROUND_UP )", "docstring_tokens": "Takes a decimal price and rounds to a number of decimal places", "label": 1}, {"idx": "cosqa-train-16091", "doc": "how to overlay an image on a background in python", "code": "def copy_image_on_background(image, color=WHITE):\n    \"\"\"\n    Create a new image by copying the image on a *color* background.\n\n    Args:\n        image (PIL.Image.Image): Image to copy\n        color (tuple): Background color usually WHITE or BLACK\n\n    Returns:\n        PIL.Image.Image\n\n    \"\"\"\n    background = Image.new(\"RGB\", image.size, color)\n    background.paste(image, mask=image.split()[3])\n    return background", "code_tokens": "def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "docstring_tokens": "Create a new image by copying the image on a * color * background .", "label": 0}, {"idx": "cosqa-train-16092", "doc": "python rows to columns but not transpose", "code": "def sf01(arr):\n    \"\"\"\n    swap and then flatten axes 0 and 1\n    \"\"\"\n    s = arr.shape\n    return arr.swapaxes(0, 1).reshape(s[0] * s[1], *s[2:])", "code_tokens": "def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "docstring_tokens": "swap and then flatten axes 0 and 1", "label": 0}, {"idx": "cosqa-train-16093", "doc": "how to overwrite print function python", "code": "def pstd(self, *args, **kwargs):\n        \"\"\" Console to STDOUT \"\"\"\n        kwargs['file'] = self.out\n        self.print(*args, **kwargs)\n        sys.stdout.flush()", "code_tokens": "def pstd ( self , * args , * * kwargs ) : kwargs [ 'file' ] = self . out self . print ( * args , * * kwargs ) sys . stdout . flush ( )", "docstring_tokens": "Console to STDOUT", "label": 0}, {"idx": "cosqa-train-16094", "doc": "python s3 remove bucket policy", "code": "def remove_file_from_s3(awsclient, bucket, key):\n    \"\"\"Remove a file from an AWS S3 bucket.\n\n    :param awsclient:\n    :param bucket:\n    :param key:\n    :return:\n    \"\"\"\n    client_s3 = awsclient.get_client('s3')\n    response = client_s3.delete_object(Bucket=bucket, Key=key)", "code_tokens": "def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )", "docstring_tokens": "Remove a file from an AWS S3 bucket .", "label": 0}, {"idx": "cosqa-train-16095", "doc": "how to pad an image in python", "code": "def __call__(self, img):\n        \"\"\"\n        Args:\n            img (PIL Image): Image to be padded.\n\n        Returns:\n            PIL Image: Padded image.\n        \"\"\"\n        return F.pad(img, self.padding, self.fill, self.padding_mode)", "code_tokens": "def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )", "docstring_tokens": "Args : img ( PIL Image ) : Image to be padded .", "label": 0}, {"idx": "cosqa-train-16096", "doc": "python s3 save string", "code": "def get_as_string(self, s3_path, encoding='utf-8'):\n        \"\"\"\n        Get the contents of an object stored in S3 as string.\n\n        :param s3_path: URL for target S3 location\n        :param encoding: Encoding to decode bytes to string\n        :return: File contents as a string\n        \"\"\"\n        content = self.get_as_bytes(s3_path)\n        return content.decode(encoding)", "code_tokens": "def get_as_string ( self , s3_path , encoding = 'utf-8' ) : content = self . get_as_bytes ( s3_path ) return content . decode ( encoding )", "docstring_tokens": "Get the contents of an object stored in S3 as string .", "label": 1}, {"idx": "cosqa-train-16097", "doc": "how to pass the variables between functions in python with multiple args", "code": "def trigger(self, target: str, trigger: str, parameters: Dict[str, Any]={}):\n\t\t\"\"\"Calls the specified Trigger of another Area with the optionally given parameters.\n\n\t\tArgs:\n\t\t\ttarget: The name of the target Area.\n\t\t\ttrigger: The name of the Trigger.\n\t\t\tparameters: The parameters of the function call.\n\t\t\"\"\"\n\t\tpass", "code_tokens": "def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "docstring_tokens": "Calls the specified Trigger of another Area with the optionally given parameters .", "label": 1}, {"idx": "cosqa-train-16098", "doc": "python save base64 string to image", "code": "def base64ToImage(imgData, out_path, out_file):\n        \"\"\" converts a base64 string to a file \"\"\"\n        fh = open(os.path.join(out_path, out_file), \"wb\")\n        fh.write(imgData.decode('base64'))\n        fh.close()\n        del fh\n        return os.path.join(out_path, out_file)", "code_tokens": "def base64ToImage ( imgData , out_path , out_file ) : fh = open ( os . path . join ( out_path , out_file ) , \"wb\" ) fh . write ( imgData . decode ( 'base64' ) ) fh . close ( ) del fh return os . path . join ( out_path , out_file )", "docstring_tokens": "converts a base64 string to a file", "label": 0}, {"idx": "cosqa-train-16099", "doc": "how to plot various charts on a single figure python", "code": "def strip_figures(figure):\n\t\"\"\"\n\tStrips a figure into multiple figures with a trace on each of them\n\n\tParameters:\n\t-----------\n\t\tfigure : Figure\n\t\t\tPlotly Figure\n\t\"\"\"\n\tfig=[]\n\tfor trace in figure['data']:\n\t\tfig.append(dict(data=[trace],layout=figure['layout']))\n\treturn fig", "code_tokens": "def strip_figures ( figure ) : fig = [ ] for trace in figure [ 'data' ] : fig . append ( dict ( data = [ trace ] , layout = figure [ 'layout' ] ) ) return fig", "docstring_tokens": "Strips a figure into multiple figures with a trace on each of them", "label": 0}, {"idx": "cosqa-train-16100", "doc": "python save networkx file", "code": "def draw(graph, fname):\n    \"\"\"Draw a graph and save it into a file\"\"\"\n    ag = networkx.nx_agraph.to_agraph(graph)\n    ag.draw(fname, prog='dot')", "code_tokens": "def draw ( graph , fname ) : ag = networkx . nx_agraph . to_agraph ( graph ) ag . draw ( fname , prog = 'dot' )", "docstring_tokens": "Draw a graph and save it into a file", "label": 0}, {"idx": "cosqa-train-16101", "doc": "how to print 1st ten lines of an npy file python", "code": "def head(filename, n=10):\n    \"\"\" prints the top `n` lines of a file \"\"\"\n    with freader(filename) as fr:\n        for _ in range(n):\n            print(fr.readline().strip())", "code_tokens": "def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )", "docstring_tokens": "prints the top n lines of a file", "label": 0}, {"idx": "cosqa-train-16102", "doc": "python scapy is ssl packet", "code": "def _sslobj(sock):\n    \"\"\"Returns the underlying PySLLSocket object with which the C extension\n    functions interface.\n\n    \"\"\"\n    pass\n    if isinstance(sock._sslobj, _ssl._SSLSocket):\n        return sock._sslobj\n    else:\n        return sock._sslobj._sslobj", "code_tokens": "def _sslobj ( sock ) : pass if isinstance ( sock . _sslobj , _ssl . _SSLSocket ) : return sock . _sslobj else : return sock . _sslobj . _sslobj", "docstring_tokens": "Returns the underlying PySLLSocket object with which the C extension functions interface .", "label": 0}, {"idx": "cosqa-train-16103", "doc": "how to print a python doc", "code": "def see_doc(obj_with_doc):\n    \"\"\"Copy docstring from existing object to the decorated callable.\"\"\"\n    def decorator(fn):\n        fn.__doc__ = obj_with_doc.__doc__\n        return fn\n    return decorator", "code_tokens": "def see_doc ( obj_with_doc ) : def decorator ( fn ) : fn . __doc__ = obj_with_doc . __doc__ return fn return decorator", "docstring_tokens": "Copy docstring from existing object to the decorated callable .", "label": 0}, {"idx": "cosqa-train-16104", "doc": "python scatter specify marker and color", "code": "def scatter(self, *args, **kwargs):\n        \"\"\"Add a scatter plot.\"\"\"\n        cls = _make_class(ScatterVisual,\n                          _default_marker=kwargs.pop('marker', None),\n                          )\n        return self._add_item(cls, *args, **kwargs)", "code_tokens": "def scatter ( self , * args , * * kwargs ) : cls = _make_class ( ScatterVisual , _default_marker = kwargs . pop ( 'marker' , None ) , ) return self . _add_item ( cls , * args , * * kwargs )", "docstring_tokens": "Add a scatter plot .", "label": 0}, {"idx": "cosqa-train-16105", "doc": "how to print all values in dictionary python", "code": "def printdict(adict):\n    \"\"\"printdict\"\"\"\n    dlist = list(adict.keys())\n    dlist.sort()\n    for i in range(0, len(dlist)):\n        print(dlist[i], adict[dlist[i]])", "code_tokens": "def printdict ( adict ) : dlist = list ( adict . keys ( ) ) dlist . sort ( ) for i in range ( 0 , len ( dlist ) ) : print ( dlist [ i ] , adict [ dlist [ i ] ] )", "docstring_tokens": "printdict", "label": 1}, {"idx": "cosqa-train-16106", "doc": "python scipy optimize constraint example", "code": "def _cho_factor(A, lower=True, check_finite=True):\n    \"\"\"Implementaton of :func:`scipy.linalg.cho_factor` using\n    a function supported in cupy.\"\"\"\n\n    return cp.linalg.cholesky(A), True", "code_tokens": "def _cho_factor ( A , lower = True , check_finite = True ) : return cp . linalg . cholesky ( A ) , True", "docstring_tokens": "Implementaton of : func : scipy . linalg . cho_factor using a function supported in cupy .", "label": 1}, {"idx": "cosqa-train-16107", "doc": "how to print data in table format python csv", "code": "def csv_matrix_print(classes, table):\n    \"\"\"\n    Return matrix as csv data.\n\n    :param classes: classes list\n    :type classes:list\n    :param table: table\n    :type table:dict\n    :return:\n    \"\"\"\n    result = \"\"\n    classes.sort()\n    for i in classes:\n        for j in classes:\n            result += str(table[i][j]) + \",\"\n        result = result[:-1] + \"\\n\"\n    return result[:-1]", "code_tokens": "def csv_matrix_print ( classes , table ) : result = \"\" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + \",\" result = result [ : - 1 ] + \"\\n\" return result [ : - 1 ]", "docstring_tokens": "Return matrix as csv data .", "label": 0}, {"idx": "cosqa-train-16108", "doc": "python scope of variable in function", "code": "def ex(self, cmd):\n        \"\"\"Execute a normal python statement in user namespace.\"\"\"\n        with self.builtin_trap:\n            exec cmd in self.user_global_ns, self.user_ns", "code_tokens": "def ex ( self , cmd ) : with self . builtin_trap : exec cmd in self . user_global_ns , self . user_ns", "docstring_tokens": "Execute a normal python statement in user namespace .", "label": 0}, {"idx": "cosqa-train-16109", "doc": "how to print each value in dictionary python", "code": "def printdict(adict):\n    \"\"\"printdict\"\"\"\n    dlist = list(adict.keys())\n    dlist.sort()\n    for i in range(0, len(dlist)):\n        print(dlist[i], adict[dlist[i]])", "code_tokens": "def printdict ( adict ) : dlist = list ( adict . keys ( ) ) dlist . sort ( ) for i in range ( 0 , len ( dlist ) ) : print ( dlist [ i ] , adict [ dlist [ i ] ] )", "docstring_tokens": "printdict", "label": 0}, {"idx": "cosqa-train-16110", "doc": "python scrapy do not print log", "code": "def handle_logging(self):\n        \"\"\"\n        To allow devs to log as early as possible, logging will already be\n        handled here\n        \"\"\"\n\n        configure_logging(self.get_scrapy_options())\n\n        # Disable duplicates\n        self.__scrapy_options[\"LOG_ENABLED\"] = False\n\n        # Now, after log-level is correctly set, lets log them.\n        for msg in self.log_output:\n            if msg[\"level\"] is \"error\":\n                self.log.error(msg[\"msg\"])\n            elif msg[\"level\"] is \"info\":\n                self.log.info(msg[\"msg\"])\n            elif msg[\"level\"] is \"debug\":\n                self.log.debug(msg[\"msg\"])", "code_tokens": "def handle_logging ( self ) : configure_logging ( self . get_scrapy_options ( ) ) # Disable duplicates self . __scrapy_options [ \"LOG_ENABLED\" ] = False # Now, after log-level is correctly set, lets log them. for msg in self . log_output : if msg [ \"level\" ] is \"error\" : self . log . error ( msg [ \"msg\" ] ) elif msg [ \"level\" ] is \"info\" : self . log . info ( msg [ \"msg\" ] ) elif msg [ \"level\" ] is \"debug\" : self . log . debug ( msg [ \"msg\" ] )", "docstring_tokens": "To allow devs to log as early as possible logging will already be handled here", "label": 0}, {"idx": "cosqa-train-16111", "doc": "how to print out the index of a line in python", "code": "def translate_index_to_position(self, index):\n        \"\"\"\n        Given an index for the text, return the corresponding (row, col) tuple.\n        (0-based. Returns (0, 0) for index=0.)\n        \"\"\"\n        # Find start of this line.\n        row, row_index = self._find_line_start_index(index)\n        col = index - row_index\n\n        return row, col", "code_tokens": "def translate_index_to_position ( self , index ) : # Find start of this line. row , row_index = self . _find_line_start_index ( index ) col = index - row_index return row , col", "docstring_tokens": "Given an index for the text return the corresponding ( row col ) tuple . ( 0 - based . Returns ( 0 0 ) for index = 0 . )", "label": 0}, {"idx": "cosqa-train-16112", "doc": "how to print text in color in python", "code": "def printc(cls, txt, color=colors.red):\n        \"\"\"Print in color.\"\"\"\n        print(cls.color_txt(txt, color))", "code_tokens": "def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "docstring_tokens": "Print in color .", "label": 0}, {"idx": "cosqa-train-16113", "doc": "python seconds to hours minutes seconds", "code": "def time2seconds(t):\n    \"\"\"Returns seconds since 0h00.\"\"\"\n    return t.hour * 3600 + t.minute * 60 + t.second + float(t.microsecond) / 1e6", "code_tokens": "def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6", "docstring_tokens": "Returns seconds since 0h00 .", "label": 0}, {"idx": "cosqa-train-16114", "doc": "how to print traceback error in python", "code": "def format_exception(e):\n    \"\"\"Returns a string containing the type and text of the exception.\n\n    \"\"\"\n    from .utils.printing import fill\n    return '\\n'.join(fill(line) for line in traceback.format_exception_only(type(e), e))", "code_tokens": "def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "docstring_tokens": "Returns a string containing the type and text of the exception .", "label": 0}, {"idx": "cosqa-train-16115", "doc": "python secure json server wrappedsocet", "code": "def json(body, charset='utf-8', **kwargs):\n    \"\"\"Takes JSON formatted data, converting it into native Python objects\"\"\"\n    return json_converter.loads(text(body, charset=charset))", "code_tokens": "def json ( body , charset = 'utf-8' , * * kwargs ) : return json_converter . loads ( text ( body , charset = charset ) )", "docstring_tokens": "Takes JSON formatted data converting it into native Python objects", "label": 0}, {"idx": "cosqa-train-16116", "doc": "how to program mouse clicks and movments with python", "code": "def on_mouse_motion(self, x, y, dx, dy):\n        \"\"\"\n        Pyglet specific mouse motion callback.\n        Forwards and traslates the event to the example\n        \"\"\"\n        # Screen coordinates relative to the lower-left corner\n        # so we have to flip the y axis to make this consistent with\n        # other window libraries\n        self.example.mouse_position_event(x, self.buffer_height - y)", "code_tokens": "def on_mouse_motion ( self , x , y , dx , dy ) : # Screen coordinates relative to the lower-left corner\n # so we have to flip the y axis to make this consistent with\n # other window libraries\n self . example . mouse_position_event ( x , self . buffer_height - y )", "docstring_tokens": "Pyglet specific mouse motion callback . Forwards and traslates the event to the example", "label": 1}, {"idx": "cosqa-train-16117", "doc": "python see if a file exists", "code": "def _file_exists(path, filename):\n  \"\"\"Checks if the filename exists under the path.\"\"\"\n  return os.path.isfile(os.path.join(path, filename))", "code_tokens": "def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )", "docstring_tokens": "Checks if the filename exists under the path .", "label": 1}, {"idx": "cosqa-train-16118", "doc": "how to put the legend box outside the graph matplotlib python", "code": "def mpl_outside_legend(ax, **kwargs):\n    \"\"\" Places a legend box outside a matplotlib Axes instance. \"\"\"\n    box = ax.get_position()\n    ax.set_position([box.x0, box.y0, box.width * 0.75, box.height])\n    # Put a legend to the right of the current axis\n    ax.legend(loc='upper left', bbox_to_anchor=(1, 1), **kwargs)", "code_tokens": "def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )", "docstring_tokens": "Places a legend box outside a matplotlib Axes instance .", "label": 1}, {"idx": "cosqa-train-16119", "doc": "how to quickly add hashtag to python", "code": "def _add_hash(source):\n    \"\"\"Add a leading hash '#' at the beginning of every line in the source.\"\"\"\n    source = '\\n'.join('# ' + line.rstrip()\n                       for line in source.splitlines())\n    return source", "code_tokens": "def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "docstring_tokens": "Add a leading hash # at the beginning of every line in the source .", "label": 1}, {"idx": "cosqa-train-16120", "doc": "how to randomize someones input in a list in python", "code": "def get_randomized_guid_sample(self, item_count):\n        \"\"\" Fetch a subset of randomzied GUIDs from the whitelist \"\"\"\n        dataset = self.get_whitelist()\n        random.shuffle(dataset)\n        return dataset[:item_count]", "code_tokens": "def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]", "docstring_tokens": "Fetch a subset of randomzied GUIDs from the whitelist", "label": 0}, {"idx": "cosqa-train-16121", "doc": "python select row by boolen", "code": "def selecttrue(table, field, complement=False):\n    \"\"\"Select rows where the given field evaluates `True`.\"\"\"\n\n    return select(table, field, lambda v: bool(v), complement=complement)", "code_tokens": "def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "docstring_tokens": "Select rows where the given field evaluates True .", "label": 0}, {"idx": "cosqa-train-16122", "doc": "how to randomly select indices in array python", "code": "def downsample(array, k):\n    \"\"\"Choose k random elements of array.\"\"\"\n    length = array.shape[0]\n    indices = random.sample(xrange(length), k)\n    return array[indices]", "code_tokens": "def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]", "docstring_tokens": "Choose k random elements of array .", "label": 1}, {"idx": "cosqa-train-16123", "doc": "python serialize and save a numpy array", "code": "def adapt_array(arr):\n    \"\"\"\n    Adapts a Numpy array into an ARRAY string to put into the database.\n\n    Parameters\n    ----------\n    arr: array\n        The Numpy array to be adapted into an ARRAY type that can be inserted into a SQL file.\n\n    Returns\n    -------\n    ARRAY\n            The adapted array object\n\n    \"\"\"\n    out = io.BytesIO()\n    np.save(out, arr), out.seek(0)\n    return buffer(out.read())", "code_tokens": "def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )", "docstring_tokens": "Adapts a Numpy array into an ARRAY string to put into the database .", "label": 1}, {"idx": "cosqa-train-16124", "doc": "how to read a binary file into numpy python", "code": "def read_numpy(fd, byte_order, dtype, count):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    return numpy.fromfile(fd, byte_order+dtype[-1], count)", "code_tokens": "def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 1}, {"idx": "cosqa-train-16125", "doc": "python series index to array", "code": "def from_series(cls, series):\n        \"\"\"Convert a pandas.Series into an xarray.DataArray.\n\n        If the series's index is a MultiIndex, it will be expanded into a\n        tensor product of one-dimensional coordinates (filling in missing\n        values with NaN). Thus this operation should be the inverse of the\n        `to_series` method.\n        \"\"\"\n        # TODO: add a 'name' parameter\n        name = series.name\n        df = pd.DataFrame({name: series})\n        ds = Dataset.from_dataframe(df)\n        return ds[name]", "code_tokens": "def from_series ( cls , series ) : # TODO: add a 'name' parameter name = series . name df = pd . DataFrame ( { name : series } ) ds = Dataset . from_dataframe ( df ) return ds [ name ]", "docstring_tokens": "Convert a pandas . Series into an xarray . DataArray .", "label": 1}, {"idx": "cosqa-train-16126", "doc": "how to read a tif as a matrix in python", "code": "def ReadTif(tifFile):\n        \"\"\"Reads a tif file to a 2D NumPy array\"\"\"\n        img = Image.open(tifFile)\n        img = np.array(img)\n        return img", "code_tokens": "def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img", "docstring_tokens": "Reads a tif file to a 2D NumPy array", "label": 0}, {"idx": "cosqa-train-16127", "doc": "python series unique value and corresponding index", "code": "def describe_unique_1d(series):\n    \"\"\"Compute summary statistics of a unique (`S_TYPE_UNIQUE`) variable (a Series).\n\n    Parameters\n    ----------\n    series : Series\n        The variable to describe.\n\n    Returns\n    -------\n    Series\n        The description of the variable as a Series with index being stats keys.\n    \"\"\"\n    return pd.Series([base.S_TYPE_UNIQUE], index=['type'], name=series.name)", "code_tokens": "def describe_unique_1d ( series ) : return pd . Series ( [ base . S_TYPE_UNIQUE ] , index = [ 'type' ] , name = series . name )", "docstring_tokens": "Compute summary statistics of a unique ( S_TYPE_UNIQUE ) variable ( a Series ) .", "label": 0}, {"idx": "cosqa-train-16128", "doc": "how to read file content in numpy python", "code": "def read_numpy(fd, byte_order, dtype, count):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    return numpy.fromfile(fd, byte_order+dtype[-1], count)", "code_tokens": "def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 0}, {"idx": "cosqa-train-16129", "doc": "python service manager, register", "code": "def register_service(self, service):\n        \"\"\"\n            Register service into the system. Called by Services.\n        \"\"\"\n        if service not in self.services:\n            self.services.append(service)", "code_tokens": "def register_service ( self , service ) : if service not in self . services : self . services . append ( service )", "docstring_tokens": "Register service into the system . Called by Services .", "label": 1}, {"idx": "cosqa-train-16130", "doc": "how to read in a text file as list python", "code": "def get_list_from_file(file_name):\n    \"\"\"read the lines from a file into a list\"\"\"\n    with open(file_name, mode='r', encoding='utf-8') as f1:\n        lst = f1.readlines()\n    return lst", "code_tokens": "def get_list_from_file ( file_name ) : with open ( file_name , mode = 'r' , encoding = 'utf-8' ) as f1 : lst = f1 . readlines ( ) return lst", "docstring_tokens": "read the lines from a file into a list", "label": 0}, {"idx": "cosqa-train-16131", "doc": "python set case sensitive", "code": "def to_snake_case(text):\n    \"\"\"Convert to snake case.\n\n    :param str text:\n    :rtype: str\n    :return:\n    \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert to snake case .", "label": 0}, {"idx": "cosqa-train-16132", "doc": "how to read in file as list python", "code": "def get_list_from_file(file_name):\n    \"\"\"read the lines from a file into a list\"\"\"\n    with open(file_name, mode='r', encoding='utf-8') as f1:\n        lst = f1.readlines()\n    return lst", "code_tokens": "def get_list_from_file ( file_name ) : with open ( file_name , mode = 'r' , encoding = 'utf-8' ) as f1 : lst = f1 . readlines ( ) return lst", "docstring_tokens": "read the lines from a file into a list", "label": 0}, {"idx": "cosqa-train-16133", "doc": "python set list no duplicates", "code": "def delete_duplicates(seq):\n    \"\"\"\n    Remove duplicates from an iterable, preserving the order.\n\n    Args:\n        seq: Iterable of various type.\n\n    Returns:\n        list: List of unique objects.\n\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Remove duplicates from an iterable preserving the order .", "label": 1}, {"idx": "cosqa-train-16134", "doc": "how to read matrix in python", "code": "def load_data(filename):\n    \"\"\"\n    :rtype : numpy matrix\n    \"\"\"\n    data = pandas.read_csv(filename, header=None, delimiter='\\t', skiprows=9)\n    return data.as_matrix()", "code_tokens": "def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\\t' , skiprows = 9 ) return data . as_matrix ( )", "docstring_tokens": ": rtype : numpy matrix", "label": 1}, {"idx": "cosqa-train-16135", "doc": "python set list with not duplicates", "code": "def unique(iterable):\n    \"\"\" Returns a list copy in which each item occurs only once (in-order).\n    \"\"\"\n    seen = set()\n    return [x for x in iterable if x not in seen and not seen.add(x)]", "code_tokens": "def unique ( iterable ) : seen = set ( ) return [ x for x in iterable if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Returns a list copy in which each item occurs only once ( in - order ) .", "label": 1}, {"idx": "cosqa-train-16136", "doc": "how to read the lowest value out of a set of values in python", "code": "def find_le(a, x):\n    \"\"\"Find rightmost value less than or equal to x.\"\"\"\n    i = bs.bisect_right(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than or equal to x .", "label": 0}, {"idx": "cosqa-train-16137", "doc": "python set pixel in matplotlib figure", "code": "def setPixel(self, x, y, color):\n        \"\"\"Set the pixel at (x,y) to the integers in sequence 'color'.\"\"\"\n        return _fitz.Pixmap_setPixel(self, x, y, color)", "code_tokens": "def setPixel ( self , x , y , color ) : return _fitz . Pixmap_setPixel ( self , x , y , color )", "docstring_tokens": "Set the pixel at ( x y ) to the integers in sequence color .", "label": 0}, {"idx": "cosqa-train-16138", "doc": "how to reduce noise in an image python", "code": "def lighting(im, b, c):\n    \"\"\" Adjust image balance and contrast \"\"\"\n    if b==0 and c==1: return im\n    mu = np.average(im)\n    return np.clip((im-mu)*c+mu+b,0.,1.).astype(np.float32)", "code_tokens": "def lighting ( im , b , c ) : if b == 0 and c == 1 : return im mu = np . average ( im ) return np . clip ( ( im - mu ) * c + mu + b , 0. , 1. ) . astype ( np . float32 )", "docstring_tokens": "Adjust image balance and contrast", "label": 0}, {"idx": "cosqa-train-16139", "doc": "python set random state", "code": "def reseed_random(seed):\n    \"\"\"Reseed factory.fuzzy's random generator.\"\"\"\n    r = random.Random(seed)\n    random_internal_state = r.getstate()\n    set_random_state(random_internal_state)", "code_tokens": "def reseed_random ( seed ) : r = random . Random ( seed ) random_internal_state = r . getstate ( ) set_random_state ( random_internal_state )", "docstring_tokens": "Reseed factory . fuzzy s random generator .", "label": 1}, {"idx": "cosqa-train-16140", "doc": "how to reduce significant digits in python", "code": "def round_sig(x, sig):\n    \"\"\"Round the number to the specified number of significant figures\"\"\"\n    return round(x, sig - int(floor(log10(abs(x)))) - 1)", "code_tokens": "def round_sig ( x , sig ) : return round ( x , sig - int ( floor ( log10 ( abs ( x ) ) ) ) - 1 )", "docstring_tokens": "Round the number to the specified number of significant figures", "label": 0}, {"idx": "cosqa-train-16141", "doc": "python set subtract another set", "code": "def __isub__(self, other):\n        \"\"\"Remove all elements of another set from this RangeSet.\"\"\"\n        self._binary_sanity_check(other)\n        set.difference_update(self, other)\n        return self", "code_tokens": "def __isub__ ( self , other ) : self . _binary_sanity_check ( other ) set . difference_update ( self , other ) return self", "docstring_tokens": "Remove all elements of another set from this RangeSet .", "label": 1}, {"idx": "cosqa-train-16142", "doc": "how to refer coordinate's tuple in python", "code": "def getTuple(self):\n        \"\"\" Returns the shape of the region as (x, y, w, h) \"\"\"\n        return (self.x, self.y, self.w, self.h)", "code_tokens": "def getTuple ( self ) : return ( self . x , self . y , self . w , self . h )", "docstring_tokens": "Returns the shape of the region as ( x y w h )", "label": 0}, {"idx": "cosqa-train-16143", "doc": "how to refresh win in graphics python", "code": "def update_screen(self):\n        \"\"\"Refresh the screen. You don't need to override this except to update only small portins of the screen.\"\"\"\n        self.clock.tick(self.FPS)\n        pygame.display.update()", "code_tokens": "def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )", "docstring_tokens": "Refresh the screen . You don t need to override this except to update only small portins of the screen .", "label": 1}, {"idx": "cosqa-train-16144", "doc": "python set that can take repeats", "code": "def delete_duplicates(seq):\n    \"\"\"\n    Remove duplicates from an iterable, preserving the order.\n\n    Args:\n        seq: Iterable of various type.\n\n    Returns:\n        list: List of unique objects.\n\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Remove duplicates from an iterable preserving the order .", "label": 1}, {"idx": "cosqa-train-16145", "doc": "how to remove a file extension in python", "code": "def remove_ext(fname):\n    \"\"\"Removes the extension from a filename\n    \"\"\"\n    bn = os.path.basename(fname)\n    return os.path.splitext(bn)[0]", "code_tokens": "def remove_ext ( fname ) : bn = os . path . basename ( fname ) return os . path . splitext ( bn ) [ 0 ]", "docstring_tokens": "Removes the extension from a filename", "label": 1}, {"idx": "cosqa-train-16146", "doc": "python setuptools command not found", "code": "def main(argv, version=DEFAULT_VERSION):\n    \"\"\"Install or upgrade setuptools and EasyInstall\"\"\"\n    tarball = download_setuptools()\n    _install(tarball, _build_install_args(argv))", "code_tokens": "def main ( argv , version = DEFAULT_VERSION ) : tarball = download_setuptools ( ) _install ( tarball , _build_install_args ( argv ) )", "docstring_tokens": "Install or upgrade setuptools and EasyInstall", "label": 1}, {"idx": "cosqa-train-16147", "doc": "how to remove all alphabets in a string in python", "code": "def strip_accents(string):\n    \"\"\"\n    Strip all the accents from the string\n    \"\"\"\n    return u''.join(\n        (character for character in unicodedata.normalize('NFD', string)\n         if unicodedata.category(character) != 'Mn'))", "code_tokens": "def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "docstring_tokens": "Strip all the accents from the string", "label": 0}, {"idx": "cosqa-train-16148", "doc": "python setuptools undefined distutils defines", "code": "def main(argv, version=DEFAULT_VERSION):\n    \"\"\"Install or upgrade setuptools and EasyInstall\"\"\"\n    tarball = download_setuptools()\n    _install(tarball, _build_install_args(argv))", "code_tokens": "def main ( argv , version = DEFAULT_VERSION ) : tarball = download_setuptools ( ) _install ( tarball , _build_install_args ( argv ) )", "docstring_tokens": "Install or upgrade setuptools and EasyInstall", "label": 1}, {"idx": "cosqa-train-16149", "doc": "how to remove all non alophatcial characters from string python", "code": "def strip_accents(string):\n    \"\"\"\n    Strip all the accents from the string\n    \"\"\"\n    return u''.join(\n        (character for character in unicodedata.normalize('NFD', string)\n         if unicodedata.category(character) != 'Mn'))", "code_tokens": "def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "docstring_tokens": "Strip all the accents from the string", "label": 0}, {"idx": "cosqa-train-16150", "doc": "python seurch closest in the list", "code": "def get_closest_index(myList, myNumber):\n    \"\"\"\n    Assumes myList is sorted. Returns closest value to myNumber.\n    If two numbers are equally close, return the smallest number.\n\n    Parameters\n    ----------\n    myList : array\n        The list in which to find the closest value to myNumber\n    myNumber : float\n        The number to find the closest to in MyList\n\n    Returns\n    -------\n    closest_values_index : int\n        The index in the array of the number closest to myNumber in myList\n    \"\"\"\n    closest_values_index = _np.where(self.time == take_closest(myList, myNumber))[0][0]\n    return closest_values_index", "code_tokens": "def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index", "docstring_tokens": "Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .", "label": 0}, {"idx": "cosqa-train-16151", "doc": "how to remove all of one character from a string python", "code": "def strip_accents(text):\n    \"\"\"\n    Strip agents from a string.\n    \"\"\"\n\n    normalized_str = unicodedata.normalize('NFD', text)\n\n    return ''.join([\n        c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "code_tokens": "def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "docstring_tokens": "Strip agents from a string .", "label": 0}, {"idx": "cosqa-train-16152", "doc": "python show only distinct elements in a list", "code": "def distinct(xs):\n    \"\"\"Get the list of distinct values with preserving order.\"\"\"\n    # don't use collections.OrderedDict because we do support Python 2.6\n    seen = set()\n    return [x for x in xs if x not in seen and not seen.add(x)]", "code_tokens": "def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Get the list of distinct values with preserving order .", "label": 1}, {"idx": "cosqa-train-16153", "doc": "how to remove and then insert item from list python", "code": "def list_move_to_front(l,value='other'):\n    \"\"\"if the value is in the list, move it to the front and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.insert(0,value)\n    return l", "code_tokens": "def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "docstring_tokens": "if the value is in the list move it to the front and return it .", "label": 0}, {"idx": "cosqa-train-16154", "doc": "python shutil rmtree [errno 39] directory not empty", "code": "def safe_rmtree(directory):\n  \"\"\"Delete a directory if it's present. If it's not present, no-op.\"\"\"\n  if os.path.exists(directory):\n    shutil.rmtree(directory, True)", "code_tokens": "def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "docstring_tokens": "Delete a directory if it s present . If it s not present no - op .", "label": 1}, {"idx": "cosqa-train-16155", "doc": "how to remove blank lines in python file", "code": "def lines(input):\n    \"\"\"Remove comments and empty lines\"\"\"\n    for raw_line in input:\n        line = raw_line.strip()\n        if line and not line.startswith('#'):\n            yield strip_comments(line)", "code_tokens": "def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "docstring_tokens": "Remove comments and empty lines", "label": 1}, {"idx": "cosqa-train-16156", "doc": "python signal handler quit", "code": "def signal_handler(signal_name, frame):\n    \"\"\"Quit signal handler.\"\"\"\n    sys.stdout.flush()\n    print(\"\\nSIGINT in frame signal received. Quitting...\")\n    sys.stdout.flush()\n    sys.exit(0)", "code_tokens": "def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( \"\\nSIGINT in frame signal received. Quitting...\" ) sys . stdout . flush ( ) sys . exit ( 0 )", "docstring_tokens": "Quit signal handler .", "label": 1}, {"idx": "cosqa-train-16157", "doc": "how to remove blank lines of text file with python", "code": "def cleanLines(source, lineSep=os.linesep):\n    \"\"\"\n    :param source: some iterable source (list, file, etc)\n    :param lineSep: string of separators (chars) that must be removed\n    :return: list of non empty lines with removed separators\n    \"\"\"\n    stripped = (line.strip(lineSep) for line in source)\n    return (line for line in stripped if len(line) != 0)", "code_tokens": "def cleanLines ( source , lineSep = os . linesep ) : stripped = ( line . strip ( lineSep ) for line in source ) return ( line for line in stripped if len ( line ) != 0 )", "docstring_tokens": ": param source : some iterable source ( list file etc ) : param lineSep : string of separators ( chars ) that must be removed : return : list of non empty lines with removed separators", "label": 0}, {"idx": "cosqa-train-16158", "doc": "python simple way to remove duplicates", "code": "def remove_dups(seq):\n    \"\"\"remove duplicates from a sequence, preserving order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "remove duplicates from a sequence preserving order", "label": 1}, {"idx": "cosqa-train-16159", "doc": "how to remove cache python", "code": "def __delitem__(self, resource):\n        \"\"\"Remove resource instance from internal cache\"\"\"\n        self.__caches[type(resource)].pop(resource.get_cache_internal_key(), None)", "code_tokens": "def __delitem__ ( self , resource ) : self . __caches [ type ( resource ) ] . pop ( resource . get_cache_internal_key ( ) , None )", "docstring_tokens": "Remove resource instance from internal cache", "label": 1}, {"idx": "cosqa-train-16160", "doc": "python sklearn fit several versions of a model with different features", "code": "def partial_fit(self, X, y=None, classes=None, **fit_params):\n        \"\"\"Fit the module.\n\n        If the module is initialized, it is not re-initialized, which\n        means that this method should be used if you want to continue\n        training a model (warm start).\n\n        Parameters\n        ----------\n        X : input data, compatible with skorch.dataset.Dataset\n          By default, you should be able to pass:\n\n            * numpy arrays\n            * torch tensors\n            * pandas DataFrame or Series\n            * scipy sparse CSR matrices\n            * a dictionary of the former three\n            * a list/tuple of the former three\n            * a Dataset\n\n          If this doesn't work with your data, you have to pass a\n          ``Dataset`` that can deal with the data.\n\n        y : target data, compatible with skorch.dataset.Dataset\n          The same data types as for ``X`` are supported. If your X is\n          a Dataset that contains the target, ``y`` may be set to\n          None.\n\n        classes : array, sahpe (n_classes,)\n          Solely for sklearn compatibility, currently unused.\n\n        **fit_params : dict\n          Additional parameters passed to the ``forward`` method of\n          the module and to the ``self.train_split`` call.\n\n        \"\"\"\n        if not self.initialized_:\n            self.initialize()\n\n        self.notify('on_train_begin', X=X, y=y)\n        try:\n            self.fit_loop(X, y, **fit_params)\n        except KeyboardInterrupt:\n            pass\n        self.notify('on_train_end', X=X, y=y)\n        return self", "code_tokens": "def partial_fit ( self , X , y = None , classes = None , * * fit_params ) : if not self . initialized_ : self . initialize ( ) self . notify ( 'on_train_begin' , X = X , y = y ) try : self . fit_loop ( X , y , * * fit_params ) except KeyboardInterrupt : pass self . notify ( 'on_train_end' , X = X , y = y ) return self", "docstring_tokens": "Fit the module .", "label": 0}, {"idx": "cosqa-train-16161", "doc": "how to remove comma in a string python", "code": "def split_comma_argument(comma_sep_str):\n    \"\"\"Split a comma separated option into a list.\"\"\"\n    terms = []\n    for term in comma_sep_str.split(','):\n        if term:\n            terms.append(term)\n    return terms", "code_tokens": "def split_comma_argument ( comma_sep_str ) : terms = [ ] for term in comma_sep_str . split ( ',' ) : if term : terms . append ( term ) return terms", "docstring_tokens": "Split a comma separated option into a list .", "label": 1}, {"idx": "cosqa-train-16162", "doc": "python slice array beginning", "code": "def getbyteslice(self, start, end):\n        \"\"\"Direct access to byte data.\"\"\"\n        c = self._rawarray[start:end]\n        return c", "code_tokens": "def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c", "docstring_tokens": "Direct access to byte data .", "label": 0}, {"idx": "cosqa-train-16163", "doc": "how to remove empty dictionaries in python", "code": "def _remove_empty_items(d, required):\n  \"\"\"Return a new dict with any empty items removed.\n\n  Note that this is not a deep check. If d contains a dictionary which\n  itself contains empty items, those are never checked.\n\n  This method exists to make to_serializable() functions cleaner.\n  We could revisit this some day, but for now, the serialized objects are\n  stripped of empty values to keep the output YAML more compact.\n\n  Args:\n    d: a dictionary\n    required: list of required keys (for example, TaskDescriptors always emit\n      the \"task-id\", even if None)\n\n  Returns:\n    A dictionary with empty items removed.\n  \"\"\"\n\n  new_dict = {}\n  for k, v in d.items():\n    if k in required:\n      new_dict[k] = v\n    elif isinstance(v, int) or v:\n      # \"if v\" would suppress emitting int(0)\n      new_dict[k] = v\n\n  return new_dict", "code_tokens": "def _remove_empty_items ( d , required ) : new_dict = { } for k , v in d . items ( ) : if k in required : new_dict [ k ] = v elif isinstance ( v , int ) or v : # \"if v\" would suppress emitting int(0) new_dict [ k ] = v return new_dict", "docstring_tokens": "Return a new dict with any empty items removed .", "label": 0}, {"idx": "cosqa-train-16164", "doc": "python slice array without copy", "code": "def getbyteslice(self, start, end):\n        \"\"\"Direct access to byte data.\"\"\"\n        c = self._rawarray[start:end]\n        return c", "code_tokens": "def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c", "docstring_tokens": "Direct access to byte data .", "label": 0}, {"idx": "cosqa-train-16165", "doc": "how to remove letters in python data frame", "code": "def clean_colnames(df):\n    \"\"\" Cleans the column names on a DataFrame\n    Parameters:\n    df - DataFrame\n        The DataFrame to clean\n    \"\"\"\n    col_list = []\n    for index in range(_dutils.cols(df)):\n        col_list.append(df.columns[index].strip().lower().replace(' ','_'))\n    df.columns = col_list", "code_tokens": "def clean_colnames ( df ) : col_list = [ ] for index in range ( _dutils . cols ( df ) ) : col_list . append ( df . columns [ index ] . strip ( ) . lower ( ) . replace ( ' ' , '_' ) ) df . columns = col_list", "docstring_tokens": "Cleans the column names on a DataFrame Parameters : df - DataFrame The DataFrame to clean", "label": 1}, {"idx": "cosqa-train-16166", "doc": "python slice list in unequal lengths", "code": "def partition(a, sz): \n    \"\"\"splits iterables a in equal parts of size sz\"\"\"\n    return [a[i:i+sz] for i in range(0, len(a), sz)]", "code_tokens": "def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]", "docstring_tokens": "splits iterables a in equal parts of size sz", "label": 0}, {"idx": "cosqa-train-16167", "doc": "how to remove space string from a list in python", "code": "def split(s):\n  \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"\n  l = [_split(x) for x in _SPLIT_RE.split(s)]\n  return [item for sublist in l for item in sublist]", "code_tokens": "def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Uses dynamic programming to infer the location of spaces in a string without spaces .", "label": 0}, {"idx": "cosqa-train-16168", "doc": "python slice notation iteables", "code": "def chunks(iterable, chunk):\n    \"\"\"Yield successive n-sized chunks from an iterable.\"\"\"\n    for i in range(0, len(iterable), chunk):\n        yield iterable[i:i + chunk]", "code_tokens": "def chunks ( iterable , chunk ) : for i in range ( 0 , len ( iterable ) , chunk ) : yield iterable [ i : i + chunk ]", "docstring_tokens": "Yield successive n - sized chunks from an iterable .", "label": 0}, {"idx": "cosqa-train-16169", "doc": "how to repeat a try in python", "code": "def retry_test(func):\n    \"\"\"Retries the passed function 3 times before failing\"\"\"\n    success = False\n    ex = Exception(\"Unknown\")\n    for i in six.moves.range(3):\n        try:\n            result = func()\n        except Exception as e:\n            time.sleep(1)\n            ex = e\n        else:\n            success = True\n            break\n    if not success:\n        raise ex\n    assert success\n    return result", "code_tokens": "def retry_test ( func ) : success = False ex = Exception ( \"Unknown\" ) for i in six . moves . range ( 3 ) : try : result = func ( ) except Exception as e : time . sleep ( 1 ) ex = e else : success = True break if not success : raise ex assert success return result", "docstring_tokens": "Retries the passed function 3 times before failing", "label": 1}, {"idx": "cosqa-train-16170", "doc": "python small unique id", "code": "def generate_unique_host_id():\n    \"\"\"Generate a unique ID, that is somewhat guaranteed to be unique among all\n    instances running at the same time.\"\"\"\n    host = \".\".join(reversed(socket.gethostname().split(\".\")))\n    pid = os.getpid()\n    return \"%s.%d\" % (host, pid)", "code_tokens": "def generate_unique_host_id ( ) : host = \".\" . join ( reversed ( socket . gethostname ( ) . split ( \".\" ) ) ) pid = os . getpid ( ) return \"%s.%d\" % ( host , pid )", "docstring_tokens": "Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time .", "label": 0}, {"idx": "cosqa-train-16171", "doc": "how to replace a letter in python", "code": "def dashrepl(value):\n    \"\"\"\n    Replace any non-word characters with a dash.\n    \"\"\"\n    patt = re.compile(r'\\W', re.UNICODE)\n    return re.sub(patt, '-', value)", "code_tokens": "def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "docstring_tokens": "Replace any non - word characters with a dash .", "label": 0}, {"idx": "cosqa-train-16172", "doc": "python smooth a matrix", "code": "def smooth_array(array, amount=1):\n    \"\"\"\n\n    Returns the nearest-neighbor (+/- amount) smoothed array.\n    This does not modify the array or slice off the funny end points.\n\n    \"\"\"\n    if amount==0: return array\n\n    # we have to store the old values in a temp array to keep the\n    # smoothing from affecting the smoothing\n    new_array = _n.array(array)\n\n    for n in range(len(array)):\n        new_array[n] = smooth(array, n, amount)\n\n    return new_array", "code_tokens": "def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-16173", "doc": "how to replace a phrase with underscore in python", "code": "def underscore(text):\n    \"\"\"Converts text that may be camelcased into an underscored format\"\"\"\n    return UNDERSCORE[1].sub(r'\\1_\\2', UNDERSCORE[0].sub(r'\\1_\\2', text)).lower()", "code_tokens": "def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "docstring_tokens": "Converts text that may be camelcased into an underscored format", "label": 1}, {"idx": "cosqa-train-16174", "doc": "python solve exponential function", "code": "def algo_exp(x, m, t, b):\n    \"\"\"mono-exponential curve.\"\"\"\n    return m*np.exp(-t*x)+b", "code_tokens": "def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b", "docstring_tokens": "mono - exponential curve .", "label": 0}, {"idx": "cosqa-train-16175", "doc": "how to replace a string in a file python", "code": "def replace_all(filepath, searchExp, replaceExp):\n    \"\"\"\n    Replace all the ocurrences (in a file) of a string with another value.\n    \"\"\"\n    for line in fileinput.input(filepath, inplace=1):\n        if searchExp in line:\n            line = line.replace(searchExp, replaceExp)\n        sys.stdout.write(line)", "code_tokens": "def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )", "docstring_tokens": "Replace all the ocurrences ( in a file ) of a string with another value .", "label": 1}, {"idx": "cosqa-train-16176", "doc": "python some stdout to screen", "code": "def _stdout_raw(self, s):\n        \"\"\"Writes the string to stdout\"\"\"\n        print(s, end='', file=sys.stdout)\n        sys.stdout.flush()", "code_tokens": "def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )", "docstring_tokens": "Writes the string to stdout", "label": 1}, {"idx": "cosqa-train-16177", "doc": "how to replace infinity in python with 0", "code": "def get_neg_infinity(dtype):\n    \"\"\"Return an appropriate positive infinity for this dtype.\n\n    Parameters\n    ----------\n    dtype : np.dtype\n\n    Returns\n    -------\n    fill_value : positive infinity value corresponding to this dtype.\n    \"\"\"\n    if issubclass(dtype.type, (np.floating, np.integer)):\n        return -np.inf\n\n    if issubclass(dtype.type, np.complexfloating):\n        return -np.inf - 1j * np.inf\n\n    return NINF", "code_tokens": "def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "docstring_tokens": "Return an appropriate positive infinity for this dtype .", "label": 0}, {"idx": "cosqa-train-16178", "doc": "how to replace remove spaces in input python", "code": "def _sanitize(text):\n    \"\"\"Return sanitized Eidos text field for human readability.\"\"\"\n    d = {'-LRB-': '(', '-RRB-': ')'}\n    return re.sub('|'.join(d.keys()), lambda m: d[m.group(0)], text)", "code_tokens": "def _sanitize ( text ) : d = { '-LRB-' : '(' , '-RRB-' : ')' } return re . sub ( '|' . join ( d . keys ( ) ) , lambda m : d [ m . group ( 0 ) ] , text )", "docstring_tokens": "Return sanitized Eidos text field for human readability .", "label": 0}, {"idx": "cosqa-train-16179", "doc": "python sort dictionary list by key", "code": "def unique_list_dicts(dlist, key):\n    \"\"\"Return a list of dictionaries which are sorted for only unique entries.\n\n    :param dlist:\n    :param key:\n    :return list:\n    \"\"\"\n\n    return list(dict((val[key], val) for val in dlist).values())", "code_tokens": "def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )", "docstring_tokens": "Return a list of dictionaries which are sorted for only unique entries .", "label": 0}, {"idx": "cosqa-train-16180", "doc": "how to replace the value in python by fillna", "code": "def _maybe_fill(arr, fill_value=np.nan):\n    \"\"\"\n    if we have a compatible fill_value and arr dtype, then fill\n    \"\"\"\n    if _isna_compat(arr, fill_value):\n        arr.fill(fill_value)\n    return arr", "code_tokens": "def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr", "docstring_tokens": "if we have a compatible fill_value and arr dtype then fill", "label": 0}, {"idx": "cosqa-train-16181", "doc": "python sort filenames like windows", "code": "def sort_filenames(filenames):\n    \"\"\"\n    sort a list of files by filename only, ignoring the directory names\n    \"\"\"\n    basenames = [os.path.basename(x) for x in filenames]\n    indexes = [i[0] for i in sorted(enumerate(basenames), key=lambda x:x[1])]\n    return [filenames[x] for x in indexes]", "code_tokens": "def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "docstring_tokens": "sort a list of files by filename only ignoring the directory names", "label": 1}, {"idx": "cosqa-train-16182", "doc": "how to reset a input python", "code": "def internal_reset(self):\n        \"\"\"\n        internal state reset.\n        used e.g. in unittests\n        \"\"\"\n        log.critical(\"PIA internal_reset()\")\n        self.empty_key_toggle = True\n        self.current_input_char = None\n        self.input_repead = 0", "code_tokens": "def internal_reset ( self ) : log . critical ( \"PIA internal_reset()\" ) self . empty_key_toggle = True self . current_input_char = None self . input_repead = 0", "docstring_tokens": "internal state reset . used e . g . in unittests", "label": 1}, {"idx": "cosqa-train-16183", "doc": "python specify precision of number", "code": "def round_to_int(number, precision):\n    \"\"\"Round a number to a precision\"\"\"\n    precision = int(precision)\n    rounded = (int(number) + precision / 2) // precision * precision\n    return rounded", "code_tokens": "def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "docstring_tokens": "Round a number to a precision", "label": 0}, {"idx": "cosqa-train-16184", "doc": "python specify type in signature", "code": "def returns(self):\n        \"\"\"The return type for this method in a JSON-compatible format.\n\n        This handles the special case of ``None`` which allows ``type(None)`` also.\n\n        :rtype: str | None\n        \"\"\"\n        return_type = self.signature.return_type\n        none_type = type(None)\n        if return_type is not None and return_type is not none_type:\n            return return_type.__name__", "code_tokens": "def returns ( self ) : return_type = self . signature . return_type none_type = type ( None ) if return_type is not None and return_type is not none_type : return return_type . __name__", "docstring_tokens": "The return type for this method in a JSON - compatible format .", "label": 1}, {"idx": "cosqa-train-16185", "doc": "how to reshape a 3d matrix to 2d python", "code": "def im2mat(I):\n    \"\"\"Converts and image to matrix (one pixel per line)\"\"\"\n    return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))", "code_tokens": "def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "docstring_tokens": "Converts and image to matrix ( one pixel per line )", "label": 0}, {"idx": "cosqa-train-16186", "doc": "python sphere fit huge radius", "code": "def Fsphere(q, R):\n    \"\"\"Scattering form-factor amplitude of a sphere normalized to F(q=0)=V\n\n    Inputs:\n    -------\n        ``q``: independent variable\n        ``R``: sphere radius\n\n    Formula:\n    --------\n        ``4*pi/q^3 * (sin(qR) - qR*cos(qR))``\n    \"\"\"\n    return 4 * np.pi / q ** 3 * (np.sin(q * R) - q * R * np.cos(q * R))", "code_tokens": "def Fsphere ( q , R ) : return 4 * np . pi / q ** 3 * ( np . sin ( q * R ) - q * R * np . cos ( q * R ) )", "docstring_tokens": "Scattering form - factor amplitude of a sphere normalized to F ( q = 0 ) = V", "label": 0}, {"idx": "cosqa-train-16187", "doc": "how to reshape an image into a 1 dimensional array on python", "code": "def im2mat(I):\n    \"\"\"Converts and image to matrix (one pixel per line)\"\"\"\n    return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))", "code_tokens": "def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "docstring_tokens": "Converts and image to matrix ( one pixel per line )", "label": 0}, {"idx": "cosqa-train-16188", "doc": "python sphinx attribute docstrings", "code": "def process_docstring(app, what, name, obj, options, lines):\n    \"\"\"Process the docstring for a given python object.\n\n    Called when autodoc has read and processed a docstring. `lines` is a list\n    of docstring lines that `_process_docstring` modifies in place to change\n    what Sphinx outputs.\n\n    The following settings in conf.py control what styles of docstrings will\n    be parsed:\n\n    * ``napoleon_google_docstring`` -- parse Google style docstrings\n    * ``napoleon_numpy_docstring`` -- parse NumPy style docstrings\n\n    Parameters\n    ----------\n    app : sphinx.application.Sphinx\n        Application object representing the Sphinx process.\n    what : str\n        A string specifying the type of the object to which the docstring\n        belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n        \"method\", \"attribute\".\n    name : str\n        The fully qualified name of the object.\n    obj : module, class, exception, function, method, or attribute\n        The object to which the docstring belongs.\n    options : sphinx.ext.autodoc.Options\n        The options given to the directive: an object with attributes\n        inherited_members, undoc_members, show_inheritance and noindex that\n        are True if the flag option of same name was given to the auto\n        directive.\n    lines : list of str\n        The lines of the docstring, see above.\n\n        .. note:: `lines` is modified *in place*\n\n    Notes\n    -----\n    This function is (to most parts) taken from the :mod:`sphinx.ext.napoleon`\n    module, sphinx version 1.3.1, and adapted to the classes defined here\"\"\"\n    result_lines = lines\n    if app.config.napoleon_numpy_docstring:\n        docstring = ExtendedNumpyDocstring(\n            result_lines, app.config, app, what, name, obj, options)\n        result_lines = docstring.lines()\n    if app.config.napoleon_google_docstring:\n        docstring = ExtendedGoogleDocstring(\n            result_lines, app.config, app, what, name, obj, options)\n        result_lines = docstring.lines()\n\n    lines[:] = result_lines[:]", "code_tokens": "def process_docstring ( app , what , name , obj , options , lines ) : result_lines = lines if app . config . napoleon_numpy_docstring : docstring = ExtendedNumpyDocstring ( result_lines , app . config , app , what , name , obj , options ) result_lines = docstring . lines ( ) if app . config . napoleon_google_docstring : docstring = ExtendedGoogleDocstring ( result_lines , app . config , app , what , name , obj , options ) result_lines = docstring . lines ( ) lines [ : ] = result_lines [ : ]", "docstring_tokens": "Process the docstring for a given python object .", "label": 0}, {"idx": "cosqa-train-16189", "doc": "how to retrieve pieces of an http code in python", "code": "def parse_code(url):\n    \"\"\"\n    Parse the code parameter from the a URL\n\n    :param str url: URL to parse\n    :return: code query parameter\n    :rtype: str\n    \"\"\"\n    result = urlparse(url)\n    query = parse_qs(result.query)\n    return query['code']", "code_tokens": "def parse_code ( url ) : result = urlparse ( url ) query = parse_qs ( result . query ) return query [ 'code' ]", "docstring_tokens": "Parse the code parameter from the a URL", "label": 1}, {"idx": "cosqa-train-16190", "doc": "python split a iterable to equal parts", "code": "def partition(a, sz): \n    \"\"\"splits iterables a in equal parts of size sz\"\"\"\n    return [a[i:i+sz] for i in range(0, len(a), sz)]", "code_tokens": "def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]", "docstring_tokens": "splits iterables a in equal parts of size sz", "label": 0}, {"idx": "cosqa-train-16191", "doc": "how to return a json response in python", "code": "def json_response(data, status=200):\n    \"\"\"Return a JsonResponse. Make sure you have django installed first.\"\"\"\n    from django.http import JsonResponse\n    return JsonResponse(data=data, status=status, safe=isinstance(data, dict))", "code_tokens": "def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )", "docstring_tokens": "Return a JsonResponse . Make sure you have django installed first .", "label": 0}, {"idx": "cosqa-train-16192", "doc": "python split a list into multiple lists of size 3", "code": "def chunked(l, n):\n    \"\"\"Chunk one big list into few small lists.\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Chunk one big list into few small lists .", "label": 0}, {"idx": "cosqa-train-16193", "doc": "how to return a y/n question in python using if then", "code": "def prompt_yes_or_no(message):\n    \"\"\" prompt_yes_or_no: Prompt user to reply with a y/n response\n        Args: None\n        Returns: None\n    \"\"\"\n    user_input = input(\"{} [y/n]:\".format(message)).lower()\n    if user_input.startswith(\"y\"):\n        return True\n    elif user_input.startswith(\"n\"):\n        return False\n    else:\n        return prompt_yes_or_no(message)", "code_tokens": "def prompt_yes_or_no ( message ) : user_input = input ( \"{} [y/n]:\" . format ( message ) ) . lower ( ) if user_input . startswith ( \"y\" ) : return True elif user_input . startswith ( \"n\" ) : return False else : return prompt_yes_or_no ( message )", "docstring_tokens": "prompt_yes_or_no : Prompt user to reply with a y / n response Args : None Returns : None", "label": 0}, {"idx": "cosqa-train-16194", "doc": "python split line by space ignoring multiple", "code": "def split_multiline(value):\n    \"\"\"Split a multiline string into a list, excluding blank lines.\"\"\"\n    return [element for element in (line.strip() for line in value.split('\\n'))\n            if element]", "code_tokens": "def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\\n' ) ) if element ]", "docstring_tokens": "Split a multiline string into a list excluding blank lines .", "label": 1}, {"idx": "cosqa-train-16195", "doc": "how to return path of a file in python", "code": "def get_file_string(filepath):\n    \"\"\"Get string from file.\"\"\"\n    with open(os.path.abspath(filepath)) as f:\n        return f.read()", "code_tokens": "def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )", "docstring_tokens": "Get string from file .", "label": 1}, {"idx": "cosqa-train-16196", "doc": "python split string into list of strings of length n", "code": "def _split_str(s, n):\n    \"\"\"\n    split string into list of strings by specified number.\n    \"\"\"\n    length = len(s)\n    return [s[i:i + n] for i in range(0, length, n)]", "code_tokens": "def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "docstring_tokens": "split string into list of strings by specified number .", "label": 1}, {"idx": "cosqa-train-16197", "doc": "how to return the type of an object in python", "code": "def is_integer(obj):\n    \"\"\"Is this an integer.\n\n    :param object obj:\n    :return:\n    \"\"\"\n    if PYTHON3:\n        return isinstance(obj, int)\n    return isinstance(obj, (int, long))", "code_tokens": "def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )", "docstring_tokens": "Is this an integer .", "label": 1}, {"idx": "cosqa-train-16198", "doc": "python sql conmmands whre clause", "code": "def get_sql(query):\n    \"\"\" Returns the sql query \"\"\"\n    sql = str(query.statement.compile(dialect=sqlite.dialect(),\n                                      compile_kwargs={\"literal_binds\": True}))\n    return sql", "code_tokens": "def get_sql ( query ) : sql = str ( query . statement . compile ( dialect = sqlite . dialect ( ) , compile_kwargs = { \"literal_binds\" : True } ) ) return sql", "docstring_tokens": "Returns the sql query", "label": 1}, {"idx": "cosqa-train-16199", "doc": "how to rotate a square through its origin in python", "code": "def rotate_point(xorigin, yorigin, x, y, angle):\n    \"\"\"Rotate the given point by angle\n    \"\"\"\n    rotx = (x - xorigin) * np.cos(angle) - (y - yorigin) * np.sin(angle)\n    roty = (x - yorigin) * np.sin(angle) + (y - yorigin) * np.cos(angle)\n    return rotx, roty", "code_tokens": "def rotate_point ( xorigin , yorigin , x , y , angle ) : rotx = ( x - xorigin ) * np . cos ( angle ) - ( y - yorigin ) * np . sin ( angle ) roty = ( x - yorigin ) * np . sin ( angle ) + ( y - yorigin ) * np . cos ( angle ) return rotx , roty", "docstring_tokens": "Rotate the given point by angle", "label": 1}, {"idx": "cosqa-train-16200", "doc": "python sql server bulk update", "code": "def forceupdate(self, *args, **kw):\n        \"\"\"Like a bulk :meth:`forceput`.\"\"\"\n        self._update(False, self._ON_DUP_OVERWRITE, *args, **kw)", "code_tokens": "def forceupdate ( self , * args , * * kw ) : self . _update ( False , self . _ON_DUP_OVERWRITE , * args , * * kw )", "docstring_tokens": "Like a bulk : meth : forceput .", "label": 0}, {"idx": "cosqa-train-16201", "doc": "how to rotate an array 90 degrees in python", "code": "def rotateImage(image, angle):\n    \"\"\"\n        rotates a 2d array to a multiple of 90 deg.\n        0 = default\n        1 = 90 deg. cw\n        2 = 180 deg.\n        3 = 90 deg. ccw\n    \"\"\"\n    image = [list(row) for row in image]\n\n    for n in range(angle % 4):\n        image = list(zip(*image[::-1]))\n\n    return image", "code_tokens": "def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "docstring_tokens": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw", "label": 1}, {"idx": "cosqa-train-16202", "doc": "python sslconnection reset by peer", "code": "def _shutdown_transport(self):\n        \"\"\"Unwrap a Python 2.6 SSL socket, so we can call shutdown()\"\"\"\n        if self.sock is not None:\n            try:\n                unwrap = self.sock.unwrap\n            except AttributeError:\n                return\n            try:\n                self.sock = unwrap()\n            except ValueError:\n                # Failure within SSL might mean unwrap exists but socket is not\n                # deemed wrapped\n                pass", "code_tokens": "def _shutdown_transport ( self ) : if self . sock is not None : try : unwrap = self . sock . unwrap except AttributeError : return try : self . sock = unwrap ( ) except ValueError : # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass", "docstring_tokens": "Unwrap a Python 2 . 6 SSL socket so we can call shutdown ()", "label": 0}, {"idx": "cosqa-train-16203", "doc": "how to rotate an image clockwise in python", "code": "def rotateImage(img, angle):\n    \"\"\"\n\n    querries scipy.ndimage.rotate routine\n    :param img: image to be rotated\n    :param angle: angle to be rotated (radian)\n    :return: rotated image\n    \"\"\"\n    imgR = scipy.ndimage.rotate(img, angle, reshape=False)\n    return imgR", "code_tokens": "def rotateImage ( img , angle ) : imgR = scipy . ndimage . rotate ( img , angle , reshape = False ) return imgR", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-16204", "doc": "python stack multiple datasets together", "code": "def column_stack_2d(data):\n    \"\"\"Perform column-stacking on a list of 2d data blocks.\"\"\"\n    return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))", "code_tokens": "def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "docstring_tokens": "Perform column - stacking on a list of 2d data blocks .", "label": 0}, {"idx": "cosqa-train-16205", "doc": "how to round significant figures in python", "code": "def round_figures(x, n):\n    \"\"\"Returns x rounded to n significant figures.\"\"\"\n    return round(x, int(n - math.ceil(math.log10(abs(x)))))", "code_tokens": "def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "docstring_tokens": "Returns x rounded to n significant figures .", "label": 0}, {"idx": "cosqa-train-16206", "doc": "python start bottle server in background", "code": "def start():\n    \"\"\"Starts the web server.\"\"\"\n    global app\n    bottle.run(app, host=conf.WebHost, port=conf.WebPort,\n               debug=conf.WebAutoReload, reloader=conf.WebAutoReload,\n               quiet=conf.WebQuiet)", "code_tokens": "def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )", "docstring_tokens": "Starts the web server .", "label": 0}, {"idx": "cosqa-train-16207", "doc": "how to round to certain number of sig figs in python", "code": "def round_sig(x, sig):\n    \"\"\"Round the number to the specified number of significant figures\"\"\"\n    return round(x, sig - int(floor(log10(abs(x)))) - 1)", "code_tokens": "def round_sig ( x , sig ) : return round ( x , sig - int ( floor ( log10 ( abs ( x ) ) ) ) - 1 )", "docstring_tokens": "Round the number to the specified number of significant figures", "label": 1}, {"idx": "cosqa-train-16208", "doc": "python stop a function from calling twice", "code": "def _callable_once(func):\n    \"\"\" Returns a function that is only callable once; any other call will do nothing \"\"\"\n\n    def once(*args, **kwargs):\n        if not once.called:\n            once.called = True\n            return func(*args, **kwargs)\n\n    once.called = False\n    return once", "code_tokens": "def _callable_once ( func ) : def once ( * args , * * kwargs ) : if not once . called : once . called = True return func ( * args , * * kwargs ) once . called = False return once", "docstring_tokens": "Returns a function that is only callable once ; any other call will do nothing", "label": 0}, {"idx": "cosqa-train-16209", "doc": "python store a function as variable", "code": "def getFunction(self):\n        \"\"\"Called by remote workers. Useful to populate main module globals()\n        for interactive shells. Retrieves the serialized function.\"\"\"\n        return functionFactory(\n            self.code,\n            self.name,\n            self.defaults,\n            self.globals,\n            self.imports,\n        )", "code_tokens": "def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "docstring_tokens": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function .", "label": 0}, {"idx": "cosqa-train-16210", "doc": "how to run a python compiled file", "code": "def get_code(module):\n    \"\"\"\n    Compile and return a Module's code object.\n    \"\"\"\n    fp = open(module.path)\n    try:\n        return compile(fp.read(), str(module.name), 'exec')\n    finally:\n        fp.close()", "code_tokens": "def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )", "docstring_tokens": "Compile and return a Module s code object .", "label": 0}, {"idx": "cosqa-train-16211", "doc": "python storing session based information", "code": "def _session_set(self, key, value):\n        \"\"\"\n        Saves a value to session.\n        \"\"\"\n\n        self.session[self._session_key(key)] = value", "code_tokens": "def _session_set ( self , key , value ) : self . session [ self . _session_key ( key ) ] = value", "docstring_tokens": "Saves a value to session .", "label": 1}, {"idx": "cosqa-train-16212", "doc": "how to run python unittests", "code": "def test():\n    \"\"\"Run the unit tests.\"\"\"\n    import unittest\n    tests = unittest.TestLoader().discover('tests')\n    unittest.TextTestRunner(verbosity=2).run(tests)", "code_tokens": "def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )", "docstring_tokens": "Run the unit tests .", "label": 1}, {"idx": "cosqa-train-16213", "doc": "python str object not callable", "code": "def __str__(self):\n        \"\"\"Executes self.function to convert LazyString instance to a real\n        str.\"\"\"\n        if not hasattr(self, '_str'):\n            self._str=self.function(*self.args, **self.kwargs)\n        return self._str", "code_tokens": "def __str__ ( self ) : if not hasattr ( self , '_str' ) : self . _str = self . function ( * self . args , * * self . kwargs ) return self . _str", "docstring_tokens": "Executes self . function to convert LazyString instance to a real str .", "label": 0}, {"idx": "cosqa-train-16214", "doc": "how to save a corpus in python", "code": "def write_json_corpus(documents, fnm):\n    \"\"\"Write a lisst of Text instances as JSON corpus on disk.\n    A JSON corpus contains one document per line, encoded in JSON.\n\n    Parameters\n    ----------\n    documents: iterable of estnltk.text.Text\n        The documents of the corpus\n    fnm: str\n        The path to save the corpus.\n    \"\"\"\n    with codecs.open(fnm, 'wb', 'ascii') as f:\n        for document in documents:\n            f.write(json.dumps(document) + '\\n')\n    return documents", "code_tokens": "def write_json_corpus ( documents , fnm ) : with codecs . open ( fnm , 'wb' , 'ascii' ) as f : for document in documents : f . write ( json . dumps ( document ) + '\\n' ) return documents", "docstring_tokens": "Write a lisst of Text instances as JSON corpus on disk . A JSON corpus contains one document per line encoded in JSON .", "label": 1}, {"idx": "cosqa-train-16215", "doc": "python str pass to shell lost quote", "code": "def quote(self, s):\n        \"\"\"Return a shell-escaped version of the string s.\"\"\"\n\n        if six.PY2:\n            from pipes import quote\n        else:\n            from shlex import quote\n\n        return quote(s)", "code_tokens": "def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "docstring_tokens": "Return a shell - escaped version of the string s .", "label": 0}, {"idx": "cosqa-train-16216", "doc": "how to save a keras model in python", "code": "def save_keras_definition(keras_model, path):\n    \"\"\"\n    Save a Keras model definition to JSON with given path\n    \"\"\"\n    model_json = keras_model.to_json()\n    with open(path, \"w\") as json_file:\n        json_file.write(model_json)", "code_tokens": "def save_keras_definition ( keras_model , path ) : model_json = keras_model . to_json ( ) with open ( path , \"w\" ) as json_file : json_file . write ( model_json )", "docstring_tokens": "Save a Keras model definition to JSON with given path", "label": 0}, {"idx": "cosqa-train-16217", "doc": "python str remove all non allowed character", "code": "def strip_accents(text):\n    \"\"\"\n    Strip agents from a string.\n    \"\"\"\n\n    normalized_str = unicodedata.normalize('NFD', text)\n\n    return ''.join([\n        c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "code_tokens": "def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "docstring_tokens": "Strip agents from a string .", "label": 0}, {"idx": "cosqa-train-16218", "doc": "how to save a python variable as a text file", "code": "def save(variable, filename):\n    \"\"\"Save variable on given path using Pickle\n    \n    Args:\n        variable: what to save\n        path (str): path of the output\n    \"\"\"\n    fileObj = open(filename, 'wb')\n    pickle.dump(variable, fileObj)\n    fileObj.close()", "code_tokens": "def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )", "docstring_tokens": "Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output", "label": 1}, {"idx": "cosqa-train-16219", "doc": "python strictredis redis password", "code": "def get_connection(self, host, port, db):\n        \"\"\"\n        Returns a ``StrictRedis`` connection instance.\n        \"\"\"\n        return redis.StrictRedis(\n            host=host,\n            port=port,\n            db=db,\n            decode_responses=True\n        )", "code_tokens": "def get_connection ( self , host , port , db ) : return redis . StrictRedis ( host = host , port = port , db = db , decode_responses = True )", "docstring_tokens": "Returns a StrictRedis connection instance .", "label": 1}, {"idx": "cosqa-train-16220", "doc": "how to save an image back into file python", "code": "def file_to_png(fp):\n\t\"\"\"Convert an image to PNG format with Pillow.\n\t\n\t:arg file-like fp: The image file.\n\t:rtype: bytes\n\t\"\"\"\n\timport PIL.Image # pylint: disable=import-error\n\twith io.BytesIO() as dest:\n\t\tPIL.Image.open(fp).save(dest, \"PNG\", optimize=True)\n\t\treturn dest.getvalue()", "code_tokens": "def file_to_png ( fp ) : import PIL . Image # pylint: disable=import-error with io . BytesIO ( ) as dest : PIL . Image . open ( fp ) . save ( dest , \"PNG\" , optimize = True ) return dest . getvalue ( )", "docstring_tokens": "Convert an image to PNG format with Pillow . : arg file - like fp : The image file . : rtype : bytes", "label": 1}, {"idx": "cosqa-train-16221", "doc": "python string converts dict", "code": "def str_dict(some_dict):\n    \"\"\"Convert dict of ascii str/unicode to dict of str, if necessary\"\"\"\n    return {str(k): str(v) for k, v in some_dict.items()}", "code_tokens": "def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "docstring_tokens": "Convert dict of ascii str / unicode to dict of str if necessary", "label": 0}, {"idx": "cosqa-train-16222", "doc": "how to see if a value exists in python fcache", "code": "def is_cached(file_name):\n\t\"\"\"\n\tCheck if a given file is available in the cache or not\n\t\"\"\"\n\n\tgml_file_path = join(join(expanduser('~'), OCTOGRID_DIRECTORY), file_name)\n\n\treturn isfile(gml_file_path)", "code_tokens": "def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )", "docstring_tokens": "Check if a given file is available in the cache or not", "label": 0}, {"idx": "cosqa-train-16223", "doc": "python string formatting null or float", "code": "def clean_float(v):\n    \"\"\"Remove commas from a float\"\"\"\n\n    if v is None or not str(v).strip():\n        return None\n\n    return float(str(v).replace(',', ''))", "code_tokens": "def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "docstring_tokens": "Remove commas from a float", "label": 0}, {"idx": "cosqa-train-16224", "doc": "how to see python code in spyder", "code": "def test():        \n    \"\"\"Local test.\"\"\"\n    from spyder.utils.qthelpers import qapplication\n    app = qapplication()\n    dlg = ProjectDialog(None)\n    dlg.show()\n    sys.exit(app.exec_())", "code_tokens": "def test ( ) : from spyder . utils . qthelpers import qapplication app = qapplication ( ) dlg = ProjectDialog ( None ) dlg . show ( ) sys . exit ( app . exec_ ( ) )", "docstring_tokens": "Local test .", "label": 0}, {"idx": "cosqa-train-16225", "doc": "python string last match index", "code": "def findLastCharIndexMatching(text, func):\n    \"\"\" Return index of last character in string for which func(char) evaluates to True. \"\"\"\n    for i in range(len(text) - 1, -1, -1):\n      if func(text[i]):\n        return i", "code_tokens": "def findLastCharIndexMatching ( text , func ) : for i in range ( len ( text ) - 1 , - 1 , - 1 ) : if func ( text [ i ] ) : return i", "docstring_tokens": "Return index of last character in string for which func ( char ) evaluates to True .", "label": 0}, {"idx": "cosqa-train-16226", "doc": "how to select region in array python", "code": "def select_from_array(cls, array, identifier):\n        \"\"\"Return a region from a numpy array.\n        \n        :param array: :class:`numpy.ndarray`\n        :param identifier: value representing the region to select in the array\n        :returns: :class:`jicimagelib.region.Region`\n        \"\"\"\n\n        base_array = np.zeros(array.shape)\n        array_coords = np.where(array == identifier)\n        base_array[array_coords] = 1\n\n        return cls(base_array)", "code_tokens": "def select_from_array ( cls , array , identifier ) : base_array = np . zeros ( array . shape ) array_coords = np . where ( array == identifier ) base_array [ array_coords ] = 1 return cls ( base_array )", "docstring_tokens": "Return a region from a numpy array . : param array : : class : numpy . ndarray : param identifier : value representing the region to select in the array : returns : : class : jicimagelib . region . Region", "label": 1}, {"idx": "cosqa-train-16227", "doc": "python string md5 hashing", "code": "def md5_string(s):\n    \"\"\"\n    Shortcut to create md5 hash\n    :param s:\n    :return:\n    \"\"\"\n    m = hashlib.md5()\n    m.update(s)\n    return str(m.hexdigest())", "code_tokens": "def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "docstring_tokens": "Shortcut to create md5 hash : param s : : return :", "label": 0}, {"idx": "cosqa-train-16228", "doc": "how to select unique elements froma list in python", "code": "def unique_element(ll):\n    \"\"\" returns unique elements from a list preserving the original order \"\"\"\n    seen = {}\n    result = []\n    for item in ll:\n        if item in seen:\n            continue\n        seen[item] = 1\n        result.append(item)\n    return result", "code_tokens": "def unique_element ( ll ) : seen = { } result = [ ] for item in ll : if item in seen : continue seen [ item ] = 1 result . append ( item ) return result", "docstring_tokens": "returns unique elements from a list preserving the original order", "label": 0}, {"idx": "cosqa-train-16229", "doc": "python string method to count whitespace", "code": "def _count_leading_whitespace(text):\n  \"\"\"Returns the number of characters at the beginning of text that are whitespace.\"\"\"\n  idx = 0\n  for idx, char in enumerate(text):\n    if not char.isspace():\n      return idx\n  return idx + 1", "code_tokens": "def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1", "docstring_tokens": "Returns the number of characters at the beginning of text that are whitespace .", "label": 1}, {"idx": "cosqa-train-16230", "doc": "how to self close process in python", "code": "def close(self):\n        \"\"\"Close child subprocess\"\"\"\n        if self._subprocess is not None:\n            os.killpg(self._subprocess.pid, signal.SIGTERM)\n            self._subprocess = None", "code_tokens": "def close ( self ) : if self . _subprocess is not None : os . killpg ( self . _subprocess . pid , signal . SIGTERM ) self . _subprocess = None", "docstring_tokens": "Close child subprocess", "label": 1}, {"idx": "cosqa-train-16231", "doc": "python string to float or nan", "code": "def _convert_to_float_if_possible(s):\n    \"\"\"\n    A small helper function to convert a string to a numeric value\n    if appropriate\n\n    :param s: the string to be converted\n    :type s: str\n    \"\"\"\n    try:\n        ret = float(s)\n    except (ValueError, TypeError):\n        ret = s\n    return ret", "code_tokens": "def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "docstring_tokens": "A small helper function to convert a string to a numeric value if appropriate", "label": 0}, {"idx": "cosqa-train-16232", "doc": "how to send a javascript object to python", "code": "def add_to_js(self, name, var):\n        \"\"\"Add an object to Javascript.\"\"\"\n        frame = self.page().mainFrame()\n        frame.addToJavaScriptWindowObject(name, var)", "code_tokens": "def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "docstring_tokens": "Add an object to Javascript .", "label": 0}, {"idx": "cosqa-train-16233", "doc": "python string to interpolation", "code": "def lin_interp(x, rangeX, rangeY):\n    \"\"\"\n    Interpolate linearly variable x in rangeX onto rangeY.\n    \"\"\"\n    s = (x - rangeX[0]) / mag(rangeX[1] - rangeX[0])\n    y = rangeY[0] * (1 - s) + rangeY[1] * s\n    return y", "code_tokens": "def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y", "docstring_tokens": "Interpolate linearly variable x in rangeX onto rangeY .", "label": 0}, {"idx": "cosqa-train-16234", "doc": "how to send signal to kill a process in python", "code": "def process_kill(pid, sig=None):\n    \"\"\"Send signal to process.\n    \"\"\"\n    sig = sig or signal.SIGTERM\n    os.kill(pid, sig)", "code_tokens": "def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )", "docstring_tokens": "Send signal to process .", "label": 0}, {"idx": "cosqa-train-16235", "doc": "python string uppercase first letter", "code": "def parse_case_snake_to_camel(snake, upper_first=True):\n\t\"\"\"\n\tConvert a string from snake_case to CamelCase.\n\n\t:param str snake: The snake_case string to convert.\n\t:param bool upper_first: Whether or not to capitalize the first\n\t\tcharacter of the string.\n\t:return: The CamelCase version of string.\n\t:rtype: str\n\t\"\"\"\n\tsnake = snake.split('_')\n\tfirst_part = snake[0]\n\tif upper_first:\n\t\tfirst_part = first_part.title()\n\treturn first_part + ''.join(word.title() for word in snake[1:])", "code_tokens": "def parse_case_snake_to_camel ( snake , upper_first = True ) : snake = snake . split ( '_' ) first_part = snake [ 0 ] if upper_first : first_part = first_part . title ( ) return first_part + '' . join ( word . title ( ) for word in snake [ 1 : ] )", "docstring_tokens": "Convert a string from snake_case to CamelCase .", "label": 0}, {"idx": "cosqa-train-16236", "doc": "how to session log in python", "code": "def destroy(self):\n\t\t\"\"\"Finish up a session.\n\t\t\"\"\"\n\t\tif self.session_type == 'bash':\n\t\t\t# TODO: does this work/handle already being logged out/logged in deep OK?\n\t\t\tself.logout()\n\t\telif self.session_type == 'vagrant':\n\t\t\t# TODO: does this work/handle already being logged out/logged in deep OK?\n\t\t\tself.logout()", "code_tokens": "def destroy ( self ) : if self . session_type == 'bash' : # TODO: does this work/handle already being logged out/logged in deep OK? self . logout ( ) elif self . session_type == 'vagrant' : # TODO: does this work/handle already being logged out/logged in deep OK? self . logout ( )", "docstring_tokens": "Finish up a session .", "label": 0}, {"idx": "cosqa-train-16237", "doc": "python strip new lines while reading file", "code": "def get_stripped_file_lines(filename):\n    \"\"\"\n    Return lines of a file with whitespace removed\n    \"\"\"\n    try:\n        lines = open(filename).readlines()\n    except FileNotFoundError:\n        fatal(\"Could not open file: {!r}\".format(filename))\n\n    return [line.strip() for line in lines]", "code_tokens": "def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( \"Could not open file: {!r}\" . format ( filename ) ) return [ line . strip ( ) for line in lines ]", "docstring_tokens": "Return lines of a file with whitespace removed", "label": 1}, {"idx": "cosqa-train-16238", "doc": "python strip non space whitespace", "code": "def text_remove_empty_lines(text):\n    \"\"\"\n    Whitespace normalization:\n\n      - Strip empty lines\n      - Strip trailing whitespace\n    \"\"\"\n    lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]\n    return \"\\n\".join(lines)", "code_tokens": "def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "docstring_tokens": "Whitespace normalization :", "label": 1}, {"idx": "cosqa-train-16239", "doc": "how to set axis range in python plot", "code": "def ylim(self, low, high, index=1):\n        \"\"\"Set yaxis limits.\n\n        Parameters\n        ----------\n        low : number\n        high : number\n        index : int, optional\n\n        Returns\n        -------\n        Chart\n\n        \"\"\"\n        self.layout['yaxis' + str(index)]['range'] = [low, high]\n        return self", "code_tokens": "def ylim ( self , low , high , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'range' ] = [ low , high ] return self", "docstring_tokens": "Set yaxis limits .", "label": 0}, {"idx": "cosqa-train-16240", "doc": "python strip single quote from string output", "code": "def _repr_strip(mystring):\n    \"\"\"\n    Returns the string without any initial or final quotes.\n    \"\"\"\n    r = repr(mystring)\n    if r.startswith(\"'\") and r.endswith(\"'\"):\n        return r[1:-1]\n    else:\n        return r", "code_tokens": "def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "docstring_tokens": "Returns the string without any initial or final quotes .", "label": 0}, {"idx": "cosqa-train-16241", "doc": "how to set axis range on graphs in python", "code": "def ylim(self, low, high, index=1):\n        \"\"\"Set yaxis limits.\n\n        Parameters\n        ----------\n        low : number\n        high : number\n        index : int, optional\n\n        Returns\n        -------\n        Chart\n\n        \"\"\"\n        self.layout['yaxis' + str(index)]['range'] = [low, high]\n        return self", "code_tokens": "def ylim ( self , low , high , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'range' ] = [ low , high ] return self", "docstring_tokens": "Set yaxis limits .", "label": 1}, {"idx": "cosqa-train-16242", "doc": "python style multiline array", "code": "def barray(iterlines):\n    \"\"\"\n    Array of bytes\n    \"\"\"\n    lst = [line.encode('utf-8') for line in iterlines]\n    arr = numpy.array(lst)\n    return arr", "code_tokens": "def barray ( iterlines ) : lst = [ line . encode ( 'utf-8' ) for line in iterlines ] arr = numpy . array ( lst ) return arr", "docstring_tokens": "Array of bytes", "label": 0}, {"idx": "cosqa-train-16243", "doc": "how to set clipping thresholds automatcally python", "code": "def set_gradclip_const(self, min_value, max_value):\n        \"\"\"\n        Configure constant clipping settings.\n\n\n        :param min_value: the minimum value to clip by\n        :param max_value: the maxmimum value to clip by\n        \"\"\"\n        callBigDlFunc(self.bigdl_type, \"setConstantClip\", self.value, min_value, max_value)", "code_tokens": "def set_gradclip_const ( self , min_value , max_value ) : callBigDlFunc ( self . bigdl_type , \"setConstantClip\" , self . value , min_value , max_value )", "docstring_tokens": "Configure constant clipping settings .", "label": 0}, {"idx": "cosqa-train-16244", "doc": "python subplot no padding for xticks", "code": "def show_xticklabels(self, row, column):\n        \"\"\"Show the x-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_xticklabels()", "code_tokens": "def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "docstring_tokens": "Show the x - axis tick labels for a subplot .", "label": 0}, {"idx": "cosqa-train-16245", "doc": "how to set connection timeout in python", "code": "def connect(self):\n        \"\"\"Connects to the given host\"\"\"\n        self.socket = socket.create_connection(self.address, self.timeout)", "code_tokens": "def connect ( self ) : self . socket = socket . create_connection ( self . address , self . timeout )", "docstring_tokens": "Connects to the given host", "label": 0}, {"idx": "cosqa-train-16246", "doc": "python subprocess kill all the processes", "code": "def kill_all(self, kill_signal, kill_shell=False):\n        \"\"\"Kill all running processes.\"\"\"\n        for key in self.processes.keys():\n            self.kill_process(key, kill_signal, kill_shell)", "code_tokens": "def kill_all ( self , kill_signal , kill_shell = False ) : for key in self . processes . keys ( ) : self . kill_process ( key , kill_signal , kill_shell )", "docstring_tokens": "Kill all running processes .", "label": 0}, {"idx": "cosqa-train-16247", "doc": "how to set cursor location in python", "code": "def set_cursor_position(self, position):\n        \"\"\"Set cursor position\"\"\"\n        position = self.get_position(position)\n        cursor = self.textCursor()\n        cursor.setPosition(position)\n        self.setTextCursor(cursor)\n        self.ensureCursorVisible()", "code_tokens": "def set_cursor_position ( self , position ) : position = self . get_position ( position ) cursor = self . textCursor ( ) cursor . setPosition ( position ) self . setTextCursor ( cursor ) self . ensureCursorVisible ( )", "docstring_tokens": "Set cursor position", "label": 0}, {"idx": "cosqa-train-16248", "doc": "python subprocess open can not kill", "code": "def _finish(self):\n        \"\"\"\n        Closes and waits for subprocess to exit.\n        \"\"\"\n        if self._process.returncode is None:\n            self._process.stdin.flush()\n            self._process.stdin.close()\n            self._process.wait()\n            self.closed = True", "code_tokens": "def _finish ( self ) : if self . _process . returncode is None : self . _process . stdin . flush ( ) self . _process . stdin . close ( ) self . _process . wait ( ) self . closed = True", "docstring_tokens": "Closes and waits for subprocess to exit .", "label": 0}, {"idx": "cosqa-train-16249", "doc": "how to set limits on axis in python", "code": "def _set_axis_limits(self, which, lims, d, scale, reverse=False):\n        \"\"\"Private method for setting axis limits.\n\n        Sets the axis limits on each axis for an individual plot.\n\n        Args:\n            which (str): The indicator of which part of the plots\n                to adjust. This currently handles `x` and `y`.\n            lims (len-2 list of floats): The limits for the axis.\n            d (float): Amount to increment by between the limits.\n            scale (str): Scale of the axis. Either `log` or `lin`.\n            reverse (bool, optional): If True, reverse the axis tick marks. Default is False.\n\n        \"\"\"\n        setattr(self.limits, which + 'lims', lims)\n        setattr(self.limits, 'd' + which, d)\n        setattr(self.limits, which + 'scale', scale)\n\n        if reverse:\n            setattr(self.limits, 'reverse_' + which + '_axis', True)\n        return", "code_tokens": "def _set_axis_limits ( self , which , lims , d , scale , reverse = False ) : setattr ( self . limits , which + 'lims' , lims ) setattr ( self . limits , 'd' + which , d ) setattr ( self . limits , which + 'scale' , scale ) if reverse : setattr ( self . limits , 'reverse_' + which + '_axis' , True ) return", "docstring_tokens": "Private method for setting axis limits .", "label": 1}, {"idx": "cosqa-train-16250", "doc": "python subsample replaced with strides", "code": "def downsample_with_striding(array, factor):\n    \"\"\"Downsample x by factor using striding.\n\n    @return: The downsampled array, of the same type as x.\n    \"\"\"\n    return array[tuple(np.s_[::f] for f in factor)]", "code_tokens": "def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]", "docstring_tokens": "Downsample x by factor using striding .", "label": 0}, {"idx": "cosqa-train-16251", "doc": "how to set path of a file in python", "code": "def relative_path(path):\n    \"\"\"\n    Return the given path relative to this file.\n    \"\"\"\n    return os.path.join(os.path.dirname(__file__), path)", "code_tokens": "def relative_path ( path ) : return os . path . join ( os . path . dirname ( __file__ ) , path )", "docstring_tokens": "Return the given path relative to this file .", "label": 1}, {"idx": "cosqa-train-16252", "doc": "python subset of a column not missing values and not zero", "code": "def dropna(self, subset=None):\n        \"\"\"Remove missing values according to Baloo's convention.\n\n        Parameters\n        ----------\n        subset : list of str, optional\n            Which columns to check for missing values in.\n\n        Returns\n        -------\n        DataFrame\n            DataFrame with no null values in columns.\n\n        \"\"\"\n        subset = check_and_obtain_subset_columns(subset, self)\n        not_nas = [v.notna() for v in self[subset]._iter()]\n        and_filter = reduce(lambda x, y: x & y, not_nas)\n\n        return self[and_filter]", "code_tokens": "def dropna ( self , subset = None ) : subset = check_and_obtain_subset_columns ( subset , self ) not_nas = [ v . notna ( ) for v in self [ subset ] . _iter ( ) ] and_filter = reduce ( lambda x , y : x & y , not_nas ) return self [ and_filter ]", "docstring_tokens": "Remove missing values according to Baloo s convention .", "label": 0}, {"idx": "cosqa-train-16253", "doc": "how to set python libary path on linux", "code": "def GetPythonLibraryDirectoryPath():\n  \"\"\"Retrieves the Python library directory path.\"\"\"\n  path = sysconfig.get_python_lib(True)\n  _, _, path = path.rpartition(sysconfig.PREFIX)\n\n  if path.startswith(os.sep):\n    path = path[1:]\n\n  return path", "code_tokens": "def GetPythonLibraryDirectoryPath ( ) : path = sysconfig . get_python_lib ( True ) _ , _ , path = path . rpartition ( sysconfig . PREFIX ) if path . startswith ( os . sep ) : path = path [ 1 : ] return path", "docstring_tokens": "Retrieves the Python library directory path .", "label": 1}, {"idx": "cosqa-train-16254", "doc": "python super get parent attribute", "code": "def dump_parent(self, obj):\n        \"\"\"Dump the parent of a PID.\"\"\"\n        if not self._is_parent(obj):\n            return self._dump_relative(obj.pid)\n        return None", "code_tokens": "def dump_parent ( self , obj ) : if not self . _is_parent ( obj ) : return self . _dump_relative ( obj . pid ) return None", "docstring_tokens": "Dump the parent of a PID .", "label": 0}, {"idx": "cosqa-train-16255", "doc": "how to set title of window in python in windows 10", "code": "def title(msg):\n    \"\"\"Sets the title of the console window.\"\"\"\n    if sys.platform.startswith(\"win\"):\n        ctypes.windll.kernel32.SetConsoleTitleW(tounicode(msg))", "code_tokens": "def title ( msg ) : if sys . platform . startswith ( \"win\" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )", "docstring_tokens": "Sets the title of the console window .", "label": 0}, {"idx": "cosqa-train-16256", "doc": "python suppress subprocess stor dont print", "code": "def disown(cmd):\n    \"\"\"Call a system command in the background,\n       disown it and hide it's output.\"\"\"\n    subprocess.Popen(cmd,\n                     stdout=subprocess.DEVNULL,\n                     stderr=subprocess.DEVNULL)", "code_tokens": "def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "docstring_tokens": "Call a system command in the background disown it and hide it s output .", "label": 0}, {"idx": "cosqa-train-16257", "doc": "how to sort a list of datetime in python", "code": "def sort_fn_list(fn_list):\n    \"\"\"Sort input filename list by datetime\n    \"\"\"\n    dt_list = get_dt_list(fn_list)\n    fn_list_sort = [fn for (dt,fn) in sorted(zip(dt_list,fn_list))]\n    return fn_list_sort", "code_tokens": "def sort_fn_list ( fn_list ) : dt_list = get_dt_list ( fn_list ) fn_list_sort = [ fn for ( dt , fn ) in sorted ( zip ( dt_list , fn_list ) ) ] return fn_list_sort", "docstring_tokens": "Sort input filename list by datetime", "label": 0}, {"idx": "cosqa-train-16258", "doc": "python svd failing because of numpy dependcies", "code": "def test_SVD(pca):\n    \"\"\"\n    Function to test the validity of singular\n    value decomposition by reconstructing original\n    data.\n    \"\"\"\n    _ = pca\n    rec = N.dot(_.U,N.dot(_.sigma,_.V))\n    assert N.allclose(_.arr,rec)", "code_tokens": "def test_SVD ( pca ) : _ = pca rec = N . dot ( _ . U , N . dot ( _ . sigma , _ . V ) ) assert N . allclose ( _ . arr , rec )", "docstring_tokens": "Function to test the validity of singular value decomposition by reconstructing original data .", "label": 0}, {"idx": "cosqa-train-16259", "doc": "how to sort data within a column python", "code": "def sort_data(data, cols):\n    \"\"\"Sort `data` rows and order columns\"\"\"\n    return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)", "code_tokens": "def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "docstring_tokens": "Sort data rows and order columns", "label": 1}, {"idx": "cosqa-train-16260", "doc": "python syas im running win32", "code": "def inside_softimage():\n    \"\"\"Returns a boolean indicating if the code is executed inside softimage.\"\"\"\n    try:\n        import maya\n        return False\n    except ImportError:\n        pass\n    try:\n        from win32com.client import Dispatch as disp\n        disp('XSI.Application')\n        return True\n    except:\n        return False", "code_tokens": "def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "docstring_tokens": "Returns a boolean indicating if the code is executed inside softimage .", "label": 1}, {"idx": "cosqa-train-16261", "doc": "how to specify a float number python", "code": "def set_float(self, option, value):\n        \"\"\"Set a float option.\n\n            Args:\n                option (str): name of option.\n                value (float): value of the option.\n\n            Raises:\n                TypeError: Value must be a float.\n        \"\"\"\n        if not isinstance(value, float):\n            raise TypeError(\"Value must be a float\")\n        self.options[option] = value", "code_tokens": "def set_float ( self , option , value ) : if not isinstance ( value , float ) : raise TypeError ( \"Value must be a float\" ) self . options [ option ] = value", "docstring_tokens": "Set a float option .", "label": 1}, {"idx": "cosqa-train-16262", "doc": "python symbols and what do they do", "code": "def symbols():\n    \"\"\"Return a list of symbols.\"\"\"\n    symbols = []\n    for line in symbols_stream():\n        symbols.append(line.decode('utf-8').strip())\n    return symbols", "code_tokens": "def symbols ( ) : symbols = [ ] for line in symbols_stream ( ) : symbols . append ( line . decode ( 'utf-8' ) . strip ( ) ) return symbols", "docstring_tokens": "Return a list of symbols .", "label": 0}, {"idx": "cosqa-train-16263", "doc": "how to split list into words in python", "code": "def tokenize_list(self, text):\n        \"\"\"\n        Split a text into separate words.\n        \"\"\"\n        return [self.get_record_token(record) for record in self.analyze(text)]", "code_tokens": "def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "docstring_tokens": "Split a text into separate words .", "label": 0}, {"idx": "cosqa-train-16264", "doc": "how to split multiple lines of strings in python", "code": "def split_multiline(value):\n    \"\"\"Split a multiline string into a list, excluding blank lines.\"\"\"\n    return [element for element in (line.strip() for line in value.split('\\n'))\n            if element]", "code_tokens": "def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\\n' ) ) if element ]", "docstring_tokens": "Split a multiline string into a list excluding blank lines .", "label": 1}, {"idx": "cosqa-train-16265", "doc": "python tensorflow suppress logging", "code": "def main(argv=None):\n  \"\"\"Run a Tensorflow model on the Iris dataset.\"\"\"\n  args = parse_arguments(sys.argv if argv is None else argv)\n\n  tf.logging.set_verbosity(tf.logging.INFO)\n  learn_runner.run(\n      experiment_fn=get_experiment_fn(args),\n      output_dir=args.job_dir)", "code_tokens": "def main ( argv = None ) : args = parse_arguments ( sys . argv if argv is None else argv ) tf . logging . set_verbosity ( tf . logging . INFO ) learn_runner . run ( experiment_fn = get_experiment_fn ( args ) , output_dir = args . job_dir )", "docstring_tokens": "Run a Tensorflow model on the Iris dataset .", "label": 0}, {"idx": "cosqa-train-16266", "doc": "how to stack column arrays in python", "code": "def column_stack_2d(data):\n    \"\"\"Perform column-stacking on a list of 2d data blocks.\"\"\"\n    return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))", "code_tokens": "def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "docstring_tokens": "Perform column - stacking on a list of 2d data blocks .", "label": 1}, {"idx": "cosqa-train-16267", "doc": "python testing the type of an object instance", "code": "def is_integer(obj):\n    \"\"\"Is this an integer.\n\n    :param object obj:\n    :return:\n    \"\"\"\n    if PYTHON3:\n        return isinstance(obj, int)\n    return isinstance(obj, (int, long))", "code_tokens": "def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )", "docstring_tokens": "Is this an integer .", "label": 0}, {"idx": "cosqa-train-16268", "doc": "how to start django in python", "code": "def server(port):\n    \"\"\"Start the Django dev server.\"\"\"\n    args = ['python', 'manage.py', 'runserver']\n    if port:\n        args.append(port)\n    run.main(args)", "code_tokens": "def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )", "docstring_tokens": "Start the Django dev server .", "label": 0}, {"idx": "cosqa-train-16269", "doc": "python testing to see if a directory is writeable", "code": "def _writable_dir(path):\n    \"\"\"Whether `path` is a directory, to which the user has write access.\"\"\"\n    return os.path.isdir(path) and os.access(path, os.W_OK)", "code_tokens": "def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )", "docstring_tokens": "Whether path is a directory to which the user has write access .", "label": 1}, {"idx": "cosqa-train-16270", "doc": "how to stop running a infinite loop without closing program python", "code": "def timeout_thread_handler(timeout, stop_event):\n    \"\"\"A background thread to kill the process if it takes too long.\n\n    Args:\n        timeout (float): The number of seconds to wait before killing\n            the process.\n        stop_event (Event): An optional event to cleanly stop the background\n            thread if required during testing.\n    \"\"\"\n\n    stop_happened = stop_event.wait(timeout)\n    if stop_happened is False:\n        print(\"Killing program due to %f second timeout\" % timeout)\n\n    os._exit(2)", "code_tokens": "def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( \"Killing program due to %f second timeout\" % timeout ) os . _exit ( 2 )", "docstring_tokens": "A background thread to kill the process if it takes too long .", "label": 1}, {"idx": "cosqa-train-16271", "doc": "python thread list won't clear", "code": "def remove_stopped_threads (self):\n        \"\"\"Remove the stopped threads from the internal thread list.\"\"\"\n        self.threads = [t for t in self.threads if t.is_alive()]", "code_tokens": "def remove_stopped_threads ( self ) : self . threads = [ t for t in self . threads if t . is_alive ( ) ]", "docstring_tokens": "Remove the stopped threads from the internal thread list .", "label": 0}, {"idx": "cosqa-train-16272", "doc": "how to store a list slice as a varable python numpy", "code": "def open_store_variable(self, name, var):\n        \"\"\"Turn CDMRemote variable into something like a numpy.ndarray.\"\"\"\n        data = indexing.LazilyOuterIndexedArray(CDMArrayWrapper(name, self))\n        return Variable(var.dimensions, data, {a: getattr(var, a) for a in var.ncattrs()})", "code_tokens": "def open_store_variable ( self , name , var ) : data = indexing . LazilyOuterIndexedArray ( CDMArrayWrapper ( name , self ) ) return Variable ( var . dimensions , data , { a : getattr ( var , a ) for a in var . ncattrs ( ) } )", "docstring_tokens": "Turn CDMRemote variable into something like a numpy . ndarray .", "label": 0}, {"idx": "cosqa-train-16273", "doc": "python time adjust timezone", "code": "def normalize_time(timestamp):\n    \"\"\"Normalize time in arbitrary timezone to UTC naive object.\"\"\"\n    offset = timestamp.utcoffset()\n    if offset is None:\n        return timestamp\n    return timestamp.replace(tzinfo=None) - offset", "code_tokens": "def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset", "docstring_tokens": "Normalize time in arbitrary timezone to UTC naive object .", "label": 0}, {"idx": "cosqa-train-16274", "doc": "how to store all my python errors in a log file", "code": "def on_error(e):  # pragma: no cover\n    \"\"\"Error handler\n\n    RuntimeError or ValueError exceptions raised by commands will be handled\n    by this function.\n    \"\"\"\n    exname = {'RuntimeError': 'Runtime error', 'Value Error': 'Value error'}\n    sys.stderr.write('{}: {}\\n'.format(exname[e.__class__.__name__], str(e)))\n    sys.stderr.write('See file slam_error.log for additional details.\\n')\n    sys.exit(1)", "code_tokens": "def on_error ( e ) : # pragma: no cover exname = { 'RuntimeError' : 'Runtime error' , 'Value Error' : 'Value error' } sys . stderr . write ( '{}: {}\\n' . format ( exname [ e . __class__ . __name__ ] , str ( e ) ) ) sys . stderr . write ( 'See file slam_error.log for additional details.\\n' ) sys . exit ( 1 )", "docstring_tokens": "Error handler", "label": 0}, {"idx": "cosqa-train-16275", "doc": "python time get the previous monday", "code": "def prevmonday(num):\n    \"\"\"\n    Return unix SECOND timestamp of \"num\" mondays ago\n    \"\"\"\n    today = get_today()\n    lastmonday = today - timedelta(days=today.weekday(), weeks=num)\n    return lastmonday", "code_tokens": "def prevmonday ( num ) : today = get_today ( ) lastmonday = today - timedelta ( days = today . weekday ( ) , weeks = num ) return lastmonday", "docstring_tokens": "Return unix SECOND timestamp of num mondays ago", "label": 0}, {"idx": "cosqa-train-16276", "doc": "how to store list of arrays in python", "code": "def _listify(collection):\n        \"\"\"This is a workaround where Collections are no longer iterable\n        when using JPype.\"\"\"\n        new_list = []\n        for index in range(len(collection)):\n            new_list.append(collection[index])\n        return new_list", "code_tokens": "def _listify ( collection ) : new_list = [ ] for index in range ( len ( collection ) ) : new_list . append ( collection [ index ] ) return new_list", "docstring_tokens": "This is a workaround where Collections are no longer iterable when using JPype .", "label": 0}, {"idx": "cosqa-train-16277", "doc": "python time limit to kill the process", "code": "def _shutdown_proc(p, timeout):\n  \"\"\"Wait for a proc to shut down, then terminate or kill it after `timeout`.\"\"\"\n  freq = 10  # how often to check per second\n  for _ in range(1 + timeout * freq):\n    ret = p.poll()\n    if ret is not None:\n      logging.info(\"Shutdown gracefully.\")\n      return ret\n    time.sleep(1 / freq)\n  logging.warning(\"Killing the process.\")\n  p.kill()\n  return p.wait()", "code_tokens": "def _shutdown_proc ( p , timeout ) : freq = 10 # how often to check per second for _ in range ( 1 + timeout * freq ) : ret = p . poll ( ) if ret is not None : logging . info ( \"Shutdown gracefully.\" ) return ret time . sleep ( 1 / freq ) logging . warning ( \"Killing the process.\" ) p . kill ( ) return p . wait ( )", "docstring_tokens": "Wait for a proc to shut down then terminate or kill it after timeout .", "label": 1}, {"idx": "cosqa-train-16278", "doc": "how to strip non alphanumeric characters python", "code": "def strip_accents(string):\n    \"\"\"\n    Strip all the accents from the string\n    \"\"\"\n    return u''.join(\n        (character for character in unicodedata.normalize('NFD', string)\n         if unicodedata.category(character) != 'Mn'))", "code_tokens": "def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "docstring_tokens": "Strip all the accents from the string", "label": 0}, {"idx": "cosqa-train-16279", "doc": "python time struct to unix time", "code": "def to_unix(cls, timestamp):\n        \"\"\" Wrapper over time module to produce Unix epoch time as a float \"\"\"\n        if not isinstance(timestamp, datetime.datetime):\n            raise TypeError('Time.milliseconds expects a datetime object')\n        base = time.mktime(timestamp.timetuple())\n        return base", "code_tokens": "def to_unix ( cls , timestamp ) : if not isinstance ( timestamp , datetime . datetime ) : raise TypeError ( 'Time.milliseconds expects a datetime object' ) base = time . mktime ( timestamp . timetuple ( ) ) return base", "docstring_tokens": "Wrapper over time module to produce Unix epoch time as a float", "label": 1}, {"idx": "cosqa-train-16280", "doc": "how to strip single quote python", "code": "def _repr_strip(mystring):\n    \"\"\"\n    Returns the string without any initial or final quotes.\n    \"\"\"\n    r = repr(mystring)\n    if r.startswith(\"'\") and r.endswith(\"'\"):\n        return r[1:-1]\n    else:\n        return r", "code_tokens": "def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "docstring_tokens": "Returns the string without any initial or final quotes .", "label": 0}, {"idx": "cosqa-train-16281", "doc": "python time zone offset", "code": "def normalize_time(timestamp):\n    \"\"\"Normalize time in arbitrary timezone to UTC naive object.\"\"\"\n    offset = timestamp.utcoffset()\n    if offset is None:\n        return timestamp\n    return timestamp.replace(tzinfo=None) - offset", "code_tokens": "def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset", "docstring_tokens": "Normalize time in arbitrary timezone to UTC naive object .", "label": 1}, {"idx": "cosqa-train-16282", "doc": "how to strip spaces from string python", "code": "def split(s):\n  \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"\n  l = [_split(x) for x in _SPLIT_RE.split(s)]\n  return [item for sublist in l for item in sublist]", "code_tokens": "def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Uses dynamic programming to infer the location of spaces in a string without spaces .", "label": 0}, {"idx": "cosqa-train-16283", "doc": "how to swap letter cases in python", "code": "def to_snake_case(s):\n    \"\"\"Converts camel-case identifiers to snake-case.\"\"\"\n    return re.sub('([^_A-Z])([A-Z])', lambda m: m.group(1) + '_' + m.group(2).lower(), s)", "code_tokens": "def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )", "docstring_tokens": "Converts camel - case identifiers to snake - case .", "label": 0}, {"idx": "cosqa-train-16284", "doc": "python tkinter event keyrelease", "code": "def keyReleaseEvent(self, event):\n        \"\"\"\n        Pyqt specific key release callback function.\n        Translates and forwards events to :py:func:`keyboard_event`.\n        \"\"\"\n        self.keyboard_event(event.key(), self.keys.ACTION_RELEASE, 0)", "code_tokens": "def keyReleaseEvent ( self , event ) : self . keyboard_event ( event . key ( ) , self . keys . ACTION_RELEASE , 0 )", "docstring_tokens": "Pyqt specific key release callback function . Translates and forwards events to : py : func : keyboard_event .", "label": 1}, {"idx": "cosqa-train-16285", "doc": "how to swap rows and columns of a matrix in python", "code": "def _swap_rows(self, i, j):\n        \"\"\"Swap i and j rows\n\n        As the side effect, determinant flips.\n\n        \"\"\"\n\n        L = np.eye(3, dtype='intc')\n        L[i, i] = 0\n        L[j, j] = 0\n        L[i, j] = 1\n        L[j, i] = 1\n        self._L.append(L.copy())\n        self._A = np.dot(L, self._A)", "code_tokens": "def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "docstring_tokens": "Swap i and j rows", "label": 0}, {"idx": "cosqa-train-16286", "doc": "python tkinter how to create scrollable canvas", "code": "def _set_scroll_v(self, *args):\n        \"\"\"Scroll both categories Canvas and scrolling container\"\"\"\n        self._canvas_categories.yview(*args)\n        self._canvas_scroll.yview(*args)", "code_tokens": "def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "docstring_tokens": "Scroll both categories Canvas and scrolling container", "label": 1}, {"idx": "cosqa-train-16287", "doc": "how to switch the python prompt", "code": "def input(self, prompt, default=None, show_default=True):\n        \"\"\"Provide a command prompt.\"\"\"\n        return click.prompt(prompt, default=default, show_default=show_default)", "code_tokens": "def input ( self , prompt , default = None , show_default = True ) : return click . prompt ( prompt , default = default , show_default = show_default )", "docstring_tokens": "Provide a command prompt .", "label": 0}, {"idx": "cosqa-train-16288", "doc": "python tkinter open file dialog", "code": "def askopenfilename(**kwargs):\n    \"\"\"Return file name(s) from Tkinter's file open dialog.\"\"\"\n    try:\n        from Tkinter import Tk\n        import tkFileDialog as filedialog\n    except ImportError:\n        from tkinter import Tk, filedialog\n    root = Tk()\n    root.withdraw()\n    root.update()\n    filenames = filedialog.askopenfilename(**kwargs)\n    root.destroy()\n    return filenames", "code_tokens": "def askopenfilename ( * * kwargs ) : try : from Tkinter import Tk import tkFileDialog as filedialog except ImportError : from tkinter import Tk , filedialog root = Tk ( ) root . withdraw ( ) root . update ( ) filenames = filedialog . askopenfilename ( * * kwargs ) root . destroy ( ) return filenames", "docstring_tokens": "Return file name ( s ) from Tkinter s file open dialog .", "label": 0}, {"idx": "cosqa-train-16289", "doc": "how to take date as array in python", "code": "def get_dt_list(fn_list):\n    \"\"\"Get list of datetime objects, extracted from a filename\n    \"\"\"\n    dt_list = np.array([fn_getdatetime(fn) for fn in fn_list])\n    return dt_list", "code_tokens": "def get_dt_list ( fn_list ) : dt_list = np . array ( [ fn_getdatetime ( fn ) for fn in fn_list ] ) return dt_list", "docstring_tokens": "Get list of datetime objects extracted from a filename", "label": 0}, {"idx": "cosqa-train-16290", "doc": "python tkinter prevent text wrapping", "code": "def toggle_word_wrap(self):\n        \"\"\"\n        Toggles document word wrap.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        self.setWordWrapMode(not self.wordWrapMode() and QTextOption.WordWrap or QTextOption.NoWrap)\n        return True", "code_tokens": "def toggle_word_wrap ( self ) : self . setWordWrapMode ( not self . wordWrapMode ( ) and QTextOption . WordWrap or QTextOption . NoWrap ) return True", "docstring_tokens": "Toggles document word wrap .", "label": 0}, {"idx": "cosqa-train-16291", "doc": "how to take the inverse of a list in python", "code": "def unique_inverse(item_list):\n    \"\"\"\n    Like np.unique(item_list, return_inverse=True)\n    \"\"\"\n    import utool as ut\n    unique_items = ut.unique(item_list)\n    inverse = list_alignment(unique_items, item_list)\n    return unique_items, inverse", "code_tokens": "def unique_inverse ( item_list ) : import utool as ut unique_items = ut . unique ( item_list ) inverse = list_alignment ( unique_items , item_list ) return unique_items , inverse", "docstring_tokens": "Like np . unique ( item_list return_inverse = True )", "label": 0}, {"idx": "cosqa-train-16292", "doc": "python tkinter prevent window update", "code": "def hide(self):\n        \"\"\"Hide the window.\"\"\"\n        self.tk.withdraw()\n        self._visible = False\n        if self._modal:\n            self.tk.grab_release()", "code_tokens": "def hide ( self ) : self . tk . withdraw ( ) self . _visible = False if self . _modal : self . tk . grab_release ( )", "docstring_tokens": "Hide the window .", "label": 0}, {"idx": "cosqa-train-16293", "doc": "how to tell turtle python to move and draw", "code": "def forward(self, step):\n        \"\"\"Move the turtle forward.\n\n        :param step: Integer. Distance to move forward.\n        \"\"\"\n        x = self.pos_x + math.cos(math.radians(self.rotation)) * step\n        y = self.pos_y + math.sin(math.radians(self.rotation)) * step\n        prev_brush_state = self.brush_on\n        self.brush_on = True\n        self.move(x, y)\n        self.brush_on = prev_brush_state", "code_tokens": "def forward ( self , step ) : x = self . pos_x + math . cos ( math . radians ( self . rotation ) ) * step y = self . pos_y + math . sin ( math . radians ( self . rotation ) ) * step prev_brush_state = self . brush_on self . brush_on = True self . move ( x , y ) self . brush_on = prev_brush_state", "docstring_tokens": "Move the turtle forward .", "label": 0}, {"idx": "cosqa-train-16294", "doc": "python tkinter remove all existing widgets without destroying window", "code": "def empty(self):\n        \"\"\"remove all children from the widget\"\"\"\n        for k in list(self.children.keys()):\n            self.remove_child(self.children[k])", "code_tokens": "def empty ( self ) : for k in list ( self . children . keys ( ) ) : self . remove_child ( self . children [ k ] )", "docstring_tokens": "remove all children from the widget", "label": 0}, {"idx": "cosqa-train-16295", "doc": "how to terminate whole program in python from middle", "code": "def set_stop_handler(self):\n        \"\"\"\n        Initializes functions that are invoked when the user or OS wants to kill this process.\n        :return:\n        \"\"\"\n        signal.signal(signal.SIGTERM, self.graceful_stop)\n        signal.signal(signal.SIGABRT, self.graceful_stop)\n        signal.signal(signal.SIGINT, self.graceful_stop)", "code_tokens": "def set_stop_handler ( self ) : signal . signal ( signal . SIGTERM , self . graceful_stop ) signal . signal ( signal . SIGABRT , self . graceful_stop ) signal . signal ( signal . SIGINT , self . graceful_stop )", "docstring_tokens": "Initializes functions that are invoked when the user or OS wants to kill this process . : return :", "label": 0}, {"idx": "cosqa-train-16296", "doc": "python tkinter scrollbar listbox grid", "code": "def __init__(self, master=None, compound=tk.RIGHT, autohidescrollbar=True, **kwargs):\n        \"\"\"\n        Create a Listbox with a vertical scrollbar.\n\n        :param master: master widget\n        :type master: widget\n        :param compound: side for the Scrollbar to be on (:obj:`tk.LEFT` or :obj:`tk.RIGHT`)\n        :type compound: str\n        :param autohidescrollbar: whether to use an :class:`~ttkwidgets.AutoHideScrollbar` or a :class:`ttk.Scrollbar`\n        :type autohidescrollbar: bool\n        :param kwargs: keyword arguments passed on to the :class:`tk.Listbox` initializer\n        \"\"\"\n        ttk.Frame.__init__(self, master)\n        self.columnconfigure(1, weight=1)\n        self.rowconfigure(0, weight=1)\n        self.listbox = tk.Listbox(self, **kwargs)\n        if autohidescrollbar:\n            self.scrollbar = AutoHideScrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview)\n        else:\n            self.scrollbar = ttk.Scrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview)\n        self.config_listbox(yscrollcommand=self.scrollbar.set)\n        if compound is not tk.LEFT and compound is not tk.RIGHT:\n            raise ValueError(\"Invalid compound value passed: {0}\".format(compound))\n        self.__compound = compound\n        self._grid_widgets()", "code_tokens": "def __init__ ( self , master = None , compound = tk . RIGHT , autohidescrollbar = True , * * kwargs ) : ttk . Frame . __init__ ( self , master ) self . columnconfigure ( 1 , weight = 1 ) self . rowconfigure ( 0 , weight = 1 ) self . listbox = tk . Listbox ( self , * * kwargs ) if autohidescrollbar : self . scrollbar = AutoHideScrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) else : self . scrollbar = ttk . Scrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) self . config_listbox ( yscrollcommand = self . scrollbar . set ) if compound is not tk . LEFT and compound is not tk . RIGHT : raise ValueError ( \"Invalid compound value passed: {0}\" . format ( compound ) ) self . __compound = compound self . _grid_widgets ( )", "docstring_tokens": "Create a Listbox with a vertical scrollbar .", "label": 0}, {"idx": "cosqa-train-16297", "doc": "how to test if two files are the same in python", "code": "def is_same_file (filename1, filename2):\n    \"\"\"Check if filename1 and filename2 point to the same file object.\n    There can be false negatives, ie. the result is False, but it is\n    the same file anyway. Reason is that network filesystems can create\n    different paths to the same physical file.\n    \"\"\"\n    if filename1 == filename2:\n        return True\n    if os.name == 'posix':\n        return os.path.samefile(filename1, filename2)\n    return is_same_filename(filename1, filename2)", "code_tokens": "def is_same_file ( filename1 , filename2 ) : if filename1 == filename2 : return True if os . name == 'posix' : return os . path . samefile ( filename1 , filename2 ) return is_same_filename ( filename1 , filename2 )", "docstring_tokens": "Check if filename1 and filename2 point to the same file object . There can be false negatives ie . the result is False but it is the same file anyway . Reason is that network filesystems can create different paths to the same physical file .", "label": 1}, {"idx": "cosqa-train-16298", "doc": "how to test not equal list in python", "code": "def _check_elements_equal(lst):\n    \"\"\"\n    Returns true if all of the elements in the list are equal.\n    \"\"\"\n    assert isinstance(lst, list), \"Input value must be a list.\"\n    return not lst or lst.count(lst[0]) == len(lst)", "code_tokens": "def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "docstring_tokens": "Returns true if all of the elements in the list are equal .", "label": 1}, {"idx": "cosqa-train-16299", "doc": "python to check device power state", "code": "def get_host_power_status(self):\n        \"\"\"Request the power state of the server.\n\n        :returns: Power State of the server, 'ON' or 'OFF'\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        return GET_POWER_STATE_MAP.get(sushy_system.power_state)", "code_tokens": "def get_host_power_status ( self ) : sushy_system = self . _get_sushy_system ( PROLIANT_SYSTEM_ID ) return GET_POWER_STATE_MAP . get ( sushy_system . power_state )", "docstring_tokens": "Request the power state of the server .", "label": 1}, {"idx": "cosqa-train-16300", "doc": "how to time function execution in python", "code": "def timed_call(func, *args, log_level='DEBUG', **kwargs):\n    \"\"\"Logs a function's run time\n\n    :param func: The function to run\n    :param args: The args to pass to the function\n    :param kwargs: The keyword args to pass to the function\n    :param log_level: The log level at which to print the run time\n    :return: The function's return value\n    \"\"\"\n    start = time()\n    r = func(*args, **kwargs)\n    t = time() - start\n    log(log_level, \"Call to '{}' took {:0.6f}s\".format(func.__name__, t))\n    return r", "code_tokens": "def timed_call ( func , * args , log_level = 'DEBUG' , * * kwargs ) : start = time ( ) r = func ( * args , * * kwargs ) t = time ( ) - start log ( log_level , \"Call to '{}' took {:0.6f}s\" . format ( func . __name__ , t ) ) return r", "docstring_tokens": "Logs a function s run time", "label": 1}, {"idx": "cosqa-train-16301", "doc": "python to known whether an image is valid", "code": "def _is_image_sequenced(image):\n    \"\"\"Determine if the image is a sequenced image.\"\"\"\n    try:\n        image.seek(1)\n        image.seek(0)\n        result = True\n    except EOFError:\n        result = False\n\n    return result", "code_tokens": "def _is_image_sequenced ( image ) : try : image . seek ( 1 ) image . seek ( 0 ) result = True except EOFError : result = False return result", "docstring_tokens": "Determine if the image is a sequenced image .", "label": 0}, {"idx": "cosqa-train-16302", "doc": "how to transform list of words to sentences in python", "code": "def sent2features(sentence, template):\n    \"\"\" extract features in a sentence\n\n    :type sentence: list of token, each token is a list of tag\n    \"\"\"\n    return [word2features(sentence, i, template) for i in range(len(sentence))]", "code_tokens": "def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]", "docstring_tokens": "extract features in a sentence", "label": 0}, {"idx": "cosqa-train-16303", "doc": "python to match names", "code": "def _namematcher(regex):\n    \"\"\"Checks if a target name matches with an input regular expression.\"\"\"\n\n    matcher = re_compile(regex)\n\n    def match(target):\n        target_name = getattr(target, '__name__', '')\n        result = matcher.match(target_name)\n        return result\n\n    return match", "code_tokens": "def _namematcher ( regex ) : matcher = re_compile ( regex ) def match ( target ) : target_name = getattr ( target , '__name__' , '' ) result = matcher . match ( target_name ) return result return match", "docstring_tokens": "Checks if a target name matches with an input regular expression .", "label": 1}, {"idx": "cosqa-train-16304", "doc": "how to turn a json dictionary into a python dictionary", "code": "def _unjsonify(x, isattributes=False):\n    \"\"\"Convert JSON string to an ordered defaultdict.\"\"\"\n    if isattributes:\n        obj = json.loads(x)\n        return dict_class(obj)\n    return json.loads(x)", "code_tokens": "def _unjsonify ( x , isattributes = False ) : if isattributes : obj = json . loads ( x ) return dict_class ( obj ) return json . loads ( x )", "docstring_tokens": "Convert JSON string to an ordered defaultdict .", "label": 1}, {"idx": "cosqa-train-16305", "doc": "python to opengl texture", "code": "def eglInitialize(display):\n    \"\"\" Initialize EGL and return EGL version tuple.\n    \"\"\"\n    majorVersion = (_c_int*1)()\n    minorVersion = (_c_int*1)()\n    res = _lib.eglInitialize(display, majorVersion, minorVersion)\n    if res == EGL_FALSE:\n        raise RuntimeError('Could not initialize')\n    return majorVersion[0], minorVersion[0]", "code_tokens": "def eglInitialize ( display ) : majorVersion = ( _c_int * 1 ) ( ) minorVersion = ( _c_int * 1 ) ( ) res = _lib . eglInitialize ( display , majorVersion , minorVersion ) if res == EGL_FALSE : raise RuntimeError ( 'Could not initialize' ) return majorVersion [ 0 ] , minorVersion [ 0 ]", "docstring_tokens": "Initialize EGL and return EGL version tuple .", "label": 0}, {"idx": "cosqa-train-16306", "doc": "python track mouse location", "code": "def mouse_move_event(self, event):\n        \"\"\"\n        Forward mouse cursor position events to the example\n        \"\"\"\n        self.example.mouse_position_event(event.x(), event.y())", "code_tokens": "def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )", "docstring_tokens": "Forward mouse cursor position events to the example", "label": 0}, {"idx": "cosqa-train-16307", "doc": "how to turn a list into a dictionary python", "code": "def list2dict(lst):\n    \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"\n\n    dic = {}\n    for k,v in lst: dic[k] = v\n    return dic", "code_tokens": "def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "docstring_tokens": "Takes a list of ( key value ) pairs and turns it into a dict .", "label": 0}, {"idx": "cosqa-train-16308", "doc": "python transfer a string to a list", "code": "def path_to_list(pathstr):\n    \"\"\"Conver a path string to a list of path elements.\"\"\"\n    return [elem for elem in pathstr.split(os.path.pathsep) if elem]", "code_tokens": "def path_to_list ( pathstr ) : return [ elem for elem in pathstr . split ( os . path . pathsep ) if elem ]", "docstring_tokens": "Conver a path string to a list of path elements .", "label": 1}, {"idx": "cosqa-train-16309", "doc": "how to turn a string into a dict python", "code": "def string_to_identity(identity_str):\n    \"\"\"Parse string into Identity dictionary.\"\"\"\n    m = _identity_regexp.match(identity_str)\n    result = m.groupdict()\n    log.debug('parsed identity: %s', result)\n    return {k: v for k, v in result.items() if v}", "code_tokens": "def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "docstring_tokens": "Parse string into Identity dictionary .", "label": 1}, {"idx": "cosqa-train-16310", "doc": "python translate enum values to", "code": "def normalize_enum_constant(s):\n    \"\"\"Return enum constant `s` converted to a canonical snake-case.\"\"\"\n    if s.islower(): return s\n    if s.isupper(): return s.lower()\n    return \"\".join(ch if ch.islower() else \"_\" + ch.lower() for ch in s).strip(\"_\")", "code_tokens": "def normalize_enum_constant ( s ) : if s . islower ( ) : return s if s . isupper ( ) : return s . lower ( ) return \"\" . join ( ch if ch . islower ( ) else \"_\" + ch . lower ( ) for ch in s ) . strip ( \"_\" )", "docstring_tokens": "Return enum constant s converted to a canonical snake - case .", "label": 0}, {"idx": "cosqa-train-16311", "doc": "how to turn a string list into a float python", "code": "def string_to_float_list(string_var):\n        \"\"\"Pull comma separated string values out of a text file and converts them to float list\"\"\"\n        try:\n            return [float(s) for s in string_var.strip('[').strip(']').split(', ')]\n        except:\n            return [float(s) for s in string_var.strip('[').strip(']').split(',')]", "code_tokens": "def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]", "docstring_tokens": "Pull comma separated string values out of a text file and converts them to float list", "label": 0}, {"idx": "cosqa-train-16312", "doc": "python transpose axis example", "code": "def sf01(arr):\n    \"\"\"\n    swap and then flatten axes 0 and 1\n    \"\"\"\n    s = arr.shape\n    return arr.swapaxes(0, 1).reshape(s[0] * s[1], *s[2:])", "code_tokens": "def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "docstring_tokens": "swap and then flatten axes 0 and 1", "label": 0}, {"idx": "cosqa-train-16313", "doc": "how to turn bytes string into bytes in python3", "code": "def to_bytes(s, encoding=\"utf-8\"):\n    \"\"\"Convert a string to bytes.\"\"\"\n    if isinstance(s, six.binary_type):\n        return s\n    if six.PY3:\n        return bytes(s, encoding)\n    return s.encode(encoding)", "code_tokens": "def to_bytes ( s , encoding = \"utf-8\" ) : if isinstance ( s , six . binary_type ) : return s if six . PY3 : return bytes ( s , encoding ) return s . encode ( encoding )", "docstring_tokens": "Convert a string to bytes .", "label": 1}, {"idx": "cosqa-train-16314", "doc": "python transpose dict to column array", "code": "def C_dict2array(C):\n    \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"\n    return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "code_tokens": "def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )", "docstring_tokens": "Convert an OrderedDict containing C values to a 1D array .", "label": 1}, {"idx": "cosqa-train-16315", "doc": "how to turn ints to binary python", "code": "def intToBin(i):\n    \"\"\" Integer to two bytes \"\"\"\n    # divide in two parts (bytes)\n    i1 = i % 256\n    i2 = int(i / 256)\n    # make string (little endian)\n    return i.to_bytes(2, byteorder='little')", "code_tokens": "def intToBin ( i ) : # divide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return i . to_bytes ( 2 , byteorder = 'little' )", "docstring_tokens": "Integer to two bytes", "label": 1}, {"idx": "cosqa-train-16316", "doc": "python tree count total", "code": "def size(self):\n        \"\"\"\n        Recursively find size of a tree. Slow.\n        \"\"\"\n\n        if self is NULL:\n            return 0\n        return 1 + self.left.size() + self.right.size()", "code_tokens": "def size ( self ) : if self is NULL : return 0 return 1 + self . left . size ( ) + self . right . size ( )", "docstring_tokens": "Recursively find size of a tree . Slow .", "label": 0}, {"idx": "cosqa-train-16317", "doc": "how to turn logging off, python", "code": "def should_skip_logging(func):\n    \"\"\"\n    Should we skip logging for this handler?\n\n    \"\"\"\n    disabled = strtobool(request.headers.get(\"x-request-nolog\", \"false\"))\n    return disabled or getattr(func, SKIP_LOGGING, False)", "code_tokens": "def should_skip_logging ( func ) : disabled = strtobool ( request . headers . get ( \"x-request-nolog\" , \"false\" ) ) return disabled or getattr ( func , SKIP_LOGGING , False )", "docstring_tokens": "Should we skip logging for this handler?", "label": 0}, {"idx": "cosqa-train-16318", "doc": "python trim spaces in xml", "code": "def cleanup_nodes(doc):\n    \"\"\"\n    Remove text nodes containing only whitespace\n    \"\"\"\n    for node in doc.documentElement.childNodes:\n        if node.nodeType == Node.TEXT_NODE and node.nodeValue.isspace():\n            doc.documentElement.removeChild(node)\n    return doc", "code_tokens": "def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc", "docstring_tokens": "Remove text nodes containing only whitespace", "label": 1}, {"idx": "cosqa-train-16319", "doc": "how to turn output into a list python", "code": "def stdout_to_results(s):\n    \"\"\"Turns the multi-line output of a benchmark process into\n    a sequence of BenchmarkResult instances.\"\"\"\n    results = s.strip().split('\\n')\n    return [BenchmarkResult(*r.split()) for r in results]", "code_tokens": "def stdout_to_results ( s ) : results = s . strip ( ) . split ( '\\n' ) return [ BenchmarkResult ( * r . split ( ) ) for r in results ]", "docstring_tokens": "Turns the multi - line output of a benchmark process into a sequence of BenchmarkResult instances .", "label": 0}, {"idx": "cosqa-train-16320", "doc": "python trim zeros from list", "code": "def _remove_blank(l):\n        \"\"\" Removes trailing zeros in the list of integers and returns a new list of integers\"\"\"\n        ret = []\n        for i, _ in enumerate(l):\n            if l[i] == 0:\n                break\n            ret.append(l[i])\n        return ret", "code_tokens": "def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret", "docstring_tokens": "Removes trailing zeros in the list of integers and returns a new list of integers", "label": 1}, {"idx": "cosqa-train-16321", "doc": "how to type out negative infinity in python", "code": "def get_neg_infinity(dtype):\n    \"\"\"Return an appropriate positive infinity for this dtype.\n\n    Parameters\n    ----------\n    dtype : np.dtype\n\n    Returns\n    -------\n    fill_value : positive infinity value corresponding to this dtype.\n    \"\"\"\n    if issubclass(dtype.type, (np.floating, np.integer)):\n        return -np.inf\n\n    if issubclass(dtype.type, np.complexfloating):\n        return -np.inf - 1j * np.inf\n\n    return NINF", "code_tokens": "def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "docstring_tokens": "Return an appropriate positive infinity for this dtype .", "label": 0}, {"idx": "cosqa-train-16322", "doc": "python try again in a function", "code": "def retry_call(func, cleanup=lambda: None, retries=0, trap=()):\n\t\"\"\"\n\tGiven a callable func, trap the indicated exceptions\n\tfor up to 'retries' times, invoking cleanup on the\n\texception. On the final attempt, allow any exceptions\n\tto propagate.\n\t\"\"\"\n\tattempts = count() if retries == float('inf') else range(retries)\n\tfor attempt in attempts:\n\t\ttry:\n\t\t\treturn func()\n\t\texcept trap:\n\t\t\tcleanup()\n\n\treturn func()", "code_tokens": "def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )", "docstring_tokens": "Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate .", "label": 1}, {"idx": "cosqa-train-16323", "doc": "how to union two set types in python", "code": "def union(self, other):\n        \"\"\"Return a new set which is the union of I{self} and I{other}.\n\n        @param other: the other set\n        @type other: Set object\n        @rtype: the same type as I{self}\n        \"\"\"\n\n        obj = self._clone()\n        obj.union_update(other)\n        return obj", "code_tokens": "def union ( self , other ) : obj = self . _clone ( ) obj . union_update ( other ) return obj", "docstring_tokens": "Return a new set which is the union of I { self } and I { other } .", "label": 0}, {"idx": "cosqa-train-16324", "doc": "python ttk scrollbar change disabled color", "code": "def set_scrollbars_cb(self, w, tf):\n        \"\"\"This callback is invoked when the user checks the 'Use Scrollbars'\n        box in the preferences pane.\"\"\"\n        scrollbars = 'on' if tf else 'off'\n        self.t_.set(scrollbars=scrollbars)", "code_tokens": "def set_scrollbars_cb ( self , w , tf ) : scrollbars = 'on' if tf else 'off' self . t_ . set ( scrollbars = scrollbars )", "docstring_tokens": "This callback is invoked when the user checks the Use Scrollbars box in the preferences pane .", "label": 0}, {"idx": "cosqa-train-16325", "doc": "how to unzip file from url using python", "code": "def install_from_zip(url):\n    \"\"\"Download and unzip from url.\"\"\"\n    fname = 'tmp.zip'\n    downlad_file(url, fname)\n    unzip_file(fname)\n    print(\"Removing {}\".format(fname))\n    os.unlink(fname)", "code_tokens": "def install_from_zip ( url ) : fname = 'tmp.zip' downlad_file ( url , fname ) unzip_file ( fname ) print ( \"Removing {}\" . format ( fname ) ) os . unlink ( fname )", "docstring_tokens": "Download and unzip from url .", "label": 1}, {"idx": "cosqa-train-16326", "doc": "python tuple must be str, not tuple shape", "code": "def tuple_check(*args, func=None):\n    \"\"\"Check if arguments are tuple type.\"\"\"\n    func = func or inspect.stack()[2][3]\n    for var in args:\n        if not isinstance(var, (tuple, collections.abc.Sequence)):\n            name = type(var).__name__\n            raise TupleError(\n                f'Function {func} expected tuple, {name} got instead.')", "code_tokens": "def tuple_check ( * args , func = None ) : func = func or inspect . stack ( ) [ 2 ] [ 3 ] for var in args : if not isinstance ( var , ( tuple , collections . abc . Sequence ) ) : name = type ( var ) . __name__ raise TupleError ( f'Function {func} expected tuple, {name} got instead.' )", "docstring_tokens": "Check if arguments are tuple type .", "label": 0}, {"idx": "cosqa-train-16327", "doc": "how to use a code to use python's range function without using range", "code": "def min_values(args):\n    \"\"\" Return possible range for min function. \"\"\"\n    return Interval(min(x.low for x in args), min(x.high for x in args))", "code_tokens": "def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "docstring_tokens": "Return possible range for min function .", "label": 0}, {"idx": "cosqa-train-16328", "doc": "python turn a text file into a markdown fiel", "code": "def md_to_text(content):\n    \"\"\" Converts markdown content to text \"\"\"\n    text = None\n    html = markdown.markdown(content)\n    if html:\n        text = html_to_text(content)\n    return text", "code_tokens": "def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text", "docstring_tokens": "Converts markdown content to text", "label": 0}, {"idx": "cosqa-train-16329", "doc": "how to use a tensorflow model in python", "code": "def unit_ball_L2(shape):\n  \"\"\"A tensorflow variable tranfomed to be constrained in a L2 unit ball.\n\n  EXPERIMENTAL: Do not use for adverserial examples if you need to be confident\n  they are strong attacks. We are not yet confident in this code.\n  \"\"\"\n  x = tf.Variable(tf.zeros(shape))\n  return constrain_L2(x)", "code_tokens": "def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )", "docstring_tokens": "A tensorflow variable tranfomed to be constrained in a L2 unit ball .", "label": 1}, {"idx": "cosqa-train-16330", "doc": "python turn resylts of query to dictionary", "code": "def list_of_dict(self):\n        \"\"\"\n        This will convert the data from a list of list to a list of dictionary\n        :return: list of dict\n        \"\"\"\n        ret = []\n        for row in self:\n            ret.append(dict([(self._col_names[i], row[i]) for i in\n                             range(len(self._col_names))]))\n        return ReprListDict(ret, col_names=self._col_names,\n                            col_types=self._col_types,\n                            width_limit=self._width_limit,\n                            digits=self._digits,\n                            convert_unicode=self._convert_unicode)", "code_tokens": "def list_of_dict ( self ) : ret = [ ] for row in self : ret . append ( dict ( [ ( self . _col_names [ i ] , row [ i ] ) for i in range ( len ( self . _col_names ) ) ] ) ) return ReprListDict ( ret , col_names = self . _col_names , col_types = self . _col_types , width_limit = self . _width_limit , digits = self . _digits , convert_unicode = self . _convert_unicode )", "docstring_tokens": "This will convert the data from a list of list to a list of dictionary : return : list of dict", "label": 0}, {"idx": "cosqa-train-16331", "doc": "how to use dictionary to replace in python", "code": "def copy_and_update(dictionary, update):\n    \"\"\"Returns an updated copy of the dictionary without modifying the original\"\"\"\n    newdict = dictionary.copy()\n    newdict.update(update)\n    return newdict", "code_tokens": "def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict", "docstring_tokens": "Returns an updated copy of the dictionary without modifying the original", "label": 0}, {"idx": "cosqa-train-16332", "doc": "python turn string into uri format", "code": "def uri_to_iri_parts(path, query, fragment):\n    r\"\"\"\n    Converts a URI parts to corresponding IRI parts in a given charset.\n\n    Examples for URI versus IRI:\n\n    :param path: The path of URI to convert.\n    :param query: The query string of URI to convert.\n    :param fragment: The fragment of URI to convert.\n    \"\"\"\n    path = url_unquote(path, '%/;?')\n    query = url_unquote(query, '%;/?:@&=+,$#')\n    fragment = url_unquote(fragment, '%;/?:@&=+,$#')\n    return path, query, fragment", "code_tokens": "def uri_to_iri_parts ( path , query , fragment ) : path = url_unquote ( path , '%/;?' ) query = url_unquote ( query , '%;/?:@&=+,$#' ) fragment = url_unquote ( fragment , '%;/?:@&=+,$#' ) return path , query , fragment", "docstring_tokens": "r Converts a URI parts to corresponding IRI parts in a given charset .", "label": 1}, {"idx": "cosqa-train-16333", "doc": "how to use help function on method in python", "code": "def _help():\n    \"\"\" Display both SQLAlchemy and Python help statements \"\"\"\n\n    statement = '%s%s' % (shelp, phelp % ', '.join(cntx_.keys()))\n    print statement.strip()", "code_tokens": "def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )", "docstring_tokens": "Display both SQLAlchemy and Python help statements", "label": 0}, {"idx": "cosqa-train-16334", "doc": "how to use input fuction in strings in python", "code": "def get_input(input_func, input_str):\n    \"\"\"\n    Get input from the user given an input function and an input string\n    \"\"\"\n    val = input_func(\"Please enter your {0}: \".format(input_str))\n    while not val or not len(val.strip()):\n        val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))\n    return val", "code_tokens": "def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "docstring_tokens": "Get input from the user given an input function and an input string", "label": 0}, {"idx": "cosqa-train-16335", "doc": "python type casting into strng", "code": "def check_str(obj):\n        \"\"\" Returns a string for various input types \"\"\"\n        if isinstance(obj, str):\n            return obj\n        if isinstance(obj, float):\n            return str(int(obj))\n        else:\n            return str(obj)", "code_tokens": "def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )", "docstring_tokens": "Returns a string for various input types", "label": 0}, {"idx": "cosqa-train-16336", "doc": "how to use isdigit to pick out numbers in a string python", "code": "def str2int(string_with_int):\n    \"\"\" Collect digits from a string \"\"\"\n    return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)", "code_tokens": "def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "docstring_tokens": "Collect digits from a string", "label": 0}, {"idx": "cosqa-train-16337", "doc": "python type hinting optional value", "code": "def parse_parameter(value):\n    \"\"\"\n    @return: The best approximation of a type of the given value.\n    \"\"\"\n    if any((isinstance(value, float), isinstance(value, int), isinstance(value, bool))):\n        return value\n\n    try:\n        return int(value)\n    except ValueError:\n        try:\n            return float(value)\n        except ValueError:\n            if value in string_aliases.true_boolean_aliases:\n                return True\n            elif value in string_aliases.false_boolean_aliases:\n                return False\n            else:\n                return str(value)", "code_tokens": "def parse_parameter ( value ) : if any ( ( isinstance ( value , float ) , isinstance ( value , int ) , isinstance ( value , bool ) ) ) : return value try : return int ( value ) except ValueError : try : return float ( value ) except ValueError : if value in string_aliases . true_boolean_aliases : return True elif value in string_aliases . false_boolean_aliases : return False else : return str ( value )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-16338", "doc": "how to use isin and notin in python", "code": "def notin(arg, values):\n    \"\"\"\n    Like isin, but checks whether this expression's value(s) are not\n    contained in the passed values. See isin docs for full usage.\n    \"\"\"\n    op = ops.NotContains(arg, values)\n    return op.to_expr()", "code_tokens": "def notin ( arg , values ) : op = ops . NotContains ( arg , values ) return op . to_expr ( )", "docstring_tokens": "Like isin but checks whether this expression s value ( s ) are not contained in the passed values . See isin docs for full usage .", "label": 0}, {"idx": "cosqa-train-16339", "doc": "python type is not datetime", "code": "def is_timestamp(instance):\n    \"\"\"Validates data is a timestamp\"\"\"\n    if not isinstance(instance, (int, str)):\n        return True\n    return datetime.fromtimestamp(int(instance))", "code_tokens": "def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "docstring_tokens": "Validates data is a timestamp", "label": 0}, {"idx": "cosqa-train-16340", "doc": "how to use python request for 401 error", "code": "def HttpResponse401(request, template=KEY_AUTH_401_TEMPLATE,\ncontent=KEY_AUTH_401_CONTENT, content_type=KEY_AUTH_401_CONTENT_TYPE):\n    \"\"\"\n    HTTP response for not-authorized access (status code 403)\n    \"\"\"\n    return AccessFailedResponse(request, template, content, content_type, status=401)", "code_tokens": "def HttpResponse401 ( request , template = KEY_AUTH_401_TEMPLATE , content = KEY_AUTH_401_CONTENT , content_type = KEY_AUTH_401_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 401 )", "docstring_tokens": "HTTP response for not - authorized access ( status code 403 )", "label": 1}, {"idx": "cosqa-train-16341", "doc": "python unable to add handler", "code": "def subscribe(self, handler):\n        \"\"\"Adds a new event handler.\"\"\"\n        assert callable(handler), \"Invalid handler %s\" % handler\n        self.handlers.append(handler)", "code_tokens": "def subscribe ( self , handler ) : assert callable ( handler ) , \"Invalid handler %s\" % handler self . handlers . append ( handler )", "docstring_tokens": "Adds a new event handler .", "label": 0}, {"idx": "cosqa-train-16342", "doc": "how to use requests in python to get the text of a page", "code": "def get_page_text(self, page):\n        \"\"\"\n        Downloads and returns the full text of a particular page\n        in the document.\n        \"\"\"\n        url = self.get_page_text_url(page)\n        return self._get_url(url)", "code_tokens": "def get_page_text ( self , page ) : url = self . get_page_text_url ( page ) return self . _get_url ( url )", "docstring_tokens": "Downloads and returns the full text of a particular page in the document .", "label": 0}, {"idx": "cosqa-train-16343", "doc": "python unboundfield bind to form", "code": "def get_form_bound_field(form, field_name):\n    \"\"\"\n    Intends to get the bound field from the form regarding the field name\n\n    :param form: Django Form: django form instance\n    :param field_name: str: name of the field in form instance\n    :return: Django Form bound field\n    \"\"\"\n    field = form.fields[field_name]\n    field = field.get_bound_field(form, field_name)\n    return field", "code_tokens": "def get_form_bound_field ( form , field_name ) : field = form . fields [ field_name ] field = field . get_bound_field ( form , field_name ) return field", "docstring_tokens": "Intends to get the bound field from the form regarding the field name", "label": 0}, {"idx": "cosqa-train-16344", "doc": "how to use scrollbar in canvas using python", "code": "def set_scrollregion(self, event=None):\n        \"\"\" Set the scroll region on the canvas\"\"\"\n        self.canvas.configure(scrollregion=self.canvas.bbox('all'))", "code_tokens": "def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )", "docstring_tokens": "Set the scroll region on the canvas", "label": 0}, {"idx": "cosqa-train-16345", "doc": "python union of nonoverlapping intervals", "code": "def union_overlapping(intervals):\n    \"\"\"Union any overlapping intervals in the given set.\"\"\"\n    disjoint_intervals = []\n\n    for interval in intervals:\n        if disjoint_intervals and disjoint_intervals[-1].overlaps(interval):\n            disjoint_intervals[-1] = disjoint_intervals[-1].union(interval)\n        else:\n            disjoint_intervals.append(interval)\n\n    return disjoint_intervals", "code_tokens": "def union_overlapping ( intervals ) : disjoint_intervals = [ ] for interval in intervals : if disjoint_intervals and disjoint_intervals [ - 1 ] . overlaps ( interval ) : disjoint_intervals [ - 1 ] = disjoint_intervals [ - 1 ] . union ( interval ) else : disjoint_intervals . append ( interval ) return disjoint_intervals", "docstring_tokens": "Union any overlapping intervals in the given set .", "label": 1}, {"idx": "cosqa-train-16346", "doc": "how to write ''or'' sympole in python", "code": "def print_latex(o):\n    \"\"\"A function to generate the latex representation of sympy\n    expressions.\"\"\"\n    if can_print_latex(o):\n        s = latex(o, mode='plain')\n        s = s.replace('\\\\dag','\\\\dagger')\n        s = s.strip('$')\n        return '$$%s$$' % s\n    # Fallback to the string printer\n    return None", "code_tokens": "def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "docstring_tokens": "A function to generate the latex representation of sympy expressions .", "label": 0}, {"idx": "cosqa-train-16347", "doc": "python union table concat", "code": "def flatten_union(table):\n    \"\"\"Extract all union queries from `table`.\n\n    Parameters\n    ----------\n    table : TableExpr\n\n    Returns\n    -------\n    Iterable[Union[TableExpr, bool]]\n    \"\"\"\n    op = table.op()\n    if isinstance(op, ops.Union):\n        return toolz.concatv(\n            flatten_union(op.left), [op.distinct], flatten_union(op.right)\n        )\n    return [table]", "code_tokens": "def flatten_union ( table ) : op = table . op ( ) if isinstance ( op , ops . Union ) : return toolz . concatv ( flatten_union ( op . left ) , [ op . distinct ] , flatten_union ( op . right ) ) return [ table ]", "docstring_tokens": "Extract all union queries from table .", "label": 1}, {"idx": "cosqa-train-16348", "doc": "how to write a comment block in python", "code": "def comment (self, s, **args):\n        \"\"\"Write GML comment.\"\"\"\n        self.writeln(s=u'comment \"%s\"' % s, **args)", "code_tokens": "def comment ( self , s , * * args ) : self . writeln ( s = u'comment \"%s\"' % s , * * args )", "docstring_tokens": "Write GML comment .", "label": 1}, {"idx": "cosqa-train-16349", "doc": "python unit test assert html response", "code": "def page_title(step, title):\n    \"\"\"\n    Check that the page title matches the given one.\n    \"\"\"\n\n    with AssertContextManager(step):\n        assert_equals(world.browser.title, title)", "code_tokens": "def page_title ( step , title ) : with AssertContextManager ( step ) : assert_equals ( world . browser . title , title )", "docstring_tokens": "Check that the page title matches the given one .", "label": 0}, {"idx": "cosqa-train-16350", "doc": "how to write a default value in python", "code": "def setdefault(obj, field, default):\n    \"\"\"Set an object's field to default if it doesn't have a value\"\"\"\n    setattr(obj, field, getattr(obj, field, default))", "code_tokens": "def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )", "docstring_tokens": "Set an object s field to default if it doesn t have a value", "label": 0}, {"idx": "cosqa-train-16351", "doc": "python unit test set pythonpath", "code": "def test():  # pragma: no cover\n    \"\"\"Execute the unit tests on an installed copy of unyt.\n\n    Note that this function requires pytest to run. If pytest is not\n    installed this function will raise ImportError.\n    \"\"\"\n    import pytest\n    import os\n\n    pytest.main([os.path.dirname(os.path.abspath(__file__))])", "code_tokens": "def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )", "docstring_tokens": "Execute the unit tests on an installed copy of unyt .", "label": 1}, {"idx": "cosqa-train-16352", "doc": "python unittest how to assert 2 lists are almost equal", "code": "def expect_all(a, b):\n    \"\"\"\\\n    Asserts that two iterables contain the same values.\n    \"\"\"\n    assert all(_a == _b for _a, _b in zip_longest(a, b))", "code_tokens": "def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "docstring_tokens": "\\ Asserts that two iterables contain the same values .", "label": 1}, {"idx": "cosqa-train-16353", "doc": "how to write a string to a file in python 2", "code": "def write_str2file(pathname, astr):\n    \"\"\"writes a string to file\"\"\"\n    fname = pathname\n    fhandle = open(fname, 'wb')\n    fhandle.write(astr)\n    fhandle.close()", "code_tokens": "def write_str2file ( pathname , astr ) : fname = pathname fhandle = open ( fname , 'wb' ) fhandle . write ( astr ) fhandle . close ( )", "docstring_tokens": "writes a string to file", "label": 1}, {"idx": "cosqa-train-16354", "doc": "python unittest redirect assert failure", "code": "def assert_redirect(self, response, expected_url=None):\n        \"\"\"\n        assertRedirects from Django TestCase follows the redirects chains,\n        this assertion does not - which is more like real unit testing\n        \"\"\"\n        self.assertIn(\n            response.status_code,\n            self.redirect_codes,\n            self._get_redirect_assertion_message(response),\n        )\n        if expected_url:\n            location_header = response._headers.get('location', None)\n            self.assertEqual(\n                location_header,\n                ('Location', str(expected_url)),\n                'Response should redirect to {0}, but it redirects to {1} instead'.format(\n                    expected_url,\n                    location_header[1],\n                )\n            )", "code_tokens": "def assert_redirect ( self , response , expected_url = None ) : self . assertIn ( response . status_code , self . redirect_codes , self . _get_redirect_assertion_message ( response ) , ) if expected_url : location_header = response . _headers . get ( 'location' , None ) self . assertEqual ( location_header , ( 'Location' , str ( expected_url ) ) , 'Response should redirect to {0}, but it redirects to {1} instead' . format ( expected_url , location_header [ 1 ] , ) )", "docstring_tokens": "assertRedirects from Django TestCase follows the redirects chains this assertion does not - which is more like real unit testing", "label": 0}, {"idx": "cosqa-train-16355", "doc": "how to write on a new line in pythone", "code": "def _write_separator(self):\n        \"\"\"\n        Inserts a horizontal (commented) line tot the generated code.\n        \"\"\"\n        tmp = self._page_width - ((4 * self.__indent_level) + 2)\n        self._write_line('# ' + ('-' * tmp))", "code_tokens": "def _write_separator ( self ) : tmp = self . _page_width - ( ( 4 * self . __indent_level ) + 2 ) self . _write_line ( '# ' + ( '-' * tmp ) )", "docstring_tokens": "Inserts a horizontal ( commented ) line tot the generated code .", "label": 0}, {"idx": "cosqa-train-16356", "doc": "python unixpath names on windows", "code": "def __unixify(self, s):\n        \"\"\" stupid windows. converts the backslash to forwardslash for consistency \"\"\"\n        return os.path.normpath(s).replace(os.sep, \"/\")", "code_tokens": "def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "docstring_tokens": "stupid windows . converts the backslash to forwardslash for consistency", "label": 0}, {"idx": "cosqa-train-16357", "doc": "python unpack bytes to numpy", "code": "def convert_array(array):\n    \"\"\"\n    Converts an ARRAY string stored in the database back into a Numpy array.\n\n    Parameters\n    ----------\n    array: ARRAY\n        The array object to be converted back into a Numpy array.\n\n    Returns\n    -------\n    array\n            The converted Numpy array.\n\n    \"\"\"\n    out = io.BytesIO(array)\n    out.seek(0)\n    return np.load(out)", "code_tokens": "def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "docstring_tokens": "Converts an ARRAY string stored in the database back into a Numpy array .", "label": 0}, {"idx": "cosqa-train-16358", "doc": "how we can save python out put in excel file", "code": "def save_excel(self, fd):\n        \"\"\" Saves the case as an Excel spreadsheet.\n        \"\"\"\n        from pylon.io.excel import ExcelWriter\n        ExcelWriter(self).write(fd)", "code_tokens": "def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )", "docstring_tokens": "Saves the case as an Excel spreadsheet .", "label": 0}, {"idx": "cosqa-train-16359", "doc": "python upcase entire dictionary", "code": "def _keys_to_camel_case(self, obj):\n        \"\"\"\n        Make a copy of a dictionary with all keys converted to camel case. This is just calls to_camel_case on each of the keys in the dictionary and returns a new dictionary.\n\n        :param obj: Dictionary to convert keys to camel case.\n        :return: Dictionary with the input values and all keys in camel case\n        \"\"\"\n        return dict((to_camel_case(key), value) for (key, value) in obj.items())", "code_tokens": "def _keys_to_camel_case ( self , obj ) : return dict ( ( to_camel_case ( key ) , value ) for ( key , value ) in obj . items ( ) )", "docstring_tokens": "Make a copy of a dictionary with all keys converted to camel case . This is just calls to_camel_case on each of the keys in the dictionary and returns a new dictionary .", "label": 0}, {"idx": "cosqa-train-16360", "doc": "html table borders using python", "code": "def top(n, width=WIDTH, style=STYLE):\n    \"\"\"Prints the top row of a table\"\"\"\n    return hrule(n, width, linestyle=STYLES[style].top)", "code_tokens": "def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "docstring_tokens": "Prints the top row of a table", "label": 0}, {"idx": "cosqa-train-16361", "doc": "python update a global variable from a def", "code": "def set_global(node: Node, key: str, value: Any):\n    \"\"\"Adds passed value to node's globals\"\"\"\n    node.node_globals[key] = value", "code_tokens": "def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "docstring_tokens": "Adds passed value to node s globals", "label": 1}, {"idx": "cosqa-train-16362", "doc": "hwo to return 400 in python flask", "code": "def handle_exception(error):\n        \"\"\"Simple method for handling exceptions raised by `PyBankID`.\n\n        :param flask_pybankid.FlaskPyBankIDError error: The exception to handle.\n        :return: The exception represented as a dictionary.\n        :rtype: dict\n\n        \"\"\"\n        response = jsonify(error.to_dict())\n        response.status_code = error.status_code\n        return response", "code_tokens": "def handle_exception ( error ) : response = jsonify ( error . to_dict ( ) ) response . status_code = error . status_code return response", "docstring_tokens": "Simple method for handling exceptions raised by PyBankID .", "label": 1}, {"idx": "cosqa-train-16363", "doc": "python update context with a dict", "code": "def update_context(self, ctx):\n        \"\"\" updates the query context with this clauses values \"\"\"\n        assert isinstance(ctx, dict)\n        ctx[str(self.context_id)] = self.value", "code_tokens": "def update_context ( self , ctx ) : assert isinstance ( ctx , dict ) ctx [ str ( self . context_id ) ] = self . value", "docstring_tokens": "updates the query context with this clauses values", "label": 1}, {"idx": "cosqa-train-16364", "doc": "identify encoding type python", "code": "def get_encoding(binary):\n    \"\"\"Return the encoding type.\"\"\"\n\n    try:\n        from chardet import detect\n    except ImportError:\n        LOGGER.error(\"Please install the 'chardet' module\")\n        sys.exit(1)\n\n    encoding = detect(binary).get('encoding')\n\n    return 'iso-8859-1' if encoding == 'CP949' else encoding", "code_tokens": "def get_encoding ( binary ) : try : from chardet import detect except ImportError : LOGGER . error ( \"Please install the 'chardet' module\" ) sys . exit ( 1 ) encoding = detect ( binary ) . get ( 'encoding' ) return 'iso-8859-1' if encoding == 'CP949' else encoding", "docstring_tokens": "Return the encoding type .", "label": 0}, {"idx": "cosqa-train-16365", "doc": "python urlparse query paramters", "code": "def get_url_args(url):\n    \"\"\" Returns a dictionary from a URL params \"\"\"\n    url_data = urllib.parse.urlparse(url)\n    arg_dict = urllib.parse.parse_qs(url_data.query)\n    return arg_dict", "code_tokens": "def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict", "docstring_tokens": "Returns a dictionary from a URL params", "label": 1}, {"idx": "cosqa-train-16366", "doc": "if a value in python is empty", "code": "def clear_list_value(self, value):\n        \"\"\"\n        Clean the argument value to eliminate None or Falsy values if needed.\n        \"\"\"\n        # Don't go any further: this value is empty.\n        if not value:\n            return self.empty_value\n        # Clean empty items if wanted\n        if self.clean_empty:\n            value = [v for v in value if v]\n        return value or self.empty_value", "code_tokens": "def clear_list_value ( self , value ) : # Don't go any further: this value is empty. if not value : return self . empty_value # Clean empty items if wanted if self . clean_empty : value = [ v for v in value if v ] return value or self . empty_value", "docstring_tokens": "Clean the argument value to eliminate None or Falsy values if needed .", "label": 0}, {"idx": "cosqa-train-16367", "doc": "python urlretrieve file name", "code": "def get_url_file_name(url):\n    \"\"\"Get the file name from an url\n    \n    Parameters\n    ----------\n    url : str\n\n    Returns\n    -------\n    str\n        The file name \n    \"\"\"\n\n    assert isinstance(url, (str, _oldstr))\n    return urlparse.urlparse(url).path.split('/')[-1]", "code_tokens": "def get_url_file_name ( url ) : assert isinstance ( url , ( str , _oldstr ) ) return urlparse . urlparse ( url ) . path . split ( '/' ) [ - 1 ]", "docstring_tokens": "Get the file name from an url Parameters ---------- url : str", "label": 0}, {"idx": "cosqa-train-16368", "doc": "if table exists python", "code": "def table_exists(cursor, tablename, schema='public'):\n    query = \"\"\"\n    SELECT EXISTS (\n        SELECT 1\n        FROM information_schema.tables\n        WHERE table_schema = %s\n        AND table_name = %s\n    )\"\"\"\n    cursor.execute(query, (schema, tablename))\n    res = cursor.fetchone()[0]\n    return res", "code_tokens": "def table_exists ( cursor , tablename , schema = 'public' ) : query = \"\"\"\n    SELECT EXISTS (\n        SELECT 1\n        FROM information_schema.tables\n        WHERE table_schema = %s\n        AND table_name = %s\n    )\"\"\" cursor . execute ( query , ( schema , tablename ) ) res = cursor . fetchone ( ) [ 0 ] return res", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-16369", "doc": "python use a function to fill a list", "code": "def _fill_array_from_list(the_list, the_array):\n        \"\"\"Fill an `array` from a `list`\"\"\"\n        for i, val in enumerate(the_list):\n            the_array[i] = val\n        return the_array", "code_tokens": "def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array", "docstring_tokens": "Fill an array from a list", "label": 1}, {"idx": "cosqa-train-16370", "doc": "if type is str python", "code": "def isString(s):\n    \"\"\"Convenience method that works with all 2.x versions of Python\n    to determine whether or not something is stringlike.\"\"\"\n    try:\n        return isinstance(s, unicode) or isinstance(s, basestring)\n    except NameError:\n        return isinstance(s, str)", "code_tokens": "def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "docstring_tokens": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike .", "label": 1}, {"idx": "cosqa-train-16371", "doc": "python use format string with list", "code": "def list_formatter(handler, item, value):\n    \"\"\"Format list.\"\"\"\n    return u', '.join(str(v) for v in value)", "code_tokens": "def list_formatter ( handler , item , value ) : return u', ' . join ( str ( v ) for v in value )", "docstring_tokens": "Format list .", "label": 1}, {"idx": "cosqa-train-16372", "doc": "image calculate the gradient value python", "code": "def average_gradient(data, *kwargs):\n    \"\"\" Compute average gradient norm of an image\n    \"\"\"\n    return np.average(np.array(np.gradient(data))**2)", "code_tokens": "def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "docstring_tokens": "Compute average gradient norm of an image", "label": 1}, {"idx": "cosqa-train-16373", "doc": "implement dfs recursive python", "code": "def dfs_recursive(graph, node, seen):\n    \"\"\"DFS, detect connected component, recursive implementation\n\n    :param graph: directed graph in listlist or listdict format\n    :param int node: to start graph exploration\n    :param boolean-table seen: will be set true for the connected component\n          containing node.\n    :complexity: `O(|V|+|E|)`\n    \"\"\"\n    seen[node] = True\n    for neighbor in graph[node]:\n        if not seen[neighbor]:\n            dfs_recursive(graph, neighbor, seen)", "code_tokens": "def dfs_recursive ( graph , node , seen ) : seen [ node ] = True for neighbor in graph [ node ] : if not seen [ neighbor ] : dfs_recursive ( graph , neighbor , seen )", "docstring_tokens": "DFS detect connected component recursive implementation", "label": 1}, {"idx": "cosqa-train-16374", "doc": "python useless super delegation in method", "code": "def Proxy(f):\n  \"\"\"A helper to create a proxy method in a class.\"\"\"\n\n  def Wrapped(self, *args):\n    return getattr(self, f)(*args)\n\n  return Wrapped", "code_tokens": "def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped", "docstring_tokens": "A helper to create a proxy method in a class .", "label": 1}, {"idx": "cosqa-train-16375", "doc": "imshow bounding box python", "code": "def bbox(self):\n        \"\"\"\n        The minimal `~photutils.aperture.BoundingBox` for the cutout\n        region with respect to the original (large) image.\n        \"\"\"\n\n        return BoundingBox(self.slices[1].start, self.slices[1].stop,\n                           self.slices[0].start, self.slices[0].stop)", "code_tokens": "def bbox ( self ) : return BoundingBox ( self . slices [ 1 ] . start , self . slices [ 1 ] . stop , self . slices [ 0 ] . start , self . slices [ 0 ] . stop )", "docstring_tokens": "The minimal ~photutils . aperture . BoundingBox for the cutout region with respect to the original ( large ) image .", "label": 0}, {"idx": "cosqa-train-16376", "doc": "python user meaningful prompts", "code": "def prompt(*args, **kwargs):\n    \"\"\"Prompt the user for input and handle any abort exceptions.\"\"\"\n    try:\n        return click.prompt(*args, **kwargs)\n    except click.Abort:\n        return False", "code_tokens": "def prompt ( * args , * * kwargs ) : try : return click . prompt ( * args , * * kwargs ) except click . Abort : return False", "docstring_tokens": "Prompt the user for input and handle any abort exceptions .", "label": 0}, {"idx": "cosqa-train-16377", "doc": "in mongodb to retrieve from particular document using python", "code": "def find_one(cls, *args, **kw):\n\t\t\"\"\"Get a single document from the collection this class is bound to.\n\t\t\n\t\tAdditional arguments are processed according to `_prepare_find` prior to passing to PyMongo, where positional\n\t\tparameters are interpreted as query fragments, parametric keyword arguments combined, and other keyword\n\t\targuments passed along with minor transformation.\n\t\t\n\t\tAutomatically calls `to_mongo` with the retrieved data.\n\t\t\n\t\thttps://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find_one\n\t\t\"\"\"\n\t\t\n\t\tif len(args) == 1 and not isinstance(args[0], Filter):\n\t\t\targs = (getattr(cls, cls.__pk__) == args[0], )\n\t\t\n\t\tDoc, collection, query, options = cls._prepare_find(*args, **kw)\n\t\tresult = Doc.from_mongo(collection.find_one(query, **options))\n\t\t\n\t\treturn result", "code_tokens": "def find_one ( cls , * args , * * kw ) : if len ( args ) == 1 and not isinstance ( args [ 0 ] , Filter ) : args = ( getattr ( cls , cls . __pk__ ) == args [ 0 ] , ) Doc , collection , query , options = cls . _prepare_find ( * args , * * kw ) result = Doc . from_mongo ( collection . find_one ( query , * * options ) ) return result", "docstring_tokens": "Get a single document from the collection this class is bound to . Additional arguments are processed according to _prepare_find prior to passing to PyMongo where positional parameters are interpreted as query fragments parametric keyword arguments combined and other keyword arguments passed along with minor transformation . Automatically calls to_mongo with the retrieved data . https : // api . mongodb . com / python / current / api / pymongo / collection . html#pymongo . collection . Collection . find_one", "label": 0}, {"idx": "cosqa-train-16378", "doc": "python using uuid as user token", "code": "def generate_user_token(self, user, salt=None):\n        \"\"\"Generates a unique token associated to the user\n        \"\"\"\n        return self.token_serializer.dumps(str(user.id), salt=salt)", "code_tokens": "def generate_user_token ( self , user , salt = None ) : return self . token_serializer . dumps ( str ( user . id ) , salt = salt )", "docstring_tokens": "Generates a unique token associated to the user", "label": 0}, {"idx": "cosqa-train-16379", "doc": "in python fit an exponential", "code": "def exp_fit_fun(x, a, tau, c):\n    \"\"\"Function used to fit the exponential decay.\"\"\"\n    # pylint: disable=invalid-name\n    return a * np.exp(-x / tau) + c", "code_tokens": "def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "docstring_tokens": "Function used to fit the exponential decay .", "label": 1}, {"idx": "cosqa-train-16380", "doc": "python uuid fixed length", "code": "def random_string(string_length=10):\n    \"\"\"Returns a random string of length string_length.\"\"\"\n    random = str(uuid.uuid4())  # Convert UUID format to a Python string.\n    random = random.upper()  # Make all characters uppercase.\n    random = random.replace(\"-\", \"\")  # Remove the UUID '-'.\n    return random[0:string_length]", "code_tokens": "def random_string ( string_length = 10 ) : random = str ( uuid . uuid4 ( ) ) # Convert UUID format to a Python string. random = random . upper ( ) # Make all characters uppercase. random = random . replace ( \"-\" , \"\" ) # Remove the UUID '-'. return random [ 0 : string_length ]", "docstring_tokens": "Returns a random string of length string_length .", "label": 1}, {"idx": "cosqa-train-16381", "doc": "in python for loop include the last item", "code": "def end_index(self):\n        \"\"\"\n        Returns the 1-based index of the last object on this page,\n        relative to total objects found (hits).\n        \"\"\"\n        return ((self.number - 1) * self.paginator.per_page +\n            len(self.object_list))", "code_tokens": "def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "docstring_tokens": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) .", "label": 0}, {"idx": "cosqa-train-16382", "doc": "python validate boolean string", "code": "def bool_str(string):\n    \"\"\"Returns a boolean from a string imput of 'true' or 'false'\"\"\"\n    if string not in BOOL_STRS:\n        raise ValueError('Invalid boolean string: \"{}\"'.format(string))\n    return True if string == 'true' else False", "code_tokens": "def bool_str ( string ) : if string not in BOOL_STRS : raise ValueError ( 'Invalid boolean string: \"{}\"' . format ( string ) ) return True if string == 'true' else False", "docstring_tokens": "Returns a boolean from a string imput of true or false", "label": 1}, {"idx": "cosqa-train-16383", "doc": "include single quotes in string python", "code": "def quote(self, s):\n        \"\"\"Return a shell-escaped version of the string s.\"\"\"\n\n        if six.PY2:\n            from pipes import quote\n        else:\n            from shlex import quote\n\n        return quote(s)", "code_tokens": "def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "docstring_tokens": "Return a shell - escaped version of the string s .", "label": 0}, {"idx": "cosqa-train-16384", "doc": "python validate dict is json", "code": "def is_valid(data):\n        \"\"\"\n        Checks if the input data is a Swagger document\n\n        :param dict data: Data to be validated\n        :return: True, if data is a Swagger\n        \"\"\"\n        return bool(data) and \\\n            isinstance(data, dict) and \\\n            bool(data.get(\"swagger\")) and \\\n            isinstance(data.get('paths'), dict)", "code_tokens": "def is_valid ( data ) : return bool ( data ) and isinstance ( data , dict ) and bool ( data . get ( \"swagger\" ) ) and isinstance ( data . get ( 'paths' ) , dict )", "docstring_tokens": "Checks if the input data is a Swagger document", "label": 1}, {"idx": "cosqa-train-16385", "doc": "increase number of axis ticks python", "code": "def ynticks(self, nticks, index=1):\n        \"\"\"Set the number of ticks.\"\"\"\n        self.layout['yaxis' + str(index)]['nticks'] = nticks\n        return self", "code_tokens": "def ynticks ( self , nticks , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'nticks' ] = nticks return self", "docstring_tokens": "Set the number of ticks .", "label": 0}, {"idx": "cosqa-train-16386", "doc": "python variable for format length", "code": "def __len__(self):\n        \"\"\" This will equal 124 for the V1 database. \"\"\"\n        length = 0\n        for typ, siz, _ in self.format:\n            length += siz\n        return length", "code_tokens": "def __len__ ( self ) : length = 0 for typ , siz , _ in self . format : length += siz return length", "docstring_tokens": "This will equal 124 for the V1 database .", "label": 1}, {"idx": "cosqa-train-16387", "doc": "increase page num python", "code": "def _set_lastpage(self):\n        \"\"\"Calculate value of class attribute ``last_page``.\"\"\"\n        self.last_page = (len(self._page_data) - 1) // self.screen.page_size", "code_tokens": "def _set_lastpage ( self ) : self . last_page = ( len ( self . _page_data ) - 1 ) // self . screen . page_size", "docstring_tokens": "Calculate value of class attribute last_page .", "label": 0}, {"idx": "cosqa-train-16388", "doc": "python venv no directory created", "code": "def venv():\n    \"\"\"Install venv + deps.\"\"\"\n    try:\n        import virtualenv  # NOQA\n    except ImportError:\n        sh(\"%s -m pip install virtualenv\" % PYTHON)\n    if not os.path.isdir(\"venv\"):\n        sh(\"%s -m virtualenv venv\" % PYTHON)\n    sh(\"venv\\\\Scripts\\\\pip install -r %s\" % (REQUIREMENTS_TXT))", "code_tokens": "def venv ( ) : try : import virtualenv # NOQA except ImportError : sh ( \"%s -m pip install virtualenv\" % PYTHON ) if not os . path . isdir ( \"venv\" ) : sh ( \"%s -m virtualenv venv\" % PYTHON ) sh ( \"venv\\\\Scripts\\\\pip install -r %s\" % ( REQUIREMENTS_TXT ) )", "docstring_tokens": "Install venv + deps .", "label": 0}, {"idx": "cosqa-train-16389", "doc": "initialize logger on start up python", "code": "def ServerLoggingStartupInit():\n  \"\"\"Initialize the server logging configuration.\"\"\"\n  global LOGGER\n  if local_log:\n    logging.debug(\"Using local LogInit from %s\", local_log)\n    local_log.LogInit()\n    logging.debug(\"Using local AppLogInit from %s\", local_log)\n    LOGGER = local_log.AppLogInit()\n  else:\n    LogInit()\n    LOGGER = AppLogInit()", "code_tokens": "def ServerLoggingStartupInit ( ) : global LOGGER if local_log : logging . debug ( \"Using local LogInit from %s\" , local_log ) local_log . LogInit ( ) logging . debug ( \"Using local AppLogInit from %s\" , local_log ) LOGGER = local_log . AppLogInit ( ) else : LogInit ( ) LOGGER = AppLogInit ( )", "docstring_tokens": "Initialize the server logging configuration .", "label": 0}, {"idx": "cosqa-train-16390", "doc": "python virtualenv production how to activate", "code": "def init():\n    \"\"\"\n    Execute init tasks for all components (virtualenv, pip).\n    \"\"\"\n    print(yellow(\"# Setting up environment...\\n\", True))\n    virtualenv.init()\n    virtualenv.update_requirements()\n    print(green(\"\\n# DONE.\", True))\n    print(green(\"Type \") + green(\"activate\", True) + green(\" to enable your virtual environment.\"))", "code_tokens": "def init ( ) : print ( yellow ( \"# Setting up environment...\\n\" , True ) ) virtualenv . init ( ) virtualenv . update_requirements ( ) print ( green ( \"\\n# DONE.\" , True ) ) print ( green ( \"Type \" ) + green ( \"activate\" , True ) + green ( \" to enable your virtual environment.\" ) )", "docstring_tokens": "Execute init tasks for all components ( virtualenv pip ) .", "label": 0}, {"idx": "cosqa-train-16391", "doc": "inner join on str in python", "code": "def _py2_and_3_joiner(sep, joinable):\n    \"\"\"\n    Allow '\\n'.join(...) statements to work in Py2 and Py3.\n    :param sep:\n    :param joinable:\n    :return:\n    \"\"\"\n    if ISPY3:\n        sep = bytes(sep, DEFAULT_ENCODING)\n    joined = sep.join(joinable)\n    return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined", "code_tokens": "def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "docstring_tokens": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return :", "label": 0}, {"idx": "cosqa-train-16392", "doc": "python way to sort based on object dictionary", "code": "def csort(objs, key):\n    \"\"\"Order-preserving sorting function.\"\"\"\n    idxs = dict((obj, i) for (i, obj) in enumerate(objs))\n    return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))", "code_tokens": "def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )", "docstring_tokens": "Order - preserving sorting function .", "label": 0}, {"idx": "cosqa-train-16393", "doc": "insert a key to file in python", "code": "def put_text(self, key, text):\n        \"\"\"Put the text into the storage associated with the key.\"\"\"\n        with open(key, \"w\") as fh:\n            fh.write(text)", "code_tokens": "def put_text ( self , key , text ) : with open ( key , \"w\" ) as fh : fh . write ( text )", "docstring_tokens": "Put the text into the storage associated with the key .", "label": 0}, {"idx": "cosqa-train-16394", "doc": "python webdriver ie unexpectedly exited 2", "code": "def destroy_webdriver(driver):\n    \"\"\"\n    Destroy a driver\n    \"\"\"\n\n    # This is some very flaky code in selenium. Hence the retries\n    # and catch-all exceptions\n    try:\n        retry_call(driver.close, tries=2)\n    except Exception:\n        pass\n    try:\n        driver.quit()\n    except Exception:\n        pass", "code_tokens": "def destroy_webdriver ( driver ) : # This is some very flaky code in selenium. Hence the retries # and catch-all exceptions try : retry_call ( driver . close , tries = 2 ) except Exception : pass try : driver . quit ( ) except Exception : pass", "docstring_tokens": "Destroy a driver", "label": 0}, {"idx": "cosqa-train-16395", "doc": "insert a line at the beginning of a file python", "code": "def prepend_line(filepath, line):\n    \"\"\"Rewrite a file adding a line to its beginning.\n    \"\"\"\n    with open(filepath) as f:\n        lines = f.readlines()\n\n    lines.insert(0, line)\n\n    with open(filepath, 'w') as f:\n        f.writelines(lines)", "code_tokens": "def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "docstring_tokens": "Rewrite a file adding a line to its beginning .", "label": 0}, {"idx": "cosqa-train-16396", "doc": "insert python code in markdown", "code": "def build_code(self, lang, body):\n        \"\"\"Wrap text with markdown specific flavour.\"\"\"\n        self.out.append(\"```\" + lang)\n        self.build_markdown(lang, body)\n        self.out.append(\"```\")", "code_tokens": "def build_code ( self , lang , body ) : self . out . append ( \"```\" + lang ) self . build_markdown ( lang , body ) self . out . append ( \"```\" )", "docstring_tokens": "Wrap text with markdown specific flavour .", "label": 0}, {"idx": "cosqa-train-16397", "doc": "python webelement checkbox ischecked", "code": "def check_by_selector(self, selector):\n    \"\"\"Check the checkbox matching the CSS selector.\"\"\"\n    elem = find_element_by_jquery(world.browser, selector)\n    if not elem.is_selected():\n        elem.click()", "code_tokens": "def check_by_selector ( self , selector ) : elem = find_element_by_jquery ( world . browser , selector ) if not elem . is_selected ( ) : elem . click ( )", "docstring_tokens": "Check the checkbox matching the CSS selector .", "label": 0}, {"idx": "cosqa-train-16398", "doc": "ironpython python script global name not defined", "code": "def IPYTHON_MAIN():\n    \"\"\"Decide if the Ipython command line is running code.\"\"\"\n    import pkg_resources\n\n    runner_frame = inspect.getouterframes(inspect.currentframe())[-2]\n    return (\n        getattr(runner_frame, \"function\", None)\n        == pkg_resources.load_entry_point(\"ipython\", \"console_scripts\", \"ipython\").__name__\n    )", "code_tokens": "def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , \"function\" , None ) == pkg_resources . load_entry_point ( \"ipython\" , \"console_scripts\" , \"ipython\" ) . __name__ )", "docstring_tokens": "Decide if the Ipython command line is running code .", "label": 0}, {"idx": "cosqa-train-16399", "doc": "python widget maximum dimensions", "code": "def _checkSize(self):\n        \"\"\"Automatically resizes widget to display at most max_height_items items\"\"\"\n        if self._item_height is not None:\n            sz = min(self._max_height_items, self.count()) * self._item_height + 5\n            sz = max(sz, 20)\n            self.setMinimumSize(0, sz)\n            self.setMaximumSize(1000000, sz)\n            self.resize(self.width(), sz)", "code_tokens": "def _checkSize ( self ) : if self . _item_height is not None : sz = min ( self . _max_height_items , self . count ( ) ) * self . _item_height + 5 sz = max ( sz , 20 ) self . setMinimumSize ( 0 , sz ) self . setMaximumSize ( 1000000 , sz ) self . resize ( self . width ( ) , sz )", "docstring_tokens": "Automatically resizes widget to display at most max_height_items items", "label": 1}, {"idx": "cosqa-train-16400", "doc": "is there a select distinct in python", "code": "def fast_distinct(self):\n        \"\"\"\n        Because standard distinct used on the all fields are very slow and works only with PostgreSQL database\n        this method provides alternative to the standard distinct method.\n        :return: qs with unique objects\n        \"\"\"\n        return self.model.objects.filter(pk__in=self.values_list('pk', flat=True))", "code_tokens": "def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "docstring_tokens": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects", "label": 0}, {"idx": "cosqa-train-16401", "doc": "python widgets dont expand in grid", "code": "def __grid_widgets(self):\n        \"\"\"Places all the child widgets in the appropriate positions.\"\"\"\n        scrollbar_column = 0 if self.__compound is tk.LEFT else 2\n        self._canvas.grid(row=0, column=1, sticky=\"nswe\")\n        self._scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")", "code_tokens": "def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = \"nswe\" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = \"ns\" )", "docstring_tokens": "Places all the child widgets in the appropriate positions .", "label": 0}, {"idx": "cosqa-train-16402", "doc": "is there a unit test runner in python", "code": "def test():\n    \"\"\"Run the unit tests.\"\"\"\n    import unittest\n    tests = unittest.TestLoader().discover('tests')\n    unittest.TextTestRunner(verbosity=2).run(tests)", "code_tokens": "def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )", "docstring_tokens": "Run the unit tests .", "label": 1}, {"idx": "cosqa-train-16403", "doc": "python will the for loop keep going after the try excpetion", "code": "def retry_on_signal(function):\n    \"\"\"Retries function until it doesn't raise an EINTR error\"\"\"\n    while True:\n        try:\n            return function()\n        except EnvironmentError, e:\n            if e.errno != errno.EINTR:\n                raise", "code_tokens": "def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "docstring_tokens": "Retries function until it doesn t raise an EINTR error", "label": 0}, {"idx": "cosqa-train-16404", "doc": "is there a way in python to check that 2 numpy arrays are identical", "code": "def all_equal(arg1,arg2):\n    \"\"\"\n    Return a single boolean for arg1==arg2, even for numpy arrays\n    using element-wise comparison.\n\n    Uses all(arg1==arg2) for sequences, and arg1==arg2 otherwise.\n\n    If both objects have an '_infinitely_iterable' attribute, they are\n    not be zipped together and are compared directly instead.\n    \"\"\"\n    if all(hasattr(el, '_infinitely_iterable') for el in [arg1,arg2]):\n        return arg1==arg2\n    try:\n        return all(a1 == a2 for a1, a2 in zip(arg1, arg2))\n    except TypeError:\n        return arg1==arg2", "code_tokens": "def all_equal ( arg1 , arg2 ) : if all ( hasattr ( el , '_infinitely_iterable' ) for el in [ arg1 , arg2 ] ) : return arg1 == arg2 try : return all ( a1 == a2 for a1 , a2 in zip ( arg1 , arg2 ) ) except TypeError : return arg1 == arg2", "docstring_tokens": "Return a single boolean for arg1 == arg2 even for numpy arrays using element - wise comparison .", "label": 1}, {"idx": "cosqa-train-16405", "doc": "python windows stdin encoding", "code": "def __init__(self, encoding='utf-8'):\n    \"\"\"Initializes an stdin input reader.\n\n    Args:\n      encoding (Optional[str]): input encoding.\n    \"\"\"\n    super(StdinInputReader, self).__init__(sys.stdin, encoding=encoding)", "code_tokens": "def __init__ ( self , encoding = 'utf-8' ) : super ( StdinInputReader , self ) . __init__ ( sys . stdin , encoding = encoding )", "docstring_tokens": "Initializes an stdin input reader .", "label": 0}, {"idx": "cosqa-train-16406", "doc": "is there an alert like in javascript in python", "code": "def check_alert(self, text):\n    \"\"\"\n    Assert an alert is showing with the given text.\n    \"\"\"\n\n    try:\n        alert = Alert(world.browser)\n        if alert.text != text:\n            raise AssertionError(\n                \"Alert text expected to be {!r}, got {!r}.\".format(\n                    text, alert.text))\n    except WebDriverException:\n        # PhantomJS is kinda poor\n        pass", "code_tokens": "def check_alert ( self , text ) : try : alert = Alert ( world . browser ) if alert . text != text : raise AssertionError ( \"Alert text expected to be {!r}, got {!r}.\" . format ( text , alert . text ) ) except WebDriverException : # PhantomJS is kinda poor pass", "docstring_tokens": "Assert an alert is showing with the given text .", "label": 0}, {"idx": "cosqa-train-16407", "doc": "python write header to fits file", "code": "def write_fits(self, fitsfile):\n        \"\"\"Write the ROI model to a FITS file.\"\"\"\n\n        tab = self.create_table()\n        hdu_data = fits.table_to_hdu(tab)\n        hdus = [fits.PrimaryHDU(), hdu_data]\n        fits_utils.write_hdus(hdus, fitsfile)", "code_tokens": "def write_fits ( self , fitsfile ) : tab = self . create_table ( ) hdu_data = fits . table_to_hdu ( tab ) hdus = [ fits . PrimaryHDU ( ) , hdu_data ] fits_utils . write_hdus ( hdus , fitsfile )", "docstring_tokens": "Write the ROI model to a FITS file .", "label": 0}, {"idx": "cosqa-train-16408", "doc": "iterate all the images in a directory + python + opencv", "code": "def each_img(img_dir):\n    \"\"\"\n    Reads and iterates through each image file in the given directory\n    \"\"\"\n    for fname in utils.each_img(img_dir):\n        fname = os.path.join(img_dir, fname)\n        yield cv.imread(fname), fname", "code_tokens": "def each_img ( img_dir ) : for fname in utils . each_img ( img_dir ) : fname = os . path . join ( img_dir , fname ) yield cv . imread ( fname ) , fname", "docstring_tokens": "Reads and iterates through each image file in the given directory", "label": 1}, {"idx": "cosqa-train-16409", "doc": "python writing a dict to a file", "code": "def save_dict_to_file(filename, dictionary):\n  \"\"\"Saves dictionary as CSV file.\"\"\"\n  with open(filename, 'w') as f:\n    writer = csv.writer(f)\n    for k, v in iteritems(dictionary):\n      writer.writerow([str(k), str(v)])", "code_tokens": "def save_dict_to_file ( filename , dictionary ) : with open ( filename , 'w' ) as f : writer = csv . writer ( f ) for k , v in iteritems ( dictionary ) : writer . writerow ( [ str ( k ) , str ( v ) ] )", "docstring_tokens": "Saves dictionary as CSV file .", "label": 1}, {"idx": "cosqa-train-16410", "doc": "iterate distance over list of points python", "code": "def path_distance(points):\n    \"\"\"\n    Compute the path distance from given set of points\n    \"\"\"\n    vecs = np.diff(points, axis=0)[:, :3]\n    d2 = [np.dot(p, p) for p in vecs]\n    return np.sum(np.sqrt(d2))", "code_tokens": "def path_distance ( points ) : vecs = np . diff ( points , axis = 0 ) [ : , : 3 ] d2 = [ np . dot ( p , p ) for p in vecs ] return np . sum ( np . sqrt ( d2 ) )", "docstring_tokens": "Compute the path distance from given set of points", "label": 1}, {"idx": "cosqa-train-16411", "doc": "python xl number of entries in a column", "code": "def series_table_row_offset(self, series):\n        \"\"\"\n        Return the number of rows preceding the data table for *series* in\n        the Excel worksheet.\n        \"\"\"\n        title_and_spacer_rows = series.index * 2\n        data_point_rows = series.data_point_offset\n        return title_and_spacer_rows + data_point_rows", "code_tokens": "def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows", "docstring_tokens": "Return the number of rows preceding the data table for * series * in the Excel worksheet .", "label": 0}, {"idx": "cosqa-train-16412", "doc": "iterate over words in text line python", "code": "def extract_words(lines):\n    \"\"\"\n    Extract from the given iterable of lines the list of words.\n\n    :param lines: an iterable of lines;\n    :return: a generator of words of lines.\n    \"\"\"\n    for line in lines:\n        for word in re.findall(r\"\\w+\", line):\n            yield word", "code_tokens": "def extract_words ( lines ) : for line in lines : for word in re . findall ( r\"\\w+\" , line ) : yield word", "docstring_tokens": "Extract from the given iterable of lines the list of words .", "label": 0}, {"idx": "cosqa-train-16413", "doc": "python xml elements as a list", "code": "def as_list(self):\n        \"\"\"Return all child objects in nested lists of strings.\"\"\"\n        return [self.name, self.value, [x.as_list for x in self.children]]", "code_tokens": "def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "docstring_tokens": "Return all child objects in nested lists of strings .", "label": 0}, {"idx": "cosqa-train-16414", "doc": "iterator inpython has next next", "code": "def __next__(self, reward, ask_id, lbl):\n        \"\"\"For Python3 compatibility of generator.\"\"\"\n        return self.next(reward, ask_id, lbl)", "code_tokens": "def __next__ ( self , reward , ask_id , lbl ) : return self . next ( reward , ask_id , lbl )", "docstring_tokens": "For Python3 compatibility of generator .", "label": 1}, {"idx": "cosqa-train-16415", "doc": "python xml elementtree to string", "code": "def element_to_string(element, include_declaration=True, encoding=DEFAULT_ENCODING, method='xml'):\n    \"\"\" :return: the string value of the element or element tree \"\"\"\n\n    if isinstance(element, ElementTree):\n        element = element.getroot()\n    elif not isinstance(element, ElementType):\n        element = get_element(element)\n\n    if element is None:\n        return u''\n\n    element_as_string = tostring(element, encoding, method).decode(encoding=encoding)\n    if include_declaration:\n        return element_as_string\n    else:\n        return strip_xml_declaration(element_as_string)", "code_tokens": "def element_to_string ( element , include_declaration = True , encoding = DEFAULT_ENCODING , method = 'xml' ) : if isinstance ( element , ElementTree ) : element = element . getroot ( ) elif not isinstance ( element , ElementType ) : element = get_element ( element ) if element is None : return u'' element_as_string = tostring ( element , encoding , method ) . decode ( encoding = encoding ) if include_declaration : return element_as_string else : return strip_xml_declaration ( element_as_string )", "docstring_tokens": ": return : the string value of the element or element tree", "label": 1}, {"idx": "cosqa-train-16416", "doc": "itertools groupby in python list of dicts by key", "code": "def group_by(iterable, key_func):\n    \"\"\"Wrap itertools.groupby to make life easier.\"\"\"\n    groups = (\n        list(sub) for key, sub in groupby(iterable, key_func)\n    )\n    return zip(groups, groups)", "code_tokens": "def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "docstring_tokens": "Wrap itertools . groupby to make life easier .", "label": 0}, {"idx": "cosqa-train-16417", "doc": "python xml get value in tag", "code": "def _get_minidom_tag_value(station, tag_name):\n    \"\"\"get a value from a tag (if it exists)\"\"\"\n    tag = station.getElementsByTagName(tag_name)[0].firstChild\n    if tag:\n        return tag.nodeValue\n\n    return None", "code_tokens": "def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "docstring_tokens": "get a value from a tag ( if it exists )", "label": 1}, {"idx": "cosqa-train-16418", "doc": "jacquard similarity using python", "code": "def jaccard(c_1, c_2):\n    \"\"\"\n    Calculates the Jaccard similarity between two sets of nodes. Called by mroc.\n\n    Inputs:  - c_1: Community (set of nodes) 1.\n             - c_2: Community (set of nodes) 2.\n\n    Outputs: - jaccard_similarity: The Jaccard similarity of these two communities.\n    \"\"\"\n    nom = np.intersect1d(c_1, c_2).size\n    denom = np.union1d(c_1, c_2).size\n    return nom/denom", "code_tokens": "def jaccard ( c_1 , c_2 ) : nom = np . intersect1d ( c_1 , c_2 ) . size denom = np . union1d ( c_1 , c_2 ) . size return nom / denom", "docstring_tokens": "Calculates the Jaccard similarity between two sets of nodes . Called by mroc .", "label": 1}, {"idx": "cosqa-train-16419", "doc": "python xml parser check attribute", "code": "def required_attributes(element, *attributes):\n    \"\"\"Check element for required attributes. Raise ``NotValidXmlException`` on error.\n\n    :param element: ElementTree element\n    :param attributes: list of attributes names to check\n    :raises NotValidXmlException: if some argument is missing\n    \"\"\"\n    if not reduce(lambda still_valid, param: still_valid and param in element.attrib, attributes, True):\n        raise NotValidXmlException(msg_err_missing_attributes(element.tag, *attributes))", "code_tokens": "def required_attributes ( element , * attributes ) : if not reduce ( lambda still_valid , param : still_valid and param in element . attrib , attributes , True ) : raise NotValidXmlException ( msg_err_missing_attributes ( element . tag , * attributes ) )", "docstring_tokens": "Check element for required attributes . Raise NotValidXmlException on error .", "label": 0}, {"idx": "cosqa-train-16420", "doc": "join list of empty strings and strings python", "code": "def join(mapping, bind, values):\n    \"\"\" Merge all the strings. Put space between them. \"\"\"\n    return [' '.join([six.text_type(v) for v in values if v is not None])]", "code_tokens": "def join ( mapping , bind , values ) : return [ ' ' . join ( [ six . text_type ( v ) for v in values if v is not None ] ) ]", "docstring_tokens": "Merge all the strings . Put space between them .", "label": 1}, {"idx": "cosqa-train-16421", "doc": "python xml to dictionary", "code": "def xml_str_to_dict(s):\n    \"\"\" Transforms an XML string it to python-zimbra dict format\n\n    For format, see:\n      https://github.com/Zimbra-Community/python-zimbra/blob/master/README.md\n\n    :param: a string, containing XML\n    :returns: a dict, with python-zimbra format\n    \"\"\"\n    xml = minidom.parseString(s)\n    return pythonzimbra.tools.xmlserializer.dom_to_dict(xml.firstChild)", "code_tokens": "def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )", "docstring_tokens": "Transforms an XML string it to python - zimbra dict format", "label": 0}, {"idx": "cosqa-train-16422", "doc": "kafka python producer not sending message", "code": "def send(self, topic, *args, **kwargs):\n        \"\"\"\n        Appends the prefix to the topic before sendingf\n        \"\"\"\n        prefix_topic = self.heroku_kafka.prefix_topic(topic)\n        return super(HerokuKafkaProducer, self).send(prefix_topic, *args, **kwargs)", "code_tokens": "def send ( self , topic , * args , * * kwargs ) : prefix_topic = self . heroku_kafka . prefix_topic ( topic ) return super ( HerokuKafkaProducer , self ) . send ( prefix_topic , * args , * * kwargs )", "docstring_tokens": "Appends the prefix to the topic before sendingf", "label": 0}, {"idx": "cosqa-train-16423", "doc": "python xmlnode get parent", "code": "def root_parent(self, category=None):\n        \"\"\" Returns the topmost parent of the current category. \"\"\"\n        return next(filter(lambda c: c.is_root, self.hierarchy()))", "code_tokens": "def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )", "docstring_tokens": "Returns the topmost parent of the current category .", "label": 1}, {"idx": "cosqa-train-16424", "doc": "keep track of 5 largest values in python", "code": "def best(self):\n        \"\"\"\n        Returns the element with the highest probability.\n        \"\"\"\n        b = (-1e999999, None)\n        for k, c in iteritems(self.counts):\n            b = max(b, (c, k))\n        return b[1]", "code_tokens": "def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]", "docstring_tokens": "Returns the element with the highest probability .", "label": 0}, {"idx": "cosqa-train-16425", "doc": "python xmlrpc doesn't work over a network", "code": "def _Open(self, hostname, port):\n    \"\"\"Opens the RPC communication channel for clients.\n\n    Args:\n      hostname (str): hostname or IP address to connect to for requests.\n      port (int): port to connect to for requests.\n\n    Returns:\n      bool: True if the communication channel was successfully opened.\n    \"\"\"\n    try:\n      self._xmlrpc_server = SimpleXMLRPCServer.SimpleXMLRPCServer(\n          (hostname, port), logRequests=False, allow_none=True)\n    except SocketServer.socket.error as exception:\n      logger.warning((\n          'Unable to bind a RPC server on {0:s}:{1:d} with error: '\n          '{2!s}').format(hostname, port, exception))\n      return False\n\n    self._xmlrpc_server.register_function(\n        self._callback, self._RPC_FUNCTION_NAME)\n    return True", "code_tokens": "def _Open ( self , hostname , port ) : try : self . _xmlrpc_server = SimpleXMLRPCServer . SimpleXMLRPCServer ( ( hostname , port ) , logRequests = False , allow_none = True ) except SocketServer . socket . error as exception : logger . warning ( ( 'Unable to bind a RPC server on {0:s}:{1:d} with error: ' '{2!s}' ) . format ( hostname , port , exception ) ) return False self . _xmlrpc_server . register_function ( self . _callback , self . _RPC_FUNCTION_NAME ) return True", "docstring_tokens": "Opens the RPC communication channel for clients .", "label": 0}, {"idx": "cosqa-train-16426", "doc": "keras python sequential predict batch size one one input", "code": "def predict(self, X):\n        \"\"\"Predict the class for X.\n\n        The predicted class for each sample in X is returned.\n\n        Parameters\n        ----------\n        X : List of ndarrays, one for each training example.\n            Each training example's shape is (string1_len,\n            string2_len, n_features), where string1_len and\n            string2_len are the length of the two training strings and\n            n_features the number of features.\n\n        Returns\n        -------\n        y : iterable of shape = [n_samples]\n            The predicted classes.\n\n        \"\"\"\n        return [self.classes[prediction.argmax()] for prediction in self.predict_proba(X)]", "code_tokens": "def predict ( self , X ) : return [ self . classes [ prediction . argmax ( ) ] for prediction in self . predict_proba ( X ) ]", "docstring_tokens": "Predict the class for X .", "label": 0}, {"idx": "cosqa-train-16427", "doc": "kill a python process in linux", "code": "def stop(pid):\n    \"\"\"Shut down a specific process.\n\n    Args:\n      pid: the pid of the process to shutdown.\n    \"\"\"\n    if psutil.pid_exists(pid):\n      try:\n        p = psutil.Process(pid)\n        p.kill()\n      except Exception:\n        pass", "code_tokens": "def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass", "docstring_tokens": "Shut down a specific process .", "label": 1}, {"idx": "cosqa-train-16428", "doc": "python yaml as object attributes", "code": "def yaml_to_param(obj, name):\n\t\"\"\"\n\tReturn the top-level element of a document sub-tree containing the\n\tYAML serialization of a Python object.\n\t\"\"\"\n\treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "code_tokens": "def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "docstring_tokens": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .", "label": 0}, {"idx": "cosqa-train-16429", "doc": "kill a python program after a time limit", "code": "def timeout_thread_handler(timeout, stop_event):\n    \"\"\"A background thread to kill the process if it takes too long.\n\n    Args:\n        timeout (float): The number of seconds to wait before killing\n            the process.\n        stop_event (Event): An optional event to cleanly stop the background\n            thread if required during testing.\n    \"\"\"\n\n    stop_happened = stop_event.wait(timeout)\n    if stop_happened is False:\n        print(\"Killing program due to %f second timeout\" % timeout)\n\n    os._exit(2)", "code_tokens": "def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( \"Killing program due to %f second timeout\" % timeout ) os . _exit ( 2 )", "docstring_tokens": "A background thread to kill the process if it takes too long .", "label": 0}, {"idx": "cosqa-train-16430", "doc": "python yaml load multiple documents", "code": "def ParseMany(text):\n  \"\"\"Parses many YAML documents into a list of Python objects.\n\n  Args:\n    text: A YAML source with multiple documents embedded.\n\n  Returns:\n    A list of Python data structures corresponding to the YAML documents.\n  \"\"\"\n  precondition.AssertType(text, Text)\n\n  if compatibility.PY2:\n    text = text.encode(\"utf-8\")\n\n  return list(yaml.safe_load_all(text))", "code_tokens": "def ParseMany ( text ) : precondition . AssertType ( text , Text ) if compatibility . PY2 : text = text . encode ( \"utf-8\" ) return list ( yaml . safe_load_all ( text ) )", "docstring_tokens": "Parses many YAML documents into a list of Python objects .", "label": 1}, {"idx": "cosqa-train-16431", "doc": "kill a thread python after a specified time", "code": "def timeout_thread_handler(timeout, stop_event):\n    \"\"\"A background thread to kill the process if it takes too long.\n\n    Args:\n        timeout (float): The number of seconds to wait before killing\n            the process.\n        stop_event (Event): An optional event to cleanly stop the background\n            thread if required during testing.\n    \"\"\"\n\n    stop_happened = stop_event.wait(timeout)\n    if stop_happened is False:\n        print(\"Killing program due to %f second timeout\" % timeout)\n\n    os._exit(2)", "code_tokens": "def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( \"Killing program due to %f second timeout\" % timeout ) os . _exit ( 2 )", "docstring_tokens": "A background thread to kill the process if it takes too long .", "label": 1}, {"idx": "cosqa-train-16432", "doc": "python yaml special dict representation", "code": "def safe_dump(data, stream=None, **kwds):\n    \"\"\"implementation of safe dumper using Ordered Dict Yaml Dumper\"\"\"\n    return yaml.dump(data, stream=stream, Dumper=ODYD, **kwds)", "code_tokens": "def safe_dump ( data , stream = None , * * kwds ) : return yaml . dump ( data , stream = stream , Dumper = ODYD , * * kwds )", "docstring_tokens": "implementation of safe dumper using Ordered Dict Yaml Dumper", "label": 0}, {"idx": "cosqa-train-16433", "doc": "kill command for python", "code": "def cli_command_quit(self, msg):\n        \"\"\"\\\n        kills the child and exits\n        \"\"\"\n        if self.state == State.RUNNING and self.sprocess and self.sprocess.proc:\n            self.sprocess.proc.kill()\n        else:\n            sys.exit(0)", "code_tokens": "def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )", "docstring_tokens": "\\ kills the child and exits", "label": 0}, {"idx": "cosqa-train-16434", "doc": "python yaml store as dict", "code": "def yaml_to_param(obj, name):\n\t\"\"\"\n\tReturn the top-level element of a document sub-tree containing the\n\tYAML serialization of a Python object.\n\t\"\"\"\n\treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "code_tokens": "def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "docstring_tokens": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .", "label": 0}, {"idx": "cosqa-train-16435", "doc": "killing logging handlers in python", "code": "def kill_test_logger(logger):\n    \"\"\"Cleans up a test logger object by removing all of its handlers.\n\n    Args:\n        logger: The logging object to clean up.\n    \"\"\"\n    for h in list(logger.handlers):\n        logger.removeHandler(h)\n        if isinstance(h, logging.FileHandler):\n            h.close()", "code_tokens": "def kill_test_logger ( logger ) : for h in list ( logger . handlers ) : logger . removeHandler ( h ) if isinstance ( h , logging . FileHandler ) : h . close ( )", "docstring_tokens": "Cleans up a test logger object by removing all of its handlers .", "label": 1}, {"idx": "cosqa-train-16436", "doc": "python yield catch except", "code": "def trap_exceptions(results, handler, exceptions=Exception):\n\t\"\"\"\n\tIterate through the results, but if an exception occurs, stop\n\tprocessing the results and instead replace\n\tthe results with the output from the exception handler.\n\t\"\"\"\n\ttry:\n\t\tfor result in results:\n\t\t\tyield result\n\texcept exceptions as exc:\n\t\tfor result in always_iterable(handler(exc)):\n\t\t\tyield result", "code_tokens": "def trap_exceptions ( results , handler , exceptions = Exception ) : try : for result in results : yield result except exceptions as exc : for result in always_iterable ( handler ( exc ) ) : yield result", "docstring_tokens": "Iterate through the results but if an exception occurs stop processing the results and instead replace the results with the output from the exception handler .", "label": 1}, {"idx": "cosqa-train-16437", "doc": "least common element in a list python", "code": "def _most_common(iterable):\n    \"\"\"Returns the most common element in `iterable`.\"\"\"\n    data = Counter(iterable)\n    return max(data, key=data.__getitem__)", "code_tokens": "def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "docstring_tokens": "Returns the most common element in iterable .", "label": 0}, {"idx": "cosqa-train-16438", "doc": "python yield from memory leak", "code": "def connected_socket(address, timeout=3):\n    \"\"\" yields a connected socket \"\"\"\n    sock = socket.create_connection(address, timeout)\n    yield sock\n    sock.close()", "code_tokens": "def connected_socket ( address , timeout = 3 ) : sock = socket . create_connection ( address , timeout ) yield sock sock . close ( )", "docstring_tokens": "yields a connected socket", "label": 0}, {"idx": "cosqa-train-16439", "doc": "left right function in python", "code": "def value_left(self, other):\n    \"\"\"\n    Returns the value of the other type instance to use in an\n    operator method, namely when the method's instance is on the\n    left side of the expression.\n    \"\"\"\n    return other.value if isinstance(other, self.__class__) else other", "code_tokens": "def value_left ( self , other ) : return other . value if isinstance ( other , self . __class__ ) else other", "docstring_tokens": "Returns the value of the other type instance to use in an operator method namely when the method s instance is on the left side of the expression .", "label": 1}, {"idx": "cosqa-train-16440", "doc": "python yield how to know the function is finish", "code": "def _return_result(self, done):\n        \"\"\"Called set the returned future's state that of the future\n        we yielded, and set the current future for the iterator.\n        \"\"\"\n        chain_future(done, self._running_future)\n\n        self.current_future = done\n        self.current_index = self._unfinished.pop(done)", "code_tokens": "def _return_result ( self , done ) : chain_future ( done , self . _running_future ) self . current_future = done self . current_index = self . _unfinished . pop ( done )", "docstring_tokens": "Called set the returned future s state that of the future we yielded and set the current future for the iterator .", "label": 0}, {"idx": "cosqa-train-16441", "doc": "limit character length on print python", "code": "def pprint(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Like `pretty` but print to stdout.\n    \"\"\"\n    printer = RepresentationPrinter(sys.stdout, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    sys.stdout.write(newline)\n    sys.stdout.flush()", "code_tokens": "def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "docstring_tokens": "Like pretty but print to stdout .", "label": 0}, {"idx": "cosqa-train-16442", "doc": "python zipfile unzip to folder", "code": "def unzip_file_to_dir(path_to_zip, output_directory):\n    \"\"\"\n    Extract a ZIP archive to a directory\n    \"\"\"\n    z = ZipFile(path_to_zip, 'r')\n    z.extractall(output_directory)\n    z.close()", "code_tokens": "def unzip_file_to_dir ( path_to_zip , output_directory ) : z = ZipFile ( path_to_zip , 'r' ) z . extractall ( output_directory ) z . close ( )", "docstring_tokens": "Extract a ZIP archive to a directory", "label": 0}, {"idx": "cosqa-train-16443", "doc": "limit x and y python", "code": "def _get_xy_scaling_parameters(self):\n        \"\"\"Get the X/Y coordinate limits for the full resulting image\"\"\"\n        return self.mx, self.bx, self.my, self.by", "code_tokens": "def _get_xy_scaling_parameters ( self ) : return self . mx , self . bx , self . my , self . by", "docstring_tokens": "Get the X / Y coordinate limits for the full resulting image", "label": 0}, {"idx": "cosqa-train-16444", "doc": "python zmq check if connected", "code": "def start(self, test_connection=True):\n        \"\"\"Starts connection to server if not existent.\n\n        NO-OP if connection is already established.\n        Makes ping-pong test as well if desired.\n\n        \"\"\"\n        if self._context is None:\n            self._logger.debug('Starting Client')\n            self._context = zmq.Context()\n            self._poll = zmq.Poller()\n            self._start_socket()\n            if test_connection:\n                self.test_ping()", "code_tokens": "def start ( self , test_connection = True ) : if self . _context is None : self . _logger . debug ( 'Starting Client' ) self . _context = zmq . Context ( ) self . _poll = zmq . Poller ( ) self . _start_socket ( ) if test_connection : self . test_ping ( )", "docstring_tokens": "Starts connection to server if not existent .", "label": 1}, {"idx": "cosqa-train-16445", "doc": "limiting a floating number range python", "code": "def open01(x, limit=1.e-6):\n    \"\"\"Constrain numbers to (0,1) interval\"\"\"\n    try:\n        return np.array([min(max(y, limit), 1. - limit) for y in x])\n    except TypeError:\n        return min(max(x, limit), 1. - limit)", "code_tokens": "def open01 ( x , limit = 1.e-6 ) : try : return np . array ( [ min ( max ( y , limit ) , 1. - limit ) for y in x ] ) except TypeError : return min ( max ( x , limit ) , 1. - limit )", "docstring_tokens": "Constrain numbers to ( 0 1 ) interval", "label": 0}, {"idx": "cosqa-train-16446", "doc": "python zmq fork new connection", "code": "def init_mq(self):\n        \"\"\"Init connection and consumer with openstack mq.\"\"\"\n        mq = self.init_connection()\n        self.init_consumer(mq)\n        return mq.connection", "code_tokens": "def init_mq ( self ) : mq = self . init_connection ( ) self . init_consumer ( mq ) return mq . connection", "docstring_tokens": "Init connection and consumer with openstack mq .", "label": 0}, {"idx": "cosqa-train-16447", "doc": "line edit changed signal python", "code": "def _on_text_changed(self):\n        \"\"\" Adjust dirty flag depending on editor's content \"\"\"\n        if not self._cleaning:\n            ln = TextHelper(self).cursor_position()[0]\n            self._modified_lines.add(ln)", "code_tokens": "def _on_text_changed ( self ) : if not self . _cleaning : ln = TextHelper ( self ) . cursor_position ( ) [ 0 ] self . _modified_lines . add ( ln )", "docstring_tokens": "Adjust dirty flag depending on editor s content", "label": 0}, {"idx": "cosqa-train-16448", "doc": "python zmq get queue length", "code": "def qsize(self):\n        \"\"\"Return the approximate size of the queue (not reliable!).\"\"\"\n        self.mutex.acquire()\n        n = self._qsize()\n        self.mutex.release()\n        return n", "code_tokens": "def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n", "docstring_tokens": "Return the approximate size of the queue ( not reliable! ) .", "label": 0}, {"idx": "cosqa-train-16449", "doc": "linear interpolation of 3 arrays in python", "code": "def _linearInterpolationTransformMatrix(matrix1, matrix2, value):\n    \"\"\" Linear, 'oldstyle' interpolation of the transform matrix.\"\"\"\n    return tuple(_interpolateValue(matrix1[i], matrix2[i], value) for i in range(len(matrix1)))", "code_tokens": "def _linearInterpolationTransformMatrix ( matrix1 , matrix2 , value ) : return tuple ( _interpolateValue ( matrix1 [ i ] , matrix2 [ i ] , value ) for i in range ( len ( matrix1 ) ) )", "docstring_tokens": "Linear oldstyle interpolation of the transform matrix .", "label": 0}, {"idx": "cosqa-train-16450", "doc": "python, accepting a string input as upper or lower case", "code": "def clean(some_string, uppercase=False):\n    \"\"\"\n    helper to clean up an input string\n    \"\"\"\n    if uppercase:\n        return some_string.strip().upper()\n    else:\n        return some_string.strip().lower()", "code_tokens": "def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )", "docstring_tokens": "helper to clean up an input string", "label": 0}, {"idx": "cosqa-train-16451", "doc": "linux python3 stack trace", "code": "def stack_as_string():\n    \"\"\"\n    stack_as_string\n    \"\"\"\n    if sys.version_info.major == 3:\n        stack = io.StringIO()\n    else:\n        stack = io.BytesIO()\n\n    traceback.print_stack(file=stack)\n    stack.seek(0)\n    stack = stack.read()\n    return stack", "code_tokens": "def stack_as_string ( ) : if sys . version_info . major == 3 : stack = io . StringIO ( ) else : stack = io . BytesIO ( ) traceback . print_stack ( file = stack ) stack . seek ( 0 ) stack = stack . read ( ) return stack", "docstring_tokens": "stack_as_string", "label": 0}, {"idx": "cosqa-train-16452", "doc": "python, get the size of the queue", "code": "def qsize(self):\n        \"\"\"Return the approximate size of the queue (not reliable!).\"\"\"\n        self.mutex.acquire()\n        n = self._qsize()\n        self.mutex.release()\n        return n", "code_tokens": "def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n", "docstring_tokens": "Return the approximate size of the queue ( not reliable! ) .", "label": 1}, {"idx": "cosqa-train-16453", "doc": "list following months entered in python", "code": "def get_previous_month(self):\n        \"\"\"Returns date range for the previous full month.\"\"\"\n        end = utils.get_month_start() - relativedelta(days=1)\n        end = utils.to_datetime(end)\n        start = utils.get_month_start(end)\n        return start, end", "code_tokens": "def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end", "docstring_tokens": "Returns date range for the previous full month .", "label": 0}, {"idx": "cosqa-train-16454", "doc": "python, reshape a list to array", "code": "def shape_list(l,shape,dtype):\n    \"\"\" Shape a list of lists into the appropriate shape and data type \"\"\"\n    return np.array(l, dtype=dtype).reshape(shape)", "code_tokens": "def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )", "docstring_tokens": "Shape a list of lists into the appropriate shape and data type", "label": 1}, {"idx": "cosqa-train-16455", "doc": "list of a list of tokens python", "code": "def append_position_to_token_list(token_list):\n    \"\"\"Converts a list of Token into a list of Token, asuming size == 1\"\"\"\n    return [PositionToken(value.content, value.gd, index, index+1) for (index, value) in enumerate(token_list)]", "code_tokens": "def append_position_to_token_list ( token_list ) : return [ PositionToken ( value . content , value . gd , index , index + 1 ) for ( index , value ) in enumerate ( token_list ) ]", "docstring_tokens": "Converts a list of Token into a list of Token asuming size == 1", "label": 1}, {"idx": "cosqa-train-16456", "doc": "python, time to milliseconds", "code": "def ms_to_datetime(ms):\n    \"\"\"\n    Converts a millisecond accuracy timestamp to a datetime\n    \"\"\"\n    dt = datetime.datetime.utcfromtimestamp(ms / 1000)\n    return dt.replace(microsecond=(ms % 1000) * 1000).replace(tzinfo=pytz.utc)", "code_tokens": "def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )", "docstring_tokens": "Converts a millisecond accuracy timestamp to a datetime", "label": 0}, {"idx": "cosqa-train-16457", "doc": "list of prefixes and show as headers python", "code": "def display_list_by_prefix(names_list, starting_spaces=0):\n  \"\"\"Creates a help string for names_list grouped by prefix.\"\"\"\n  cur_prefix, result_lines = None, []\n  space = \" \" * starting_spaces\n  for name in sorted(names_list):\n    split = name.split(\"_\", 1)\n    prefix = split[0]\n    if cur_prefix != prefix:\n      result_lines.append(space + prefix + \":\")\n      cur_prefix = prefix\n    result_lines.append(space + \"  * \" + name)\n  return \"\\n\".join(result_lines)", "code_tokens": "def display_list_by_prefix ( names_list , starting_spaces = 0 ) : cur_prefix , result_lines = None , [ ] space = \" \" * starting_spaces for name in sorted ( names_list ) : split = name . split ( \"_\" , 1 ) prefix = split [ 0 ] if cur_prefix != prefix : result_lines . append ( space + prefix + \":\" ) cur_prefix = prefix result_lines . append ( space + \"  * \" + name ) return \"\\n\" . join ( result_lines )", "docstring_tokens": "Creates a help string for names_list grouped by prefix .", "label": 1}, {"idx": "cosqa-train-16458", "doc": "python3 create random unique identifier", "code": "def _get_random_id():\n    \"\"\" Get a random (i.e., unique) string identifier\"\"\"\n    symbols = string.ascii_uppercase + string.ascii_lowercase + string.digits\n    return ''.join(random.choice(symbols) for _ in range(15))", "code_tokens": "def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )", "docstring_tokens": "Get a random ( i . e . unique ) string identifier", "label": 1}, {"idx": "cosqa-train-16459", "doc": "list or nd array type check python", "code": "def is_iterable(value):\n    \"\"\"must be an iterable (list, array, tuple)\"\"\"\n    return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value", "code_tokens": "def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value", "docstring_tokens": "must be an iterable ( list array tuple )", "label": 1}, {"idx": "cosqa-train-16460", "doc": "python3 ctypes pointer of array", "code": "def cint32_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes int pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)):\n        return np.fromiter(cptr, dtype=np.int32, count=length)\n    else:\n        raise RuntimeError('Expected int pointer')", "code_tokens": "def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "docstring_tokens": "Convert a ctypes int pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-16461", "doc": "list python numpy flatten", "code": "def flatten_array(grid):\n    \"\"\"\n    Takes a multi-dimensional array and returns a 1 dimensional array with the\n    same contents.\n    \"\"\"\n    grid = [grid[i][j] for i in range(len(grid)) for j in range(len(grid[i]))]\n    while type(grid[0]) is list:\n        grid = flatten_array(grid)\n    return grid", "code_tokens": "def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid", "docstring_tokens": "Takes a multi - dimensional array and returns a 1 dimensional array with the same contents .", "label": 0}, {"idx": "cosqa-train-16462", "doc": "python3 get file md5", "code": "def get_md5_for_file(file):\n    \"\"\"Get the md5 hash for a file.\n\n    :param file: the file to get the md5 hash for\n    \"\"\"\n    md5 = hashlib.md5()\n\n    while True:\n        data = file.read(md5.block_size)\n\n        if not data:\n            break\n\n        md5.update(data)\n\n    return md5.hexdigest()", "code_tokens": "def get_md5_for_file ( file ) : md5 = hashlib . md5 ( ) while True : data = file . read ( md5 . block_size ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )", "docstring_tokens": "Get the md5 hash for a file .", "label": 0}, {"idx": "cosqa-train-16463", "doc": "python3 how read a stream buffer without eof", "code": "def get_iter_string_reader(stdin):\n    \"\"\" return an iterator that returns a chunk of a string every time it is\n    called.  notice that even though bufsize_type might be line buffered, we're\n    not doing any line buffering here.  that's because our StreamBufferer\n    handles all buffering.  we just need to return a reasonable-sized chunk. \"\"\"\n    bufsize = 1024\n    iter_str = (stdin[i:i + bufsize] for i in range(0, len(stdin), bufsize))\n    return get_iter_chunk_reader(iter_str)", "code_tokens": "def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )", "docstring_tokens": "return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .", "label": 1}, {"idx": "cosqa-train-16464", "doc": "list the constants in a python file dynamically", "code": "def _get_all_constants():\n    \"\"\"\n    Get list of all uppercase, non-private globals (doesn't start with ``_``).\n\n    Returns:\n        list: Uppercase names defined in `globals()` (variables from this \\\n              module).\n    \"\"\"\n    return [\n        key for key in globals().keys()\n        if all([\n            not key.startswith(\"_\"),          # publicly accesible\n            key.upper() == key,               # uppercase\n            type(globals()[key]) in _ALLOWED  # and with type from _ALLOWED\n        ])\n    ]", "code_tokens": "def _get_all_constants ( ) : return [ key for key in globals ( ) . keys ( ) if all ( [ not key . startswith ( \"_\" ) , # publicly accesible key . upper ( ) == key , # uppercase type ( globals ( ) [ key ] ) in _ALLOWED # and with type from _ALLOWED ] ) ]", "docstring_tokens": "Get list of all uppercase non - private globals ( doesn t start with _ ) .", "label": 0}, {"idx": "cosqa-train-16465", "doc": "python3 how to remove multiple items from a list", "code": "def dedupe_list(l):\n    \"\"\"Remove duplicates from a list preserving the order.\n\n    We might be tempted to use the list(set(l)) idiom, but it doesn't preserve\n    the order, which hinders testability and does not work for lists with\n    unhashable elements.\n    \"\"\"\n    result = []\n\n    for el in l:\n        if el not in result:\n            result.append(el)\n\n    return result", "code_tokens": "def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result", "docstring_tokens": "Remove duplicates from a list preserving the order .", "label": 1}, {"idx": "cosqa-train-16466", "doc": "list to np array in python without add additional dimension", "code": "def recarray(self):\n        \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"\n        return numpy.rec.fromrecords(self.records, names=self.names)", "code_tokens": "def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "docstring_tokens": "Returns data as : class : numpy . recarray .", "label": 0}, {"idx": "cosqa-train-16467", "doc": "python3 ip expand cidr notations", "code": "def ip_address_list(ips):\n    \"\"\" IP address range validation and expansion. \"\"\"\n    # first, try it as a single IP address\n    try:\n        return ip_address(ips)\n    except ValueError:\n        pass\n    # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it\n    return list(ipaddress.ip_network(u(ips)).hosts())", "code_tokens": "def ip_address_list ( ips ) : # first, try it as a single IP address try : return ip_address ( ips ) except ValueError : pass # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it return list ( ipaddress . ip_network ( u ( ips ) ) . hosts ( ) )", "docstring_tokens": "IP address range validation and expansion .", "label": 0}, {"idx": "cosqa-train-16468", "doc": "load in data as bytearray python", "code": "def be_array_from_bytes(fmt, data):\n    \"\"\"\n    Reads an array from bytestring with big-endian data.\n    \"\"\"\n    arr = array.array(str(fmt), data)\n    return fix_byteorder(arr)", "code_tokens": "def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )", "docstring_tokens": "Reads an array from bytestring with big - endian data .", "label": 0}, {"idx": "cosqa-train-16469", "doc": "python3 not equal string", "code": "def polite_string(a_string):\n    \"\"\"Returns a \"proper\" string that should work in both Py3/Py2\"\"\"\n    if is_py3() and hasattr(a_string, 'decode'):\n        try:\n            return a_string.decode('utf-8')\n        except UnicodeDecodeError:\n            return a_string\n\n    return a_string", "code_tokens": "def polite_string ( a_string ) : if is_py3 ( ) and hasattr ( a_string , 'decode' ) : try : return a_string . decode ( 'utf-8' ) except UnicodeDecodeError : return a_string return a_string", "docstring_tokens": "Returns a proper string that should work in both Py3 / Py2", "label": 0}, {"idx": "cosqa-train-16470", "doc": "load javascript file in python", "code": "def import_js(path, lib_name, globals):\n    \"\"\"Imports from javascript source file.\n      globals is your globals()\"\"\"\n    with codecs.open(path_as_local(path), \"r\", \"utf-8\") as f:\n        js = f.read()\n    e = EvalJs()\n    e.execute(js)\n    var = e.context['var']\n    globals[lib_name] = var.to_python()", "code_tokens": "def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "docstring_tokens": "Imports from javascript source file . globals is your globals ()", "label": 0}, {"idx": "cosqa-train-16471", "doc": "python3 read linux clipboard", "code": "def paste(cmd=paste_cmd, stdout=PIPE):\n    \"\"\"Returns system clipboard contents.\n    \"\"\"\n    return Popen(cmd, stdout=stdout).communicate()[0].decode('utf-8')", "code_tokens": "def paste ( cmd = paste_cmd , stdout = PIPE ) : return Popen ( cmd , stdout = stdout ) . communicate ( ) [ 0 ] . decode ( 'utf-8' )", "docstring_tokens": "Returns system clipboard contents .", "label": 1}, {"idx": "cosqa-train-16472", "doc": "loading a file in python", "code": "def Load(file):\n    \"\"\" Loads a model from specified file \"\"\"\n    with open(file, 'rb') as file:\n        model = dill.load(file)\n        return model", "code_tokens": "def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model", "docstring_tokens": "Loads a model from specified file", "label": 1}, {"idx": "cosqa-train-16473", "doc": "python3 round comparison float", "code": "def py3round(number):\n    \"\"\"Unified rounding in all python versions.\"\"\"\n    if abs(round(number) - number) == 0.5:\n        return int(2.0 * round(number / 2.0))\n\n    return int(round(number))", "code_tokens": "def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "docstring_tokens": "Unified rounding in all python versions .", "label": 0}, {"idx": "cosqa-train-16474", "doc": "python3 select all text in a text document and delete text", "code": "def delete_lines(self):\n        \"\"\"\n        Deletes the document lines under cursor.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n        self.__select_text_under_cursor_blocks(cursor)\n        cursor.removeSelectedText()\n        cursor.deleteChar()\n        return True", "code_tokens": "def delete_lines ( self ) : cursor = self . textCursor ( ) self . __select_text_under_cursor_blocks ( cursor ) cursor . removeSelectedText ( ) cursor . deleteChar ( ) return True", "docstring_tokens": "Deletes the document lines under cursor .", "label": 0}, {"idx": "cosqa-train-16475", "doc": "lock the file python", "code": "def __enter__(self):\n        \"\"\"Acquire a lock on the output file, prevents collisions between multiple runs.\"\"\"\n        self.fd = open(self.filename, 'a')\n        fcntl.lockf(self.fd, fcntl.LOCK_EX)\n        return self.fd", "code_tokens": "def __enter__ ( self ) : self . fd = open ( self . filename , 'a' ) fcntl . lockf ( self . fd , fcntl . LOCK_EX ) return self . fd", "docstring_tokens": "Acquire a lock on the output file prevents collisions between multiple runs .", "label": 0}, {"idx": "cosqa-train-16476", "doc": "python3 string byte enciode", "code": "def to_bytes(value):\n    \"\"\" str to bytes (py3k) \"\"\"\n    vtype = type(value)\n\n    if vtype == bytes or vtype == type(None):\n        return value\n\n    try:\n        return vtype.encode(value)\n    except UnicodeEncodeError:\n        pass\n    return value", "code_tokens": "def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value", "docstring_tokens": "str to bytes ( py3k )", "label": 0}, {"idx": "cosqa-train-16477", "doc": "log normal distribution in python", "code": "def ln_norm(x, mu, sigma=1.0):\n    \"\"\" Natural log of scipy norm function truncated at zero \"\"\"\n    return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))", "code_tokens": "def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "docstring_tokens": "Natural log of scipy norm function truncated at zero", "label": 0}, {"idx": "cosqa-train-16478", "doc": "python3 subprocess get stdout text", "code": "def _run_cmd_get_output(cmd):\n    \"\"\"Runs a shell command, returns console output.\n\n    Mimics python3's subprocess.getoutput\n    \"\"\"\n    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)\n    out, err = process.communicate()\n    return out or err", "code_tokens": "def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "docstring_tokens": "Runs a shell command returns console output .", "label": 0}, {"idx": "cosqa-train-16479", "doc": "logistic regression lasso python", "code": "def cric__lasso():\n    \"\"\" Lasso Regression\n    \"\"\"\n    model = sklearn.linear_model.LogisticRegression(penalty=\"l1\", C=0.002)\n\n    # we want to explain the raw probability outputs of the trees\n    model.predict = lambda X: model.predict_proba(X)[:,1]\n    \n    return model", "code_tokens": "def cric__lasso ( ) : model = sklearn . linear_model . LogisticRegression ( penalty = \"l1\" , C = 0.002 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model", "docstring_tokens": "Lasso Regression", "label": 0}, {"idx": "cosqa-train-16480", "doc": "python3 syntax for deletin g duplicate entries", "code": "def unique(transactions):\n    \"\"\" Remove any duplicate entries. \"\"\"\n    seen = set()\n    # TODO: Handle comments\n    return [x for x in transactions if not (x in seen or seen.add(x))]", "code_tokens": "def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Remove any duplicate entries .", "label": 0}, {"idx": "cosqa-train-16481", "doc": "logistic regression overflow python", "code": "def survival(value=t, lam=lam, f=failure):\n    \"\"\"Exponential survival likelihood, accounting for censoring\"\"\"\n    return sum(f * log(lam) - lam * value)", "code_tokens": "def survival ( value = t , lam = lam , f = failure ) : return sum ( f * log ( lam ) - lam * value )", "docstring_tokens": "Exponential survival likelihood accounting for censoring", "label": 0}, {"idx": "cosqa-train-16482", "doc": "pythone code to make first and last letter of string capital", "code": "def to_identifier(s):\n  \"\"\"\n  Convert snake_case to camel_case.\n  \"\"\"\n  if s.startswith('GPS'):\n      s = 'Gps' + s[3:]\n  return ''.join([i.capitalize() for i in s.split('_')]) if '_' in s else s", "code_tokens": "def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "docstring_tokens": "Convert snake_case to camel_case .", "label": 0}, {"idx": "cosqa-train-16483", "doc": "longest non decreasing subsequence python", "code": "def get_longest_orf(orfs):\n    \"\"\"Find longest ORF from the given list of ORFs.\"\"\"\n    sorted_orf = sorted(orfs, key=lambda x: len(x['sequence']), reverse=True)[0]\n    return sorted_orf", "code_tokens": "def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf", "docstring_tokens": "Find longest ORF from the given list of ORFs .", "label": 0}, {"idx": "cosqa-train-16484", "doc": "pythong mysql how to get column names", "code": "def get_table_columns(dbconn, tablename):\n    \"\"\"\n    Return a list of tuples specifying the column name and type\n    \"\"\"\n    cur = dbconn.cursor()\n    cur.execute(\"PRAGMA table_info('%s');\" % tablename)\n    info = cur.fetchall()\n    cols = [(i[1], i[2]) for i in info]\n    return cols", "code_tokens": "def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( \"PRAGMA table_info('%s');\" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols", "docstring_tokens": "Return a list of tuples specifying the column name and type", "label": 1}, {"idx": "cosqa-train-16485", "doc": "loooping through a string with white spaces python", "code": "def strip_spaces(s):\n    \"\"\" Strip excess spaces from a string \"\"\"\n    return u\" \".join([c for c in s.split(u' ') if c])", "code_tokens": "def strip_spaces ( s ) : return u\" \" . join ( [ c for c in s . split ( u' ' ) if c ] )", "docstring_tokens": "Strip excess spaces from a string", "label": 0}, {"idx": "cosqa-train-16486", "doc": "pythonic way to check if a string is empty", "code": "def is_non_empty_string(input_string):\n    \"\"\"\n    Validate if non empty string\n\n    :param input_string: Input is a *str*.\n    :return: True if input is string and non empty.\n       Raise :exc:`Exception` otherwise.\n    \"\"\"\n    try:\n        if not input_string.strip():\n            raise ValueError()\n    except AttributeError as error:\n        raise TypeError(error)\n\n    return True", "code_tokens": "def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True", "docstring_tokens": "Validate if non empty string", "label": 1}, {"idx": "cosqa-train-16487", "doc": "loop through queryset python", "code": "def _unordered_iterator(self):\n        \"\"\"\n        Return the value of each QuerySet, but also add the '#' property to each\n        return item.\n        \"\"\"\n        for i, qs in zip(self._queryset_idxs, self._querysets):\n            for item in qs:\n                setattr(item, '#', i)\n                yield item", "code_tokens": "def _unordered_iterator ( self ) : for i , qs in zip ( self . _queryset_idxs , self . _querysets ) : for item in qs : setattr ( item , '#' , i ) yield item", "docstring_tokens": "Return the value of each QuerySet but also add the # property to each return item .", "label": 0}, {"idx": "cosqa-train-16488", "doc": "qbytearray to python str", "code": "def handle_qbytearray(obj, encoding):\n    \"\"\"Qt/Python2/3 compatibility helper.\"\"\"\n    if isinstance(obj, QByteArray):\n        obj = obj.data()\n\n    return to_text_string(obj, encoding=encoding)", "code_tokens": "def handle_qbytearray ( obj , encoding ) : if isinstance ( obj , QByteArray ) : obj = obj . data ( ) return to_text_string ( obj , encoding = encoding )", "docstring_tokens": "Qt / Python2 / 3 compatibility helper .", "label": 0}, {"idx": "cosqa-train-16489", "doc": "loops through the last n elements python", "code": "def searchlast(self,n=10):\n        \"\"\"Return the last n results (or possibly less if not found). Note that the last results are not necessarily the best ones! Depending on the search type.\"\"\"            \n        solutions = deque([], n)\n        for solution in self:\n            solutions.append(solution)\n        return solutions", "code_tokens": "def searchlast ( self , n = 10 ) : solutions = deque ( [ ] , n ) for solution in self : solutions . append ( solution ) return solutions", "docstring_tokens": "Return the last n results ( or possibly less if not found ) . Note that the last results are not necessarily the best ones! Depending on the search type .", "label": 0}, {"idx": "cosqa-train-16490", "doc": "query server objects ldap in python", "code": "def search(self, filterstr, attrlist):\n        \"\"\"Query the configured LDAP server.\"\"\"\n        return self._paged_search_ext_s(self.settings.BASE, ldap.SCOPE_SUBTREE, filterstr=filterstr,\n                                        attrlist=attrlist, page_size=self.settings.PAGE_SIZE)", "code_tokens": "def search ( self , filterstr , attrlist ) : return self . _paged_search_ext_s ( self . settings . BASE , ldap . SCOPE_SUBTREE , filterstr = filterstr , attrlist = attrlist , page_size = self . settings . PAGE_SIZE )", "docstring_tokens": "Query the configured LDAP server .", "label": 1}, {"idx": "cosqa-train-16491", "doc": "mac python clean clipboard", "code": "def osx_clipboard_get():\n    \"\"\" Get the clipboard's text on OS X.\n    \"\"\"\n    p = subprocess.Popen(['pbpaste', '-Prefer', 'ascii'],\n        stdout=subprocess.PIPE)\n    text, stderr = p.communicate()\n    # Text comes in with old Mac \\r line endings. Change them to \\n.\n    text = text.replace('\\r', '\\n')\n    return text", "code_tokens": "def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \\r line endings. Change them to \\n. text = text . replace ( '\\r' , '\\n' ) return text", "docstring_tokens": "Get the clipboard s text on OS X .", "label": 0}, {"idx": "cosqa-train-16492", "doc": "querystring to url python", "code": "def urlencoded(body, charset='ascii', **kwargs):\n    \"\"\"Converts query strings into native Python objects\"\"\"\n    return parse_query_string(text(body, charset=charset), False)", "code_tokens": "def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )", "docstring_tokens": "Converts query strings into native Python objects", "label": 1}, {"idx": "cosqa-train-16493", "doc": "magnitude of matrix exponential python", "code": "def magnitude(X):\n    \"\"\"Magnitude of a complex matrix.\"\"\"\n    r = np.real(X)\n    i = np.imag(X)\n    return np.sqrt(r * r + i * i);", "code_tokens": "def magnitude ( X ) : r = np . real ( X ) i = np . imag ( X ) return np . sqrt ( r * r + i * i )", "docstring_tokens": "Magnitude of a complex matrix .", "label": 0}, {"idx": "cosqa-train-16494", "doc": "quick way to make a python array with sequence without forloop", "code": "def pack_triples_numpy(triples):\n    \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"\n    if len(triples) == 0:\n        return np.array([], dtype=np.int64)\n    return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "code_tokens": "def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "docstring_tokens": "Packs a list of triple indexes into a 2D numpy array .", "label": 0}, {"idx": "cosqa-train-16495", "doc": "maintaining an aspect ration in gridspec python", "code": "def image_set_aspect(aspect=1.0, axes=\"gca\"):\n    \"\"\"\n    sets the aspect ratio of the current zoom level of the imshow image\n    \"\"\"\n    if axes is \"gca\": axes = _pylab.gca()\n\n    e = axes.get_images()[0].get_extent()\n    axes.set_aspect(abs((e[1]-e[0])/(e[3]-e[2]))/aspect)", "code_tokens": "def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "docstring_tokens": "sets the aspect ratio of the current zoom level of the imshow image", "label": 0}, {"idx": "cosqa-train-16496", "doc": "random int except a number python", "code": "def positive_integer(anon, obj, field, val):\n    \"\"\"\n    Returns a random positive integer (for a Django PositiveIntegerField)\n    \"\"\"\n    return anon.faker.positive_integer(field=field)", "code_tokens": "def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )", "docstring_tokens": "Returns a random positive integer ( for a Django PositiveIntegerField )", "label": 1}, {"idx": "cosqa-train-16497", "doc": "make a dict a string python", "code": "def str_dict(some_dict):\n    \"\"\"Convert dict of ascii str/unicode to dict of str, if necessary\"\"\"\n    return {str(k): str(v) for k, v in some_dict.items()}", "code_tokens": "def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "docstring_tokens": "Convert dict of ascii str / unicode to dict of str if necessary", "label": 0}, {"idx": "cosqa-train-16498", "doc": "random number of a given range python", "code": "def runiform(lower, upper, size=None):\n    \"\"\"\n    Random uniform variates.\n    \"\"\"\n    return np.random.uniform(lower, upper, size)", "code_tokens": "def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )", "docstring_tokens": "Random uniform variates .", "label": 0}, {"idx": "cosqa-train-16499", "doc": "make a dictionary a string in python", "code": "def stringify_dict_contents(dct):\n    \"\"\"Turn dict keys and values into native strings.\"\"\"\n    return {\n        str_if_nested_or_str(k): str_if_nested_or_str(v)\n        for k, v in dct.items()\n    }", "code_tokens": "def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }", "docstring_tokens": "Turn dict keys and values into native strings .", "label": 0}, {"idx": "cosqa-train-16500", "doc": "range object is not callable python filter", "code": "def range(self, chromosome, start, stop, exact=False):\n        \"\"\"\n        Shortcut to do range filters on genomic datasets.\n        \"\"\"\n        return self._clone(\n            filters=[GenomicFilter(chromosome, start, stop, exact)])", "code_tokens": "def range ( self , chromosome , start , stop , exact = False ) : return self . _clone ( filters = [ GenomicFilter ( chromosome , start , stop , exact ) ] )", "docstring_tokens": "Shortcut to do range filters on genomic datasets .", "label": 0}, {"idx": "cosqa-train-16501", "doc": "make a value of var infinity in python", "code": "def get_neg_infinity(dtype):\n    \"\"\"Return an appropriate positive infinity for this dtype.\n\n    Parameters\n    ----------\n    dtype : np.dtype\n\n    Returns\n    -------\n    fill_value : positive infinity value corresponding to this dtype.\n    \"\"\"\n    if issubclass(dtype.type, (np.floating, np.integer)):\n        return -np.inf\n\n    if issubclass(dtype.type, np.complexfloating):\n        return -np.inf - 1j * np.inf\n\n    return NINF", "code_tokens": "def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "docstring_tokens": "Return an appropriate positive infinity for this dtype .", "label": 0}, {"idx": "cosqa-train-16502", "doc": "read a json file and load python", "code": "def open_json(file_name):\n    \"\"\"\n    returns json contents as string\n    \"\"\"\n    with open(file_name, \"r\") as json_data:\n        data = json.load(json_data)\n        return data", "code_tokens": "def open_json ( file_name ) : with open ( file_name , \"r\" ) as json_data : data = json . load ( json_data ) return data", "docstring_tokens": "returns json contents as string", "label": 0}, {"idx": "cosqa-train-16503", "doc": "make boolean string in python", "code": "def strToBool(val):\n    \"\"\"\n    Helper function to turn a string representation of \"true\" into\n    boolean True.\n    \"\"\"\n    if isinstance(val, str):\n        val = val.lower()\n\n    return val in ['true', 'on', 'yes', True]", "code_tokens": "def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "docstring_tokens": "Helper function to turn a string representation of true into boolean True .", "label": 1}, {"idx": "cosqa-train-16504", "doc": "read binary data byte array python", "code": "def be_array_from_bytes(fmt, data):\n    \"\"\"\n    Reads an array from bytestring with big-endian data.\n    \"\"\"\n    arr = array.array(str(fmt), data)\n    return fix_byteorder(arr)", "code_tokens": "def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )", "docstring_tokens": "Reads an array from bytestring with big - endian data .", "label": 1}, {"idx": "cosqa-train-16505", "doc": "make date vairable from string python", "code": "def parse_date(s):\n    \"\"\"Fast %Y-%m-%d parsing.\"\"\"\n    try:\n        return datetime.date(int(s[:4]), int(s[5:7]), int(s[8:10]))\n    except ValueError:  # other accepted format used in one-day data set\n        return datetime.datetime.strptime(s, '%d %B %Y').date()", "code_tokens": "def parse_date ( s ) : try : return datetime . date ( int ( s [ : 4 ] ) , int ( s [ 5 : 7 ] ) , int ( s [ 8 : 10 ] ) ) except ValueError : # other accepted format used in one-day data set return datetime . datetime . strptime ( s , '%d %B %Y' ) . date ( )", "docstring_tokens": "Fast %Y - %m - %d parsing .", "label": 0}, {"idx": "cosqa-train-16506", "doc": "read file into python with numpy", "code": "def read_numpy(fd, byte_order, dtype, count):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    return numpy.fromfile(fd, byte_order+dtype[-1], count)", "code_tokens": "def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 1}, {"idx": "cosqa-train-16507", "doc": "make image clear with python", "code": "def _clear(self):\n        \"\"\"\n        Helper that clears the composition.\n        \"\"\"\n        draw = ImageDraw.Draw(self._background_image)\n        draw.rectangle(self._device.bounding_box,\n                       fill=\"black\")\n        del draw", "code_tokens": "def _clear ( self ) : draw = ImageDraw . Draw ( self . _background_image ) draw . rectangle ( self . _device . bounding_box , fill = \"black\" ) del draw", "docstring_tokens": "Helper that clears the composition .", "label": 0}, {"idx": "cosqa-train-16508", "doc": "read private key rsa python", "code": "def import_public_rsa_key_from_file(filename):\n    \"\"\"\n    Read a public RSA key from a PEM file.\n\n    :param filename: The name of the file\n    :param passphrase: A pass phrase to use to unpack the PEM file.\n    :return: A\n        cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey instance\n    \"\"\"\n    with open(filename, \"rb\") as key_file:\n        public_key = serialization.load_pem_public_key(\n            key_file.read(),\n            backend=default_backend())\n    return public_key", "code_tokens": "def import_public_rsa_key_from_file ( filename ) : with open ( filename , \"rb\" ) as key_file : public_key = serialization . load_pem_public_key ( key_file . read ( ) , backend = default_backend ( ) ) return public_key", "docstring_tokens": "Read a public RSA key from a PEM file .", "label": 0}, {"idx": "cosqa-train-16509", "doc": "make mouse move in python", "code": "def mouse_move_event(self, event):\n        \"\"\"\n        Forward mouse cursor position events to the example\n        \"\"\"\n        self.example.mouse_position_event(event.x(), event.y())", "code_tokens": "def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )", "docstring_tokens": "Forward mouse cursor position events to the example", "label": 1}, {"idx": "cosqa-train-16510", "doc": "read s3 object python", "code": "def get_as_bytes(self, s3_path):\n        \"\"\"\n        Get the contents of an object stored in S3 as bytes\n\n        :param s3_path: URL for target S3 location\n        :return: File contents as pure bytes\n        \"\"\"\n        (bucket, key) = self._path_to_bucket_and_key(s3_path)\n        obj = self.s3.Object(bucket, key)\n        contents = obj.get()['Body'].read()\n        return contents", "code_tokens": "def get_as_bytes ( self , s3_path ) : ( bucket , key ) = self . _path_to_bucket_and_key ( s3_path ) obj = self . s3 . Object ( bucket , key ) contents = obj . get ( ) [ 'Body' ] . read ( ) return contents", "docstring_tokens": "Get the contents of an object stored in S3 as bytes", "label": 0}, {"idx": "cosqa-train-16511", "doc": "make python read csv and represent as matrix", "code": "def load_data(filename):\n    \"\"\"\n    :rtype : numpy matrix\n    \"\"\"\n    data = pandas.read_csv(filename, header=None, delimiter='\\t', skiprows=9)\n    return data.as_matrix()", "code_tokens": "def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\\t' , skiprows = 9 ) return data . as_matrix ( )", "docstring_tokens": ": rtype : numpy matrix", "label": 0}, {"idx": "cosqa-train-16512", "doc": "read until end of file bytes python", "code": "def _readuntil(f, end=_TYPE_END):\n\t\"\"\"Helper function to read bytes until a certain end byte is hit\"\"\"\n\tbuf = bytearray()\n\tbyte = f.read(1)\n\twhile byte != end:\n\t\tif byte == b'':\n\t\t\traise ValueError('File ended unexpectedly. Expected end byte {}.'.format(end))\n\t\tbuf += byte\n\t\tbyte = f.read(1)\n\treturn buf", "code_tokens": "def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf", "docstring_tokens": "Helper function to read bytes until a certain end byte is hit", "label": 1}, {"idx": "cosqa-train-16513", "doc": "make python secret key urandom", "code": "def hash_producer(*args, **kwargs):\n    \"\"\" Returns a random hash for a confirmation secret. \"\"\"\n    return hashlib.md5(six.text_type(uuid.uuid4()).encode('utf-8')).hexdigest()", "code_tokens": "def hash_producer ( * args , * * kwargs ) : return hashlib . md5 ( six . text_type ( uuid . uuid4 ( ) ) . encode ( 'utf-8' ) ) . hexdigest ( )", "docstring_tokens": "Returns a random hash for a confirmation secret .", "label": 0}, {"idx": "cosqa-train-16514", "doc": "read yaml file in python", "code": "def load_yaml(filepath):\n    \"\"\"Convenience function for loading yaml-encoded data from disk.\"\"\"\n    with open(filepath) as f:\n        txt = f.read()\n    return yaml.load(txt)", "code_tokens": "def load_yaml ( filepath ) : with open ( filepath ) as f : txt = f . read ( ) return yaml . load ( txt )", "docstring_tokens": "Convenience function for loading yaml - encoded data from disk .", "label": 1}, {"idx": "cosqa-train-16515", "doc": "make the first letter lower case python", "code": "def to_camel(s):\n    \"\"\"\n    :param string s: under_scored string to be CamelCased\n    :return: CamelCase version of input\n    :rtype: str\n    \"\"\"\n    # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups\n    return re.sub(r'_([a-zA-Z])', lambda m: m.group(1).upper(), '_' + s)", "code_tokens": "def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "docstring_tokens": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str", "label": 0}, {"idx": "cosqa-train-16516", "doc": "reading a text file into a dictionary python", "code": "def read_dict_from_file(file_path):\n    \"\"\"\n    Read a dictionary of strings from a file\n    \"\"\"\n    with open(file_path) as file:\n        lines = file.read().splitlines()\n\n    obj = {}\n    for line in lines:\n        key, value = line.split(':', maxsplit=1)\n        obj[key] = eval(value)\n\n    return obj", "code_tokens": "def read_dict_from_file ( file_path ) : with open ( file_path ) as file : lines = file . read ( ) . splitlines ( ) obj = { } for line in lines : key , value = line . split ( ':' , maxsplit = 1 ) obj [ key ] = eval ( value ) return obj", "docstring_tokens": "Read a dictionary of strings from a file", "label": 1}, {"idx": "cosqa-train-16517", "doc": "make translucent color python", "code": "def get_translucent_cmap(r, g, b):\n\n    class TranslucentCmap(BaseColormap):\n        glsl_map = \"\"\"\n        vec4 translucent_fire(float t) {{\n            return vec4({0}, {1}, {2}, t);\n        }}\n        \"\"\".format(r, g, b)\n\n    return TranslucentCmap()", "code_tokens": "def get_translucent_cmap ( r , g , b ) : class TranslucentCmap ( BaseColormap ) : glsl_map = \"\"\"\n        vec4 translucent_fire(float t) {{\n            return vec4({0}, {1}, {2}, t);\n        }}\n        \"\"\" . format ( r , g , b ) return TranslucentCmap ( )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-16518", "doc": "reading json from url in python", "code": "def get_jsonparsed_data(url):\n    \"\"\"Receive the content of ``url``, parse it as JSON and return the\n       object.\n    \"\"\"\n    response = urlopen(url)\n    data = response.read().decode('utf-8')\n    return json.loads(data)", "code_tokens": "def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "docstring_tokens": "Receive the content of url parse it as JSON and return the object .", "label": 0}, {"idx": "cosqa-train-16519", "doc": "makeing a frequency list python", "code": "def reduce_freqs(freqlist):\n    \"\"\"\n    Add up a list of freq counts to get the total counts.\n    \"\"\"\n    allfreqs = np.zeros_like(freqlist[0])\n    for f in freqlist:\n        allfreqs += f\n    return allfreqs", "code_tokens": "def reduce_freqs ( freqlist ) : allfreqs = np . zeros_like ( freqlist [ 0 ] ) for f in freqlist : allfreqs += f return allfreqs", "docstring_tokens": "Add up a list of freq counts to get the total counts .", "label": 0}, {"idx": "cosqa-train-16520", "doc": "redis set key python dict", "code": "def __setitem__(self, field, value):\n        \"\"\" :see::meth:RedisMap.__setitem__ \"\"\"\n        return self._client.hset(self.key_prefix, field, self._dumps(value))", "code_tokens": "def __setitem__ ( self , field , value ) : return self . _client . hset ( self . key_prefix , field , self . _dumps ( value ) )", "docstring_tokens": ": see :: meth : RedisMap . __setitem__", "label": 0}, {"idx": "cosqa-train-16521", "doc": "maker a string lowercase pythong", "code": "def to_snake_case(text):\n    \"\"\"Convert to snake case.\n\n    :param str text:\n    :rtype: str\n    :return:\n    \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert to snake case .", "label": 1}, {"idx": "cosqa-train-16522", "doc": "referring to a key in python", "code": "def get_from_human_key(self, key):\n        \"\"\"Return the key (aka database value) of a human key (aka Python identifier).\"\"\"\n        if key in self._identifier_map:\n            return self._identifier_map[key]\n        raise KeyError(key)", "code_tokens": "def get_from_human_key ( self , key ) : if key in self . _identifier_map : return self . _identifier_map [ key ] raise KeyError ( key )", "docstring_tokens": "Return the key ( aka database value ) of a human key ( aka Python identifier ) .", "label": 1}, {"idx": "cosqa-train-16523", "doc": "making an alias list in python", "code": "def retrieve_import_alias_mapping(names_list):\n    \"\"\"Creates a dictionary mapping aliases to their respective name.\n    import_alias_names is used in module_definitions.py and visit_Call\"\"\"\n    import_alias_names = dict()\n\n    for alias in names_list:\n        if alias.asname:\n            import_alias_names[alias.asname] = alias.name\n    return import_alias_names", "code_tokens": "def retrieve_import_alias_mapping ( names_list ) : import_alias_names = dict ( ) for alias in names_list : if alias . asname : import_alias_names [ alias . asname ] = alias . name return import_alias_names", "docstring_tokens": "Creates a dictionary mapping aliases to their respective name . import_alias_names is used in module_definitions . py and visit_Call", "label": 1}, {"idx": "cosqa-train-16524", "doc": "registration time stored in python", "code": "def get_unixtime_registered(self):\n        \"\"\"Returns the user's registration date as a UNIX timestamp.\"\"\"\n\n        doc = self._request(self.ws_prefix + \".getInfo\", True)\n\n        return int(doc.getElementsByTagName(\"registered\")[0].getAttribute(\"unixtime\"))", "code_tokens": "def get_unixtime_registered ( self ) : doc = self . _request ( self . ws_prefix + \".getInfo\" , True ) return int ( doc . getElementsByTagName ( \"registered\" ) [ 0 ] . getAttribute ( \"unixtime\" ) )", "docstring_tokens": "Returns the user s registration date as a UNIX timestamp .", "label": 0}, {"idx": "cosqa-train-16525", "doc": "max heap with double link list python", "code": "def heappush_max(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown_max(heap, 0, len(heap) - 1)", "code_tokens": "def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "docstring_tokens": "Push item onto heap maintaining the heap invariant .", "label": 0}, {"idx": "cosqa-train-16526", "doc": "regula expression for specific string in comma separated strings python", "code": "def split_comma_argument(comma_sep_str):\n    \"\"\"Split a comma separated option into a list.\"\"\"\n    terms = []\n    for term in comma_sep_str.split(','):\n        if term:\n            terms.append(term)\n    return terms", "code_tokens": "def split_comma_argument ( comma_sep_str ) : terms = [ ] for term in comma_sep_str . split ( ',' ) : if term : terms . append ( term ) return terms", "docstring_tokens": "Split a comma separated option into a list .", "label": 1}, {"idx": "cosqa-train-16527", "doc": "maximum number of characters per line in python", "code": "def _multiline_width(multiline_s, line_width_fn=len):\n    \"\"\"Visible width of a potentially multiline content.\"\"\"\n    return max(map(line_width_fn, re.split(\"[\\r\\n]\", multiline_s)))", "code_tokens": "def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "docstring_tokens": "Visible width of a potentially multiline content .", "label": 0}, {"idx": "cosqa-train-16528", "doc": "relative path to config file in python", "code": "def input_dir(self):\n        \"\"\"\n        :returns: absolute path to where the job.ini is\n        \"\"\"\n        return os.path.abspath(os.path.dirname(self.inputs['job_ini']))", "code_tokens": "def input_dir ( self ) : return os . path . abspath ( os . path . dirname ( self . inputs [ 'job_ini' ] ) )", "docstring_tokens": ": returns : absolute path to where the job . ini is", "label": 0}, {"idx": "cosqa-train-16529", "doc": "maya python create shader", "code": "def shader_string(body, glsl_version='450 core'):\n    \"\"\"\n    Call this method from a function that defines a literal shader string as the \"body\" argument.\n    Dresses up a shader string in three ways:\n        1) Insert #version at the top\n        2) Insert #line number declaration\n        3) un-indents\n    The line number information can help debug glsl compile errors.\n    The version string needs to be the very first characters in the shader,\n    which can be distracting, requiring backslashes or other tricks.\n    The unindenting allows you to type the shader code at a pleasing indent level\n    in your python method, while still creating an unindented GLSL string at the end.\n    \"\"\"\n    line_count = len(body.split('\\n'))\n    line_number = inspect.currentframe().f_back.f_lineno + 1 - line_count\n    return \"\"\"\\\n#version %s\n%s\n\"\"\" % (glsl_version, shader_substring(body, stack_frame=2))", "code_tokens": "def shader_string ( body , glsl_version = '450 core' ) : line_count = len ( body . split ( '\\n' ) ) line_number = inspect . currentframe ( ) . f_back . f_lineno + 1 - line_count return \"\"\"\\\n#version %s\n%s\n\"\"\" % ( glsl_version , shader_substring ( body , stack_frame = 2 ) )", "docstring_tokens": "Call this method from a function that defines a literal shader string as the body argument . Dresses up a shader string in three ways : 1 ) Insert #version at the top 2 ) Insert #line number declaration 3 ) un - indents The line number information can help debug glsl compile errors . The version string needs to be the very first characters in the shader which can be distracting requiring backslashes or other tricks . The unindenting allows you to type the shader code at a pleasing indent level in your python method while still creating an unindented GLSL string at the end .", "label": 1}, {"idx": "cosqa-train-16530", "doc": "relu activation function python", "code": "def softplus(attrs, inputs, proto_obj):\n    \"\"\"Applies the sofplus activation function element-wise to the input.\"\"\"\n    new_attrs = translation_utils._add_extra_attributes(attrs, {'act_type' : 'softrelu'})\n    return 'Activation', new_attrs, inputs", "code_tokens": "def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs", "docstring_tokens": "Applies the sofplus activation function element - wise to the input .", "label": 1}, {"idx": "cosqa-train-16531", "doc": "md5 value of a file python", "code": "def get_file_md5sum(path):\n    \"\"\"Calculate the MD5 hash for a file.\"\"\"\n    with open(path, 'rb') as fh:\n        h = str(hashlib.md5(fh.read()).hexdigest())\n    return h", "code_tokens": "def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h", "docstring_tokens": "Calculate the MD5 hash for a file .", "label": 1}, {"idx": "cosqa-train-16532", "doc": "remotely access file in python", "code": "def get_remote_content(filepath):\n        \"\"\" A handy wrapper to get a remote file content \"\"\"\n        with hide('running'):\n            temp = BytesIO()\n            get(filepath, temp)\n            content = temp.getvalue().decode('utf-8')\n        return content.strip()", "code_tokens": "def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )", "docstring_tokens": "A handy wrapper to get a remote file content", "label": 0}, {"idx": "cosqa-train-16533", "doc": "measure length of object in python", "code": "def __len__(self):\n        \"\"\" This will equal 124 for the V1 database. \"\"\"\n        length = 0\n        for typ, siz, _ in self.format:\n            length += siz\n        return length", "code_tokens": "def __len__ ( self ) : length = 0 for typ , siz , _ in self . format : length += siz return length", "docstring_tokens": "This will equal 124 for the V1 database .", "label": 0}, {"idx": "cosqa-train-16534", "doc": "remove all blanks from list python", "code": "def remove_bad(string):\n    \"\"\"\n    remove problem characters from string\n    \"\"\"\n    remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']\n    for c in remove:\n        string = string.replace(c, '_')\n    return string", "code_tokens": "def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\\'' ] for c in remove : string = string . replace ( c , '_' ) return string", "docstring_tokens": "remove problem characters from string", "label": 0}, {"idx": "cosqa-train-16535", "doc": "memory size of an array python", "code": "def array_bytes(array):\n    \"\"\" Estimates the memory of the supplied array in bytes \"\"\"\n    return np.product(array.shape)*np.dtype(array.dtype).itemsize", "code_tokens": "def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize", "docstring_tokens": "Estimates the memory of the supplied array in bytes", "label": 1}, {"idx": "cosqa-train-16536", "doc": "remove all empty elements from list python", "code": "def unique(seq):\n    \"\"\"Return the unique elements of a collection even if those elements are\n       unhashable and unsortable, like dicts and sets\"\"\"\n    cleaned = []\n    for each in seq:\n        if each not in cleaned:\n            cleaned.append(each)\n    return cleaned", "code_tokens": "def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned", "docstring_tokens": "Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets", "label": 0}, {"idx": "cosqa-train-16537", "doc": "merge data frames with 2 columns and inner join in python", "code": "def cross_join(df1, df2):\n    \"\"\"\n    Return a dataframe that is a cross between dataframes\n    df1 and df2\n\n    ref: https://github.com/pydata/pandas/issues/5401\n    \"\"\"\n    if len(df1) == 0:\n        return df2\n\n    if len(df2) == 0:\n        return df1\n\n    # Add as lists so that the new index keeps the items in\n    # the order that they are added together\n    all_columns = pd.Index(list(df1.columns) + list(df2.columns))\n    df1['key'] = 1\n    df2['key'] = 1\n    return pd.merge(df1, df2, on='key').loc[:, all_columns]", "code_tokens": "def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "docstring_tokens": "Return a dataframe that is a cross between dataframes df1 and df2", "label": 0}, {"idx": "cosqa-train-16538", "doc": "remove all non alphabet characters python", "code": "def strip_accents(string):\n    \"\"\"\n    Strip all the accents from the string\n    \"\"\"\n    return u''.join(\n        (character for character in unicodedata.normalize('NFD', string)\n         if unicodedata.category(character) != 'Mn'))", "code_tokens": "def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "docstring_tokens": "Strip all the accents from the string", "label": 0}, {"idx": "cosqa-train-16539", "doc": "mimetext is not defined python examples", "code": "def IsBinary(self, filename):\n\t\t\"\"\"Returns true if the guessed mimetyped isnt't in text group.\"\"\"\n\t\tmimetype = mimetypes.guess_type(filename)[0]\n\t\tif not mimetype:\n\t\t\treturn False  # e.g. README, \"real\" binaries usually have an extension\n\t\t# special case for text files which don't start with text/\n\t\tif mimetype in TEXT_MIMETYPES:\n\t\t\treturn False\n\t\treturn not mimetype.startswith(\"text/\")", "code_tokens": "def IsBinary ( self , filename ) : mimetype = mimetypes . guess_type ( filename ) [ 0 ] if not mimetype : return False # e.g. README, \"real\" binaries usually have an extension # special case for text files which don't start with text/ if mimetype in TEXT_MIMETYPES : return False return not mimetype . startswith ( \"text/\" )", "docstring_tokens": "Returns true if the guessed mimetyped isnt t in text group .", "label": 1}, {"idx": "cosqa-train-16540", "doc": "remove all punctuations from text python", "code": "def remove_punctuation(text, exceptions=[]):\n    \"\"\"\n    Return a string with punctuation removed.\n\n    Parameters:\n        text (str): The text to remove punctuation from.\n        exceptions (list): List of symbols to keep in the given text.\n\n    Return:\n        str: The input text without the punctuation.\n    \"\"\"\n\n    all_but = [\n        r'\\w',\n        r'\\s'\n    ]\n\n    all_but.extend(exceptions)\n\n    pattern = '[^{}]'.format(''.join(all_but))\n\n    return re.sub(pattern, '', text)", "code_tokens": "def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\\w' , r'\\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )", "docstring_tokens": "Return a string with punctuation removed .", "label": 1}, {"idx": "cosqa-train-16541", "doc": "min function on an array python", "code": "def SegmentMin(a, ids):\n    \"\"\"\n    Segmented min op.\n    \"\"\"\n    func = lambda idxs: np.amin(a[idxs], axis=0)\n    return seg_map(func, a, ids),", "code_tokens": "def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "docstring_tokens": "Segmented min op .", "label": 0}, {"idx": "cosqa-train-16542", "doc": "remove blanks from the list python", "code": "def remove_bad(string):\n    \"\"\"\n    remove problem characters from string\n    \"\"\"\n    remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']\n    for c in remove:\n        string = string.replace(c, '_')\n    return string", "code_tokens": "def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\\'' ] for c in remove : string = string . replace ( c , '_' ) return string", "docstring_tokens": "remove problem characters from string", "label": 0}, {"idx": "cosqa-train-16543", "doc": "modifying values of a dictionary python", "code": "def copy_and_update(dictionary, update):\n    \"\"\"Returns an updated copy of the dictionary without modifying the original\"\"\"\n    newdict = dictionary.copy()\n    newdict.update(update)\n    return newdict", "code_tokens": "def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict", "docstring_tokens": "Returns an updated copy of the dictionary without modifying the original", "label": 0}, {"idx": "cosqa-train-16544", "doc": "remove comma in a string python", "code": "def slugify(string):\n    \"\"\"\n    Removes non-alpha characters, and converts spaces to hyphens. Useful for making file names.\n\n\n    Source: http://stackoverflow.com/questions/5574042/string-slugification-in-python\n    \"\"\"\n    string = re.sub('[^\\w .-]', '', string)\n    string = string.replace(\" \", \"-\")\n    return string", "code_tokens": "def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "docstring_tokens": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python", "label": 0}, {"idx": "cosqa-train-16545", "doc": "remove commas seperating characters in list python", "code": "def strip_spaces(value, sep=None, join=True):\n    \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"\n    value = value.strip()\n    value = [v.strip() for v in value.split(sep)]\n    join_sep = sep or ' '\n    return join_sep.join(value) if join else value", "code_tokens": "def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value", "docstring_tokens": "Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .", "label": 0}, {"idx": "cosqa-train-16546", "doc": "most common element in a list python", "code": "def mostCommonItem(lst):\n    \"\"\"Choose the most common item from the list, or the first item if all\n    items are unique.\"\"\"\n    # This elegant solution from: http://stackoverflow.com/a/1518632/1760218\n    lst = [l for l in lst if l]\n    if lst:\n        return max(set(lst), key=lst.count)\n    else:\n        return None", "code_tokens": "def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "docstring_tokens": "Choose the most common item from the list or the first item if all items are unique .", "label": 0}, {"idx": "cosqa-train-16547", "doc": "remove commas string python list", "code": "def __normalize_list(self, msg):\n        \"\"\"Split message to list by commas and trim whitespace.\"\"\"\n        if isinstance(msg, list):\n            msg = \"\".join(msg)\n        return list(map(lambda x: x.strip(), msg.split(\",\")))", "code_tokens": "def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = \"\" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( \",\" ) ) )", "docstring_tokens": "Split message to list by commas and trim whitespace .", "label": 0}, {"idx": "cosqa-train-16548", "doc": "most common element in list python", "code": "def mostCommonItem(lst):\n    \"\"\"Choose the most common item from the list, or the first item if all\n    items are unique.\"\"\"\n    # This elegant solution from: http://stackoverflow.com/a/1518632/1760218\n    lst = [l for l in lst if l]\n    if lst:\n        return max(set(lst), key=lst.count)\n    else:\n        return None", "code_tokens": "def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "docstring_tokens": "Choose the most common item from the list or the first item if all items are unique .", "label": 0}, {"idx": "cosqa-train-16549", "doc": "remove dtype nparray python", "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name):\n        \"\"\"\n        ``numpy.ndarray`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: self._json_convert(obj.tolist())}", "code_tokens": "def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "docstring_tokens": "numpy . ndarray dumper .", "label": 1}, {"idx": "cosqa-train-16550", "doc": "moving average array python", "code": "def moving_average(array, n=3):\n    \"\"\"\n    Calculates the moving average of an array.\n\n    Parameters\n    ----------\n    array : array\n        The array to have the moving average taken of\n    n : int\n        The number of points of moving average to take\n    \n    Returns\n    -------\n    MovingAverageArray : array\n        The n-point moving average of the input array\n    \"\"\"\n    ret = _np.cumsum(array, dtype=float)\n    ret[n:] = ret[n:] - ret[:-n]\n    return ret[n - 1:] / n", "code_tokens": "def moving_average ( array , n = 3 ) : ret = _np . cumsum ( array , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n", "docstring_tokens": "Calculates the moving average of an array .", "label": 1}, {"idx": "cosqa-train-16551", "doc": "remove duplicates without changing porder python", "code": "def remove_dups(seq):\n    \"\"\"remove duplicates from a sequence, preserving order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "remove duplicates from a sequence preserving order", "label": 1}, {"idx": "cosqa-train-16552", "doc": "multiline strings without newline python", "code": "def reduce_multiline(string):\n    \"\"\"\n    reduces a multiline string to a single line of text.\n\n\n    args:\n        string: the text to reduce\n    \"\"\"\n    string = str(string)\n    return \" \".join([item.strip()\n                     for item in string.split(\"\\n\")\n                     if item.strip()])", "code_tokens": "def reduce_multiline ( string ) : string = str ( string ) return \" \" . join ( [ item . strip ( ) for item in string . split ( \"\\n\" ) if item . strip ( ) ] )", "docstring_tokens": "reduces a multiline string to a single line of text .", "label": 0}, {"idx": "cosqa-train-16553", "doc": "remove element by id in python", "code": "def get_element_with_id(self, id):\n        \"\"\"Return the element with the specified ID.\"\"\"\n        # Should we maintain a hashmap of ids to make this more efficient? Probably overkill.\n        # TODO: Elements can contain nested elements (captions, footnotes, table cells, etc.)\n        return next((el for el in self.elements if el.id == id), None)", "code_tokens": "def get_element_with_id ( self , id ) : # Should we maintain a hashmap of ids to make this more efficient? Probably overkill. # TODO: Elements can contain nested elements (captions, footnotes, table cells, etc.) return next ( ( el for el in self . elements if el . id == id ) , None )", "docstring_tokens": "Return the element with the specified ID .", "label": 0}, {"idx": "cosqa-train-16554", "doc": "remove element from series python", "code": "def remove_series(self, series):\n        \"\"\"Removes a :py:class:`.Series` from the chart.\n\n        :param Series series: The :py:class:`.Series` to remove.\n        :raises ValueError: if you try to remove the last\\\n        :py:class:`.Series`.\"\"\"\n\n        if len(self.all_series()) == 1:\n            raise ValueError(\"Cannot remove last series from %s\" % str(self))\n        self._all_series.remove(series)\n        series._chart = None", "code_tokens": "def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "docstring_tokens": "Removes a : py : class : . Series from the chart .", "label": 0}, {"idx": "cosqa-train-16555", "doc": "multiply each element of a matrix python", "code": "def matrixTimesVector(MM, aa):\n    \"\"\"\n\n    :param MM: A matrix of size 3x3\n    :param aa: A vector of size 3\n    :return: A vector of size 3 which is the product of the matrix by the vector\n    \"\"\"\n    bb = np.zeros(3, np.float)\n    for ii in range(3):\n        bb[ii] = np.sum(MM[ii, :] * aa)\n    return bb", "code_tokens": "def matrixTimesVector ( MM , aa ) : bb = np . zeros ( 3 , np . float ) for ii in range ( 3 ) : bb [ ii ] = np . sum ( MM [ ii , : ] * aa ) return bb", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-16556", "doc": "remove empty element in list python", "code": "def unique(_list):\n    \"\"\"\n    Makes the list have unique items only and maintains the order\n\n    list(set()) won't provide that\n\n    :type _list list\n    :rtype: list\n    \"\"\"\n    ret = []\n\n    for item in _list:\n        if item not in ret:\n            ret.append(item)\n\n    return ret", "code_tokens": "def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret", "docstring_tokens": "Makes the list have unique items only and maintains the order", "label": 1}, {"idx": "cosqa-train-16557", "doc": "multiply in python using built in function", "code": "def multiply(self, number):\n        \"\"\"Return a Vector as the product of the vector and a real number.\"\"\"\n        return self.from_list([x * number for x in self.to_list()])", "code_tokens": "def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )", "docstring_tokens": "Return a Vector as the product of the vector and a real number .", "label": 0}, {"idx": "cosqa-train-16558", "doc": "remove files in directory python", "code": "def clean_py_files(path):\n    \"\"\"\n    Removes all .py files.\n\n    :param path: the path\n    :return: None\n    \"\"\"\n\n    for dirname, subdirlist, filelist in os.walk(path):\n\n        for f in filelist:\n            if f.endswith('py'):\n                os.remove(os.path.join(dirname, f))", "code_tokens": "def clean_py_files ( path ) : for dirname , subdirlist , filelist in os . walk ( path ) : for f in filelist : if f . endswith ( 'py' ) : os . remove ( os . path . join ( dirname , f ) )", "docstring_tokens": "Removes all . py files .", "label": 1}, {"idx": "cosqa-train-16559", "doc": "must be str not list python", "code": "def validate_string_list(lst):\n    \"\"\"Validate that the input is a list of strings.\n\n    Raises ValueError if not.\"\"\"\n    if not isinstance(lst, list):\n        raise ValueError('input %r must be a list' % lst)\n    for x in lst:\n        if not isinstance(x, basestring):\n            raise ValueError('element %r in list must be a string' % x)", "code_tokens": "def validate_string_list ( lst ) : if not isinstance ( lst , list ) : raise ValueError ( 'input %r must be a list' % lst ) for x in lst : if not isinstance ( x , basestring ) : raise ValueError ( 'element %r in list must be a string' % x )", "docstring_tokens": "Validate that the input is a list of strings .", "label": 0}, {"idx": "cosqa-train-16560", "doc": "remove letters from string python for loop", "code": "def strip_accents(text):\n    \"\"\"\n    Strip agents from a string.\n    \"\"\"\n\n    normalized_str = unicodedata.normalize('NFD', text)\n\n    return ''.join([\n        c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "code_tokens": "def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "docstring_tokens": "Strip agents from a string .", "label": 0}, {"idx": "cosqa-train-16561", "doc": "mysql python how to close the connection", "code": "def close( self ):\n        \"\"\"\n        Close the db and release memory\n        \"\"\"\n        if self.db is not None:\n            self.db.commit()\n            self.db.close()\n            self.db = None\n\n        return", "code_tokens": "def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return", "docstring_tokens": "Close the db and release memory", "label": 1}, {"idx": "cosqa-train-16562", "doc": "remove multiple \\n from text python", "code": "def normalize_value(text):\n    \"\"\"\n    This removes newlines and multiple spaces from a string.\n    \"\"\"\n    result = text.replace('\\n', ' ')\n    result = re.subn('[ ]{2,}', ' ', result)[0]\n    return result", "code_tokens": "def normalize_value ( text ) : result = text . replace ( '\\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result", "docstring_tokens": "This removes newlines and multiple spaces from a string .", "label": 1}, {"idx": "cosqa-train-16563", "doc": "name a file from url python", "code": "def get_url_file_name(url):\n    \"\"\"Get the file name from an url\n    \n    Parameters\n    ----------\n    url : str\n\n    Returns\n    -------\n    str\n        The file name \n    \"\"\"\n\n    assert isinstance(url, (str, _oldstr))\n    return urlparse.urlparse(url).path.split('/')[-1]", "code_tokens": "def get_url_file_name ( url ) : assert isinstance ( url , ( str , _oldstr ) ) return urlparse . urlparse ( url ) . path . split ( '/' ) [ - 1 ]", "docstring_tokens": "Get the file name from an url Parameters ---------- url : str", "label": 0}, {"idx": "cosqa-train-16564", "doc": "remove not letters python", "code": "def strip_accents(s):\n    \"\"\"\n    Strip accents to prepare for slugification.\n    \"\"\"\n    nfkd = unicodedata.normalize('NFKD', unicode(s))\n    return u''.join(ch for ch in nfkd if not unicodedata.combining(ch))", "code_tokens": "def strip_accents ( s ) : nfkd = unicodedata . normalize ( 'NFKD' , unicode ( s ) ) return u'' . join ( ch for ch in nfkd if not unicodedata . combining ( ch ) )", "docstring_tokens": "Strip accents to prepare for slugification .", "label": 0}, {"idx": "cosqa-train-16565", "doc": "ndarray object definition python", "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name):\n        \"\"\"\n        ``numpy.ndarray`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: self._json_convert(obj.tolist())}", "code_tokens": "def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "docstring_tokens": "numpy . ndarray dumper .", "label": 0}, {"idx": "cosqa-train-16566", "doc": "remove row with empty cell python", "code": "def drop_empty(rows):\n    \"\"\"Transpose the columns into rows, remove all of the rows that are empty after the first cell, then\n    transpose back. The result is that columns that have a header but no data in the body are removed, assuming\n    the header is the first row. \"\"\"\n    return zip(*[col for col in zip(*rows) if bool(filter(bool, col[1:]))])", "code_tokens": "def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "docstring_tokens": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row .", "label": 0}, {"idx": "cosqa-train-16567", "doc": "nearest index value array python", "code": "def find_nearest_index(arr, value):\n    \"\"\"For a given value, the function finds the nearest value\n    in the array and returns its index.\"\"\"\n    arr = np.array(arr)\n    index = (abs(arr-value)).argmin()\n    return index", "code_tokens": "def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index", "docstring_tokens": "For a given value the function finds the nearest value in the array and returns its index .", "label": 0}, {"idx": "cosqa-train-16568", "doc": "remove something from a dictionary python", "code": "def rm_keys_from_dict(d, keys):\n    \"\"\"\n    Given a dictionary and a key list, remove any data in the dictionary with the given keys.\n\n    :param dict d: Metadata\n    :param list keys: Keys to be removed\n    :return dict d: Metadata\n    \"\"\"\n    # Loop for each key given\n    for key in keys:\n        # Is the key in the dictionary?\n        if key in d:\n            try:\n                d.pop(key, None)\n            except KeyError:\n                # Not concerned with an error. Keep going.\n                pass\n    return d", "code_tokens": "def rm_keys_from_dict ( d , keys ) : # Loop for each key given for key in keys : # Is the key in the dictionary? if key in d : try : d . pop ( key , None ) except KeyError : # Not concerned with an error. Keep going. pass return d", "docstring_tokens": "Given a dictionary and a key list remove any data in the dictionary with the given keys .", "label": 0}, {"idx": "cosqa-train-16569", "doc": "nearest integer numpy array python", "code": "def index_nearest(value, array):\n    \"\"\"\n    expects a _n.array\n    returns the global minimum of (value-array)^2\n    \"\"\"\n\n    a = (array-value)**2\n    return index(a.min(), a)", "code_tokens": "def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "docstring_tokens": "expects a _n . array returns the global minimum of ( value - array ) ^2", "label": 0}, {"idx": "cosqa-train-16570", "doc": "remove trailing whitespace in python", "code": "def clean(s):\n  \"\"\"Removes trailing whitespace on each line.\"\"\"\n  lines = [l.rstrip() for l in s.split('\\n')]\n  return '\\n'.join(lines)", "code_tokens": "def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\\n' ) ] return '\\n' . join ( lines )", "docstring_tokens": "Removes trailing whitespace on each line .", "label": 1}, {"idx": "cosqa-train-16571", "doc": "new fibonacci function in python", "code": "def software_fibonacci(n):\n    \"\"\" a normal old python function to return the Nth fibonacci number. \"\"\"\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a", "code_tokens": "def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a", "docstring_tokens": "a normal old python function to return the Nth fibonacci number .", "label": 1}, {"idx": "cosqa-train-16572", "doc": "remove whitespace after xml closing tag python", "code": "def _breakRemNewlines(tag):\n\t\"\"\"non-recursively break spaces and remove newlines in the tag\"\"\"\n\tfor i,c in enumerate(tag.contents):\n\t\tif type(c) != bs4.element.NavigableString:\n\t\t\tcontinue\n\t\tc.replace_with(re.sub(r' {2,}', ' ', c).replace('\\n',''))", "code_tokens": "def _breakRemNewlines ( tag ) : for i , c in enumerate ( tag . contents ) : if type ( c ) != bs4 . element . NavigableString : continue c . replace_with ( re . sub ( r' {2,}' , ' ' , c ) . replace ( '\\n' , '' ) )", "docstring_tokens": "non - recursively break spaces and remove newlines in the tag", "label": 0}, {"idx": "cosqa-train-16573", "doc": "no gradients provided for any variable tf python help", "code": "def forget_xy(t):\n  \"\"\"Ignore sizes of dimensions (1, 2) of a 4d tensor in shape inference.\n\n  This allows using smaller input sizes, which create an invalid graph at higher\n  layers (for example because a spatial dimension becomes smaller than a conv\n  filter) when we only use early parts of it.\n  \"\"\"\n  shape = (t.shape[0], None, None, t.shape[3])\n  return tf.placeholder_with_default(t, shape)", "code_tokens": "def forget_xy ( t ) : shape = ( t . shape [ 0 ] , None , None , t . shape [ 3 ] ) return tf . placeholder_with_default ( t , shape )", "docstring_tokens": "Ignore sizes of dimensions ( 1 2 ) of a 4d tensor in shape inference .", "label": 0}, {"idx": "cosqa-train-16574", "doc": "no of dimensions in python list", "code": "def get_dimension_array(array):\n    \"\"\"\n    Get dimension of an array getting the number of rows and the max num of\n    columns.\n    \"\"\"\n    if all(isinstance(el, list) for el in array):\n        result = [len(array), len(max([x for x in array], key=len,))]\n\n    # elif array and isinstance(array, list):\n    else:\n        result = [len(array), 1]\n\n    return result", "code_tokens": "def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result", "docstring_tokens": "Get dimension of an array getting the number of rows and the max num of columns .", "label": 0}, {"idx": "cosqa-train-16575", "doc": "remove zeros from list python", "code": "def _remove_blank(l):\n        \"\"\" Removes trailing zeros in the list of integers and returns a new list of integers\"\"\"\n        ret = []\n        for i, _ in enumerate(l):\n            if l[i] == 0:\n                break\n            ret.append(l[i])\n        return ret", "code_tokens": "def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret", "docstring_tokens": "Removes trailing zeros in the list of integers and returns a new list of integers", "label": 1}, {"idx": "cosqa-train-16576", "doc": "non blocking input python", "code": "async def async_input(prompt):\n    \"\"\"\n    Python's ``input()`` is blocking, which means the event loop we set\n    above can't be running while we're blocking there. This method will\n    let the loop run while we wait for input.\n    \"\"\"\n    print(prompt, end='', flush=True)\n    return (await loop.run_in_executor(None, sys.stdin.readline)).rstrip()", "code_tokens": "async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "docstring_tokens": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .", "label": 0}, {"idx": "cosqa-train-16577", "doc": "removing a symbol from a string in python", "code": "def sanitize_word(s):\n    \"\"\"Remove non-alphanumerical characters from metric word.\n    And trim excessive underscores.\n    \"\"\"\n    s = re.sub('[^\\w-]+', '_', s)\n    s = re.sub('__+', '_', s)\n    return s.strip('_')", "code_tokens": "def sanitize_word ( s ) : s = re . sub ( '[^\\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )", "docstring_tokens": "Remove non - alphanumerical characters from metric word . And trim excessive underscores .", "label": 1}, {"idx": "cosqa-train-16578", "doc": "normalize a sparse matrix python", "code": "def cell_normalize(data):\n    \"\"\"\n    Returns the data where the expression is normalized so that the total\n    count per cell is equal.\n    \"\"\"\n    if sparse.issparse(data):\n        data = sparse.csc_matrix(data.astype(float))\n        # normalize in-place\n        sparse_cell_normalize(data.data,\n                data.indices,\n                data.indptr,\n                data.shape[1],\n                data.shape[0])\n        return data\n    data_norm = data.astype(float)\n    total_umis = []\n    for i in range(data.shape[1]):\n        di = data_norm[:,i]\n        total_umis.append(di.sum())\n        di /= total_umis[i]\n    med = np.median(total_umis)\n    data_norm *= med\n    return data_norm", "code_tokens": "def cell_normalize ( data ) : if sparse . issparse ( data ) : data = sparse . csc_matrix ( data . astype ( float ) ) # normalize in-place sparse_cell_normalize ( data . data , data . indices , data . indptr , data . shape [ 1 ] , data . shape [ 0 ] ) return data data_norm = data . astype ( float ) total_umis = [ ] for i in range ( data . shape [ 1 ] ) : di = data_norm [ : , i ] total_umis . append ( di . sum ( ) ) di /= total_umis [ i ] med = np . median ( total_umis ) data_norm *= med return data_norm", "docstring_tokens": "Returns the data where the expression is normalized so that the total count per cell is equal .", "label": 1}, {"idx": "cosqa-train-16579", "doc": "removing items separated by comma from a list python", "code": "def _str_to_list(s):\n    \"\"\"Converts a comma separated string to a list\"\"\"\n    _list = s.split(\",\")\n    return list(map(lambda i: i.lstrip(), _list))", "code_tokens": "def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "docstring_tokens": "Converts a comma separated string to a list", "label": 1}, {"idx": "cosqa-train-16580", "doc": "npss signal auto correction python", "code": "def phase_correct_first(spec, freq, k):\n    \"\"\"\n    First order phase correction.\n\n    Parameters\n    ----------\n    spec : float array\n        The spectrum to be corrected.\n\n    freq : float array\n        The frequency axis.\n\n    k : float\n        The slope of the phase correction as a function of frequency.\n\n    Returns\n    -------\n    The phase-corrected spectrum.\n\n    Notes\n    -----\n    [Keeler2005] Keeler, J (2005). Understanding NMR Spectroscopy, 2nd\n        edition. Wiley. Page 88\n\n    \"\"\"\n    c_factor = np.exp(-1j * k * freq)\n    c_factor = c_factor.reshape((len(spec.shape) -1) * (1,) + c_factor.shape)\n    return spec * c_factor", "code_tokens": "def phase_correct_first ( spec , freq , k ) : c_factor = np . exp ( - 1j * k * freq ) c_factor = c_factor . reshape ( ( len ( spec . shape ) - 1 ) * ( 1 , ) + c_factor . shape ) return spec * c_factor", "docstring_tokens": "First order phase correction .", "label": 1}, {"idx": "cosqa-train-16581", "doc": "removing stop words in python without ntlk", "code": "def wordify(text):\n    \"\"\"Generate a list of words given text, removing punctuation.\n\n    Parameters\n    ----------\n    text : unicode\n        A piece of english text.\n\n    Returns\n    -------\n    words : list\n        List of words.\n    \"\"\"\n    stopset = set(nltk.corpus.stopwords.words('english'))\n    tokens = nltk.WordPunctTokenizer().tokenize(text)\n    return [w for w in tokens if w not in stopset]", "code_tokens": "def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "docstring_tokens": "Generate a list of words given text removing punctuation .", "label": 0}, {"idx": "cosqa-train-16582", "doc": "number of rows in a series python", "code": "def series_table_row_offset(self, series):\n        \"\"\"\n        Return the number of rows preceding the data table for *series* in\n        the Excel worksheet.\n        \"\"\"\n        title_and_spacer_rows = series.index * 2\n        data_point_rows = series.data_point_offset\n        return title_and_spacer_rows + data_point_rows", "code_tokens": "def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows", "docstring_tokens": "Return the number of rows preceding the data table for * series * in the Excel worksheet .", "label": 0}, {"idx": "cosqa-train-16583", "doc": "replace * in string in python", "code": "def myreplace(astr, thefind, thereplace):\n    \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"\n    alist = astr.split(thefind)\n    new_s = alist.split(thereplace)\n    return new_s", "code_tokens": "def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "docstring_tokens": "in string astr replace all occurences of thefind with thereplace", "label": 1}, {"idx": "cosqa-train-16584", "doc": "number of rows in a sheet python", "code": "def series_table_row_offset(self, series):\n        \"\"\"\n        Return the number of rows preceding the data table for *series* in\n        the Excel worksheet.\n        \"\"\"\n        title_and_spacer_rows = series.index * 2\n        data_point_rows = series.data_point_offset\n        return title_and_spacer_rows + data_point_rows", "code_tokens": "def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows", "docstring_tokens": "Return the number of rows preceding the data table for * series * in the Excel worksheet .", "label": 0}, {"idx": "cosqa-train-16585", "doc": "replace all occurrence of a searched pattern in python", "code": "def subn_filter(s, find, replace, count=0):\n    \"\"\"A non-optimal implementation of a regex filter\"\"\"\n    return re.gsub(find, replace, count, s)", "code_tokens": "def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "docstring_tokens": "A non - optimal implementation of a regex filter", "label": 0}, {"idx": "cosqa-train-16586", "doc": "number of unique values in list python", "code": "def count_list(the_list):\n    \"\"\"\n    Generates a count of the number of times each unique item appears in a list\n    \"\"\"\n    count = the_list.count\n    result = [(item, count(item)) for item in set(the_list)]\n    result.sort()\n    return result", "code_tokens": "def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result", "docstring_tokens": "Generates a count of the number of times each unique item appears in a list", "label": 1}, {"idx": "cosqa-train-16587", "doc": "replace all zeros in array with nan python", "code": "def clean_with_zeros(self,x):\n        \"\"\" set nan and inf rows from x to zero\"\"\"\n        x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0\n        return x", "code_tokens": "def clean_with_zeros ( self , x ) : x [ ~ np . any ( np . isnan ( x ) | np . isinf ( x ) , axis = 1 ) ] = 0 return x", "docstring_tokens": "set nan and inf rows from x to zero", "label": 0}, {"idx": "cosqa-train-16588", "doc": "numpy load from file in folder python", "code": "def read_array(path, mmap_mode=None):\n    \"\"\"Read a .npy array.\"\"\"\n    file_ext = op.splitext(path)[1]\n    if file_ext == '.npy':\n        return np.load(path, mmap_mode=mmap_mode)\n    raise NotImplementedError(\"The file extension `{}` \".format(file_ext) +\n                              \"is not currently supported.\")", "code_tokens": "def read_array ( path , mmap_mode = None ) : file_ext = op . splitext ( path ) [ 1 ] if file_ext == '.npy' : return np . load ( path , mmap_mode = mmap_mode ) raise NotImplementedError ( \"The file extension `{}` \" . format ( file_ext ) + \"is not currently supported.\" )", "docstring_tokens": "Read a . npy array .", "label": 0}, {"idx": "cosqa-train-16589", "doc": "replace latex with python", "code": "def escape_tex(value):\n  \"\"\"\n  Make text tex safe\n  \"\"\"\n  newval = value\n  for pattern, replacement in LATEX_SUBS:\n    newval = pattern.sub(replacement, newval)\n  return newval", "code_tokens": "def escape_tex ( value ) : newval = value for pattern , replacement in LATEX_SUBS : newval = pattern . sub ( replacement , newval ) return newval", "docstring_tokens": "Make text tex safe", "label": 1}, {"idx": "cosqa-train-16590", "doc": "numpy nearest pointin python", "code": "def index_nearest(value, array):\n    \"\"\"\n    expects a _n.array\n    returns the global minimum of (value-array)^2\n    \"\"\"\n\n    a = (array-value)**2\n    return index(a.min(), a)", "code_tokens": "def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "docstring_tokens": "expects a _n . array returns the global minimum of ( value - array ) ^2", "label": 1}, {"idx": "cosqa-train-16591", "doc": "replace multiple patterns using re python", "code": "def _sub_patterns(patterns, text):\n    \"\"\"\n    Apply re.sub to bunch of (pattern, repl)\n    \"\"\"\n    for pattern, repl in patterns:\n        text = re.sub(pattern, repl, text)\n    return text", "code_tokens": "def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text", "docstring_tokens": "Apply re . sub to bunch of ( pattern repl )", "label": 0}, {"idx": "cosqa-train-16592", "doc": "object as a list python", "code": "def as_list(self):\n        \"\"\"Return all child objects in nested lists of strings.\"\"\"\n        return [self.name, self.value, [x.as_list for x in self.children]]", "code_tokens": "def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "docstring_tokens": "Return all child objects in nested lists of strings .", "label": 0}, {"idx": "cosqa-train-16593", "doc": "replace parantheses in string python", "code": "def unapostrophe(text):\n    \"\"\"Strip apostrophe and 's' from the end of a string.\"\"\"\n    text = re.sub(r'[%s]s?$' % ''.join(APOSTROPHES), '', text)\n    return text", "code_tokens": "def unapostrophe ( text ) : text = re . sub ( r'[%s]s?$' % '' . join ( APOSTROPHES ) , '' , text ) return text", "docstring_tokens": "Strip apostrophe and s from the end of a string .", "label": 0}, {"idx": "cosqa-train-16594", "doc": "object as list python", "code": "def as_list(self):\n        \"\"\"Return all child objects in nested lists of strings.\"\"\"\n        return [self.name, self.value, [x.as_list for x in self.children]]", "code_tokens": "def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "docstring_tokens": "Return all child objects in nested lists of strings .", "label": 1}, {"idx": "cosqa-train-16595", "doc": "request param in python django", "code": "def parse_querystring(self, req, name, field):\n        \"\"\"Pull a querystring value from the request.\"\"\"\n        return core.get_value(req.args, name, field)", "code_tokens": "def parse_querystring ( self , req , name , field ) : return core . get_value ( req . args , name , field )", "docstring_tokens": "Pull a querystring value from the request .", "label": 0}, {"idx": "cosqa-train-16596", "doc": "object of type 'listserializer' is not json serializable python", "code": "def is_serializable(obj):\n    \"\"\"Return `True` if the given object conforms to the Serializable protocol.\n\n    :rtype: bool\n    \"\"\"\n    if inspect.isclass(obj):\n      return Serializable.is_serializable_type(obj)\n    return isinstance(obj, Serializable) or hasattr(obj, '_asdict')", "code_tokens": "def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )", "docstring_tokens": "Return True if the given object conforms to the Serializable protocol .", "label": 1}, {"idx": "cosqa-train-16597", "doc": "requests python json expecting value", "code": "def device_state(device_id):\n    \"\"\" Get device state via HTTP GET. \"\"\"\n    if device_id not in devices:\n        return jsonify(success=False)\n    return jsonify(state=devices[device_id].state)", "code_tokens": "def device_state ( device_id ) : if device_id not in devices : return jsonify ( success = False ) return jsonify ( state = devices [ device_id ] . state )", "docstring_tokens": "Get device state via HTTP GET .", "label": 1}, {"idx": "cosqa-train-16598", "doc": "odoo+python+add read only field", "code": "def get_readonly_fields(self, request, obj=None):\n        \"\"\"Set all fields readonly.\"\"\"\n        return list(self.readonly_fields) + [field.name for field in obj._meta.fields]", "code_tokens": "def get_readonly_fields ( self , request , obj = None ) : return list ( self . readonly_fields ) + [ field . name for field in obj . _meta . fields ]", "docstring_tokens": "Set all fields readonly .", "label": 1}, {"idx": "cosqa-train-16599", "doc": "resample 2d lon lat grid python", "code": "def resample(grid, wl, flux):\n    \"\"\" Resample spectrum onto desired grid \"\"\"\n    flux_rs = (interpolate.interp1d(wl, flux))(grid)\n    return flux_rs", "code_tokens": "def resample ( grid , wl , flux ) : flux_rs = ( interpolate . interp1d ( wl , flux ) ) ( grid ) return flux_rs", "docstring_tokens": "Resample spectrum onto desired grid", "label": 0}, {"idx": "cosqa-train-16600", "doc": "only python base64 has leading b", "code": "def toBase64(s):\n    \"\"\"Represent string / bytes s as base64, omitting newlines\"\"\"\n    if isinstance(s, str):\n        s = s.encode(\"utf-8\")\n    return binascii.b2a_base64(s)[:-1]", "code_tokens": "def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "docstring_tokens": "Represent string / bytes s as base64 omitting newlines", "label": 0}, {"idx": "cosqa-train-16601", "doc": "resampling an array in python", "code": "def downsample_with_striding(array, factor):\n    \"\"\"Downsample x by factor using striding.\n\n    @return: The downsampled array, of the same type as x.\n    \"\"\"\n    return array[tuple(np.s_[::f] for f in factor)]", "code_tokens": "def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]", "docstring_tokens": "Downsample x by factor using striding .", "label": 0}, {"idx": "cosqa-train-16602", "doc": "onvert string to float in python", "code": "def energy_string_to_float( string ):\n    \"\"\"\n    Convert a string of a calculation energy, e.g. '-1.2345 eV' to a float.\n\n    Args:\n        string (str): The string to convert.\n  \n    Return\n        (float) \n    \"\"\"\n    energy_re = re.compile( \"(-?\\d+\\.\\d+)\" )\n    return float( energy_re.match( string ).group(0) )", "code_tokens": "def energy_string_to_float ( string ) : energy_re = re . compile ( \"(-?\\d+\\.\\d+)\" ) return float ( energy_re . match ( string ) . group ( 0 ) )", "docstring_tokens": "Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .", "label": 1}, {"idx": "cosqa-train-16603", "doc": "reshape a list as an array in python", "code": "def shape_list(l,shape,dtype):\n    \"\"\" Shape a list of lists into the appropriate shape and data type \"\"\"\n    return np.array(l, dtype=dtype).reshape(shape)", "code_tokens": "def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )", "docstring_tokens": "Shape a list of lists into the appropriate shape and data type", "label": 1}, {"idx": "cosqa-train-16604", "doc": "open a file in python based on modified date", "code": "def utime(self, *args, **kwargs):\n        \"\"\" Set the access and modified times of the file specified by path. \"\"\"\n        os.utime(self.extended_path, *args, **kwargs)", "code_tokens": "def utime ( self , * args , * * kwargs ) : os . utime ( self . extended_path , * args , * * kwargs )", "docstring_tokens": "Set the access and modified times of the file specified by path .", "label": 0}, {"idx": "cosqa-train-16605", "doc": "reshape array from 4 to 2 dimensions in n\\python", "code": "def batchify(data, batch_size):\n    \"\"\"Reshape data into (num_example, batch_size)\"\"\"\n    nbatch = data.shape[0] // batch_size\n    data = data[:nbatch * batch_size]\n    data = data.reshape((batch_size, nbatch)).T\n    return data", "code_tokens": "def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data", "docstring_tokens": "Reshape data into ( num_example batch_size )", "label": 1}, {"idx": "cosqa-train-16606", "doc": "open a pickled file in python", "code": "def unpickle_file(picklefile, **kwargs):\n    \"\"\"Helper function to unpickle data from `picklefile`.\"\"\"\n    with open(picklefile, 'rb') as f:\n        return pickle.load(f, **kwargs)", "code_tokens": "def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )", "docstring_tokens": "Helper function to unpickle data from picklefile .", "label": 0}, {"idx": "cosqa-train-16607", "doc": "reshape in python 3 dimenssionto 2 example", "code": "def batchify(data, batch_size):\n    \"\"\"Reshape data into (num_example, batch_size)\"\"\"\n    nbatch = data.shape[0] // batch_size\n    data = data[:nbatch * batch_size]\n    data = data.reshape((batch_size, nbatch)).T\n    return data", "code_tokens": "def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data", "docstring_tokens": "Reshape data into ( num_example batch_size )", "label": 0}, {"idx": "cosqa-train-16608", "doc": "open an file for read or write python open", "code": "def open_file(file, mode):\n\t\"\"\"Open a file.\n\n\t:arg file: file-like or path-like object.\n\t:arg str mode: ``mode`` argument for :func:`open`.\n\t\"\"\"\n\tif hasattr(file, \"read\"):\n\t\treturn file\n\tif hasattr(file, \"open\"):\n\t\treturn file.open(mode)\n\treturn open(file, mode)", "code_tokens": "def open_file ( file , mode ) : if hasattr ( file , \"read\" ) : return file if hasattr ( file , \"open\" ) : return file . open ( mode ) return open ( file , mode )", "docstring_tokens": "Open a file .", "label": 1}, {"idx": "cosqa-train-16609", "doc": "response object pythong content incomplete", "code": "def render_none(self, context, result):\n\t\t\"\"\"Render empty responses.\"\"\"\n\t\tcontext.response.body = b''\n\t\tdel context.response.content_length\n\t\treturn True", "code_tokens": "def render_none ( self , context , result ) : context . response . body = b'' del context . response . content_length return True", "docstring_tokens": "Render empty responses .", "label": 1}, {"idx": "cosqa-train-16610", "doc": "open and read first line in a file python", "code": "def getfirstline(file, default):\n    \"\"\"\n    Returns the first line of a file.\n    \"\"\"\n    with open(file, 'rb') as fh:\n        content = fh.readlines()\n        if len(content) == 1:\n            return content[0].decode('utf-8').strip('\\n')\n\n    return default", "code_tokens": "def getfirstline ( file , default ) : with open ( file , 'rb' ) as fh : content = fh . readlines ( ) if len ( content ) == 1 : return content [ 0 ] . decode ( 'utf-8' ) . strip ( '\\n' ) return default", "docstring_tokens": "Returns the first line of a file .", "label": 1}, {"idx": "cosqa-train-16611", "doc": "restart discord bot with command python", "code": "def do_restart(self, line):\n        \"\"\"\n        Attempt to restart the bot.\n        \"\"\"\n        self.bot._frame = 0\n        self.bot._namespace.clear()\n        self.bot._namespace.update(self.bot._initial_namespace)", "code_tokens": "def do_restart ( self , line ) : self . bot . _frame = 0 self . bot . _namespace . clear ( ) self . bot . _namespace . update ( self . bot . _initial_namespace )", "docstring_tokens": "Attempt to restart the bot .", "label": 0}, {"idx": "cosqa-train-16612", "doc": "open compiled python file", "code": "def execfile(fname, variables):\n    \"\"\" This is builtin in python2, but we have to roll our own on py3. \"\"\"\n    with open(fname) as f:\n        code = compile(f.read(), fname, 'exec')\n        exec(code, variables)", "code_tokens": "def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "docstring_tokens": "This is builtin in python2 but we have to roll our own on py3 .", "label": 1}, {"idx": "cosqa-train-16613", "doc": "retrieve global variables from function python", "code": "def extract_module_locals(depth=0):\n    \"\"\"Returns (module, locals) of the funciton `depth` frames away from the caller\"\"\"\n    f = sys._getframe(depth + 1)\n    global_ns = f.f_globals\n    module = sys.modules[global_ns['__name__']]\n    return (module, f.f_locals)", "code_tokens": "def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )", "docstring_tokens": "Returns ( module locals ) of the funciton depth frames away from the caller", "label": 0}, {"idx": "cosqa-train-16614", "doc": "open files in python without decoding", "code": "def read(*args):\n    \"\"\"Reads complete file contents.\"\"\"\n    return io.open(os.path.join(HERE, *args), encoding=\"utf-8\").read()", "code_tokens": "def read ( * args ) : return io . open ( os . path . join ( HERE , * args ) , encoding = \"utf-8\" ) . read ( )", "docstring_tokens": "Reads complete file contents .", "label": 1}, {"idx": "cosqa-train-16615", "doc": "return a method from a method python", "code": "def get_class_method(cls_or_inst, method_name):\n    \"\"\"\n    Returns a method from a given class or instance. When the method doest not exist, it returns `None`. Also works with\n    properties and cached properties.\n    \"\"\"\n    cls = cls_or_inst if isinstance(cls_or_inst, type) else cls_or_inst.__class__\n    meth = getattr(cls, method_name, None)\n    if isinstance(meth, property):\n        meth = meth.fget\n    elif isinstance(meth, cached_property):\n        meth = meth.func\n    return meth", "code_tokens": "def get_class_method ( cls_or_inst , method_name ) : cls = cls_or_inst if isinstance ( cls_or_inst , type ) else cls_or_inst . __class__ meth = getattr ( cls , method_name , None ) if isinstance ( meth , property ) : meth = meth . fget elif isinstance ( meth , cached_property ) : meth = meth . func return meth", "docstring_tokens": "Returns a method from a given class or instance . When the method doest not exist it returns None . Also works with properties and cached properties .", "label": 1}, {"idx": "cosqa-train-16616", "doc": "opencv python image not found", "code": "def imdecode(image_path):\n    \"\"\"Return BGR image read by opencv\"\"\"\n    import os\n    assert os.path.exists(image_path), image_path + ' not found'\n    im = cv2.imread(image_path)\n    return im", "code_tokens": "def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im", "docstring_tokens": "Return BGR image read by opencv", "label": 0}, {"idx": "cosqa-train-16617", "doc": "return all values in python enum in tuple", "code": "def items(self):\n    \"\"\"Return a list of the (name, value) pairs of the enum.\n\n    These are returned in the order they were defined in the .proto file.\n    \"\"\"\n    return [(value_descriptor.name, value_descriptor.number)\n            for value_descriptor in self._enum_type.values]", "code_tokens": "def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]", "docstring_tokens": "Return a list of the ( name value ) pairs of the enum .", "label": 1}, {"idx": "cosqa-train-16618", "doc": "opening blank workbook using python openpyxl", "code": "def _openpyxl_read_xl(xl_path: str):\n    \"\"\" Use openpyxl to read an Excel file. \"\"\"\n    try:\n        wb = load_workbook(filename=xl_path, read_only=True)\n    except:\n        raise\n    else:\n        return wb", "code_tokens": "def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb", "docstring_tokens": "Use openpyxl to read an Excel file .", "label": 1}, {"idx": "cosqa-train-16619", "doc": "return columns names python", "code": "def get_column_keys_and_names(table):\n    \"\"\"\n    Return a generator of tuples k, c such that k is the name of the python attribute for\n    the column and c is the name of the column in the sql table.\n    \"\"\"\n    ins = inspect(table)\n    return ((k, c.name) for k, c in ins.mapper.c.items())", "code_tokens": "def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )", "docstring_tokens": "Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table .", "label": 0}, {"idx": "cosqa-train-16620", "doc": "order a number in a string python", "code": "def naturalsortkey(s):\n    \"\"\"Natural sort order\"\"\"\n    return [int(part) if part.isdigit() else part\n            for part in re.split('([0-9]+)', s)]", "code_tokens": "def naturalsortkey ( s ) : return [ int ( part ) if part . isdigit ( ) else part for part in re . split ( '([0-9]+)' , s ) ]", "docstring_tokens": "Natural sort order", "label": 0}, {"idx": "cosqa-train-16621", "doc": "return only the first column of an array python", "code": "def get_X0(X):\n    \"\"\" Return zero-th element of a one-element data container.\n    \"\"\"\n    if pandas_available and isinstance(X, pd.DataFrame):\n        assert len(X) == 1\n        x = np.array(X.iloc[0])\n    else:\n        x, = X\n    return x", "code_tokens": "def get_X0 ( X ) : if pandas_available and isinstance ( X , pd . DataFrame ) : assert len ( X ) == 1 x = np . array ( X . iloc [ 0 ] ) else : x , = X return x", "docstring_tokens": "Return zero - th element of a one - element data container .", "label": 0}, {"idx": "cosqa-train-16622", "doc": "orthonormalize 1 vector corresponding to another python", "code": "def project(self, other):\n        \"\"\"Return one vector projected on the vector other\"\"\"\n        n = other.normalized()\n        return self.dot(n) * n", "code_tokens": "def project ( self , other ) : n = other . normalized ( ) return self . dot ( n ) * n", "docstring_tokens": "Return one vector projected on the vector other", "label": 0}, {"idx": "cosqa-train-16623", "doc": "return the string after removing all alphabets python", "code": "def preprocess(string):\n    \"\"\"\n    Preprocess string to transform all diacritics and remove other special characters than appropriate\n    \n    :param string:\n    :return:\n    \"\"\"\n    string = unicode(string, encoding=\"utf-8\")\n    # convert diacritics to simpler forms\n    string = regex1.sub(lambda x: accents[x.group()], string)\n    # remove all rest of the unwanted characters\n    return regex2.sub('', string).encode('utf-8')", "code_tokens": "def preprocess ( string ) : string = unicode ( string , encoding = \"utf-8\" ) # convert diacritics to simpler forms string = regex1 . sub ( lambda x : accents [ x . group ( ) ] , string ) # remove all rest of the unwanted characters return regex2 . sub ( '' , string ) . encode ( 'utf-8' )", "docstring_tokens": "Preprocess string to transform all diacritics and remove other special characters than appropriate : param string : : return :", "label": 0}, {"idx": "cosqa-train-16624", "doc": "output current timezone python", "code": "def timestamp(format=DATEFMT, timezone='Africa/Johannesburg'):\n    \"\"\" Return current datetime with timezone applied\n        [all timezones] print sorted(pytz.all_timezones) \"\"\"\n\n    return formatdate(datetime.now(tz=pytz.timezone(timezone)))", "code_tokens": "def timestamp ( format = DATEFMT , timezone = 'Africa/Johannesburg' ) : return formatdate ( datetime . now ( tz = pytz . timezone ( timezone ) ) )", "docstring_tokens": "Return current datetime with timezone applied [ all timezones ] print sorted ( pytz . all_timezones )", "label": 0}, {"idx": "cosqa-train-16625", "doc": "returning a value from a python try function", "code": "def _try_lookup(table, value, default = \"\"):\n    \"\"\" try to get a string from the lookup table, return \"\" instead of key\n    error\n    \"\"\"\n    try:\n        string = table[ value ]\n    except KeyError:\n        string = default\n    return string", "code_tokens": "def _try_lookup ( table , value , default = \"\" ) : try : string = table [ value ] except KeyError : string = default return string", "docstring_tokens": "try to get a string from the lookup table return instead of key error", "label": 0}, {"idx": "cosqa-train-16626", "doc": "outputting pid to file linux python", "code": "def write_pid_file():\n    \"\"\"Write a file with the PID of this server instance.\n\n    Call when setting up a command line testserver.\n    \"\"\"\n    pidfile = os.path.basename(sys.argv[0])[:-3] + '.pid'  # strip .py, add .pid\n    with open(pidfile, 'w') as fh:\n        fh.write(\"%d\\n\" % os.getpid())\n        fh.close()", "code_tokens": "def write_pid_file ( ) : pidfile = os . path . basename ( sys . argv [ 0 ] ) [ : - 3 ] + '.pid' # strip .py, add .pid with open ( pidfile , 'w' ) as fh : fh . write ( \"%d\\n\" % os . getpid ( ) ) fh . close ( )", "docstring_tokens": "Write a file with the PID of this server instance .", "label": 0}, {"idx": "cosqa-train-16627", "doc": "reverse the dictionary in python", "code": "def inverse(d):\n    \"\"\"\n    reverse the k:v pairs\n    \"\"\"\n    output = {}\n    for k, v in unwrap(d).items():\n        output[v] = output.get(v, [])\n        output[v].append(k)\n    return output", "code_tokens": "def inverse ( d ) : output = { } for k , v in unwrap ( d ) . items ( ) : output [ v ] = output . get ( v , [ ] ) output [ v ] . append ( k ) return output", "docstring_tokens": "reverse the k : v pairs", "label": 0}, {"idx": "cosqa-train-16628", "doc": "overlay segmentation onto image linux python", "code": "def region_from_segment(image, segment):\n    \"\"\"given a segment (rectangle) and an image, returns it's corresponding subimage\"\"\"\n    x, y, w, h = segment\n    return image[y:y + h, x:x + w]", "code_tokens": "def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]", "docstring_tokens": "given a segment ( rectangle ) and an image returns it s corresponding subimage", "label": 0}, {"idx": "cosqa-train-16629", "doc": "round a date to the nearest hour python", "code": "def _round_half_hour(record):\n    \"\"\"\n    Round a time DOWN to half nearest half-hour.\n    \"\"\"\n    k = record.datetime + timedelta(minutes=-(record.datetime.minute % 30))\n    return datetime(k.year, k.month, k.day, k.hour, k.minute, 0)", "code_tokens": "def _round_half_hour ( record ) : k = record . datetime + timedelta ( minutes = - ( record . datetime . minute % 30 ) ) return datetime ( k . year , k . month , k . day , k . hour , k . minute , 0 )", "docstring_tokens": "Round a time DOWN to half nearest half - hour .", "label": 0}, {"idx": "cosqa-train-16630", "doc": "ow to make x and y in same dimension in python", "code": "def unpack2D(_x):\n    \"\"\"\n        Helper function for splitting 2D data into x and y component to make\n        equations simpler\n    \"\"\"\n    _x = np.atleast_2d(_x)\n    x = _x[:, 0]\n    y = _x[:, 1]\n    return x, y", "code_tokens": "def unpack2D ( _x ) : _x = np . atleast_2d ( _x ) x = _x [ : , 0 ] y = _x [ : , 1 ] return x , y", "docstring_tokens": "Helper function for splitting 2D data into x and y component to make equations simpler", "label": 0}, {"idx": "cosqa-train-16631", "doc": "round to nearest minute timestamp python", "code": "def __round_time(self, dt):\n    \"\"\"Round a datetime object to a multiple of a timedelta\n    dt : datetime.datetime object, default now.\n    \"\"\"\n    round_to = self._resolution.total_seconds()\n    seconds  = (dt - dt.min).seconds\n    rounding = (seconds + round_to / 2) // round_to * round_to\n    return dt + timedelta(0, rounding - seconds, -dt.microsecond)", "code_tokens": "def __round_time ( self , dt ) : round_to = self . _resolution . total_seconds ( ) seconds = ( dt - dt . min ) . seconds rounding = ( seconds + round_to / 2 ) // round_to * round_to return dt + timedelta ( 0 , rounding - seconds , - dt . microsecond )", "docstring_tokens": "Round a datetime object to a multiple of a timedelta dt : datetime . datetime object default now .", "label": 0}, {"idx": "cosqa-train-16632", "doc": "pad image to bounding box python", "code": "def resize_image_with_crop_or_pad(img, target_height, target_width):\n    \"\"\"\n    Crops and/or pads an image to a target width and height.\n\n    Resizes an image to a target width and height by either cropping the image or padding it with zeros.\n\n    NO CENTER CROP. NO CENTER PAD. (Just fill bottom right or crop bottom right)\n\n    :param img: Numpy array representing the image.\n    :param target_height: Target height.\n    :param target_width: Target width.\n    :return: The cropped and padded image.\n    \"\"\"\n    h, w = target_height, target_width\n    max_h, max_w, c = img.shape\n\n    # crop\n    img = crop_center(img, min(max_h, h), min(max_w, w))\n\n    # pad\n    padded_img = np.zeros(shape=(h, w, c), dtype=img.dtype)\n    padded_img[:img.shape[0], :img.shape[1], :img.shape[2]] = img\n\n    return padded_img", "code_tokens": "def resize_image_with_crop_or_pad ( img , target_height , target_width ) : h , w = target_height , target_width max_h , max_w , c = img . shape # crop img = crop_center ( img , min ( max_h , h ) , min ( max_w , w ) ) # pad padded_img = np . zeros ( shape = ( h , w , c ) , dtype = img . dtype ) padded_img [ : img . shape [ 0 ] , : img . shape [ 1 ] , : img . shape [ 2 ] ] = img return padded_img", "docstring_tokens": "Crops and / or pads an image to a target width and height .", "label": 0}, {"idx": "cosqa-train-16633", "doc": "round up float to two decimal places in python 3", "code": "def py3round(number):\n    \"\"\"Unified rounding in all python versions.\"\"\"\n    if abs(round(number) - number) == 0.5:\n        return int(2.0 * round(number / 2.0))\n\n    return int(round(number))", "code_tokens": "def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "docstring_tokens": "Unified rounding in all python versions .", "label": 1}, {"idx": "cosqa-train-16634", "doc": "panda python parse datetime", "code": "def _parse(self, date_str, format='%Y-%m-%d'):\n        \"\"\"\n        helper function for parsing FRED date string into datetime\n        \"\"\"\n        rv = pd.to_datetime(date_str, format=format)\n        if hasattr(rv, 'to_pydatetime'):\n            rv = rv.to_pydatetime()\n        return rv", "code_tokens": "def _parse ( self , date_str , format = '%Y-%m-%d' ) : rv = pd . to_datetime ( date_str , format = format ) if hasattr ( rv , 'to_pydatetime' ) : rv = rv . to_pydatetime ( ) return rv", "docstring_tokens": "helper function for parsing FRED date string into datetime", "label": 0}, {"idx": "cosqa-train-16635", "doc": "route has get and post just return postpython service", "code": "def home():\n    \"\"\"Temporary helper function to link to the API routes\"\"\"\n    return dict(links=dict(api='{}{}'.format(request.url, PREFIX[1:]))), \\\n        HTTPStatus.OK", "code_tokens": "def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK", "docstring_tokens": "Temporary helper function to link to the API routes", "label": 0}, {"idx": "cosqa-train-16636", "doc": "parsing comments with python", "code": "def parse_comments_for_file(filename):\n    \"\"\"\n    Return a list of all parsed comments in a file.  Mostly for testing &\n    interactive use.\n    \"\"\"\n    return [parse_comment(strip_stars(comment), next_line)\n            for comment, next_line in get_doc_comments(read_file(filename))]", "code_tokens": "def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "docstring_tokens": "Return a list of all parsed comments in a file . Mostly for testing & interactive use .", "label": 0}, {"idx": "cosqa-train-16637", "doc": "row is not empty in python check", "code": "def is_valid_row(cls, row):\n        \"\"\"Indicates whether or not the given row contains valid data.\"\"\"\n        for k in row.keys():\n            if row[k] is None:\n                return False\n        return True", "code_tokens": "def is_valid_row ( cls , row ) : for k in row . keys ( ) : if row [ k ] is None : return False return True", "docstring_tokens": "Indicates whether or not the given row contains valid data .", "label": 1}, {"idx": "cosqa-train-16638", "doc": "pass defined parser object to subparser python", "code": "def sub(name, func,**kwarg):\n    \"\"\" Add subparser\n\n    \"\"\"\n    sp = subparsers.add_parser(name, **kwarg)\n    sp.set_defaults(func=func)\n    sp.arg = sp.add_argument\n    return sp", "code_tokens": "def sub ( name , func , * * kwarg ) : sp = subparsers . add_parser ( name , * * kwarg ) sp . set_defaults ( func = func ) sp . arg = sp . add_argument return sp", "docstring_tokens": "Add subparser", "label": 1}, {"idx": "cosqa-train-16639", "doc": "running a webserver with python", "code": "def web(host, port):\n    \"\"\"Start web application\"\"\"\n    from .webserver.web import get_app\n    get_app().run(host=host, port=port)", "code_tokens": "def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )", "docstring_tokens": "Start web application", "label": 0}, {"idx": "cosqa-train-16640", "doc": "pass isfinite result to array python", "code": "def as_float_array(a):\n    \"\"\"View the quaternion array as an array of floats\n\n    This function is fast (of order 1 microsecond) because no data is\n    copied; the returned quantity is just a \"view\" of the original.\n\n    The output view has one more dimension (of size 4) than the input\n    array, but is otherwise the same shape.\n\n    \"\"\"\n    return np.asarray(a, dtype=np.quaternion).view((np.double, 4))", "code_tokens": "def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )", "docstring_tokens": "View the quaternion array as an array of floats", "label": 0}, {"idx": "cosqa-train-16641", "doc": "running multiple event loops python", "code": "def run(self):\n        \"\"\"Run the event loop.\"\"\"\n        self.signal_init()\n        self.listen_init()\n        self.logger.info('starting')\n        self.loop.start()", "code_tokens": "def run ( self ) : self . signal_init ( ) self . listen_init ( ) self . logger . info ( 'starting' ) self . loop . start ( )", "docstring_tokens": "Run the event loop .", "label": 0}, {"idx": "cosqa-train-16642", "doc": "pass json paramater python", "code": "def dict_jsonp(param):\n    \"\"\"Convert the parameter into a dictionary before calling jsonp, if it's not already one\"\"\"\n    if not isinstance(param, dict):\n        param = dict(param)\n    return jsonp(param)", "code_tokens": "def dict_jsonp ( param ) : if not isinstance ( param , dict ) : param = dict ( param ) return jsonp ( param )", "docstring_tokens": "Convert the parameter into a dictionary before calling jsonp if it s not already one", "label": 0}, {"idx": "cosqa-train-16643", "doc": "safely open and close a file in python 3", "code": "def file_read(filename):\n    \"\"\"Read a file and close it.  Returns the file source.\"\"\"\n    fobj = open(filename,'r');\n    source = fobj.read();\n    fobj.close()\n    return source", "code_tokens": "def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source", "docstring_tokens": "Read a file and close it . Returns the file source .", "label": 0}, {"idx": "cosqa-train-16644", "doc": "pass paramters to a function that calls another function python", "code": "def trigger(self, target: str, trigger: str, parameters: Dict[str, Any]={}):\n\t\t\"\"\"Calls the specified Trigger of another Area with the optionally given parameters.\n\n\t\tArgs:\n\t\t\ttarget: The name of the target Area.\n\t\t\ttrigger: The name of the Trigger.\n\t\t\tparameters: The parameters of the function call.\n\t\t\"\"\"\n\t\tpass", "code_tokens": "def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "docstring_tokens": "Calls the specified Trigger of another Area with the optionally given parameters .", "label": 0}, {"idx": "cosqa-train-16645", "doc": "same validation accuracy in python model", "code": "def cat_acc(y_true, y_pred):\n    \"\"\"Categorical accuracy\n    \"\"\"\n    return np.mean(y_true.argmax(axis=1) == y_pred.argmax(axis=1))", "code_tokens": "def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )", "docstring_tokens": "Categorical accuracy", "label": 0}, {"idx": "cosqa-train-16646", "doc": "pearsons cooefficient between 2 matricess in python", "code": "def tanimoto_coefficient(a, b):\n    \"\"\"Measured similarity between two points in a multi-dimensional space.\n\n    Returns:\n        1.0 if the two points completely overlap,\n        0.0 if the two points are infinitely far apart.\n    \"\"\"\n    return sum(map(lambda (x,y): float(x)*float(y), zip(a,b))) / sum([\n          -sum(map(lambda (x,y): float(x)*float(y), zip(a,b))),\n           sum(map(lambda x: float(x)**2, a)),\n           sum(map(lambda x: float(x)**2, b))])", "code_tokens": "def tanimoto_coefficient ( a , b ) : return sum ( map ( lambda ( x , y ) : float ( x ) * float ( y ) , zip ( a , b ) ) ) / sum ( [ - sum ( map ( lambda ( x , y ) : float ( x ) * float ( y ) , zip ( a , b ) ) ) , sum ( map ( lambda x : float ( x ) ** 2 , a ) ) , sum ( map ( lambda x : float ( x ) ** 2 , b ) ) ] )", "docstring_tokens": "Measured similarity between two points in a multi - dimensional space .", "label": 0}, {"idx": "cosqa-train-16647", "doc": "saticlly type python lists", "code": "def flatten(l, types=(list, float)):\n    \"\"\"\n    Flat nested list of lists into a single list.\n    \"\"\"\n    l = [item if isinstance(item, types) else [item] for item in l]\n    return [item for sublist in l for item in sublist]", "code_tokens": "def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Flat nested list of lists into a single list .", "label": 0}, {"idx": "cosqa-train-16648", "doc": "perform fft on data with python", "code": "def dft(blk, freqs, normalize=True):\n  \"\"\"\n  Complex non-optimized Discrete Fourier Transform\n\n  Finds the DFT for values in a given frequency list, in order, over the data\n  block seen as periodic.\n\n  Parameters\n  ----------\n  blk :\n    An iterable with well-defined length. Don't use this function with Stream\n    objects!\n  freqs :\n    List of frequencies to find the DFT, in rad/sample. FFT implementations\n    like numpy.fft.ftt finds the coefficients for N frequencies equally\n    spaced as ``line(N, 0, 2 * pi, finish=False)`` for N frequencies.\n  normalize :\n    If True (default), the coefficient sums are divided by ``len(blk)``,\n    and the coefficient for the DC level (frequency equals to zero) is the\n    mean of the block. If False, that coefficient would be the sum of the\n    data in the block.\n\n  Returns\n  -------\n  A list of DFT values for each frequency, in the same order that they appear\n  in the freqs input.\n\n  Note\n  ----\n  This isn't a FFT implementation, and performs :math:`O(M . N)` float\n  pointing operations, with :math:`M` and :math:`N` equals to the length of\n  the inputs. This function can find the DFT for any specific frequency, with\n  no need for zero padding or finding all frequencies in a linearly spaced\n  band grid with N frequency bins at once.\n\n  \"\"\"\n  dft_data = (sum(xn * cexp(-1j * n * f) for n, xn in enumerate(blk))\n                                         for f in freqs)\n  if normalize:\n    lblk = len(blk)\n    return [v / lblk for v in dft_data]\n  return list(dft_data)", "code_tokens": "def dft ( blk , freqs , normalize = True ) : dft_data = ( sum ( xn * cexp ( - 1j * n * f ) for n , xn in enumerate ( blk ) ) for f in freqs ) if normalize : lblk = len ( blk ) return [ v / lblk for v in dft_data ] return list ( dft_data )", "docstring_tokens": "Complex non - optimized Discrete Fourier Transform", "label": 0}, {"idx": "cosqa-train-16649", "doc": "save a pickle file for python 3 in python 2", "code": "def pickle_save(thing,fname):\n    \"\"\"save something to a pickle file\"\"\"\n    pickle.dump(thing, open(fname,\"wb\"),pickle.HIGHEST_PROTOCOL)\n    return thing", "code_tokens": "def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "docstring_tokens": "save something to a pickle file", "label": 0}, {"idx": "cosqa-train-16650", "doc": "perform string replace with string in list item python", "code": "def replace_list(items, match, replacement):\n    \"\"\"Replaces occurrences of a match string in a given list of strings and returns\n    a list of new strings. The match string can be a regex expression.\n\n    Args:\n        items (list):       the list of strings to modify.\n        match (str):        the search expression.\n        replacement (str):  the string to replace with.\n    \"\"\"\n    return [replace(item, match, replacement) for item in items]", "code_tokens": "def replace_list ( items , match , replacement ) : return [ replace ( item , match , replacement ) for item in items ]", "docstring_tokens": "Replaces occurrences of a match string in a given list of strings and returns a list of new strings . The match string can be a regex expression .", "label": 0}, {"idx": "cosqa-train-16651", "doc": "save json to file in python", "code": "def save(self, fname):\n        \"\"\" Saves the dictionary in json format\n        :param fname: file to save to\n        \"\"\"\n        with open(fname, 'wb') as f:\n            json.dump(self, f)", "code_tokens": "def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "docstring_tokens": "Saves the dictionary in json format : param fname : file to save to", "label": 0}, {"idx": "cosqa-train-16652", "doc": "plot the decision boundary of a svm model in python", "code": "def plot_decision_boundary(model, X, y, step=0.1, figsize=(10, 8), alpha=0.4, size=20):\n    \"\"\"Plots the classification decision boundary of `model` on `X` with labels `y`.\n    Using numpy and matplotlib.\n    \"\"\"\n\n    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n    xx, yy = np.meshgrid(np.arange(x_min, x_max, step),\n                         np.arange(y_min, y_max, step))\n\n    f, ax = plt.subplots(figsize=figsize)\n    Z = model.predict(np.c_[xx.ravel(), yy.ravel()])\n    Z = Z.reshape(xx.shape)\n\n    ax.contourf(xx, yy, Z, alpha=alpha)\n    ax.scatter(X[:, 0], X[:, 1], c=y, s=size, edgecolor='k')\n    plt.show()", "code_tokens": "def plot_decision_boundary ( model , X , y , step = 0.1 , figsize = ( 10 , 8 ) , alpha = 0.4 , size = 20 ) : x_min , x_max = X [ : , 0 ] . min ( ) - 1 , X [ : , 0 ] . max ( ) + 1 y_min , y_max = X [ : , 1 ] . min ( ) - 1 , X [ : , 1 ] . max ( ) + 1 xx , yy = np . meshgrid ( np . arange ( x_min , x_max , step ) , np . arange ( y_min , y_max , step ) ) f , ax = plt . subplots ( figsize = figsize ) Z = model . predict ( np . c_ [ xx . ravel ( ) , yy . ravel ( ) ] ) Z = Z . reshape ( xx . shape ) ax . contourf ( xx , yy , Z , alpha = alpha ) ax . scatter ( X [ : , 0 ] , X [ : , 1 ] , c = y , s = size , edgecolor = 'k' ) plt . show ( )", "docstring_tokens": "Plots the classification decision boundary of model on X with labels y . Using numpy and matplotlib .", "label": 0}, {"idx": "cosqa-train-16653", "doc": "save plot in python without superimposing", "code": "def plot_and_save(self, **kwargs):\n        \"\"\"Used when the plot method defined does not create a figure nor calls save_plot\n        Then the plot method has to use self.fig\"\"\"\n        self.fig = pyplot.figure()\n        self.plot()\n        self.axes = pyplot.gca()\n        self.save_plot(self.fig, self.axes, **kwargs)\n        pyplot.close(self.fig)", "code_tokens": "def plot_and_save ( self , * * kwargs ) : self . fig = pyplot . figure ( ) self . plot ( ) self . axes = pyplot . gca ( ) self . save_plot ( self . fig , self . axes , * * kwargs ) pyplot . close ( self . fig )", "docstring_tokens": "Used when the plot method defined does not create a figure nor calls save_plot Then the plot method has to use self . fig", "label": 1}, {"idx": "cosqa-train-16654", "doc": "posixpath to string python", "code": "def __unixify(self, s):\n        \"\"\" stupid windows. converts the backslash to forwardslash for consistency \"\"\"\n        return os.path.normpath(s).replace(os.sep, \"/\")", "code_tokens": "def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "docstring_tokens": "stupid windows . converts the backslash to forwardslash for consistency", "label": 0}, {"idx": "cosqa-train-16655", "doc": "save python graph to a flder", "code": "def to_dotfile(G: nx.DiGraph, filename: str):\n    \"\"\" Output a networkx graph to a DOT file. \"\"\"\n    A = to_agraph(G)\n    A.write(filename)", "code_tokens": "def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )", "docstring_tokens": "Output a networkx graph to a DOT file .", "label": 0}, {"idx": "cosqa-train-16656", "doc": "powershell json serialize deserialize python wcf datacontractjsonserializer", "code": "def _deserialize(cls, key, value, fields):\n        \"\"\" Marshal incoming data into Python objects.\"\"\"\n        converter = cls._get_converter_for_field(key, None, fields)\n        return converter.deserialize(value)", "code_tokens": "def _deserialize ( cls , key , value , fields ) : converter = cls . _get_converter_for_field ( key , None , fields ) return converter . deserialize ( value )", "docstring_tokens": "Marshal incoming data into Python objects .", "label": 0}, {"idx": "cosqa-train-16657", "doc": "save yaml to file python", "code": "def generate_write_yaml_to_file(file_name):\n    \"\"\" generate a method to write the configuration in yaml to the method desired \"\"\"\n    def write_yaml(config):\n        with open(file_name, 'w+') as fh:\n            fh.write(yaml.dump(config))\n    return write_yaml", "code_tokens": "def generate_write_yaml_to_file ( file_name ) : def write_yaml ( config ) : with open ( file_name , 'w+' ) as fh : fh . write ( yaml . dump ( config ) ) return write_yaml", "docstring_tokens": "generate a method to write the configuration in yaml to the method desired", "label": 1}, {"idx": "cosqa-train-16658", "doc": "print binary tree as it is in tree format python", "code": "def print_bintree(tree, indent='  '):\n    \"\"\"print a binary tree\"\"\"\n    for n in sorted(tree.keys()):\n        print \"%s%s\" % (indent * depth(n,tree), n)", "code_tokens": "def print_bintree ( tree , indent = '  ' ) : for n in sorted ( tree . keys ( ) ) : print \"%s%s\" % ( indent * depth ( n , tree ) , n )", "docstring_tokens": "print a binary tree", "label": 0}, {"idx": "cosqa-train-16659", "doc": "scaling your x axis to zoom in on a specific area python", "code": "def zoom(ax, xy='x', factor=1):\n    \"\"\"Zoom into axis.\n\n    Parameters\n    ----------\n    \"\"\"\n    limits = ax.get_xlim() if xy == 'x' else ax.get_ylim()\n    new_limits = (0.5*(limits[0] + limits[1])\n                  + 1./factor * np.array((-0.5, 0.5)) * (limits[1] - limits[0]))\n    if xy == 'x':\n        ax.set_xlim(new_limits)\n    else:\n        ax.set_ylim(new_limits)", "code_tokens": "def zoom ( ax , xy = 'x' , factor = 1 ) : limits = ax . get_xlim ( ) if xy == 'x' else ax . get_ylim ( ) new_limits = ( 0.5 * ( limits [ 0 ] + limits [ 1 ] ) + 1. / factor * np . array ( ( - 0.5 , 0.5 ) ) * ( limits [ 1 ] - limits [ 0 ] ) ) if xy == 'x' : ax . set_xlim ( new_limits ) else : ax . set_ylim ( new_limits )", "docstring_tokens": "Zoom into axis .", "label": 0}, {"idx": "cosqa-train-16660", "doc": "print not displaying anything in python\\", "code": "def raw_print(*args, **kw):\n    \"\"\"Raw print to sys.__stdout__, otherwise identical interface to print().\"\"\"\n\n    print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\\n'),\n          file=sys.__stdout__)\n    sys.__stdout__.flush()", "code_tokens": "def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "docstring_tokens": "Raw print to sys . __stdout__ otherwise identical interface to print () .", "label": 0}, {"idx": "cosqa-train-16661", "doc": "scintillanet autocomplete and calltip for ironpython", "code": "def page_guiref(arg_s=None):\n    \"\"\"Show a basic reference about the GUI Console.\"\"\"\n    from IPython.core import page\n    page.page(gui_reference, auto_html=True)", "code_tokens": "def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )", "docstring_tokens": "Show a basic reference about the GUI Console .", "label": 0}, {"idx": "cosqa-train-16662", "doc": "print ordered dict python", "code": "def pprint_for_ordereddict():\n    \"\"\"\n    Context manager that causes pprint() to print OrderedDict objects as nicely\n    as standard Python dictionary objects.\n    \"\"\"\n    od_saved = OrderedDict.__repr__\n    try:\n        OrderedDict.__repr__ = dict.__repr__\n        yield\n    finally:\n        OrderedDict.__repr__ = od_saved", "code_tokens": "def pprint_for_ordereddict ( ) : od_saved = OrderedDict . __repr__ try : OrderedDict . __repr__ = dict . __repr__ yield finally : OrderedDict . __repr__ = od_saved", "docstring_tokens": "Context manager that causes pprint () to print OrderedDict objects as nicely as standard Python dictionary objects .", "label": 1}, {"idx": "cosqa-train-16663", "doc": "scope of embedded python function", "code": "def ex(self, cmd):\n        \"\"\"Execute a normal python statement in user namespace.\"\"\"\n        with self.builtin_trap:\n            exec cmd in self.user_global_ns, self.user_ns", "code_tokens": "def ex ( self , cmd ) : with self . builtin_trap : exec cmd in self . user_global_ns , self . user_ns", "docstring_tokens": "Execute a normal python statement in user namespace .", "label": 0}, {"idx": "cosqa-train-16664", "doc": "print original url before redirect python requests", "code": "def geturl(self):\n        \"\"\"\n        Returns the URL that was the source of this response.\n        If the request that generated this response redirected, this method\n        will return the final redirect location.\n        \"\"\"\n        if self.retries is not None and len(self.retries.history):\n            return self.retries.history[-1].redirect_location\n        else:\n            return self._request_url", "code_tokens": "def geturl ( self ) : if self . retries is not None and len ( self . retries . history ) : return self . retries . history [ - 1 ] . redirect_location else : return self . _request_url", "docstring_tokens": "Returns the URL that was the source of this response . If the request that generated this response redirected this method will return the final redirect location .", "label": 0}, {"idx": "cosqa-train-16665", "doc": "seconds ago minus current python", "code": "def _elapsed(self):\n        \"\"\" Returns elapsed time at update. \"\"\"\n        self.last_time = time.time()\n        return self.last_time - self.start", "code_tokens": "def _elapsed ( self ) : self . last_time = time . time ( ) return self . last_time - self . start", "docstring_tokens": "Returns elapsed time at update .", "label": 0}, {"idx": "cosqa-train-16666", "doc": "print percent sign in format string python", "code": "def PythonPercentFormat(format_str):\n  \"\"\"Use Python % format strings as template format specifiers.\"\"\"\n\n  if format_str.startswith('printf '):\n    fmt = format_str[len('printf '):]\n    return lambda value: fmt % value\n  else:\n    return None", "code_tokens": "def PythonPercentFormat ( format_str ) : if format_str . startswith ( 'printf ' ) : fmt = format_str [ len ( 'printf ' ) : ] return lambda value : fmt % value else : return None", "docstring_tokens": "Use Python % format strings as template format specifiers .", "label": 0}, {"idx": "cosqa-train-16667", "doc": "select a certain number of cells in python sql access database", "code": "def rowlenselect(table, n, complement=False):\n    \"\"\"Select rows of length `n`.\"\"\"\n\n    where = lambda row: len(row) == n\n    return select(table, where, complement=complement)", "code_tokens": "def rowlenselect ( table , n , complement = False ) : where = lambda row : len ( row ) == n return select ( table , where , complement = complement )", "docstring_tokens": "Select rows of length n .", "label": 1}, {"idx": "cosqa-train-16668", "doc": "print the contents of an object in python", "code": "def _get_pretty_string(obj):\n    \"\"\"Return a prettier version of obj\n\n    Parameters\n    ----------\n    obj : object\n        Object to pretty print\n\n    Returns\n    -------\n    s : str\n        Pretty print object repr\n    \"\"\"\n    sio = StringIO()\n    pprint.pprint(obj, stream=sio)\n    return sio.getvalue()", "code_tokens": "def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )", "docstring_tokens": "Return a prettier version of obj", "label": 1}, {"idx": "cosqa-train-16669", "doc": "select a set of keys in a dictionary python", "code": "def _pick_attrs(attrs, keys):\n    \"\"\" Return attrs with keys in keys list\n    \"\"\"\n    return dict((k, v) for k, v in attrs.items() if k in keys)", "code_tokens": "def _pick_attrs ( attrs , keys ) : return dict ( ( k , v ) for k , v in attrs . items ( ) if k in keys )", "docstring_tokens": "Return attrs with keys in keys list", "label": 0}, {"idx": "cosqa-train-16670", "doc": "printing without ( in python 3", "code": "def _screen(self, s, newline=False):\n        \"\"\"Print something on screen when self.verbose == True\"\"\"\n        if self.verbose:\n            if newline:\n                print(s)\n            else:\n                print(s, end=' ')", "code_tokens": "def _screen ( self , s , newline = False ) : if self . verbose : if newline : print ( s ) else : print ( s , end = ' ' )", "docstring_tokens": "Print something on screen when self . verbose == True", "label": 0}, {"idx": "cosqa-train-16671", "doc": "sending an email with python using jinja template", "code": "def gen_text(env: TextIOBase, package: str, tmpl: str):\n    \"\"\"Create output from Jinja template.\"\"\"\n    if env:\n        env_args = json_datetime.load(env)\n    else:\n        env_args = {}\n    jinja_env = template.setup(package)\n    echo(jinja_env.get_template(tmpl).render(**env_args))", "code_tokens": "def gen_text ( env : TextIOBase , package : str , tmpl : str ) : if env : env_args = json_datetime . load ( env ) else : env_args = { } jinja_env = template . setup ( package ) echo ( jinja_env . get_template ( tmpl ) . render ( * * env_args ) )", "docstring_tokens": "Create output from Jinja template .", "label": 0}, {"idx": "cosqa-train-16672", "doc": "product of elements of a vector python", "code": "def dot_v3(v, w):\n    \"\"\"Return the dotproduct of two vectors.\"\"\"\n\n    return sum([x * y for x, y in zip(v, w)])", "code_tokens": "def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )", "docstring_tokens": "Return the dotproduct of two vectors .", "label": 0}, {"idx": "cosqa-train-16673", "doc": "session get requests not working python", "code": "def _get_url(url):\n    \"\"\"Retrieve requested URL\"\"\"\n    try:\n        data = HTTP_SESSION.get(url, stream=True)\n        data.raise_for_status()\n    except requests.exceptions.RequestException as exc:\n        raise FetcherException(exc)\n\n    return data", "code_tokens": "def _get_url ( url ) : try : data = HTTP_SESSION . get ( url , stream = True ) data . raise_for_status ( ) except requests . exceptions . RequestException as exc : raise FetcherException ( exc ) return data", "docstring_tokens": "Retrieve requested URL", "label": 0}, {"idx": "cosqa-train-16674", "doc": "set aspect ratio of image python", "code": "def image_set_aspect(aspect=1.0, axes=\"gca\"):\n    \"\"\"\n    sets the aspect ratio of the current zoom level of the imshow image\n    \"\"\"\n    if axes is \"gca\": axes = _pylab.gca()\n\n    e = axes.get_images()[0].get_extent()\n    axes.set_aspect(abs((e[1]-e[0])/(e[3]-e[2]))/aspect)", "code_tokens": "def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "docstring_tokens": "sets the aspect ratio of the current zoom level of the imshow image", "label": 0}, {"idx": "cosqa-train-16675", "doc": "prompt user input python3", "code": "def string_input(prompt=''):\n    \"\"\"Python 3 input()/Python 2 raw_input()\"\"\"\n    v = sys.version[0]\n    if v == '3':\n        return input(prompt)\n    else:\n        return raw_input(prompt)", "code_tokens": "def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )", "docstring_tokens": "Python 3 input () / Python 2 raw_input ()", "label": 1}, {"idx": "cosqa-train-16676", "doc": "set default encode python", "code": "def b(s):\n\t\"\"\" Encodes Unicode strings to byte strings, if necessary. \"\"\"\n\n\treturn s if isinstance(s, bytes) else s.encode(locale.getpreferredencoding())", "code_tokens": "def b ( s ) : return s if isinstance ( s , bytes ) else s . encode ( locale . getpreferredencoding ( ) )", "docstring_tokens": "Encodes Unicode strings to byte strings if necessary .", "label": 0}, {"idx": "cosqa-train-16677", "doc": "protobuf python dictionary of dictionary", "code": "def MessageToDict(message,\n                  including_default_value_fields=False,\n                  preserving_proto_field_name=False):\n  \"\"\"Converts protobuf message to a JSON dictionary.\n\n  Args:\n    message: The protocol buffers message instance to serialize.\n    including_default_value_fields: If True, singular primitive fields,\n        repeated fields, and map fields will always be serialized.  If\n        False, only serialize non-empty fields.  Singular message fields\n        and oneof fields are not affected by this option.\n    preserving_proto_field_name: If True, use the original proto field\n        names as defined in the .proto file. If False, convert the field\n        names to lowerCamelCase.\n\n  Returns:\n    A dict representation of the JSON formatted protocol buffer message.\n  \"\"\"\n  printer = _Printer(including_default_value_fields,\n                     preserving_proto_field_name)\n  # pylint: disable=protected-access\n  return printer._MessageToJsonObject(message)", "code_tokens": "def MessageToDict ( message , including_default_value_fields = False , preserving_proto_field_name = False ) : printer = _Printer ( including_default_value_fields , preserving_proto_field_name ) # pylint: disable=protected-access return printer . _MessageToJsonObject ( message )", "docstring_tokens": "Converts protobuf message to a JSON dictionary .", "label": 1}, {"idx": "cosqa-train-16678", "doc": "set pixels in a color in python", "code": "def setPixel(self, x, y, color):\n        \"\"\"Set the pixel at (x,y) to the integers in sequence 'color'.\"\"\"\n        return _fitz.Pixmap_setPixel(self, x, y, color)", "code_tokens": "def setPixel ( self , x , y , color ) : return _fitz . Pixmap_setPixel ( self , x , y , color )", "docstring_tokens": "Set the pixel at ( x y ) to the integers in sequence color .", "label": 0}, {"idx": "cosqa-train-16679", "doc": "protobuf python get filed by name", "code": "def _GetFieldByName(message_descriptor, field_name):\n  \"\"\"Returns a field descriptor by field name.\n\n  Args:\n    message_descriptor: A Descriptor describing all fields in message.\n    field_name: The name of the field to retrieve.\n  Returns:\n    The field descriptor associated with the field name.\n  \"\"\"\n  try:\n    return message_descriptor.fields_by_name[field_name]\n  except KeyError:\n    raise ValueError('Protocol message %s has no \"%s\" field.' %\n                     (message_descriptor.name, field_name))", "code_tokens": "def _GetFieldByName ( message_descriptor , field_name ) : try : return message_descriptor . fields_by_name [ field_name ] except KeyError : raise ValueError ( 'Protocol message %s has no \"%s\" field.' % ( message_descriptor . name , field_name ) )", "docstring_tokens": "Returns a field descriptor by field name .", "label": 1}, {"idx": "cosqa-train-16680", "doc": "set proxy tunnel for urllib python", "code": "def _prepare_proxy(self, conn):\n        \"\"\"\n        Establish tunnel connection early, because otherwise httplib\n        would improperly set Host: header to proxy's IP:port.\n        \"\"\"\n        conn.set_tunnel(self._proxy_host, self.port, self.proxy_headers)\n        conn.connect()", "code_tokens": "def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )", "docstring_tokens": "Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port .", "label": 0}, {"idx": "cosqa-train-16681", "doc": "protobuf python pass grpc dict", "code": "def toJson(protoObject, indent=None):\n    \"\"\"\n    Serialises a protobuf object as json\n    \"\"\"\n    # Using the internal method because this way we can reformat the JSON\n    js = json_format.MessageToDict(protoObject, False)\n    return json.dumps(js, indent=indent)", "code_tokens": "def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )", "docstring_tokens": "Serialises a protobuf object as json", "label": 0}, {"idx": "cosqa-train-16682", "doc": "set tickhow to keep one of axes empty python", "code": "def clear_matplotlib_ticks(self, axis=\"both\"):\n        \"\"\"Clears the default matplotlib ticks.\"\"\"\n        ax = self.get_axes()\n        plotting.clear_matplotlib_ticks(ax=ax, axis=axis)", "code_tokens": "def clear_matplotlib_ticks ( self , axis = \"both\" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )", "docstring_tokens": "Clears the default matplotlib ticks .", "label": 0}, {"idx": "cosqa-train-16683", "doc": "pulling most recent file from directory python", "code": "def newest_file(file_iterable):\n  \"\"\"\n  Returns the name of the newest file given an iterable of file names.\n\n  \"\"\"\n  return max(file_iterable, key=lambda fname: os.path.getmtime(fname))", "code_tokens": "def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "docstring_tokens": "Returns the name of the newest file given an iterable of file names .", "label": 0}, {"idx": "cosqa-train-16684", "doc": "setattr in python using kwargs", "code": "def update(self, **kwargs):\n    \"\"\"Creates or updates a property for the instance for each parameter.\"\"\"\n    for key, value in kwargs.items():\n      setattr(self, key, value)", "code_tokens": "def update ( self , * * kwargs ) : for key , value in kwargs . items ( ) : setattr ( self , key , value )", "docstring_tokens": "Creates or updates a property for the instance for each parameter .", "label": 0}, {"idx": "cosqa-train-16685", "doc": "putting a hashtag on each line in python", "code": "def _add_hash(source):\n    \"\"\"Add a leading hash '#' at the beginning of every line in the source.\"\"\"\n    source = '\\n'.join('# ' + line.rstrip()\n                       for line in source.splitlines())\n    return source", "code_tokens": "def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "docstring_tokens": "Add a leading hash # at the beginning of every line in the source .", "label": 0}, {"idx": "cosqa-train-16686", "doc": "shaded rectangle in lines in python", "code": "def hline(self, x, y, width, color):\n        \"\"\"Draw a horizontal line up to a given length.\"\"\"\n        self.rect(x, y, width, 1, color, fill=True)", "code_tokens": "def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )", "docstring_tokens": "Draw a horizontal line up to a given length .", "label": 0}, {"idx": "cosqa-train-16687", "doc": "putting a string into a set number of characters in python", "code": "def make_unique_ngrams(s, n):\n    \"\"\"Make a set of unique n-grams from a string.\"\"\"\n    return set(s[i:i + n] for i in range(len(s) - n + 1))", "code_tokens": "def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )", "docstring_tokens": "Make a set of unique n - grams from a string .", "label": 1}, {"idx": "cosqa-train-16688", "doc": "show attributes of python object", "code": "def _repr(obj):\n    \"\"\"Show the received object as precise as possible.\"\"\"\n    vals = \", \".join(\"{}={!r}\".format(\n        name, getattr(obj, name)) for name in obj._attribs)\n    if vals:\n        t = \"{}(name={}, {})\".format(obj.__class__.__name__, obj.name, vals)\n    else:\n        t = \"{}(name={})\".format(obj.__class__.__name__, obj.name)\n    return t", "code_tokens": "def _repr ( obj ) : vals = \", \" . join ( \"{}={!r}\" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = \"{}(name={}, {})\" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = \"{}(name={})\" . format ( obj . __class__ . __name__ , obj . name ) return t", "docstring_tokens": "Show the received object as precise as possible .", "label": 1}, {"idx": "cosqa-train-16689", "doc": "pybind11 get address of c++ object from python", "code": "def objectproxy_realaddress(obj):\n    \"\"\"\n    Obtain a real address as an integer from an objectproxy.\n    \"\"\"\n    voidp = QROOT.TPython.ObjectProxy_AsVoidPtr(obj)\n    return C.addressof(C.c_char.from_buffer(voidp))", "code_tokens": "def objectproxy_realaddress ( obj ) : voidp = QROOT . TPython . ObjectProxy_AsVoidPtr ( obj ) return C . addressof ( C . c_char . from_buffer ( voidp ) )", "docstring_tokens": "Obtain a real address as an integer from an objectproxy .", "label": 0}, {"idx": "cosqa-train-16690", "doc": "show legend for matplotlib in python", "code": "def finish_plot():\n    \"\"\"Helper for plotting.\"\"\"\n    plt.legend()\n    plt.grid(color='0.7')\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.show()", "code_tokens": "def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )", "docstring_tokens": "Helper for plotting .", "label": 0}, {"idx": "cosqa-train-16691", "doc": "pypdf2 reading all pdf pages python", "code": "def resources(self):\n        \"\"\"Retrieve contents of each page of PDF\"\"\"\n        return [self.pdf.getPage(i) for i in range(self.pdf.getNumPages())]", "code_tokens": "def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "docstring_tokens": "Retrieve contents of each page of PDF", "label": 0}, {"idx": "cosqa-train-16692", "doc": "signed angle between vectors python", "code": "def smallest_signed_angle(source, target):\n    \"\"\"Find the smallest angle going from angle `source` to angle `target`.\"\"\"\n    dth = target - source\n    dth = (dth + np.pi) % (2.0 * np.pi) - np.pi\n    return dth", "code_tokens": "def smallest_signed_angle ( source , target ) : dth = target - source dth = ( dth + np . pi ) % ( 2.0 * np . pi ) - np . pi return dth", "docstring_tokens": "Find the smallest angle going from angle source to angle target .", "label": 0}, {"idx": "cosqa-train-16693", "doc": "pyside python close event", "code": "def closeEvent(self, event):\n        \"\"\"closeEvent reimplementation\"\"\"\n        if self.closing(True):\n            event.accept()\n        else:\n            event.ignore()", "code_tokens": "def closeEvent ( self , event ) : if self . closing ( True ) : event . accept ( ) else : event . ignore ( )", "docstring_tokens": "closeEvent reimplementation", "label": 1}, {"idx": "cosqa-train-16694", "doc": "simplest way to calculate l2 distance between two points in python", "code": "def distance_to_line(a, b, p):\n    \"\"\"Closest distance between a line segment and a point\n\n    Args:\n        a ([float, float]): x and y coordinates. Line start\n        b ([float, float]): x and y coordinates. Line end\n        p ([float, float]): x and y coordinates. Point to compute the distance\n    Returns:\n        float\n    \"\"\"\n    return distance(closest_point(a, b, p), p)", "code_tokens": "def distance_to_line ( a , b , p ) : return distance ( closest_point ( a , b , p ) , p )", "docstring_tokens": "Closest distance between a line segment and a point", "label": 0}, {"idx": "cosqa-train-16695", "doc": "python 'jsonify' is not defined", "code": "def dump_json(obj):\n    \"\"\"Dump Python object as JSON string.\"\"\"\n    return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)", "code_tokens": "def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )", "docstring_tokens": "Dump Python object as JSON string .", "label": 0}, {"idx": "cosqa-train-16696", "doc": "sine wave with python", "code": "def sine_wave(frequency):\n  \"\"\"Emit a sine wave at the given frequency.\"\"\"\n  xs = tf.reshape(tf.range(_samples(), dtype=tf.float32), [1, _samples(), 1])\n  ts = xs / FLAGS.sample_rate\n  return tf.sin(2 * math.pi * frequency * ts)", "code_tokens": "def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "docstring_tokens": "Emit a sine wave at the given frequency .", "label": 0}, {"idx": "cosqa-train-16697", "doc": "python 'prompt' is not defined", "code": "def string_input(prompt=''):\n    \"\"\"Python 3 input()/Python 2 raw_input()\"\"\"\n    v = sys.version[0]\n    if v == '3':\n        return input(prompt)\n    else:\n        return raw_input(prompt)", "code_tokens": "def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )", "docstring_tokens": "Python 3 input () / Python 2 raw_input ()", "label": 1}, {"idx": "cosqa-train-16698", "doc": "singular matrixsingular matrix in python", "code": "def full_s(self):\n        \"\"\" Get the full singular value matrix of self\n\n        Returns\n        -------\n        Matrix : Matrix\n\n        \"\"\"\n        x = np.zeros((self.shape),dtype=np.float32)\n\n        x[:self.s.shape[0],:self.s.shape[0]] = self.s.as_2d\n        s = Matrix(x=x, row_names=self.row_names,\n                          col_names=self.col_names, isdiagonal=False,\n                          autoalign=False)\n        return s", "code_tokens": "def full_s ( self ) : x = np . zeros ( ( self . shape ) , dtype = np . float32 ) x [ : self . s . shape [ 0 ] , : self . s . shape [ 0 ] ] = self . s . as_2d s = Matrix ( x = x , row_names = self . row_names , col_names = self . col_names , isdiagonal = False , autoalign = False ) return s", "docstring_tokens": "Get the full singular value matrix of self", "label": 1}, {"idx": "cosqa-train-16699", "doc": "python 'symbol' object is not subscriptable", "code": "def bound_symbols(self):\n        \"\"\"Set of bound SymPy symbols contained within the equation.\"\"\"\n        try:\n            lhs_syms = self.lhs.bound_symbols\n        except AttributeError:\n            lhs_syms = set()\n        try:\n            rhs_syms = self.rhs.bound_symbols\n        except AttributeError:\n            rhs_syms = set()\n        return lhs_syms | rhs_syms", "code_tokens": "def bound_symbols ( self ) : try : lhs_syms = self . lhs . bound_symbols except AttributeError : lhs_syms = set ( ) try : rhs_syms = self . rhs . bound_symbols except AttributeError : rhs_syms = set ( ) return lhs_syms | rhs_syms", "docstring_tokens": "Set of bound SymPy symbols contained within the equation .", "label": 0}, {"idx": "cosqa-train-16700", "doc": "size dimension of list python", "code": "def get_dimension_array(array):\n    \"\"\"\n    Get dimension of an array getting the number of rows and the max num of\n    columns.\n    \"\"\"\n    if all(isinstance(el, list) for el in array):\n        result = [len(array), len(max([x for x in array], key=len,))]\n\n    # elif array and isinstance(array, list):\n    else:\n        result = [len(array), 1]\n\n    return result", "code_tokens": "def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result", "docstring_tokens": "Get dimension of an array getting the number of rows and the max num of columns .", "label": 0}, {"idx": "cosqa-train-16701", "doc": "python 1 element array to scalar", "code": "def is_scalar(value):\n    \"\"\"Test if the given value is a scalar.\n\n    This function also works with memory mapped array values, in contrast to the numpy is_scalar method.\n\n    Args:\n        value: the value to test for being a scalar value\n\n    Returns:\n        boolean: if the given value is a scalar or not\n    \"\"\"\n    return np.isscalar(value) or (isinstance(value, np.ndarray) and (len(np.squeeze(value).shape) == 0))", "code_tokens": "def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )", "docstring_tokens": "Test if the given value is a scalar .", "label": 0}, {"idx": "cosqa-train-16702", "doc": "size limit of a function python", "code": "def calculate_size(name, function):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += calculate_size_data(function)\n    return data_size", "code_tokens": "def calculate_size ( name , function ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += calculate_size_data ( function ) return data_size", "docstring_tokens": "Calculates the request payload size", "label": 1}, {"idx": "cosqa-train-16703", "doc": "python 2 dimensional array access with an array", "code": "def _transform_triple_numpy(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "code_tokens": "def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "docstring_tokens": "Transform triple index into a 1 - D numpy array .", "label": 1}, {"idx": "cosqa-train-16704", "doc": "slicing in 2d list python", "code": "def iget_list_column_slice(list_, start=None, stop=None, stride=None):\n    \"\"\" iterator version of get_list_column \"\"\"\n    if isinstance(start, slice):\n        slice_ = start\n    else:\n        slice_ = slice(start, stop, stride)\n    return (row[slice_] for row in list_)", "code_tokens": "def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "docstring_tokens": "iterator version of get_list_column", "label": 0}, {"idx": "cosqa-train-16705", "doc": "python 2 round float", "code": "def py3round(number):\n    \"\"\"Unified rounding in all python versions.\"\"\"\n    if abs(round(number) - number) == 0.5:\n        return int(2.0 * round(number / 2.0))\n\n    return int(round(number))", "code_tokens": "def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "docstring_tokens": "Unified rounding in all python versions .", "label": 0}, {"idx": "cosqa-train-16706", "doc": "solve power matrix function python", "code": "def MatrixSolve(a, rhs, adj):\n    \"\"\"\n    Matrix solve op.\n    \"\"\"\n    return np.linalg.solve(a if not adj else _adjoint(a), rhs),", "code_tokens": "def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "docstring_tokens": "Matrix solve op .", "label": 1}, {"idx": "cosqa-train-16707", "doc": "python 2 round up float", "code": "def py3round(number):\n    \"\"\"Unified rounding in all python versions.\"\"\"\n    if abs(round(number) - number) == 0.5:\n        return int(2.0 * round(number / 2.0))\n\n    return int(round(number))", "code_tokens": "def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "docstring_tokens": "Unified rounding in all python versions .", "label": 0}, {"idx": "cosqa-train-16708", "doc": "sort a number by its digits python", "code": "def naturalsortkey(s):\n    \"\"\"Natural sort order\"\"\"\n    return [int(part) if part.isdigit() else part\n            for part in re.split('([0-9]+)', s)]", "code_tokens": "def naturalsortkey ( s ) : return [ int ( part ) if part . isdigit ( ) else part for part in re . split ( '([0-9]+)' , s ) ]", "docstring_tokens": "Natural sort order", "label": 0}, {"idx": "cosqa-train-16709", "doc": "python 2d array to dict", "code": "def to_dicts(recarray):\n    \"\"\"convert record array to a dictionaries\"\"\"\n    for rec in recarray:\n        yield dict(zip(recarray.dtype.names, rec.tolist()))", "code_tokens": "def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )", "docstring_tokens": "convert record array to a dictionaries", "label": 1}, {"idx": "cosqa-train-16710", "doc": "sort and uniq list in python", "code": "def unique_list(lst):\n    \"\"\"Make a list unique, retaining order of initial appearance.\"\"\"\n    uniq = []\n    for item in lst:\n        if item not in uniq:\n            uniq.append(item)\n    return uniq", "code_tokens": "def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq", "docstring_tokens": "Make a list unique retaining order of initial appearance .", "label": 0}, {"idx": "cosqa-train-16711", "doc": "python 2d vector rotate angle", "code": "def create_rot2d(angle):\n    \"\"\"Create 2D rotation matrix\"\"\"\n    ca = math.cos(angle)\n    sa = math.sin(angle)\n    return np.array([[ca, -sa], [sa, ca]])", "code_tokens": "def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )", "docstring_tokens": "Create 2D rotation matrix", "label": 1}, {"idx": "cosqa-train-16712", "doc": "sort digits in an integer by digit in python", "code": "def naturalsortkey(s):\n    \"\"\"Natural sort order\"\"\"\n    return [int(part) if part.isdigit() else part\n            for part in re.split('([0-9]+)', s)]", "code_tokens": "def naturalsortkey ( s ) : return [ int ( part ) if part . isdigit ( ) else part for part in re . split ( '([0-9]+)' , s ) ]", "docstring_tokens": "Natural sort order", "label": 0}, {"idx": "cosqa-train-16713", "doc": "python 2to3 whole directory", "code": "def command_py2to3(args):\n    \"\"\"\n    Apply '2to3' tool (Python2 to Python3 conversion tool) to Python sources.\n    \"\"\"\n    from lib2to3.main import main\n    sys.exit(main(\"lib2to3.fixes\", args=args.sources))", "code_tokens": "def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( \"lib2to3.fixes\" , args = args . sources ) )", "docstring_tokens": "Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources .", "label": 1}, {"idx": "cosqa-train-16714", "doc": "sort digits in an integer in python", "code": "def naturalsortkey(s):\n    \"\"\"Natural sort order\"\"\"\n    return [int(part) if part.isdigit() else part\n            for part in re.split('([0-9]+)', s)]", "code_tokens": "def naturalsortkey ( s ) : return [ int ( part ) if part . isdigit ( ) else part for part in re . split ( '([0-9]+)' , s ) ]", "docstring_tokens": "Natural sort order", "label": 0}, {"idx": "cosqa-train-16715", "doc": "python 3 cast bytes to str", "code": "def ub_to_str(string):\n    \"\"\"\n    converts py2 unicode / py3 bytestring into str\n    Args:\n        string (unicode, byte_string): string to be converted\n        \n    Returns:\n        (str)\n    \"\"\"\n    if not isinstance(string, str):\n        if six.PY2:\n            return str(string)\n        else:\n            return string.decode()\n    return string", "code_tokens": "def ub_to_str ( string ) : if not isinstance ( string , str ) : if six . PY2 : return str ( string ) else : return string . decode ( ) return string", "docstring_tokens": "converts py2 unicode / py3 bytestring into str Args : string ( unicode byte_string ) : string to be converted Returns : ( str )", "label": 0}, {"idx": "cosqa-train-16716", "doc": "sort list by name python", "code": "def sort_by_name(self):\n        \"\"\"Sort list elements by name.\"\"\"\n        super(JSSObjectList, self).sort(key=lambda k: k.name)", "code_tokens": "def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "docstring_tokens": "Sort list elements by name .", "label": 0}, {"idx": "cosqa-train-16717", "doc": "python 3 change permission of file chmod", "code": "def add_exec_permission_to(target_file):\n    \"\"\"Add executable permissions to the file\n\n    :param target_file: the target file whose permission to be changed\n    \"\"\"\n    mode = os.stat(target_file).st_mode\n    os.chmod(target_file, mode | stat.S_IXUSR)", "code_tokens": "def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )", "docstring_tokens": "Add executable permissions to the file", "label": 1}, {"idx": "cosqa-train-16718", "doc": "specify bins in python 2d histogram", "code": "def _histplot_bins(column, bins=100):\n    \"\"\"Helper to get bins for histplot.\"\"\"\n    col_min = np.min(column)\n    col_max = np.max(column)\n    return range(col_min, col_max + 2, max((col_max - col_min) // bins, 1))", "code_tokens": "def _histplot_bins ( column , bins = 100 ) : col_min = np . min ( column ) col_max = np . max ( column ) return range ( col_min , col_max + 2 , max ( ( col_max - col_min ) // bins , 1 ) )", "docstring_tokens": "Helper to get bins for histplot .", "label": 1}, {"idx": "cosqa-train-16719", "doc": "python 3 close socket", "code": "def socket_close(self):\n        \"\"\"Close our socket.\"\"\"\n        if self.sock != NC.INVALID_SOCKET:\n            self.sock.close()\n        self.sock = NC.INVALID_SOCKET", "code_tokens": "def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET", "docstring_tokens": "Close our socket .", "label": 1}, {"idx": "cosqa-train-16720", "doc": "split a string into 5 equal size chunks in python", "code": "def schunk(string, size):\n    \"\"\"Splits string into n sized chunks.\"\"\"\n    return [string[i:i+size] for i in range(0, len(string), size)]", "code_tokens": "def schunk ( string , size ) : return [ string [ i : i + size ] for i in range ( 0 , len ( string ) , size ) ]", "docstring_tokens": "Splits string into n sized chunks .", "label": 0}, {"idx": "cosqa-train-16721", "doc": "python 3 cursor fetch data as dict", "code": "def _dictfetchall(self, cursor):\n        \"\"\" Return all rows from a cursor as a dict. \"\"\"\n        columns = [col[0] for col in cursor.description]\n        return [\n            dict(zip(columns, row))\n            for row in cursor.fetchall()\n        ]", "code_tokens": "def _dictfetchall ( self , cursor ) : columns = [ col [ 0 ] for col in cursor . description ] return [ dict ( zip ( columns , row ) ) for row in cursor . fetchall ( ) ]", "docstring_tokens": "Return all rows from a cursor as a dict .", "label": 0}, {"idx": "cosqa-train-16722", "doc": "split based on multiple characters in python", "code": "def _split(string, splitters):\n    \"\"\"Splits a string into parts at multiple characters\"\"\"\n    part = ''\n    for character in string:\n        if character in splitters:\n            yield part\n            part = ''\n        else:\n            part += character\n    yield part", "code_tokens": "def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part", "docstring_tokens": "Splits a string into parts at multiple characters", "label": 1}, {"idx": "cosqa-train-16723", "doc": "python 3 determine mime type of file", "code": "def guess_media_type(filepath):\n    \"\"\"Returns the media-type of the file at the given ``filepath``\"\"\"\n    o = subprocess.check_output(['file', '--mime-type', '-Lb', filepath])\n    o = o.strip()\n    return o", "code_tokens": "def guess_media_type ( filepath ) : o = subprocess . check_output ( [ 'file' , '--mime-type' , '-Lb' , filepath ] ) o = o . strip ( ) return o", "docstring_tokens": "Returns the media - type of the file at the given filepath", "label": 0}, {"idx": "cosqa-train-16724", "doc": "split function in python for every character", "code": "def _split(string, splitters):\n    \"\"\"Splits a string into parts at multiple characters\"\"\"\n    part = ''\n    for character in string:\n        if character in splitters:\n            yield part\n            part = ''\n        else:\n            part += character\n    yield part", "code_tokens": "def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part", "docstring_tokens": "Splits a string into parts at multiple characters", "label": 0}, {"idx": "cosqa-train-16725", "doc": "python 3 get mouse position", "code": "def mouse_get_pos():\n    \"\"\"\n\n    :return:\n    \"\"\"\n    p = POINT()\n    AUTO_IT.AU3_MouseGetPos(ctypes.byref(p))\n    return p.x, p.y", "code_tokens": "def mouse_get_pos ( ) : p = POINT ( ) AUTO_IT . AU3_MouseGetPos ( ctypes . byref ( p ) ) return p . x , p . y", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-16726", "doc": "split lines with no newlines character python", "code": "def cleanLines(source, lineSep=os.linesep):\n    \"\"\"\n    :param source: some iterable source (list, file, etc)\n    :param lineSep: string of separators (chars) that must be removed\n    :return: list of non empty lines with removed separators\n    \"\"\"\n    stripped = (line.strip(lineSep) for line in source)\n    return (line for line in stripped if len(line) != 0)", "code_tokens": "def cleanLines ( source , lineSep = os . linesep ) : stripped = ( line . strip ( lineSep ) for line in source ) return ( line for line in stripped if len ( line ) != 0 )", "docstring_tokens": ": param source : some iterable source ( list file etc ) : param lineSep : string of separators ( chars ) that must be removed : return : list of non empty lines with removed separators", "label": 0}, {"idx": "cosqa-train-16727", "doc": "python 3 get user and password from a file", "code": "def read_credentials(fname):\n    \"\"\"\n    read a simple text file from a private location to get\n    username and password\n    \"\"\"\n    with open(fname, 'r') as f:\n        username = f.readline().strip('\\n')\n        password = f.readline().strip('\\n')\n    return username, password", "code_tokens": "def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "docstring_tokens": "read a simple text file from a private location to get username and password", "label": 0}, {"idx": "cosqa-train-16728", "doc": "split the string into pairs python", "code": "def _parse_string_to_list_of_pairs(s, seconds_to_int=False):\n  r\"\"\"Parses a string into a list of pairs.\n\n  In the input string, each pair is separated by a colon, and the delimiters\n  between pairs are any of \" ,.;\".\n\n  e.g. \"rows:32,cols:32\"\n\n  Args:\n    s: str to parse.\n    seconds_to_int: Boolean. If True, then the second elements are returned\n      as integers;  otherwise they are strings.\n\n  Returns:\n    List of tuple pairs.\n\n  Raises:\n    ValueError: Badly formatted string.\n  \"\"\"\n  ret = []\n  for p in [s.split(\":\") for s in re.sub(\"[,.;]\", \" \", s).split()]:\n    if len(p) != 2:\n      raise ValueError(\"bad input to _parse_string_to_list_of_pairs %s\" % s)\n    if seconds_to_int:\n      ret.append((p[0], int(p[1])))\n    else:\n      ret.append(tuple(p))\n  return ret", "code_tokens": "def _parse_string_to_list_of_pairs ( s , seconds_to_int = False ) : ret = [ ] for p in [ s . split ( \":\" ) for s in re . sub ( \"[,.;]\" , \" \" , s ) . split ( ) ] : if len ( p ) != 2 : raise ValueError ( \"bad input to _parse_string_to_list_of_pairs %s\" % s ) if seconds_to_int : ret . append ( ( p [ 0 ] , int ( p [ 1 ] ) ) ) else : ret . append ( tuple ( p ) ) return ret", "docstring_tokens": "r Parses a string into a list of pairs .", "label": 1}, {"idx": "cosqa-train-16729", "doc": "python 3 how to return local variable to global stack", "code": "def _get_or_create_stack(name):\n  \"\"\"Returns a thread local stack uniquified by the given name.\"\"\"\n  stack = getattr(_LOCAL_STACKS, name, None)\n  if stack is None:\n    stack = []\n    setattr(_LOCAL_STACKS, name, stack)\n  return stack", "code_tokens": "def _get_or_create_stack ( name ) : stack = getattr ( _LOCAL_STACKS , name , None ) if stack is None : stack = [ ] setattr ( _LOCAL_STACKS , name , stack ) return stack", "docstring_tokens": "Returns a thread local stack uniquified by the given name .", "label": 1}, {"idx": "cosqa-train-16730", "doc": "splitting an array in python into chunks", "code": "def chunks(arr, size):\n    \"\"\"Splits a list into chunks\n\n    :param arr: list to split\n    :type arr: :class:`list`\n    :param size: number of elements in each chunk\n    :type size: :class:`int`\n    :return: generator object\n    :rtype: :class:`generator`\n    \"\"\"\n    for i in _range(0, len(arr), size):\n        yield arr[i:i+size]", "code_tokens": "def chunks ( arr , size ) : for i in _range ( 0 , len ( arr ) , size ) : yield arr [ i : i + size ]", "docstring_tokens": "Splits a list into chunks", "label": 0}, {"idx": "cosqa-train-16731", "doc": "python 3 logging findcaller", "code": "def calling_logger(height=1):\n    \"\"\" Obtain a logger for the calling module.\n\n    Uses the inspect module to find the name of the calling function and its\n    position in the module hierarchy. With the optional height argument, logs\n    for caller's caller, and so forth.\n\n    see: http://stackoverflow.com/a/900404/48251\n    \"\"\"\n    stack = inspect.stack()\n    height = min(len(stack) - 1, height)\n    caller = stack[height]\n    scope = caller[0].f_globals\n    path = scope['__name__']\n    if path == '__main__':\n        path = scope['__package__'] or os.path.basename(sys.argv[0])\n    return logging.getLogger(path)", "code_tokens": "def calling_logger ( height = 1 ) : stack = inspect . stack ( ) height = min ( len ( stack ) - 1 , height ) caller = stack [ height ] scope = caller [ 0 ] . f_globals path = scope [ '__name__' ] if path == '__main__' : path = scope [ '__package__' ] or os . path . basename ( sys . argv [ 0 ] ) return logging . getLogger ( path )", "docstring_tokens": "Obtain a logger for the calling module .", "label": 0}, {"idx": "cosqa-train-16732", "doc": "sql server stored procedure python param out", "code": "def callproc(self, name, params, param_types=None):\n    \"\"\"Calls a procedure.\n\n    :param name: the name of the procedure\n    :param params: a list or tuple of parameters to pass to the procedure.\n    :param param_types: a list or tuple of type names. If given, each param will be cast via\n                        sql_writers typecast method. This is useful to disambiguate procedure calls\n                        when several parameters are null and therefore cause overload resoluation\n                        issues.\n    :return: a 2-tuple of (cursor, params)\n    \"\"\"\n\n    if param_types:\n      placeholders = [self.sql_writer.typecast(self.sql_writer.to_placeholder(), t)\n                      for t in param_types]\n    else:\n      placeholders = [self.sql_writer.to_placeholder() for p in params]\n\n    # TODO: This may be Postgres specific...\n    qs = \"select * from {0}({1});\".format(name, \", \".join(placeholders))\n    return self.execute(qs, params), params", "code_tokens": "def callproc ( self , name , params , param_types = None ) : if param_types : placeholders = [ self . sql_writer . typecast ( self . sql_writer . to_placeholder ( ) , t ) for t in param_types ] else : placeholders = [ self . sql_writer . to_placeholder ( ) for p in params ] # TODO: This may be Postgres specific... qs = \"select * from {0}({1});\" . format ( name , \", \" . join ( placeholders ) ) return self . execute ( qs , params ) , params", "docstring_tokens": "Calls a procedure .", "label": 1}, {"idx": "cosqa-train-16733", "doc": "python 3 make an iterable", "code": "def force_iterable(f):\n    \"\"\"Will make any functions return an iterable objects by wrapping its result in a list.\"\"\"\n    def wrapper(*args, **kwargs):\n        r = f(*args, **kwargs)\n        if hasattr(r, '__iter__'):\n            return r\n        else:\n            return [r]\n    return wrapper", "code_tokens": "def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper", "docstring_tokens": "Will make any functions return an iterable objects by wrapping its result in a list .", "label": 1}, {"idx": "cosqa-train-16734", "doc": "sqlite python delete all rows", "code": "def wipe(self):\n        \"\"\" Wipe the store\n        \"\"\"\n        query = \"DELETE FROM {}\".format(self.__tablename__)\n        connection = sqlite3.connect(self.sqlite_file)\n        cursor = connection.cursor()\n        cursor.execute(query)\n        connection.commit()", "code_tokens": "def wipe ( self ) : query = \"DELETE FROM {}\" . format ( self . __tablename__ ) connection = sqlite3 . connect ( self . sqlite_file ) cursor = connection . cursor ( ) cursor . execute ( query ) connection . commit ( )", "docstring_tokens": "Wipe the store", "label": 0}, {"idx": "cosqa-train-16735", "doc": "python 3 non blocking user input", "code": "async def async_input(prompt):\n    \"\"\"\n    Python's ``input()`` is blocking, which means the event loop we set\n    above can't be running while we're blocking there. This method will\n    let the loop run while we wait for input.\n    \"\"\"\n    print(prompt, end='', flush=True)\n    return (await loop.run_in_executor(None, sys.stdin.readline)).rstrip()", "code_tokens": "async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "docstring_tokens": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .", "label": 0}, {"idx": "cosqa-train-16736", "doc": "python 3 object of type 'bytes' is not json serializable", "code": "def loadb(b):\n    \"\"\"Deserialize ``b`` (instance of ``bytes``) to a Python object.\"\"\"\n    assert isinstance(b, (bytes, bytearray))\n    return std_json.loads(b.decode('utf-8'))", "code_tokens": "def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "docstring_tokens": "Deserialize b ( instance of bytes ) to a Python object .", "label": 0}, {"idx": "cosqa-train-16737", "doc": "stack and heap in python 3", "code": "def _heapify_max(x):\n    \"\"\"Transform list into a maxheap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    for i in reversed(range(n//2)):\n        _siftup_max(x, i)", "code_tokens": "def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )", "docstring_tokens": "Transform list into a maxheap in - place in O ( len ( x )) time .", "label": 0}, {"idx": "cosqa-train-16738", "doc": "python 3 remove commas in list", "code": "def readCommaList(fileList):\n    \"\"\" Return a list of the files with the commas removed. \"\"\"\n    names=fileList.split(',')\n    fileList=[]\n    for item in names:\n        fileList.append(item)\n    return fileList", "code_tokens": "def readCommaList ( fileList ) : names = fileList . split ( ',' ) fileList = [ ] for item in names : fileList . append ( item ) return fileList", "docstring_tokens": "Return a list of the files with the commas removed .", "label": 1}, {"idx": "cosqa-train-16739", "doc": "stack overflow python object to json", "code": "def dumps(obj):\n    \"\"\"Outputs json with formatting edits + object handling.\"\"\"\n    return json.dumps(obj, indent=4, sort_keys=True, cls=CustomEncoder)", "code_tokens": "def dumps ( obj ) : return json . dumps ( obj , indent = 4 , sort_keys = True , cls = CustomEncoder )", "docstring_tokens": "Outputs json with formatting edits + object handling .", "label": 0}, {"idx": "cosqa-train-16740", "doc": "python 3 strip enclosing quotes from string", "code": "def _repr_strip(mystring):\n    \"\"\"\n    Returns the string without any initial or final quotes.\n    \"\"\"\n    r = repr(mystring)\n    if r.startswith(\"'\") and r.endswith(\"'\"):\n        return r[1:-1]\n    else:\n        return r", "code_tokens": "def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "docstring_tokens": "Returns the string without any initial or final quotes .", "label": 0}, {"idx": "cosqa-train-16741", "doc": "stackoverflow max value python list", "code": "def _heapify_max(x):\n    \"\"\"Transform list into a maxheap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    for i in reversed(range(n//2)):\n        _siftup_max(x, i)", "code_tokens": "def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )", "docstring_tokens": "Transform list into a maxheap in - place in O ( len ( x )) time .", "label": 0}, {"idx": "cosqa-train-16742", "doc": "python 3d plot set view to y and z", "code": "def surface(self, zdata, **kwargs):\n        \"\"\"Show a 3D surface plot.\n\n        Extra keyword arguments are passed to `SurfacePlot()`.\n\n        Parameters\n        ----------\n        zdata : array-like\n            A 2D array of the surface Z values.\n\n        \"\"\"\n        self._configure_3d()\n        surf = scene.SurfacePlot(z=zdata, **kwargs)\n        self.view.add(surf)\n        self.view.camera.set_range()\n        return surf", "code_tokens": "def surface ( self , zdata , * * kwargs ) : self . _configure_3d ( ) surf = scene . SurfacePlot ( z = zdata , * * kwargs ) self . view . add ( surf ) self . view . camera . set_range ( ) return surf", "docstring_tokens": "Show a 3D surface plot .", "label": 1}, {"idx": "cosqa-train-16743", "doc": "standard scaler without negative values python", "code": "def Softsign(a):\n    \"\"\"\n    Softsign op.\n    \"\"\"\n    return np.divide(a, np.add(np.abs(a), 1)),", "code_tokens": "def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,", "docstring_tokens": "Softsign op .", "label": 0}, {"idx": "cosqa-train-16744", "doc": "python [ng to gif animation", "code": "def _encode_gif(images, fps):\n  \"\"\"Encodes numpy images into gif string.\n\n  Args:\n    images: A 4-D `uint8` `np.array` (or a list of 3-D images) of shape\n      `[time, height, width, channels]` where `channels` is 1 or 3.\n    fps: frames per second of the animation\n\n  Returns:\n    The encoded gif string.\n\n  Raises:\n    IOError: If the ffmpeg command returns an error.\n  \"\"\"\n  writer = WholeVideoWriter(fps)\n  writer.write_multi(images)\n  return writer.finish()", "code_tokens": "def _encode_gif ( images , fps ) : writer = WholeVideoWriter ( fps ) writer . write_multi ( images ) return writer . finish ( )", "docstring_tokens": "Encodes numpy images into gif string .", "label": 1}, {"idx": "cosqa-train-16745", "doc": "stop a python process from inside if a condition is met", "code": "def timeout_thread_handler(timeout, stop_event):\n    \"\"\"A background thread to kill the process if it takes too long.\n\n    Args:\n        timeout (float): The number of seconds to wait before killing\n            the process.\n        stop_event (Event): An optional event to cleanly stop the background\n            thread if required during testing.\n    \"\"\"\n\n    stop_happened = stop_event.wait(timeout)\n    if stop_happened is False:\n        print(\"Killing program due to %f second timeout\" % timeout)\n\n    os._exit(2)", "code_tokens": "def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( \"Killing program due to %f second timeout\" % timeout ) os . _exit ( 2 )", "docstring_tokens": "A background thread to kill the process if it takes too long .", "label": 1}, {"idx": "cosqa-train-16746", "doc": "python a while loop instead of time sleep", "code": "def main(idle):\n    \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"\n    while True:\n\n        LOG.debug(\"Sleeping for {0} seconds.\".format(idle))\n        time.sleep(idle)", "code_tokens": "def main ( idle ) : while True : LOG . debug ( \"Sleeping for {0} seconds.\" . format ( idle ) ) time . sleep ( idle )", "docstring_tokens": "Any normal python logic which runs a loop . Can take arguments .", "label": 1}, {"idx": "cosqa-train-16747", "doc": "stop logging python function name and", "code": "def stop_logging():\n    \"\"\"Stop logging to logfile and console.\"\"\"\n    from . import log\n    logger = logging.getLogger(\"gromacs\")\n    logger.info(\"GromacsWrapper %s STOPPED logging\", get_version())\n    log.clear_handlers(logger)", "code_tokens": "def stop_logging ( ) : from . import log logger = logging . getLogger ( \"gromacs\" ) logger . info ( \"GromacsWrapper %s STOPPED logging\" , get_version ( ) ) log . clear_handlers ( logger )", "docstring_tokens": "Stop logging to logfile and console .", "label": 1}, {"idx": "cosqa-train-16748", "doc": "python access token oauth url get", "code": "def get_oauth_token():\n    \"\"\"Retrieve a simple OAuth Token for use with the local http client.\"\"\"\n    url = \"{0}/token\".format(DEFAULT_ORIGIN[\"Origin\"])\n    r = s.get(url=url)\n    return r.json()[\"t\"]", "code_tokens": "def get_oauth_token ( ) : url = \"{0}/token\" . format ( DEFAULT_ORIGIN [ \"Origin\" ] ) r = s . get ( url = url ) return r . json ( ) [ \"t\" ]", "docstring_tokens": "Retrieve a simple OAuth Token for use with the local http client .", "label": 0}, {"idx": "cosqa-train-16749", "doc": "stop window service python", "code": "def stop(self, reason=None):\n        \"\"\"Shutdown the service with a reason.\"\"\"\n        self.logger.info('stopping')\n        self.loop.stop(pyev.EVBREAK_ALL)", "code_tokens": "def stop ( self , reason = None ) : self . logger . info ( 'stopping' ) self . loop . stop ( pyev . EVBREAK_ALL )", "docstring_tokens": "Shutdown the service with a reason .", "label": 1}, {"idx": "cosqa-train-16750", "doc": "python activate conda in cmd", "code": "def update(packages, env=None, user=None):\n    \"\"\"\n    Update conda packages in a conda env\n\n    Attributes\n    ----------\n        packages: list of packages comma delimited\n    \"\"\"\n    packages = ' '.join(packages.split(','))\n    cmd = _create_conda_cmd('update', args=[packages, '--yes', '-q'], env=env, user=user)\n    return _execcmd(cmd, user=user)", "code_tokens": "def update ( packages , env = None , user = None ) : packages = ' ' . join ( packages . split ( ',' ) ) cmd = _create_conda_cmd ( 'update' , args = [ packages , '--yes' , '-q' ] , env = env , user = user ) return _execcmd ( cmd , user = user )", "docstring_tokens": "Update conda packages in a conda env", "label": 0}, {"idx": "cosqa-train-16751", "doc": "storing keywords in dictionaires in python", "code": "def _kw(keywords):\n    \"\"\"Turn list of keywords into dictionary.\"\"\"\n    r = {}\n    for k, v in keywords:\n        r[k] = v\n    return r", "code_tokens": "def _kw ( keywords ) : r = { } for k , v in keywords : r [ k ] = v return r", "docstring_tokens": "Turn list of keywords into dictionary .", "label": 0}, {"idx": "cosqa-train-16752", "doc": "python add a verbose mode", "code": "def logv(msg, *args, **kwargs):\n    \"\"\"\n    Print out a log message, only if verbose mode.\n    \"\"\"\n    if settings.VERBOSE:\n        log(msg, *args, **kwargs)", "code_tokens": "def logv ( msg , * args , * * kwargs ) : if settings . VERBOSE : log ( msg , * args , * * kwargs )", "docstring_tokens": "Print out a log message only if verbose mode .", "label": 0}, {"idx": "cosqa-train-16753", "doc": "string def python spaces", "code": "def join(mapping, bind, values):\n    \"\"\" Merge all the strings. Put space between them. \"\"\"\n    return [' '.join([six.text_type(v) for v in values if v is not None])]", "code_tokens": "def join ( mapping , bind , values ) : return [ ' ' . join ( [ six . text_type ( v ) for v in values if v is not None ] ) ]", "docstring_tokens": "Merge all the strings . Put space between them .", "label": 1}, {"idx": "cosqa-train-16754", "doc": "python add custom field to logger formatter", "code": "def debug(self, text):\n\t\t\"\"\" Ajout d'un message de log de type DEBUG \"\"\"\n\t\tself.logger.debug(\"{}{}\".format(self.message_prefix, text))", "code_tokens": "def debug ( self , text ) : self . logger . debug ( \"{}{}\" . format ( self . message_prefix , text ) )", "docstring_tokens": "Ajout d un message de log de type DEBUG", "label": 0}, {"idx": "cosqa-train-16755", "doc": "string format boolean escape values python", "code": "def _encode_bool(name, value, dummy0, dummy1):\n    \"\"\"Encode a python boolean (True/False).\"\"\"\n    return b\"\\x08\" + name + (value and b\"\\x01\" or b\"\\x00\")", "code_tokens": "def _encode_bool ( name , value , dummy0 , dummy1 ) : return b\"\\x08\" + name + ( value and b\"\\x01\" or b\"\\x00\" )", "docstring_tokens": "Encode a python boolean ( True / False ) .", "label": 0}, {"idx": "cosqa-train-16756", "doc": "python add element to map", "code": "def set_as_object(self, value):\n        \"\"\"\n        Sets a new value to map element\n\n        :param value: a new element or map value.\n        \"\"\"\n        self.clear()\n        map = MapConverter.to_map(value)\n        self.append(map)", "code_tokens": "def set_as_object ( self , value ) : self . clear ( ) map = MapConverter . to_map ( value ) self . append ( map )", "docstring_tokens": "Sets a new value to map element", "label": 0}, {"idx": "cosqa-train-16757", "doc": "string height and width in python", "code": "def text_width(string, font_name, font_size):\n    \"\"\"Determine with width in pixels of string.\"\"\"\n    return stringWidth(string, fontName=font_name, fontSize=font_size)", "code_tokens": "def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "docstring_tokens": "Determine with width in pixels of string .", "label": 0}, {"idx": "cosqa-train-16758", "doc": "python add methods to builtin", "code": "def activate(self):\n        \"\"\"Store ipython references in the __builtin__ namespace.\"\"\"\n\n        add_builtin = self.add_builtin\n        for name, func in self.auto_builtins.iteritems():\n            add_builtin(name, func)", "code_tokens": "def activate ( self ) : add_builtin = self . add_builtin for name , func in self . auto_builtins . iteritems ( ) : add_builtin ( name , func )", "docstring_tokens": "Store ipython references in the __builtin__ namespace .", "label": 0}, {"idx": "cosqa-train-16759", "doc": "string representation not printed in list python", "code": "def __repr__(self):\n        \"\"\"Return list-lookalike of representation string of objects\"\"\"\n        strings = []\n        for currItem in self:\n            strings.append(\"%s\" % currItem)\n        return \"(%s)\" % (\", \".join(strings))", "code_tokens": "def __repr__ ( self ) : strings = [ ] for currItem in self : strings . append ( \"%s\" % currItem ) return \"(%s)\" % ( \", \" . join ( strings ) )", "docstring_tokens": "Return list - lookalike of representation string of objects", "label": 0}, {"idx": "cosqa-train-16760", "doc": "python add to emtyp dict", "code": "def add_to_enum(self, clsdict):\n        \"\"\"\n        Compile XML mappings in addition to base add behavior.\n        \"\"\"\n        super(XmlMappedEnumMember, self).add_to_enum(clsdict)\n        self.register_xml_mapping(clsdict)", "code_tokens": "def add_to_enum ( self , clsdict ) : super ( XmlMappedEnumMember , self ) . add_to_enum ( clsdict ) self . register_xml_mapping ( clsdict )", "docstring_tokens": "Compile XML mappings in addition to base add behavior .", "label": 0}, {"idx": "cosqa-train-16761", "doc": "python adjacency matrix from edge list", "code": "def get_adjacent_matrix(self):\n        \"\"\"Get adjacency matrix.\n\n        Returns:\n            :param adj: adjacency matrix\n            :type adj: np.ndarray\n        \"\"\"\n        edges = self.edges\n        num_edges = len(edges) + 1\n        adj = np.zeros([num_edges, num_edges])\n\n        for k in range(num_edges - 1):\n            adj[edges[k].L, edges[k].R] = 1\n            adj[edges[k].R, edges[k].L] = 1\n\n        return adj", "code_tokens": "def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj", "docstring_tokens": "Get adjacency matrix .", "label": 1}, {"idx": "cosqa-train-16762", "doc": "string to float converter python", "code": "def energy_string_to_float( string ):\n    \"\"\"\n    Convert a string of a calculation energy, e.g. '-1.2345 eV' to a float.\n\n    Args:\n        string (str): The string to convert.\n  \n    Return\n        (float) \n    \"\"\"\n    energy_re = re.compile( \"(-?\\d+\\.\\d+)\" )\n    return float( energy_re.match( string ).group(0) )", "code_tokens": "def energy_string_to_float ( string ) : energy_re = re . compile ( \"(-?\\d+\\.\\d+)\" ) return float ( energy_re . match ( string ) . group ( 0 ) )", "docstring_tokens": "Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .", "label": 1}, {"idx": "cosqa-train-16763", "doc": "python all attributes for an object", "code": "def as_dict(self):\n        \"\"\"Package up the public attributes as a dict.\"\"\"\n        attrs = vars(self)\n        return {key: attrs[key] for key in attrs if not key.startswith('_')}", "code_tokens": "def as_dict ( self ) : attrs = vars ( self ) return { key : attrs [ key ] for key in attrs if not key . startswith ( '_' ) }", "docstring_tokens": "Package up the public attributes as a dict .", "label": 1}, {"idx": "cosqa-train-16764", "doc": "strip dangerous tags python", "code": "def do_striptags(value):\n    \"\"\"Strip SGML/XML tags and replace adjacent whitespace by one space.\n    \"\"\"\n    if hasattr(value, '__html__'):\n        value = value.__html__()\n    return Markup(unicode(value)).striptags()", "code_tokens": "def do_striptags ( value ) : if hasattr ( value , '__html__' ) : value = value . __html__ ( ) return Markup ( unicode ( value ) ) . striptags ( )", "docstring_tokens": "Strip SGML / XML tags and replace adjacent whitespace by one space .", "label": 1}, {"idx": "cosqa-train-16765", "doc": "python all the fields of a table database", "code": "def dictfetchall(cursor):\n    \"\"\"Returns all rows from a cursor as a dict (rather than a headerless table)\n\n    From Django Documentation: https://docs.djangoproject.com/en/dev/topics/db/sql/\n    \"\"\"\n    desc = cursor.description\n    return [dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]", "code_tokens": "def dictfetchall ( cursor ) : desc = cursor . description return [ dict ( zip ( [ col [ 0 ] for col in desc ] , row ) ) for row in cursor . fetchall ( ) ]", "docstring_tokens": "Returns all rows from a cursor as a dict ( rather than a headerless table )", "label": 0}, {"idx": "cosqa-train-16766", "doc": "strip white space in python string", "code": "def text_cleanup(data, key, last_type):\n    \"\"\" I strip extra whitespace off multi-line strings if they are ready to be stripped!\"\"\"\n    if key in data and last_type == STRING_TYPE:\n        data[key] = data[key].strip()\n    return data", "code_tokens": "def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data", "docstring_tokens": "I strip extra whitespace off multi - line strings if they are ready to be stripped!", "label": 0}, {"idx": "cosqa-train-16767", "doc": "python and an array of booleans", "code": "def isbinary(*args):\n    \"\"\"Checks if value can be part of binary/bitwise operations.\"\"\"\n    return all(map(lambda c: isnumber(c) or isbool(c), args))", "code_tokens": "def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "docstring_tokens": "Checks if value can be part of binary / bitwise operations .", "label": 0}, {"idx": "cosqa-train-16768", "doc": "submit python code in pysopark", "code": "def __run_spark_submit(lane_yaml, dist_dir, spark_home, spark_args, silent):\n    \"\"\"\n    Submits the packaged application to spark using a `spark-submit` subprocess\n\n    Parameters\n    ----------\n    lane_yaml (str): Path to the YAML lane definition file\n    dist_dir (str): Path to the directory where the packaged code is located\n    spark_args (str): String of any additional spark config args to be passed when submitting\n    silent (bool): Flag indicating whether job output should be printed to console\n    \"\"\"\n    # spark-submit binary\n    cmd = ['spark-submit' if spark_home is None else os.path.join(spark_home, 'bin/spark-submit')]\n\n    # Supplied spark arguments\n    if spark_args:\n        cmd += spark_args\n\n    # Packaged App & lane\n    cmd += ['--py-files', 'libs.zip,_framework.zip,tasks.zip', 'main.py']\n    cmd += ['--lane', lane_yaml]\n\n    logging.info('Submitting to Spark')\n    logging.debug(str(cmd))\n\n    # Submit\n    devnull = open(os.devnull, 'w')\n    outp = {'stderr': STDOUT, 'stdout': devnull} if silent else {}\n    call(cmd, cwd=dist_dir, env=MY_ENV, **outp)\n    devnull.close()", "code_tokens": "def __run_spark_submit ( lane_yaml , dist_dir , spark_home , spark_args , silent ) : # spark-submit binary cmd = [ 'spark-submit' if spark_home is None else os . path . join ( spark_home , 'bin/spark-submit' ) ] # Supplied spark arguments if spark_args : cmd += spark_args # Packaged App & lane cmd += [ '--py-files' , 'libs.zip,_framework.zip,tasks.zip' , 'main.py' ] cmd += [ '--lane' , lane_yaml ] logging . info ( 'Submitting to Spark' ) logging . debug ( str ( cmd ) ) # Submit devnull = open ( os . devnull , 'w' ) outp = { 'stderr' : STDOUT , 'stdout' : devnull } if silent else { } call ( cmd , cwd = dist_dir , env = MY_ENV , * * outp ) devnull . close ( )", "docstring_tokens": "Submits the packaged application to spark using a spark - submit subprocess", "label": 1}, {"idx": "cosqa-train-16769", "doc": "python angle between 3 points", "code": "def angle(x, y):\n    \"\"\"Return the angle between vectors a and b in degrees.\"\"\"\n    return arccos(dot(x, y)/(norm(x)*norm(y)))*180./pi", "code_tokens": "def angle ( x , y ) : return arccos ( dot ( x , y ) / ( norm ( x ) * norm ( y ) ) ) * 180. / pi", "docstring_tokens": "Return the angle between vectors a and b in degrees .", "label": 0}, {"idx": "cosqa-train-16770", "doc": "subplot python matplotlib set title", "code": "def set_title(self, title, **kwargs):\n        \"\"\"Sets the title on the underlying matplotlib AxesSubplot.\"\"\"\n        ax = self.get_axes()\n        ax.set_title(title, **kwargs)", "code_tokens": "def set_title ( self , title , * * kwargs ) : ax = self . get_axes ( ) ax . set_title ( title , * * kwargs )", "docstring_tokens": "Sets the title on the underlying matplotlib AxesSubplot .", "label": 0}, {"idx": "cosqa-train-16771", "doc": "python api docker login denied", "code": "def write_login(collector, image, **kwargs):\n    \"\"\"Login to a docker registry with write permissions\"\"\"\n    docker_api = collector.configuration[\"harpoon\"].docker_api\n    collector.configuration[\"authentication\"].login(docker_api, image, is_pushing=True, global_docker=True)", "code_tokens": "def write_login ( collector , image , * * kwargs ) : docker_api = collector . configuration [ \"harpoon\" ] . docker_api collector . configuration [ \"authentication\" ] . login ( docker_api , image , is_pushing = True , global_docker = True )", "docstring_tokens": "Login to a docker registry with write permissions", "label": 1}, {"idx": "cosqa-train-16772", "doc": "subprocess python stdin write", "code": "def correspond(text):\n    \"\"\"Communicate with the child process without closing stdin.\"\"\"\n    subproc.stdin.write(text)\n    subproc.stdin.flush()\n    return drain()", "code_tokens": "def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "docstring_tokens": "Communicate with the child process without closing stdin .", "label": 0}, {"idx": "cosqa-train-16773", "doc": "python apply function all elements in dictonary", "code": "def dictapply(d, fn):\n    \"\"\"\n    apply a function to all non-dict values in a dictionary\n    \"\"\"\n    for k, v in d.items():\n        if isinstance(v, dict):\n            v = dictapply(v, fn)\n        else:\n            d[k] = fn(v)\n    return d", "code_tokens": "def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d", "docstring_tokens": "apply a function to all non - dict values in a dictionary", "label": 0}, {"idx": "cosqa-train-16774", "doc": "subset dictionary based on keys python", "code": "def filter_dict(d, keys):\n    \"\"\"\n    Creates a new dict from an existing dict that only has the given keys\n    \"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": "def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "docstring_tokens": "Creates a new dict from an existing dict that only has the given keys", "label": 1}, {"idx": "cosqa-train-16775", "doc": "python apply function to dictionary", "code": "def dictapply(d, fn):\n    \"\"\"\n    apply a function to all non-dict values in a dictionary\n    \"\"\"\n    for k, v in d.items():\n        if isinstance(v, dict):\n            v = dictapply(v, fn)\n        else:\n            d[k] = fn(v)\n    return d", "code_tokens": "def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d", "docstring_tokens": "apply a function to all non - dict values in a dictionary", "label": 1}, {"idx": "cosqa-train-16776", "doc": "sum within a comprehension python", "code": "def _accumulate(sequence, func):\n    \"\"\"\n    Python2 accumulate implementation taken from\n    https://docs.python.org/3/library/itertools.html#itertools.accumulate\n    \"\"\"\n    iterator = iter(sequence)\n    total = next(iterator)\n    yield total\n    for element in iterator:\n        total = func(total, element)\n        yield total", "code_tokens": "def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total", "docstring_tokens": "Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate", "label": 1}, {"idx": "cosqa-train-16777", "doc": "python apply function to iterable", "code": "def _varargs_to_iterable_method(func):\n    \"\"\"decorator to convert a *args method to one taking a iterable\"\"\"\n    def wrapped(self, iterable, **kwargs):\n        return func(self, *iterable, **kwargs)\n    return wrapped", "code_tokens": "def _varargs_to_iterable_method ( func ) : def wrapped ( self , iterable , * * kwargs ) : return func ( self , * iterable , * * kwargs ) return wrapped", "docstring_tokens": "decorator to convert a * args method to one taking a iterable", "label": 0}, {"idx": "cosqa-train-16778", "doc": "syntax for a 303 redirect in python", "code": "def redirect(cls, request, response):\n        \"\"\"Redirect to the canonical URI for this resource.\"\"\"\n        if cls.meta.legacy_redirect:\n            if request.method in ('GET', 'HEAD',):\n                # A SAFE request is allowed to redirect using a 301\n                response.status = http.client.MOVED_PERMANENTLY\n\n            else:\n                # All other requests must use a 307\n                response.status = http.client.TEMPORARY_REDIRECT\n\n        else:\n            # Modern redirects are allowed. Let's have some fun.\n            # Hopefully you're client supports this.\n            # The RFC explicitly discourages UserAgent sniffing.\n            response.status = http.client.PERMANENT_REDIRECT\n\n        # Terminate the connection.\n        response.close()", "code_tokens": "def redirect ( cls , request , response ) : if cls . meta . legacy_redirect : if request . method in ( 'GET' , 'HEAD' , ) : # A SAFE request is allowed to redirect using a 301 response . status = http . client . MOVED_PERMANENTLY else : # All other requests must use a 307 response . status = http . client . TEMPORARY_REDIRECT else : # Modern redirects are allowed. Let's have some fun. # Hopefully you're client supports this. # The RFC explicitly discourages UserAgent sniffing. response . status = http . client . PERMANENT_REDIRECT # Terminate the connection. response . close ( )", "docstring_tokens": "Redirect to the canonical URI for this resource .", "label": 0}, {"idx": "cosqa-train-16779", "doc": "python applying format to str in map(str", "code": "def _replace_variables(data, variables):\n    \"\"\"Replace the format variables in all items of data.\"\"\"\n    formatter = string.Formatter()\n    return [formatter.vformat(item, [], variables) for item in data]", "code_tokens": "def _replace_variables ( data , variables ) : formatter = string . Formatter ( ) return [ formatter . vformat ( item , [ ] , variables ) for item in data ]", "docstring_tokens": "Replace the format variables in all items of data .", "label": 0}, {"idx": "cosqa-train-16780", "doc": "sys exc info python and traceback", "code": "def format_exc(*exc_info):\n    \"\"\"Show exception with traceback.\"\"\"\n    typ, exc, tb = exc_info or sys.exc_info()\n    error = traceback.format_exception(typ, exc, tb)\n    return \"\".join(error)", "code_tokens": "def format_exc ( * exc_info ) : typ , exc , tb = exc_info or sys . exc_info ( ) error = traceback . format_exception ( typ , exc , tb ) return \"\" . join ( error )", "docstring_tokens": "Show exception with traceback .", "label": 0}, {"idx": "cosqa-train-16781", "doc": "python are lists implemented as array", "code": "def to_list(self):\n        \"\"\"Convert this confusion matrix into a 2x2 plain list of values.\"\"\"\n        return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])],\n                [int(self.table.cell_values[1][1]), int(self.table.cell_values[1][2])]]", "code_tokens": "def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]", "docstring_tokens": "Convert this confusion matrix into a 2x2 plain list of values .", "label": 0}, {"idx": "cosqa-train-16782", "doc": "take a string and form a dictionary python", "code": "def string_to_identity(identity_str):\n    \"\"\"Parse string into Identity dictionary.\"\"\"\n    m = _identity_regexp.match(identity_str)\n    result = m.groupdict()\n    log.debug('parsed identity: %s', result)\n    return {k: v for k, v in result.items() if v}", "code_tokens": "def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "docstring_tokens": "Parse string into Identity dictionary .", "label": 1}, {"idx": "cosqa-train-16783", "doc": "python area given 3 points", "code": "def get_tri_area(pts):\n    \"\"\"\n    Given a list of coords for 3 points,\n    Compute the area of this triangle.\n\n    Args:\n        pts: [a, b, c] three points\n    \"\"\"\n    a, b, c = pts[0], pts[1], pts[2]\n    v1 = np.array(b) - np.array(a)\n    v2 = np.array(c) - np.array(a)\n    area_tri = abs(sp.linalg.norm(sp.cross(v1, v2)) / 2)\n    return area_tri", "code_tokens": "def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "docstring_tokens": "Given a list of coords for 3 points Compute the area of this triangle .", "label": 0}, {"idx": "cosqa-train-16784", "doc": "taking datetimes and matching them to another column python", "code": "def datetime_match(data, dts):\n    \"\"\"\n    matching of datetimes in time columns for data filtering\n    \"\"\"\n    dts = dts if islistable(dts) else [dts]\n    if any([not isinstance(i, datetime.datetime) for i in dts]):\n        error_msg = (\n            \"`time` can only be filtered by datetimes\"\n        )\n        raise TypeError(error_msg)\n    return data.isin(dts)", "code_tokens": "def datetime_match ( data , dts ) : dts = dts if islistable ( dts ) else [ dts ] if any ( [ not isinstance ( i , datetime . datetime ) for i in dts ] ) : error_msg = ( \"`time` can only be filtered by datetimes\" ) raise TypeError ( error_msg ) return data . isin ( dts )", "docstring_tokens": "matching of datetimes in time columns for data filtering", "label": 0}, {"idx": "cosqa-train-16785", "doc": "python argparse custom action parse file", "code": "def register_action(action):\n  \"\"\"\n  Adds an action to the parser cli.\n\n  :param action(BaseAction): a subclass of the BaseAction class\n  \"\"\"\n  sub = _subparsers.add_parser(action.meta('cmd'), help=action.meta('help'))\n  sub.set_defaults(cmd=action.meta('cmd'))\n  for (name, arg) in action.props().items():\n    sub.add_argument(arg.name, arg.flag, **arg.options)\n    _actions[action.meta('cmd')] = action", "code_tokens": "def register_action ( action ) : sub = _subparsers . add_parser ( action . meta ( 'cmd' ) , help = action . meta ( 'help' ) ) sub . set_defaults ( cmd = action . meta ( 'cmd' ) ) for ( name , arg ) in action . props ( ) . items ( ) : sub . add_argument ( arg . name , arg . flag , * * arg . options ) _actions [ action . meta ( 'cmd' ) ] = action", "docstring_tokens": "Adds an action to the parser cli .", "label": 1}, {"idx": "cosqa-train-16786", "doc": "taking out unique values from a python list", "code": "def _uniquify(_list):\n    \"\"\"Remove duplicates in a list.\"\"\"\n    seen = set()\n    result = []\n    for x in _list:\n        if x not in seen:\n            result.append(x)\n            seen.add(x)\n    return result", "code_tokens": "def _uniquify ( _list ) : seen = set ( ) result = [ ] for x in _list : if x not in seen : result . append ( x ) seen . add ( x ) return result", "docstring_tokens": "Remove duplicates in a list .", "label": 0}, {"idx": "cosqa-train-16787", "doc": "python argparse no help message", "code": "def parse_command_args():\n    \"\"\"Command line parser.\"\"\"\n    parser = argparse.ArgumentParser(description='Register PB devices.')\n    parser.add_argument('num_pb', type=int,\n                        help='Number of PBs devices to register.')\n    return parser.parse_args()", "code_tokens": "def parse_command_args ( ) : parser = argparse . ArgumentParser ( description = 'Register PB devices.' ) parser . add_argument ( 'num_pb' , type = int , help = 'Number of PBs devices to register.' ) return parser . parse_args ( )", "docstring_tokens": "Command line parser .", "label": 0}, {"idx": "cosqa-train-16788", "doc": "tell python function to expect tuple", "code": "def tuple_check(*args, func=None):\n    \"\"\"Check if arguments are tuple type.\"\"\"\n    func = func or inspect.stack()[2][3]\n    for var in args:\n        if not isinstance(var, (tuple, collections.abc.Sequence)):\n            name = type(var).__name__\n            raise TupleError(\n                f'Function {func} expected tuple, {name} got instead.')", "code_tokens": "def tuple_check ( * args , func = None ) : func = func or inspect . stack ( ) [ 2 ] [ 3 ] for var in args : if not isinstance ( var , ( tuple , collections . abc . Sequence ) ) : name = type ( var ) . __name__ raise TupleError ( f'Function {func} expected tuple, {name} got instead.' )", "docstring_tokens": "Check if arguments are tuple type .", "label": 1}, {"idx": "cosqa-train-16789", "doc": "python args kwargs to string", "code": "def kwargs_to_string(kwargs):\n    \"\"\"\n    Given a set of kwargs, turns them into a string which can then be passed to a command.\n    :param kwargs: kwargs from a function call.\n    :return: outstr: A string, which is '' if no kwargs were given, and the kwargs in string format otherwise.\n    \"\"\"\n    outstr = ''\n    for arg in kwargs:\n        outstr += ' -{} {}'.format(arg, kwargs[arg])\n    return outstr", "code_tokens": "def kwargs_to_string ( kwargs ) : outstr = '' for arg in kwargs : outstr += ' -{} {}' . format ( arg , kwargs [ arg ] ) return outstr", "docstring_tokens": "Given a set of kwargs turns them into a string which can then be passed to a command . : param kwargs : kwargs from a function call . : return : outstr : A string which is if no kwargs were given and the kwargs in string format otherwise .", "label": 1}, {"idx": "cosqa-train-16790", "doc": "tell python to pause for secs before running script", "code": "def process_wait(process, timeout=0):\n    \"\"\"\n    Pauses script execution until a given process exists.\n    :param process:\n    :param timeout:\n    :return:\n    \"\"\"\n    ret = AUTO_IT.AU3_ProcessWait(LPCWSTR(process), INT(timeout))\n    return ret", "code_tokens": "def process_wait ( process , timeout = 0 ) : ret = AUTO_IT . AU3_ProcessWait ( LPCWSTR ( process ) , INT ( timeout ) ) return ret", "docstring_tokens": "Pauses script execution until a given process exists . : param process : : param timeout : : return :", "label": 0}, {"idx": "cosqa-train-16791", "doc": "python array get most common element", "code": "def _most_common(iterable):\n    \"\"\"Returns the most common element in `iterable`.\"\"\"\n    data = Counter(iterable)\n    return max(data, key=data.__getitem__)", "code_tokens": "def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "docstring_tokens": "Returns the most common element in iterable .", "label": 1}, {"idx": "cosqa-train-16792", "doc": "tensorflow has no attribute python", "code": "def unit_ball_L2(shape):\n  \"\"\"A tensorflow variable tranfomed to be constrained in a L2 unit ball.\n\n  EXPERIMENTAL: Do not use for adverserial examples if you need to be confident\n  they are strong attacks. We are not yet confident in this code.\n  \"\"\"\n  x = tf.Variable(tf.zeros(shape))\n  return constrain_L2(x)", "code_tokens": "def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )", "docstring_tokens": "A tensorflow variable tranfomed to be constrained in a L2 unit ball .", "label": 0}, {"idx": "cosqa-train-16793", "doc": "python assert lists are equal", "code": "def expect_all(a, b):\n    \"\"\"\\\n    Asserts that two iterables contain the same values.\n    \"\"\"\n    assert all(_a == _b for _a, _b in zip_longest(a, b))", "code_tokens": "def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "docstring_tokens": "\\ Asserts that two iterables contain the same values .", "label": 0}, {"idx": "cosqa-train-16794", "doc": "tensorflow python cpu minilab", "code": "def transformer_tall_pretrain_lm_tpu_adafactor():\n  \"\"\"Hparams for transformer on LM pretraining (with 64k vocab) on TPU.\"\"\"\n  hparams = transformer_tall_pretrain_lm()\n  update_hparams_for_tpu(hparams)\n  hparams.max_length = 1024\n  # For multi-problem on TPU we need it in absolute examples.\n  hparams.batch_size = 8\n  hparams.multiproblem_vocab_size = 2**16\n  return hparams", "code_tokens": "def transformer_tall_pretrain_lm_tpu_adafactor ( ) : hparams = transformer_tall_pretrain_lm ( ) update_hparams_for_tpu ( hparams ) hparams . max_length = 1024 # For multi-problem on TPU we need it in absolute examples. hparams . batch_size = 8 hparams . multiproblem_vocab_size = 2 ** 16 return hparams", "docstring_tokens": "Hparams for transformer on LM pretraining ( with 64k vocab ) on TPU .", "label": 0}, {"idx": "cosqa-train-16795", "doc": "python assert object type", "code": "def _assert_is_type(name, value, value_type):\n    \"\"\"Assert that a value must be a given type.\"\"\"\n    if not isinstance(value, value_type):\n        if type(value_type) is tuple:\n            types = ', '.join(t.__name__ for t in value_type)\n            raise ValueError('{0} must be one of ({1})'.format(name, types))\n        else:\n            raise ValueError('{0} must be {1}'\n                             .format(name, value_type.__name__))", "code_tokens": "def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )", "docstring_tokens": "Assert that a value must be a given type .", "label": 0}, {"idx": "cosqa-train-16796", "doc": "test datetime validity python", "code": "def is_timestamp(instance):\n    \"\"\"Validates data is a timestamp\"\"\"\n    if not isinstance(instance, (int, str)):\n        return True\n    return datetime.fromtimestamp(int(instance))", "code_tokens": "def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "docstring_tokens": "Validates data is a timestamp", "label": 0}, {"idx": "cosqa-train-16797", "doc": "python astropy table np array", "code": "def from_array(cls, arr):\n        \"\"\"Convert a structured NumPy array into a Table.\"\"\"\n        return cls().with_columns([(f, arr[f]) for f in arr.dtype.names])", "code_tokens": "def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "docstring_tokens": "Convert a structured NumPy array into a Table .", "label": 0}, {"idx": "cosqa-train-16798", "doc": "test whether a python object is iterable", "code": "def is_lazy_iterable(obj):\n    \"\"\"\n    Returns whether *obj* is iterable lazily, such as generators, range objects, etc.\n    \"\"\"\n    return isinstance(obj,\n        (types.GeneratorType, collections.MappingView, six.moves.range, enumerate))", "code_tokens": "def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )", "docstring_tokens": "Returns whether * obj * is iterable lazily such as generators range objects etc .", "label": 0}, {"idx": "cosqa-train-16799", "doc": "python asyncio how to detect socket connection lost", "code": "def connection_lost(self, exc):\n        \"\"\"Called when asyncio.Protocol loses the network connection.\"\"\"\n        if exc is None:\n            self.log.warning('eof from receiver?')\n        else:\n            self.log.warning('Lost connection to receiver: %s', exc)\n\n        self.transport = None\n\n        if self._connection_lost_callback:\n            self._loop.call_soon(self._connection_lost_callback)", "code_tokens": "def connection_lost ( self , exc ) : if exc is None : self . log . warning ( 'eof from receiver?' ) else : self . log . warning ( 'Lost connection to receiver: %s' , exc ) self . transport = None if self . _connection_lost_callback : self . _loop . call_soon ( self . _connection_lost_callback )", "docstring_tokens": "Called when asyncio . Protocol loses the network connection .", "label": 0}, {"idx": "cosqa-train-16800", "doc": "text align to center in python3", "code": "def center_text(text, width=80):\n    \"\"\"Center all lines of the text.\n\n    It is assumed that all lines width is smaller then B{width}, because the\n    line width will not be checked.\n\n    Args:\n        text (str): Text to wrap.\n        width (int): Maximum number of characters per line.\n\n    Returns:\n        str: Centered text.\n    \"\"\"\n    centered = []\n    for line in text.splitlines():\n        centered.append(line.center(width))\n    return \"\\n\".join(centered)", "code_tokens": "def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "docstring_tokens": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text .", "label": 0}, {"idx": "cosqa-train-16801", "doc": "python asyncio how to determine socket connection lost", "code": "def connection_lost(self, exc):\n        \"\"\"Called when asyncio.Protocol loses the network connection.\"\"\"\n        if exc is None:\n            self.log.warning('eof from receiver?')\n        else:\n            self.log.warning('Lost connection to receiver: %s', exc)\n\n        self.transport = None\n\n        if self._connection_lost_callback:\n            self._loop.call_soon(self._connection_lost_callback)", "code_tokens": "def connection_lost ( self , exc ) : if exc is None : self . log . warning ( 'eof from receiver?' ) else : self . log . warning ( 'Lost connection to receiver: %s' , exc ) self . transport = None if self . _connection_lost_callback : self . _loop . call_soon ( self . _connection_lost_callback )", "docstring_tokens": "Called when asyncio . Protocol loses the network connection .", "label": 1}, {"idx": "cosqa-train-16802", "doc": "the sum of all squares between 1 and 100 (inclusive python with for loop", "code": "def average(iterator):\n    \"\"\"Iterative mean.\"\"\"\n    count = 0\n    total = 0\n    for num in iterator:\n        count += 1\n        total += num\n    return float(total)/count", "code_tokens": "def average ( iterator ) : count = 0 total = 0 for num in iterator : count += 1 total += num return float ( total ) / count", "docstring_tokens": "Iterative mean .", "label": 1}, {"idx": "cosqa-train-16803", "doc": "python asyncio object is not subscriptable", "code": "def StringIO(*args, **kwargs):\n    \"\"\"StringIO constructor shim for the async wrapper.\"\"\"\n    raw = sync_io.StringIO(*args, **kwargs)\n    return AsyncStringIOWrapper(raw)", "code_tokens": "def StringIO ( * args , * * kwargs ) : raw = sync_io . StringIO ( * args , * * kwargs ) return AsyncStringIOWrapper ( raw )", "docstring_tokens": "StringIO constructor shim for the async wrapper .", "label": 0}, {"idx": "cosqa-train-16804", "doc": "timezone with z in python", "code": "def convert_timezone(obj, timezone):\n    \"\"\"Convert `obj` to the timezone `timezone`.\n\n    Parameters\n    ----------\n    obj : datetime.date or datetime.datetime\n\n    Returns\n    -------\n    type(obj)\n    \"\"\"\n    if timezone is None:\n        return obj.replace(tzinfo=None)\n    return pytz.timezone(timezone).localize(obj)", "code_tokens": "def convert_timezone ( obj , timezone ) : if timezone is None : return obj . replace ( tzinfo = None ) return pytz . timezone ( timezone ) . localize ( obj )", "docstring_tokens": "Convert obj to the timezone timezone .", "label": 0}, {"idx": "cosqa-train-16805", "doc": "python asyncio transport write example", "code": "async def write(self, data):\n        \"\"\"\n        :py:func:`asyncio.coroutine`\n\n        :py:meth:`aioftp.StreamIO.write` proxy\n        \"\"\"\n        await self.wait(\"write\")\n        start = _now()\n        await super().write(data)\n        self.append(\"write\", data, start)", "code_tokens": "async def write ( self , data ) : await self . wait ( \"write\" ) start = _now ( ) await super ( ) . write ( data ) self . append ( \"write\" , data , start )", "docstring_tokens": ": py : func : asyncio . coroutine", "label": 0}, {"idx": "cosqa-train-16806", "doc": "tkinter python 3 treeview scrollbars windows", "code": "def yview(self, *args):\n        \"\"\"Update inplace widgets position when doing vertical scroll\"\"\"\n        self.after_idle(self.__updateWnds)\n        ttk.Treeview.yview(self, *args)", "code_tokens": "def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )", "docstring_tokens": "Update inplace widgets position when doing vertical scroll", "label": 0}, {"idx": "cosqa-train-16807", "doc": "python autogenerate python documentation using pydoc", "code": "def debug_src(src, pm=False, globs=None):\n    \"\"\"Debug a single doctest docstring, in argument `src`'\"\"\"\n    testsrc = script_from_examples(src)\n    debug_script(testsrc, pm, globs)", "code_tokens": "def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )", "docstring_tokens": "Debug a single doctest docstring in argument src", "label": 0}, {"idx": "cosqa-train-16808", "doc": "tkinter scroll two canvas python", "code": "def _set_scroll_v(self, *args):\n        \"\"\"Scroll both categories Canvas and scrolling container\"\"\"\n        self._canvas_categories.yview(*args)\n        self._canvas_scroll.yview(*args)", "code_tokens": "def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "docstring_tokens": "Scroll both categories Canvas and scrolling container", "label": 0}, {"idx": "cosqa-train-16809", "doc": "python azimuth from lat and lon", "code": "def Distance(lat1, lon1, lat2, lon2):\n    \"\"\"Get distance between pairs of lat-lon points\"\"\"\n\n    az12, az21, dist = wgs84_geod.inv(lon1, lat1, lon2, lat2)\n    return az21, dist", "code_tokens": "def Distance ( lat1 , lon1 , lat2 , lon2 ) : az12 , az21 , dist = wgs84_geod . inv ( lon1 , lat1 , lon2 , lat2 ) return az21 , dist", "docstring_tokens": "Get distance between pairs of lat - lon points", "label": 0}, {"idx": "cosqa-train-16810", "doc": "tkmessagebox use in python syntax", "code": "def codebox(msg=\"\", title=\" \", text=\"\"):\n    \"\"\"\n    Display some text in a monospaced font, with no line wrapping.\n    This function is suitable for displaying code and text that is\n    formatted using spaces.\n\n    The text parameter should be a string, or a list or tuple of lines to be\n    displayed in the textbox.\n\n    :param str msg: the msg to be displayed\n    :param str title: the window title\n    :param str text: what to display in the textbox\n    \"\"\"\n    return tb.textbox(msg, title, text, codebox=1)", "code_tokens": "def codebox ( msg = \"\" , title = \" \" , text = \"\" ) : return tb . textbox ( msg , title , text , codebox = 1 )", "docstring_tokens": "Display some text in a monospaced font with no line wrapping . This function is suitable for displaying code and text that is formatted using spaces .", "label": 0}, {"idx": "cosqa-train-16811", "doc": "python beautiful xml string", "code": "def pp_xml(body):\n    \"\"\"Pretty print format some XML so it's readable.\"\"\"\n    pretty = xml.dom.minidom.parseString(body)\n    return pretty.toprettyxml(indent=\"  \")", "code_tokens": "def pp_xml ( body ) : pretty = xml . dom . minidom . parseString ( body ) return pretty . toprettyxml ( indent = \"  \" )", "docstring_tokens": "Pretty print format some XML so it s readable .", "label": 1}, {"idx": "cosqa-train-16812", "doc": "to compare set data in python", "code": "def isetdiff_flags(list1, list2):\n    \"\"\"\n    move to util_iter\n    \"\"\"\n    set2 = set(list2)\n    return (item not in set2 for item in list1)", "code_tokens": "def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )", "docstring_tokens": "move to util_iter", "label": 0}, {"idx": "cosqa-train-16813", "doc": "python best way to get csv header list from a file ussing dictreader", "code": "def csv_to_dicts(file, header=None):\n    \"\"\"Reads a csv and returns a List of Dicts with keys given by header row.\"\"\"\n    with open(file) as csvfile:\n        return [row for row in csv.DictReader(csvfile, fieldnames=header)]", "code_tokens": "def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]", "docstring_tokens": "Reads a csv and returns a List of Dicts with keys given by header row .", "label": 1}, {"idx": "cosqa-train-16814", "doc": "to print the results in the form of table in python", "code": "def printComparison(results, class_or_prop):\n\t\"\"\"\n\tprint(out the results of the comparison using a nice table)\n\t\"\"\"\n\n\tdata = []\n\n\tRow = namedtuple('Row',[class_or_prop,'VALIDATED'])\n\n\tfor k,v in sorted(results.items(), key=lambda x: x[1]):\n\t\tdata += [Row(k, str(v))]\n\n\tpprinttable(data)", "code_tokens": "def printComparison ( results , class_or_prop ) : data = [ ] Row = namedtuple ( 'Row' , [ class_or_prop , 'VALIDATED' ] ) for k , v in sorted ( results . items ( ) , key = lambda x : x [ 1 ] ) : data += [ Row ( k , str ( v ) ) ] pprinttable ( data )", "docstring_tokens": "print ( out the results of the comparison using a nice table )", "label": 0}, {"idx": "cosqa-train-16815", "doc": "python best way to transform image to grayscale", "code": "def rgb2gray(img):\n    \"\"\"Converts an RGB image to grayscale using matlab's algorithm.\"\"\"\n    T = np.linalg.inv(np.array([\n        [1.0,  0.956,  0.621],\n        [1.0, -0.272, -0.647],\n        [1.0, -1.106,  1.703],\n    ]))\n    r_c, g_c, b_c = T[0]\n    r, g, b = np.rollaxis(as_float_image(img), axis=-1)\n    return r_c * r + g_c * g + b_c * b", "code_tokens": "def rgb2gray ( img ) : T = np . linalg . inv ( np . array ( [ [ 1.0 , 0.956 , 0.621 ] , [ 1.0 , - 0.272 , - 0.647 ] , [ 1.0 , - 1.106 , 1.703 ] , ] ) ) r_c , g_c , b_c = T [ 0 ] r , g , b = np . rollaxis ( as_float_image ( img ) , axis = - 1 ) return r_c * r + g_c * g + b_c * b", "docstring_tokens": "Converts an RGB image to grayscale using matlab s algorithm .", "label": 1}, {"idx": "cosqa-train-16816", "doc": "to read xml files in python", "code": "def xmltreefromfile(filename):\n    \"\"\"Internal function to read an XML file\"\"\"\n    try:\n        return ElementTree.parse(filename, ElementTree.XMLParser(collect_ids=False))\n    except TypeError:\n        return ElementTree.parse(filename, ElementTree.XMLParser())", "code_tokens": "def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )", "docstring_tokens": "Internal function to read an XML file", "label": 1}, {"idx": "cosqa-train-16817", "doc": "python bin ranges not numpy", "code": "def val_to_bin(edges, x):\n    \"\"\"Convert axis coordinate to bin index.\"\"\"\n    ibin = np.digitize(np.array(x, ndmin=1), edges) - 1\n    return ibin", "code_tokens": "def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin", "docstring_tokens": "Convert axis coordinate to bin index .", "label": 0}, {"idx": "cosqa-train-16818", "doc": "too long sentences in python", "code": "def split_long_sentence(sentence, words_per_line):\n    \"\"\"Takes a sentence and adds a newline every \"words_per_line\" words.\n\n    Parameters\n    ----------\n    sentence: str\n        Sentene to split\n    words_per_line: double\n        Add a newline every this many words\n    \"\"\"\n    words = sentence.split(' ')\n    split_sentence = ''\n    for i in range(len(words)):\n        split_sentence = split_sentence + words[i]\n        if (i+1) % words_per_line == 0:\n            split_sentence = split_sentence + '\\n'\n        elif i != len(words) - 1:\n            split_sentence = split_sentence + \" \"\n    return split_sentence", "code_tokens": "def split_long_sentence ( sentence , words_per_line ) : words = sentence . split ( ' ' ) split_sentence = '' for i in range ( len ( words ) ) : split_sentence = split_sentence + words [ i ] if ( i + 1 ) % words_per_line == 0 : split_sentence = split_sentence + '\\n' elif i != len ( words ) - 1 : split_sentence = split_sentence + \" \" return split_sentence", "docstring_tokens": "Takes a sentence and adds a newline every words_per_line words .", "label": 0}, {"idx": "cosqa-train-16819", "doc": "python bind focusin focusout", "code": "def hook_focus_events(self):\n        \"\"\" Install the hooks for focus events.\n\n        This method may be overridden by subclasses as needed.\n\n        \"\"\"\n        widget = self.widget\n        widget.focusInEvent = self.focusInEvent\n        widget.focusOutEvent = self.focusOutEvent", "code_tokens": "def hook_focus_events ( self ) : widget = self . widget widget . focusInEvent = self . focusInEvent widget . focusOutEvent = self . focusOutEvent", "docstring_tokens": "Install the hooks for focus events .", "label": 0}, {"idx": "cosqa-train-16820", "doc": "track location of mouse click python", "code": "def mouse_move_event(self, event):\n        \"\"\"\n        Forward mouse cursor position events to the example\n        \"\"\"\n        self.example.mouse_position_event(event.x(), event.y())", "code_tokens": "def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )", "docstring_tokens": "Forward mouse cursor position events to the example", "label": 1}, {"idx": "cosqa-train-16821", "doc": "python borderless table via format function", "code": "def adapter(data, headers, **kwargs):\n    \"\"\"Wrap vertical table in a function for TabularOutputFormatter.\"\"\"\n    keys = ('sep_title', 'sep_character', 'sep_length')\n    return vertical_table(data, headers, **filter_dict_by_key(kwargs, keys))", "code_tokens": "def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )", "docstring_tokens": "Wrap vertical table in a function for TabularOutputFormatter .", "label": 1}, {"idx": "cosqa-train-16822", "doc": "transform array to dictionary python", "code": "def to_dicts(recarray):\n    \"\"\"convert record array to a dictionaries\"\"\"\n    for rec in recarray:\n        yield dict(zip(recarray.dtype.names, rec.tolist()))", "code_tokens": "def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )", "docstring_tokens": "convert record array to a dictionaries", "label": 1}, {"idx": "cosqa-train-16823", "doc": "python boto3 check if sts is expiration and renew", "code": "def needs_update(self, cache_key):\n    \"\"\"Check if the given cached item is invalid.\n\n    :param cache_key: A CacheKey object (as returned by CacheKeyGenerator.key_for().\n    :returns: True if the cached version of the item is out of date.\n    \"\"\"\n    if not self.cacheable(cache_key):\n      # An uncacheable CacheKey is always out of date.\n      return True\n\n    return self._read_sha(cache_key) != cache_key.hash", "code_tokens": "def needs_update ( self , cache_key ) : if not self . cacheable ( cache_key ) : # An uncacheable CacheKey is always out of date. return True return self . _read_sha ( cache_key ) != cache_key . hash", "docstring_tokens": "Check if the given cached item is invalid .", "label": 0}, {"idx": "cosqa-train-16824", "doc": "trim from left of python string", "code": "def _trim(self, somestr):\n        \"\"\" Trim left-right given string \"\"\"\n        tmp = RE_LSPACES.sub(\"\", somestr)\n        tmp = RE_TSPACES.sub(\"\", tmp)\n        return str(tmp)", "code_tokens": "def _trim ( self , somestr ) : tmp = RE_LSPACES . sub ( \"\" , somestr ) tmp = RE_TSPACES . sub ( \"\" , tmp ) return str ( tmp )", "docstring_tokens": "Trim left - right given string", "label": 1}, {"idx": "cosqa-train-16825", "doc": "python boto3 delete file from s3 bucket", "code": "def remove_file_from_s3(awsclient, bucket, key):\n    \"\"\"Remove a file from an AWS S3 bucket.\n\n    :param awsclient:\n    :param bucket:\n    :param key:\n    :return:\n    \"\"\"\n    client_s3 = awsclient.get_client('s3')\n    response = client_s3.delete_object(Bucket=bucket, Key=key)", "code_tokens": "def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )", "docstring_tokens": "Remove a file from an AWS S3 bucket .", "label": 0}, {"idx": "cosqa-train-16826", "doc": "try updating a dictionary in python", "code": "def update(self, params):\n        \"\"\"Update the dev_info data from a dictionary.\n\n        Only updates if it already exists in the device.\n        \"\"\"\n        dev_info = self.json_state.get('deviceInfo')\n        dev_info.update({k: params[k] for k in params if dev_info.get(k)})", "code_tokens": "def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "docstring_tokens": "Update the dev_info data from a dictionary .", "label": 0}, {"idx": "cosqa-train-16827", "doc": "python byte buffer as array", "code": "def be_array_from_bytes(fmt, data):\n    \"\"\"\n    Reads an array from bytestring with big-endian data.\n    \"\"\"\n    arr = array.array(str(fmt), data)\n    return fix_byteorder(arr)", "code_tokens": "def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )", "docstring_tokens": "Reads an array from bytestring with big - endian data .", "label": 0}, {"idx": "cosqa-train-16828", "doc": "tshark command results in python", "code": "async def packets_from_tshark(self, packet_callback, packet_count=None, close_tshark=True):\n        \"\"\"\n        A coroutine which creates a tshark process, runs the given callback on each packet that is received from it and\n        closes the process when it is done.\n\n        Do not use interactively. Can be used in order to insert packets into your own eventloop.\n        \"\"\"\n        tshark_process = await self._get_tshark_process(packet_count=packet_count)\n        try:\n            await self._go_through_packets_from_fd(tshark_process.stdout, packet_callback, packet_count=packet_count)\n        except StopCapture:\n            pass\n        finally:\n            if close_tshark:\n                await self._close_async()", "code_tokens": "async def packets_from_tshark ( self , packet_callback , packet_count = None , close_tshark = True ) : tshark_process = await self . _get_tshark_process ( packet_count = packet_count ) try : await self . _go_through_packets_from_fd ( tshark_process . stdout , packet_callback , packet_count = packet_count ) except StopCapture : pass finally : if close_tshark : await self . _close_async ( )", "docstring_tokens": "A coroutine which creates a tshark process runs the given callback on each packet that is received from it and closes the process when it is done .", "label": 0}, {"idx": "cosqa-train-16829", "doc": "python byte indices must be integers or slices, not str", "code": "def _from_bytes(bytes, byteorder=\"big\", signed=False):\n    \"\"\"This is the same functionality as ``int.from_bytes`` in python 3\"\"\"\n    return int.from_bytes(bytes, byteorder=byteorder, signed=signed)", "code_tokens": "def _from_bytes ( bytes , byteorder = \"big\" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )", "docstring_tokens": "This is the same functionality as int . from_bytes in python 3", "label": 0}, {"idx": "cosqa-train-16830", "doc": "turn array of arrays to list python", "code": "def _to_array(value):\n    \"\"\"As a convenience, turn Python lists and tuples into NumPy arrays.\"\"\"\n    if isinstance(value, (tuple, list)):\n        return array(value)\n    elif isinstance(value, (float, int)):\n        return np.float64(value)\n    else:\n        return value", "code_tokens": "def _to_array ( value ) : if isinstance ( value , ( tuple , list ) ) : return array ( value ) elif isinstance ( value , ( float , int ) ) : return np . float64 ( value ) else : return value", "docstring_tokens": "As a convenience turn Python lists and tuples into NumPy arrays .", "label": 0}, {"idx": "cosqa-train-16831", "doc": "python bytes auto detect", "code": "def cast_bytes(s, encoding=None):\n    \"\"\"Source: https://github.com/ipython/ipython_genutils\"\"\"\n    if not isinstance(s, bytes):\n        return encode(s, encoding)\n    return s", "code_tokens": "def cast_bytes ( s , encoding = None ) : if not isinstance ( s , bytes ) : return encode ( s , encoding ) return s", "docstring_tokens": "Source : https : // github . com / ipython / ipython_genutils", "label": 0}, {"idx": "cosqa-train-16832", "doc": "turn binary string into bytes object python", "code": "def to_binary(s, encoding='utf8'):\n    \"\"\"Portable cast function.\n\n    In python 2 the ``str`` function which is used to coerce objects to bytes does not\n    accept an encoding argument, whereas python 3's ``bytes`` function requires one.\n\n    :param s: object to be converted to binary_type\n    :return: binary_type instance, representing s.\n    \"\"\"\n    if PY3:  # pragma: no cover\n        return s if isinstance(s, binary_type) else binary_type(s, encoding=encoding)\n    return binary_type(s)", "code_tokens": "def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )", "docstring_tokens": "Portable cast function .", "label": 1}, {"idx": "cosqa-train-16833", "doc": "python bytes to signed int", "code": "def bin_to_int(string):\n    \"\"\"Convert a one element byte string to signed int for python 2 support.\"\"\"\n    if isinstance(string, str):\n        return struct.unpack(\"b\", string)[0]\n    else:\n        return struct.unpack(\"b\", bytes([string]))[0]", "code_tokens": "def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( \"b\" , string ) [ 0 ] else : return struct . unpack ( \"b\" , bytes ( [ string ] ) ) [ 0 ]", "docstring_tokens": "Convert a one element byte string to signed int for python 2 support .", "label": 1}, {"idx": "cosqa-train-16834", "doc": "turn string to binaryn string python", "code": "def s2b(s):\n    \"\"\"\n    String to binary.\n    \"\"\"\n    ret = []\n    for c in s:\n        ret.append(bin(ord(c))[2:].zfill(8))\n    return \"\".join(ret)", "code_tokens": "def s2b ( s ) : ret = [ ] for c in s : ret . append ( bin ( ord ( c ) ) [ 2 : ] . zfill ( 8 ) ) return \"\" . join ( ret )", "docstring_tokens": "String to binary .", "label": 0}, {"idx": "cosqa-train-16835", "doc": "python bytestring to json", "code": "def _bytes_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, bytes):\n        value = base64.standard_b64encode(value).decode(\"ascii\")\n    return value", "code_tokens": "def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( \"ascii\" ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 0}, {"idx": "cosqa-train-16836", "doc": "turn time return into seconds python", "code": "def time2seconds(t):\n    \"\"\"Returns seconds since 0h00.\"\"\"\n    return t.hour * 3600 + t.minute * 60 + t.second + float(t.microsecond) / 1e6", "code_tokens": "def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6", "docstring_tokens": "Returns seconds since 0h00 .", "label": 1}, {"idx": "cosqa-train-16837", "doc": "python c++ bindings clang", "code": "def check_clang_apply_replacements_binary(args):\n  \"\"\"Checks if invoking supplied clang-apply-replacements binary works.\"\"\"\n  try:\n    subprocess.check_call([args.clang_apply_replacements_binary, '--version'])\n  except:\n    print('Unable to run clang-apply-replacements. Is clang-apply-replacements '\n          'binary correctly specified?', file=sys.stderr)\n    traceback.print_exc()\n    sys.exit(1)", "code_tokens": "def check_clang_apply_replacements_binary ( args ) : try : subprocess . check_call ( [ args . clang_apply_replacements_binary , '--version' ] ) except : print ( 'Unable to run clang-apply-replacements. Is clang-apply-replacements ' 'binary correctly specified?' , file = sys . stderr ) traceback . print_exc ( ) sys . exit ( 1 )", "docstring_tokens": "Checks if invoking supplied clang - apply - replacements binary works .", "label": 1}, {"idx": "cosqa-train-16838", "doc": "uniform variable [0,1] python", "code": "def runiform(lower, upper, size=None):\n    \"\"\"\n    Random uniform variates.\n    \"\"\"\n    return np.random.uniform(lower, upper, size)", "code_tokens": "def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )", "docstring_tokens": "Random uniform variates .", "label": 0}, {"idx": "cosqa-train-16839", "doc": "python cache json http response", "code": "def getCachedDataKey(engineVersionHash, key):\n\t\t\"\"\"\n\t\tRetrieves the cached data value for the specified engine version hash and dictionary key\n\t\t\"\"\"\n\t\tcacheFile = CachedDataManager._cacheFileForHash(engineVersionHash)\n\t\treturn JsonDataManager(cacheFile).getKey(key)", "code_tokens": "def getCachedDataKey ( engineVersionHash , key ) : cacheFile = CachedDataManager . _cacheFileForHash ( engineVersionHash ) return JsonDataManager ( cacheFile ) . getKey ( key )", "docstring_tokens": "Retrieves the cached data value for the specified engine version hash and dictionary key", "label": 0}, {"idx": "cosqa-train-16840", "doc": "uniqify a list preserve order+ python", "code": "def uniq(seq):\n    \"\"\" Return a copy of seq without duplicates. \"\"\"\n    seen = set()\n    return [x for x in seq if str(x) not in seen and not seen.add(str(x))]", "code_tokens": "def uniq ( seq ) : seen = set ( ) return [ x for x in seq if str ( x ) not in seen and not seen . add ( str ( x ) ) ]", "docstring_tokens": "Return a copy of seq without duplicates .", "label": 1}, {"idx": "cosqa-train-16841", "doc": "unique labels function in python", "code": "def get_labels(labels):\n    \"\"\"Create unique labels.\"\"\"\n    label_u = unique_labels(labels)\n    label_u_line = [i + \"_line\" for i in label_u]\n    return label_u, label_u_line", "code_tokens": "def get_labels ( labels ) : label_u = unique_labels ( labels ) label_u_line = [ i + \"_line\" for i in label_u ] return label_u , label_u_line", "docstring_tokens": "Create unique labels .", "label": 0}, {"idx": "cosqa-train-16842", "doc": "python calculate the area of several points", "code": "def get_tri_area(pts):\n    \"\"\"\n    Given a list of coords for 3 points,\n    Compute the area of this triangle.\n\n    Args:\n        pts: [a, b, c] three points\n    \"\"\"\n    a, b, c = pts[0], pts[1], pts[2]\n    v1 = np.array(b) - np.array(a)\n    v2 = np.array(c) - np.array(a)\n    area_tri = abs(sp.linalg.norm(sp.cross(v1, v2)) / 2)\n    return area_tri", "code_tokens": "def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "docstring_tokens": "Given a list of coords for 3 points Compute the area of this triangle .", "label": 0}, {"idx": "cosqa-train-16843", "doc": "unique list of duplicates python", "code": "def remove_duplicates(seq):\n    \"\"\"\n    Return unique elements from list while preserving order.\n    From https://stackoverflow.com/a/480227/2589328\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def remove_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Return unique elements from list while preserving order . From https : // stackoverflow . com / a / 480227 / 2589328", "label": 0}, {"idx": "cosqa-train-16844", "doc": "python calculate variance of a series end with 0", "code": "def var(series):\n    \"\"\"\n    Returns the variance of values in a series.\n\n    Args:\n        series (pandas.Series): column to summarize.\n    \"\"\"\n    if np.issubdtype(series.dtype, np.number):\n        return series.var()\n    else:\n        return np.nan", "code_tokens": "def var ( series ) : if np . issubdtype ( series . dtype , np . number ) : return series . var ( ) else : return np . nan", "docstring_tokens": "Returns the variance of values in a series .", "label": 0}, {"idx": "cosqa-train-16845", "doc": "uniquify a list in python", "code": "def uniquify_list(L):\n    \"\"\"Same order unique list using only a list compression.\"\"\"\n    return [e for i, e in enumerate(L) if L.index(e) == i]", "code_tokens": "def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]", "docstring_tokens": "Same order unique list using only a list compression .", "label": 1}, {"idx": "cosqa-train-16846", "doc": "python calculating sum molecular weight from protein sequence", "code": "def sequence_molecular_weight(seq):\n    \"\"\"Returns the molecular weight of the polypeptide sequence.\n\n    Notes\n    -----\n    Units = Daltons\n\n    Parameters\n    ----------\n    seq : str\n        Sequence of amino acids.\n    \"\"\"\n    if 'X' in seq:\n        warnings.warn(_nc_warning_str, NoncanonicalWarning)\n    return sum(\n        [residue_mwt[aa] * n for aa, n in Counter(seq).items()]) + water_mass", "code_tokens": "def sequence_molecular_weight ( seq ) : if 'X' in seq : warnings . warn ( _nc_warning_str , NoncanonicalWarning ) return sum ( [ residue_mwt [ aa ] * n for aa , n in Counter ( seq ) . items ( ) ] ) + water_mass", "docstring_tokens": "Returns the molecular weight of the polypeptide sequence .", "label": 1}, {"idx": "cosqa-train-16847", "doc": "unittest python assert not equal", "code": "def assert_is_not(expected, actual, message=None, extra=None):\n    \"\"\"Raises an AssertionError if expected is actual.\"\"\"\n    assert expected is not actual, _assert_fail_message(\n        message, expected, actual, \"is\", extra\n    )", "code_tokens": "def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "docstring_tokens": "Raises an AssertionError if expected is actual .", "label": 0}, {"idx": "cosqa-train-16848", "doc": "python call a function that takes self", "code": "def do(self):\n        \"\"\"\n        Set a restore point (copy the object), then call the method.\n        :return: obj.do_method(*args)\n        \"\"\"\n        self.restore_point = self.obj.copy()\n        return self.do_method(self.obj, *self.args)", "code_tokens": "def do ( self ) : self . restore_point = self . obj . copy ( ) return self . do_method ( self . obj , * self . args )", "docstring_tokens": "Set a restore point ( copy the object ) then call the method . : return : obj . do_method ( * args )", "label": 0}, {"idx": "cosqa-train-16849", "doc": "unix to windows paths python", "code": "def __unixify(self, s):\n        \"\"\" stupid windows. converts the backslash to forwardslash for consistency \"\"\"\n        return os.path.normpath(s).replace(os.sep, \"/\")", "code_tokens": "def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "docstring_tokens": "stupid windows . converts the backslash to forwardslash for consistency", "label": 0}, {"idx": "cosqa-train-16850", "doc": "python calling function with underscore", "code": "def python(string: str):\n        \"\"\"\n            :param string: String can be type, resource or python case\n        \"\"\"\n        return underscore(singularize(string) if Naming._pluralize(string) else string)", "code_tokens": "def python ( string : str ) : return underscore ( singularize ( string ) if Naming . _pluralize ( string ) else string )", "docstring_tokens": ": param string : String can be type resource or python case", "label": 1}, {"idx": "cosqa-train-16851", "doc": "updating a canvas in python", "code": "def update(self):\n        \"\"\"Update all visuals in the attached canvas.\"\"\"\n        if not self.canvas:\n            return\n        for visual in self.canvas.visuals:\n            self.update_program(visual.program)\n        self.canvas.update()", "code_tokens": "def update ( self ) : if not self . canvas : return for visual in self . canvas . visuals : self . update_program ( visual . program ) self . canvas . update ( )", "docstring_tokens": "Update all visuals in the attached canvas .", "label": 1}, {"idx": "cosqa-train-16852", "doc": "python can none value be used outside variables", "code": "def min_or_none(val1, val2):\n    \"\"\"Returns min(val1, val2) returning None only if both values are None\"\"\"\n    return min(val1, val2, key=lambda x: sys.maxint if x is None else x)", "code_tokens": "def min_or_none ( val1 , val2 ) : return min ( val1 , val2 , key = lambda x : sys . maxint if x is None else x )", "docstring_tokens": "Returns min ( val1 val2 ) returning None only if both values are None", "label": 1}, {"idx": "cosqa-train-16853", "doc": "use credentials from a text file python", "code": "def read_credentials(fname):\n    \"\"\"\n    read a simple text file from a private location to get\n    username and password\n    \"\"\"\n    with open(fname, 'r') as f:\n        username = f.readline().strip('\\n')\n        password = f.readline().strip('\\n')\n    return username, password", "code_tokens": "def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "docstring_tokens": "read a simple text file from a private location to get username and password", "label": 0}, {"idx": "cosqa-train-16854", "doc": "python can not pickle local objects", "code": "def _parallel_compare_helper(class_obj, pairs, x, x_link=None):\n    \"\"\"Internal function to overcome pickling problem in python2.\"\"\"\n    return class_obj._compute(pairs, x, x_link)", "code_tokens": "def _parallel_compare_helper ( class_obj , pairs , x , x_link = None ) : return class_obj . _compute ( pairs , x , x_link )", "docstring_tokens": "Internal function to overcome pickling problem in python2 .", "label": 0}, {"idx": "cosqa-train-16855", "doc": "use maximum performance tensorflow gpu cuda a python", "code": "def transformer_tall_pretrain_lm_tpu_adafactor():\n  \"\"\"Hparams for transformer on LM pretraining (with 64k vocab) on TPU.\"\"\"\n  hparams = transformer_tall_pretrain_lm()\n  update_hparams_for_tpu(hparams)\n  hparams.max_length = 1024\n  # For multi-problem on TPU we need it in absolute examples.\n  hparams.batch_size = 8\n  hparams.multiproblem_vocab_size = 2**16\n  return hparams", "code_tokens": "def transformer_tall_pretrain_lm_tpu_adafactor ( ) : hparams = transformer_tall_pretrain_lm ( ) update_hparams_for_tpu ( hparams ) hparams . max_length = 1024 # For multi-problem on TPU we need it in absolute examples. hparams . batch_size = 8 hparams . multiproblem_vocab_size = 2 ** 16 return hparams", "docstring_tokens": "Hparams for transformer on LM pretraining ( with 64k vocab ) on TPU .", "label": 0}, {"idx": "cosqa-train-16856", "doc": "python can you get the shape of a npz", "code": "def out_shape_from_array(arr):\n    \"\"\"Get the output shape from an array.\"\"\"\n    arr = np.asarray(arr)\n    if arr.ndim == 1:\n        return arr.shape\n    else:\n        return (arr.shape[1],)", "code_tokens": "def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "docstring_tokens": "Get the output shape from an array .", "label": 0}, {"idx": "cosqa-train-16857", "doc": "use of any to compare an array element with an int in python", "code": "def isnumber(*args):\n    \"\"\"Checks if value is an integer, long integer or float.\n\n    NOTE: Treats booleans as numbers, where True=1 and False=0.\n    \"\"\"\n    return all(map(lambda c: isinstance(c, int) or isinstance(c, float), args))", "code_tokens": "def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )", "docstring_tokens": "Checks if value is an integer long integer or float .", "label": 1}, {"idx": "cosqa-train-16858", "doc": "python canvas remove image", "code": "def clear(self):\n        \"\"\"Clear the displayed image.\"\"\"\n        self._imgobj = None\n        try:\n            # See if there is an image on the canvas\n            self.canvas.delete_object_by_tag(self._canvas_img_tag)\n            self.redraw()\n        except KeyError:\n            pass", "code_tokens": "def clear ( self ) : self . _imgobj = None try : # See if there is an image on the canvas self . canvas . delete_object_by_tag ( self . _canvas_img_tag ) self . redraw ( ) except KeyError : pass", "docstring_tokens": "Clear the displayed image .", "label": 1}, {"idx": "cosqa-train-16859", "doc": "use pickle to send data over socket python", "code": "def send(socket, data, num_bytes=20):\n    \"\"\"Send data to specified socket.\n\n\n    :param socket: open socket instance\n    :param data: data to send\n    :param num_bytes: number of bytes to read\n\n    :return: received data\n    \"\"\"\n    pickled_data = pickle.dumps(data, -1)\n    length = str(len(pickled_data)).zfill(num_bytes)\n    socket.sendall(length.encode())\n    socket.sendall(pickled_data)", "code_tokens": "def send ( socket , data , num_bytes = 20 ) : pickled_data = pickle . dumps ( data , - 1 ) length = str ( len ( pickled_data ) ) . zfill ( num_bytes ) socket . sendall ( length . encode ( ) ) socket . sendall ( pickled_data )", "docstring_tokens": "Send data to specified socket .", "label": 0}, {"idx": "cosqa-train-16860", "doc": "python capitalize word after", "code": "def decamelise(text):\n    \"\"\"Convert CamelCase to lower_and_underscore.\"\"\"\n    s = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s).lower()", "code_tokens": "def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Convert CamelCase to lower_and_underscore .", "label": 0}, {"idx": "cosqa-train-16861", "doc": "use python to change bind dns record", "code": "def _request_modify_dns_record(self, record):\n        \"\"\"Sends Modify_DNS_Record request\"\"\"\n        return self._request_internal(\"Modify_DNS_Record\",\n                                      domain=self.domain,\n                                      record=record)", "code_tokens": "def _request_modify_dns_record ( self , record ) : return self . _request_internal ( \"Modify_DNS_Record\" , domain = self . domain , record = record )", "docstring_tokens": "Sends Modify_DNS_Record request", "label": 1}, {"idx": "cosqa-train-16862", "doc": "python case insensitve string compare", "code": "def is_equal_strings_ignore_case(first, second):\n    \"\"\"The function compares strings ignoring case\"\"\"\n    if first and second:\n        return first.upper() == second.upper()\n    else:\n        return not (first or second)", "code_tokens": "def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )", "docstring_tokens": "The function compares strings ignoring case", "label": 1}, {"idx": "cosqa-train-16863", "doc": "use sparse matrices with agglomerativeclustering in python", "code": "def hclust_linearize(U):\n    \"\"\"Sorts the rows of a matrix by hierarchical clustering.\n\n    Parameters:\n        U (ndarray) : matrix of data\n\n    Returns:\n        prm (ndarray) : permutation of the rows\n    \"\"\"\n\n    from scipy.cluster import hierarchy\n    Z = hierarchy.ward(U)\n    return hierarchy.leaves_list(hierarchy.optimal_leaf_ordering(Z, U))", "code_tokens": "def hclust_linearize ( U ) : from scipy . cluster import hierarchy Z = hierarchy . ward ( U ) return hierarchy . leaves_list ( hierarchy . optimal_leaf_ordering ( Z , U ) )", "docstring_tokens": "Sorts the rows of a matrix by hierarchical clustering .", "label": 0}, {"idx": "cosqa-train-16864", "doc": "python cast data as array", "code": "def convert_array(array):\n    \"\"\"\n    Converts an ARRAY string stored in the database back into a Numpy array.\n\n    Parameters\n    ----------\n    array: ARRAY\n        The array object to be converted back into a Numpy array.\n\n    Returns\n    -------\n    array\n            The converted Numpy array.\n\n    \"\"\"\n    out = io.BytesIO(array)\n    out.seek(0)\n    return np.load(out)", "code_tokens": "def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "docstring_tokens": "Converts an ARRAY string stored in the database back into a Numpy array .", "label": 0}, {"idx": "cosqa-train-16865", "doc": "use the def function to ask a question in python", "code": "def ask_str(question: str, default: str = None):\n    \"\"\"Asks for a simple string\"\"\"\n    default_q = \" [default: {0}]: \".format(\n        default) if default is not None else \"\"\n    answer = input(\"{0} [{1}]: \".format(question, default_q))\n\n    if answer == \"\":\n        return default\n    return answer", "code_tokens": "def ask_str ( question : str , default : str = None ) : default_q = \" [default: {0}]: \" . format ( default ) if default is not None else \"\" answer = input ( \"{0} [{1}]: \" . format ( question , default_q ) ) if answer == \"\" : return default return answer", "docstring_tokens": "Asks for a simple string", "label": 1}, {"idx": "cosqa-train-16866", "doc": "python change a specific column name", "code": "def col_rename(df,col_name,new_col_name):\n    \"\"\" Changes a column name in a DataFrame\n    Parameters:\n    df - DataFrame\n        DataFrame to operate on\n    col_name - string\n        Name of column to change\n    new_col_name - string\n        New name of column\n    \"\"\"\n    col_list = list(df.columns)\n    for index,value in enumerate(col_list):\n        if value == col_name:\n            col_list[index] = new_col_name\n            break\n    df.columns = col_list", "code_tokens": "def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list", "docstring_tokens": "Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column", "label": 0}, {"idx": "cosqa-train-16867", "doc": "using ctypes to use c functions in python", "code": "def get_ctype(rtype, cfunc, *args):\n    \"\"\" Call a C function that takes a pointer as its last argument and\n        return the C object that it contains after the function has finished.\n\n    :param rtype:   C data type is filled by the function\n    :param cfunc:   C function to call\n    :param args:    Arguments to call function with\n    :return:        A pointer to the specified data type\n    \"\"\"\n    val_p = backend.ffi.new(rtype)\n    args = args + (val_p,)\n    cfunc(*args)\n    return val_p[0]", "code_tokens": "def get_ctype ( rtype , cfunc , * args ) : val_p = backend . ffi . new ( rtype ) args = args + ( val_p , ) cfunc ( * args ) return val_p [ 0 ]", "docstring_tokens": "Call a C function that takes a pointer as its last argument and return the C object that it contains after the function has finished .", "label": 1}, {"idx": "cosqa-train-16868", "doc": "python change column to datetime with different formats", "code": "def convert_str_to_datetime(df, *, column: str, format: str):\n    \"\"\"\n    Convert string column into datetime column\n\n    ---\n\n    ### Parameters\n\n    *mandatory :*\n    - `column` (*str*): name of the column to format\n    - `format` (*str*): current format of the values (see [available formats](\n    https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior))\n    \"\"\"\n    df[column] = pd.to_datetime(df[column], format=format)\n    return df", "code_tokens": "def convert_str_to_datetime ( df , * , column : str , format : str ) : df [ column ] = pd . to_datetime ( df [ column ] , format = format ) return df", "docstring_tokens": "Convert string column into datetime column", "label": 1}, {"idx": "cosqa-train-16869", "doc": "using pickle to store numpy array python", "code": "def _openResources(self):\n        \"\"\" Uses numpy.load to open the underlying file\n        \"\"\"\n        arr = np.load(self._fileName, allow_pickle=ALLOW_PICKLE)\n        check_is_an_array(arr)\n        self._array = arr", "code_tokens": "def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr", "docstring_tokens": "Uses numpy . load to open the underlying file", "label": 1}, {"idx": "cosqa-train-16870", "doc": "python change datatype from object to int", "code": "def _to_numeric(val):\n    \"\"\"\n    Helper function for conversion of various data types into numeric representation.\n    \"\"\"\n    if isinstance(val, (int, float, datetime.datetime, datetime.timedelta)):\n        return val\n    return float(val)", "code_tokens": "def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "docstring_tokens": "Helper function for conversion of various data types into numeric representation .", "label": 0}, {"idx": "cosqa-train-16871", "doc": "using python 3 widget to terminate program", "code": "def do_exit(self, arg):\n        \"\"\"Exit the shell session.\"\"\"\n\n        if self.current:\n            self.current.close()\n        self.resource_manager.close()\n        del self.resource_manager\n        return True", "code_tokens": "def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True", "docstring_tokens": "Exit the shell session .", "label": 0}, {"idx": "cosqa-train-16872", "doc": "python change date format to day month year", "code": "def get_year_start(day=None):\n    \"\"\"Returns January 1 of the given year.\"\"\"\n    day = add_timezone(day or datetime.date.today())\n    return day.replace(month=1).replace(day=1)", "code_tokens": "def get_year_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( month = 1 ) . replace ( day = 1 )", "docstring_tokens": "Returns January 1 of the given year .", "label": 1}, {"idx": "cosqa-train-16873", "doc": "using python print matrix equally spaced", "code": "def print_matrix(X, decimals=1):\n    \"\"\"Pretty printing for numpy matrix X\"\"\"\n    for row in np.round(X, decimals=decimals):\n        print(row)", "code_tokens": "def print_matrix ( X , decimals = 1 ) : for row in np . round ( X , decimals = decimals ) : print ( row )", "docstring_tokens": "Pretty printing for numpy matrix X", "label": 0}, {"idx": "cosqa-train-16874", "doc": "python change default gui closing behavior", "code": "def closing_plugin(self, cancelable=False):\n        \"\"\"Perform actions before parent main window is closed\"\"\"\n        self.dialog_manager.close_all()\n        self.shell.exit_interpreter()\n        return True", "code_tokens": "def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "docstring_tokens": "Perform actions before parent main window is closed", "label": 1}, {"idx": "cosqa-train-16875", "doc": "using python to extract c++ comments", "code": "def CleanseComments(line):\n  \"\"\"Removes //-comments and single-line C-style /* */ comments.\n\n  Args:\n    line: A line of C++ source.\n\n  Returns:\n    The line with single-line comments removed.\n  \"\"\"\n  commentpos = line.find('//')\n  if commentpos != -1 and not IsCppString(line[:commentpos]):\n    line = line[:commentpos].rstrip()\n  # get rid of /* ... */\n  return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS.sub('', line)", "code_tokens": "def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )", "docstring_tokens": "Removes // - comments and single - line C - style / * * / comments .", "label": 0}, {"idx": "cosqa-train-16876", "doc": "python change mouse cursor for window", "code": "def set_cursor(self, x, y):\n        \"\"\"\n        Sets the cursor to the desired position.\n\n        :param x: X position\n        :param y: Y position\n        \"\"\"\n        curses.curs_set(1)\n        self.screen.move(y, x)", "code_tokens": "def set_cursor ( self , x , y ) : curses . curs_set ( 1 ) self . screen . move ( y , x )", "docstring_tokens": "Sets the cursor to the desired position .", "label": 0}, {"idx": "cosqa-train-16877", "doc": "using python to remove duplicate files", "code": "def _remove_duplicate_files(xs):\n    \"\"\"Remove files specified multiple times in a list.\n    \"\"\"\n    seen = set([])\n    out = []\n    for x in xs:\n        if x[\"path\"] not in seen:\n            out.append(x)\n            seen.add(x[\"path\"])\n    return out", "code_tokens": "def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ \"path\" ] not in seen : out . append ( x ) seen . add ( x [ \"path\" ] ) return out", "docstring_tokens": "Remove files specified multiple times in a list .", "label": 0}, {"idx": "cosqa-train-16878", "doc": "python change mysql data to json", "code": "def process_result_value(self, value, dialect):\n        \"\"\"convert value from json to a python object\"\"\"\n        if value is not None:\n            value = simplejson.loads(value)\n        return value", "code_tokens": "def process_result_value ( self , value , dialect ) : if value is not None : value = simplejson . loads ( value ) return value", "docstring_tokens": "convert value from json to a python object", "label": 0}, {"idx": "cosqa-train-16879", "doc": "using replace in strings python", "code": "def multi_replace(instr, search_list=[], repl_list=None):\n    \"\"\"\n    Does a string replace with a list of search and replacements\n\n    TODO: rename\n    \"\"\"\n    repl_list = [''] * len(search_list) if repl_list is None else repl_list\n    for ser, repl in zip(search_list, repl_list):\n        instr = instr.replace(ser, repl)\n    return instr", "code_tokens": "def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr", "docstring_tokens": "Does a string replace with a list of search and replacements", "label": 1}, {"idx": "cosqa-train-16880", "doc": "python change object to dict", "code": "def _zeep_to_dict(cls, obj):\n        \"\"\"Convert a zeep object to a dictionary.\"\"\"\n        res = serialize_object(obj)\n        res = cls._get_non_empty_dict(res)\n        return res", "code_tokens": "def _zeep_to_dict ( cls , obj ) : res = serialize_object ( obj ) res = cls . _get_non_empty_dict ( res ) return res", "docstring_tokens": "Convert a zeep object to a dictionary .", "label": 1}, {"idx": "cosqa-train-16881", "doc": "using runpy with python unit tests", "code": "def test(*args):\n    \"\"\"\n    Run unit tests.\n    \"\"\"\n    subprocess.call([\"py.test-2.7\"] + list(args))\n    subprocess.call([\"py.test-3.4\"] + list(args))", "code_tokens": "def test ( * args ) : subprocess . call ( [ \"py.test-2.7\" ] + list ( args ) ) subprocess . call ( [ \"py.test-3.4\" ] + list ( args ) )", "docstring_tokens": "Run unit tests .", "label": 1}, {"idx": "cosqa-train-16882", "doc": "python changing y axis to log", "code": "def log_y_cb(self, w, val):\n        \"\"\"Toggle linear/log scale for Y-axis.\"\"\"\n        self.tab_plot.logy = val\n        self.plot_two_columns()", "code_tokens": "def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "docstring_tokens": "Toggle linear / log scale for Y - axis .", "label": 0}, {"idx": "cosqa-train-16883", "doc": "validate json to swagger in python", "code": "def main(source):\n    \"\"\"\n    For a given command line supplied argument, negotiate the content, parse\n    the schema and then return any issues to stdout or if no schema issues,\n    return success exit code.\n    \"\"\"\n    if source is None:\n        click.echo(\n            \"You need to supply a file or url to a schema to a swagger schema, for\"\n            \"the validator to work.\"\n        )\n        return 1\n    try:\n        load(source)\n        click.echo(\"Validation passed\")\n        return 0\n    except ValidationError as e:\n        raise click.ClickException(str(e))", "code_tokens": "def main ( source ) : if source is None : click . echo ( \"You need to supply a file or url to a schema to a swagger schema, for\" \"the validator to work.\" ) return 1 try : load ( source ) click . echo ( \"Validation passed\" ) return 0 except ValidationError as e : raise click . ClickException ( str ( e ) )", "docstring_tokens": "For a given command line supplied argument negotiate the content parse the schema and then return any issues to stdout or if no schema issues return success exit code .", "label": 0}, {"idx": "cosqa-train-16884", "doc": "python check all attributes of an object", "code": "def hasattrs(object, *names):\n    \"\"\"\n    Takes in an object and a variable length amount of named attributes,\n    and checks to see if the object has each property. If any of the\n    attributes are missing, this returns false.\n\n    :param object: an object that may or may not contain the listed attributes\n    :param names: a variable amount of attribute names to check for\n    :return: True if the object contains each named attribute, false otherwise\n    \"\"\"\n    for name in names:\n        if not hasattr(object, name):\n            return False\n    return True", "code_tokens": "def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True", "docstring_tokens": "Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .", "label": 1}, {"idx": "cosqa-train-16885", "doc": "value if a list is nan or is a string python", "code": "def set_float(val):\n    \"\"\" utility to set a floating value,\n    useful for converting from strings \"\"\"\n    out = None\n    if not val in (None, ''):\n        try:\n            out = float(val)\n        except ValueError:\n            return None\n        if numpy.isnan(out):\n            out = default\n    return out", "code_tokens": "def set_float ( val ) : out = None if not val in ( None , '' ) : try : out = float ( val ) except ValueError : return None if numpy . isnan ( out ) : out = default return out", "docstring_tokens": "utility to set a floating value useful for converting from strings", "label": 1}, {"idx": "cosqa-train-16886", "doc": "python check data type is datetime", "code": "def is_timestamp(obj):\n    \"\"\"\n    Yaml either have automatically converted it to a datetime object\n    or it is a string that will be validated later.\n    \"\"\"\n    return isinstance(obj, datetime.datetime) or is_string(obj) or is_int(obj) or is_float(obj)", "code_tokens": "def is_timestamp ( obj ) : return isinstance ( obj , datetime . datetime ) or is_string ( obj ) or is_int ( obj ) or is_float ( obj )", "docstring_tokens": "Yaml either have automatically converted it to a datetime object or it is a string that will be validated later .", "label": 0}, {"idx": "cosqa-train-16887", "doc": "verify a date it is last day of a month python", "code": "def last_day(year=_year, month=_month):\n    \"\"\"\n    get the current month's last day\n    :param year:  default to current year\n    :param month:  default to current month\n    :return: month's last day\n    \"\"\"\n    last_day = calendar.monthrange(year, month)[1]\n    return datetime.date(year=year, month=month, day=last_day)", "code_tokens": "def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )", "docstring_tokens": "get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day", "label": 1}, {"idx": "cosqa-train-16888", "doc": "python check default optional arg in function", "code": "def check_for_positional_argument(kwargs, name, default=False):\n    \"\"\"\n    @type kwargs: dict\n    @type name: str\n    @type default: bool, int, str\n    @return: bool, int\n    \"\"\"\n    if name in kwargs:\n        if str(kwargs[name]) == \"True\":\n            return True\n        elif str(kwargs[name]) == \"False\":\n            return False\n        else:\n            return kwargs[name]\n\n    return default", "code_tokens": "def check_for_positional_argument ( kwargs , name , default = False ) : if name in kwargs : if str ( kwargs [ name ] ) == \"True\" : return True elif str ( kwargs [ name ] ) == \"False\" : return False else : return kwargs [ name ] return default", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-16889", "doc": "verify email format regex python", "code": "def _validate_simple(email):\n        \"\"\"Does a simple validation of an email by matching it to a regexps\n\n        :param email: The email to check\n        :return: The valid Email address\n\n        :raises: ValueError if value is not a valid email\n        \"\"\"\n        name, address = parseaddr(email)\n        if not re.match('[^@]+@[^@]+\\.[^@]+', address):\n            raise ValueError('Invalid email :{email}'.format(email=email))\n        return address", "code_tokens": "def _validate_simple ( email ) : name , address = parseaddr ( email ) if not re . match ( '[^@]+@[^@]+\\.[^@]+' , address ) : raise ValueError ( 'Invalid email :{email}' . format ( email = email ) ) return address", "docstring_tokens": "Does a simple validation of an email by matching it to a regexps", "label": 1}, {"idx": "cosqa-train-16890", "doc": "python check dictionary key starts with a certain letter", "code": "def __contains__ (self, key):\n        \"\"\"Check lowercase key item.\"\"\"\n        assert isinstance(key, basestring)\n        return dict.__contains__(self, key.lower())", "code_tokens": "def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "docstring_tokens": "Check lowercase key item .", "label": 0}, {"idx": "cosqa-train-16891", "doc": "verify images if broken python", "code": "def is_image_file_valid(file_path_name):\n    \"\"\"\n    Indicate whether the specified image file is valid or not.\n\n\n    @param file_path_name: absolute path and file name of an image.\n\n\n    @return: ``True`` if the image file is valid, ``False`` if the file is\n        truncated or does not correspond to a supported image.\n    \"\"\"\n    # Image.verify is only implemented for PNG images, and it only verifies\n    # the CRC checksum in the image.  The only way to check from within\n    # Pillow is to load the image in a try/except and check the error.  If\n    # as much info as possible is from the image is needed,\n    # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it\n    # will attempt to parse as much as possible.\n    try:\n        with Image.open(file_path_name) as image:\n            image.load()\n    except IOError:\n        return False\n\n    return True", "code_tokens": "def is_image_file_valid ( file_path_name ) : # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image.  The only way to check from within # Pillow is to load the image in a try/except and check the error.  If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try : with Image . open ( file_path_name ) as image : image . load ( ) except IOError : return False return True", "docstring_tokens": "Indicate whether the specified image file is valid or not .", "label": 1}, {"idx": "cosqa-train-16892", "doc": "visit last element python", "code": "def do_last(environment, seq):\n    \"\"\"Return the last item of a sequence.\"\"\"\n    try:\n        return next(iter(reversed(seq)))\n    except StopIteration:\n        return environment.undefined('No last item, sequence was empty.')", "code_tokens": "def do_last ( environment , seq ) : try : return next ( iter ( reversed ( seq ) ) ) except StopIteration : return environment . undefined ( 'No last item, sequence was empty.' )", "docstring_tokens": "Return the last item of a sequence .", "label": 0}, {"idx": "cosqa-train-16893", "doc": "python check for all numeric types", "code": "def is_numeric_dtype(dtype):\n    \"\"\"Return ``True`` if ``dtype`` is a numeric type.\"\"\"\n    dtype = np.dtype(dtype)\n    return np.issubsctype(getattr(dtype, 'base', None), np.number)", "code_tokens": "def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )", "docstring_tokens": "Return True if dtype is a numeric type .", "label": 1}, {"idx": "cosqa-train-16894", "doc": "vs code python live output", "code": "def stdout_display():\n    \"\"\" Print results straight to stdout \"\"\"\n    if sys.version_info[0] == 2:\n        yield SmartBuffer(sys.stdout)\n    else:\n        yield SmartBuffer(sys.stdout.buffer)", "code_tokens": "def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )", "docstring_tokens": "Print results straight to stdout", "label": 0}, {"idx": "cosqa-train-16895", "doc": "python check for existence of property in model", "code": "def has_field(mc, field_name):\n    \"\"\"\n    detect if a model has a given field has\n\n    :param field_name:\n    :param mc:\n    :return:\n    \"\"\"\n    try:\n        mc._meta.get_field(field_name)\n    except FieldDoesNotExist:\n        return False\n    return True", "code_tokens": "def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True", "docstring_tokens": "detect if a model has a given field has", "label": 1}, {"idx": "cosqa-train-16896", "doc": "wav file to spectrogram python mathlab", "code": "def readwav(filename):\n    \"\"\"Read a WAV file and returns the data and sample rate\n\n    ::\n\n        from spectrum.io import readwav\n        readwav()\n\n    \"\"\"\n    from scipy.io.wavfile import read as readwav\n    samplerate, signal = readwav(filename)\n    return signal, samplerate", "code_tokens": "def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate", "docstring_tokens": "Read a WAV file and returns the data and sample rate", "label": 0}, {"idx": "cosqa-train-16897", "doc": "python check for overlapping matches in string", "code": "def _rm_name_match(s1, s2):\n  \"\"\"\n  determine whether two sequence names from a repeatmasker alignment match.\n\n  :return: True if they are the same string, or if one forms a substring of the\n           other, else False\n  \"\"\"\n  m_len = min(len(s1), len(s2))\n  return s1[:m_len] == s2[:m_len]", "code_tokens": "def _rm_name_match ( s1 , s2 ) : m_len = min ( len ( s1 ) , len ( s2 ) ) return s1 [ : m_len ] == s2 [ : m_len ]", "docstring_tokens": "determine whether two sequence names from a repeatmasker alignment match .", "label": 1}, {"idx": "cosqa-train-16898", "doc": "way to tell if image is on screen python", "code": "def inside_softimage():\n    \"\"\"Returns a boolean indicating if the code is executed inside softimage.\"\"\"\n    try:\n        import maya\n        return False\n    except ImportError:\n        pass\n    try:\n        from win32com.client import Dispatch as disp\n        disp('XSI.Application')\n        return True\n    except:\n        return False", "code_tokens": "def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "docstring_tokens": "Returns a boolean indicating if the code is executed inside softimage .", "label": 0}, {"idx": "cosqa-train-16899", "doc": "python check for tab", "code": "def _name_exists(self, name):\n        \"\"\"\n        Checks if we already have an opened tab with the same name.\n        \"\"\"\n        for i in range(self.count()):\n            if self.tabText(i) == name:\n                return True\n        return False", "code_tokens": "def _name_exists ( self , name ) : for i in range ( self . count ( ) ) : if self . tabText ( i ) == name : return True return False", "docstring_tokens": "Checks if we already have an opened tab with the same name .", "label": 1}, {"idx": "cosqa-train-16900", "doc": "webdriver python element input set value", "code": "def set_input_value(self, selector, value):\n        \"\"\"Set the value of the input matched by given selector.\"\"\"\n        script = 'document.querySelector(\"%s\").setAttribute(\"value\", \"%s\")'\n        script = script % (selector, value)\n        self.evaluate(script)", "code_tokens": "def set_input_value ( self , selector , value ) : script = 'document.querySelector(\"%s\").setAttribute(\"value\", \"%s\")' script = script % ( selector , value ) self . evaluate ( script )", "docstring_tokens": "Set the value of the input matched by given selector .", "label": 0}, {"idx": "cosqa-train-16901", "doc": "python check if admin privliges", "code": "def can_access(self, user):\n        \"\"\"Return whether or not `user` can access a project.\n\n        The project's is_ready field must be set for a user to access.\n\n        \"\"\"\n        return self.class_.is_admin(user) or \\\n            self.is_ready and self.class_ in user.classes", "code_tokens": "def can_access ( self , user ) : return self . class_ . is_admin ( user ) or self . is_ready and self . class_ in user . classes", "docstring_tokens": "Return whether or not user can access a project .", "label": 0}, {"idx": "cosqa-train-16902", "doc": "what can i store in dict python", "code": "def state(self):\n        \"\"\"Return internal state, useful for testing.\"\"\"\n        return {'c': self.c, 's0': self.s0, 's1': self.s1, 's2': self.s2}", "code_tokens": "def state ( self ) : return { 'c' : self . c , 's0' : self . s0 , 's1' : self . s1 , 's2' : self . s2 }", "docstring_tokens": "Return internal state useful for testing .", "label": 0}, {"idx": "cosqa-train-16903", "doc": "what does a dictionary return if empty python", "code": "def get_single_item(d):\n    \"\"\"Get an item from a dict which contains just one item.\"\"\"\n    assert len(d) == 1, 'Single-item dict must have just one item, not %d.' % len(d)\n    return next(six.iteritems(d))", "code_tokens": "def get_single_item ( d ) : assert len ( d ) == 1 , 'Single-item dict must have just one item, not %d.' % len ( d ) return next ( six . iteritems ( d ) )", "docstring_tokens": "Get an item from a dict which contains just one item .", "label": 0}, {"idx": "cosqa-train-16904", "doc": "wht the border of legend box is grey color in python plot", "code": "def mpl_outside_legend(ax, **kwargs):\n    \"\"\" Places a legend box outside a matplotlib Axes instance. \"\"\"\n    box = ax.get_position()\n    ax.set_position([box.x0, box.y0, box.width * 0.75, box.height])\n    # Put a legend to the right of the current axis\n    ax.legend(loc='upper left', bbox_to_anchor=(1, 1), **kwargs)", "code_tokens": "def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )", "docstring_tokens": "Places a legend box outside a matplotlib Axes instance .", "label": 0}, {"idx": "cosqa-train-16905", "doc": "python check if an item is a directory", "code": "def _IsDirectory(parent, item):\n  \"\"\"Helper that returns if parent/item is a directory.\"\"\"\n  return tf.io.gfile.isdir(os.path.join(parent, item))", "code_tokens": "def _IsDirectory ( parent , item ) : return tf . io . gfile . isdir ( os . path . join ( parent , item ) )", "docstring_tokens": "Helper that returns if parent / item is a directory .", "label": 1}, {"idx": "cosqa-train-16906", "doc": "will my python kill my child", "code": "def cli_command_quit(self, msg):\n        \"\"\"\\\n        kills the child and exits\n        \"\"\"\n        if self.state == State.RUNNING and self.sprocess and self.sprocess.proc:\n            self.sprocess.proc.kill()\n        else:\n            sys.exit(0)", "code_tokens": "def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )", "docstring_tokens": "\\ kills the child and exits", "label": 0}, {"idx": "cosqa-train-16907", "doc": "python check if any variable in list is type", "code": "def contains_geometric_info(var):\n    \"\"\" Check whether the passed variable is a tuple with two floats or integers \"\"\"\n    return isinstance(var, tuple) and len(var) == 2 and all(isinstance(val, (int, float)) for val in var)", "code_tokens": "def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )", "docstring_tokens": "Check whether the passed variable is a tuple with two floats or integers", "label": 1}, {"idx": "cosqa-train-16908", "doc": "word counts to dictionary in python", "code": "def np_counts(self):\n    \"\"\"Dictionary of noun phrase frequencies in this text.\n    \"\"\"\n    counts = defaultdict(int)\n    for phrase in self.noun_phrases:\n        counts[phrase] += 1\n    return counts", "code_tokens": "def np_counts ( self ) : counts = defaultdict ( int ) for phrase in self . noun_phrases : counts [ phrase ] += 1 return counts", "docstring_tokens": "Dictionary of noun phrase frequencies in this text .", "label": 0}, {"idx": "cosqa-train-16909", "doc": "python check if edge not exists", "code": "def has_edge(self, p_from, p_to):\n        \"\"\" Returns True when the graph has the given edge. \"\"\"\n        return p_from in self._edges and p_to in self._edges[p_from]", "code_tokens": "def has_edge ( self , p_from , p_to ) : return p_from in self . _edges and p_to in self . _edges [ p_from ]", "docstring_tokens": "Returns True when the graph has the given edge .", "label": 0}, {"idx": "cosqa-train-16910", "doc": "working with fft in python", "code": "def fft_freqs(n_fft, fs):\n    \"\"\"Return frequencies for DFT\n\n    Parameters\n    ----------\n    n_fft : int\n        Number of points in the FFT.\n    fs : float\n        The sampling rate.\n    \"\"\"\n    return np.arange(0, (n_fft // 2 + 1)) / float(n_fft) * float(fs)", "code_tokens": "def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "docstring_tokens": "Return frequencies for DFT", "label": 0}, {"idx": "cosqa-train-16911", "doc": "wrap c++ code to python code", "code": "def rpc_fix_code(self, source, directory):\n        \"\"\"Formats Python code to conform to the PEP 8 style guide.\n\n        \"\"\"\n        source = get_source(source)\n        return fix_code(source, directory)", "code_tokens": "def rpc_fix_code ( self , source , directory ) : source = get_source ( source ) return fix_code ( source , directory )", "docstring_tokens": "Formats Python code to conform to the PEP 8 style guide .", "label": 1}, {"idx": "cosqa-train-16912", "doc": "write a code in python to check the validity of a phone number", "code": "def is_valid(number):\n    \"\"\"determines whether the card number is valid.\"\"\"\n    n = str(number)\n    if not n.isdigit():\n        return False\n    return int(n[-1]) == get_check_digit(n[:-1])", "code_tokens": "def is_valid ( number ) : n = str ( number ) if not n . isdigit ( ) : return False return int ( n [ - 1 ] ) == get_check_digit ( n [ : - 1 ] )", "docstring_tokens": "determines whether the card number is valid .", "label": 0}, {"idx": "cosqa-train-16913", "doc": "python check if file is in folder", "code": "def contained_in(filename, directory):\n    \"\"\"Test if a file is located within the given directory.\"\"\"\n    filename = os.path.normcase(os.path.abspath(filename))\n    directory = os.path.normcase(os.path.abspath(directory))\n    return os.path.commonprefix([filename, directory]) == directory", "code_tokens": "def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "docstring_tokens": "Test if a file is located within the given directory .", "label": 0}, {"idx": "cosqa-train-16914", "doc": "write a function that flattens a list python", "code": "def flatten(l):\n    \"\"\"Flatten a nested list.\"\"\"\n    return sum(map(flatten, l), []) \\\n        if isinstance(l, list) or isinstance(l, tuple) else [l]", "code_tokens": "def flatten ( l ) : return sum ( map ( flatten , l ) , [ ] ) if isinstance ( l , list ) or isinstance ( l , tuple ) else [ l ]", "docstring_tokens": "Flatten a nested list .", "label": 0}, {"idx": "cosqa-train-16915", "doc": "python check if i'm in virtualenv", "code": "def _pip_exists(self):\n        \"\"\"Returns True if pip exists inside the virtual environment. Can be\n        used as a naive way to verify that the environment is installed.\"\"\"\n        return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))", "code_tokens": "def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )", "docstring_tokens": "Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed .", "label": 1}, {"idx": "cosqa-train-16916", "doc": "write a function that outputs a table in python", "code": "def get_table(ports):\n    \"\"\"\n    This function returns a pretty table used to display the port results.\n\n    :param ports: list of found ports\n    :return: the table to display\n    \"\"\"\n    table = PrettyTable([\"Name\", \"Port\", \"Protocol\", \"Description\"])\n    table.align[\"Name\"] = \"l\"\n    table.align[\"Description\"] = \"l\"\n    table.padding_width = 1\n\n    for port in ports:\n        table.add_row(port)\n\n    return table", "code_tokens": "def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "docstring_tokens": "This function returns a pretty table used to display the port results .", "label": 1}, {"idx": "cosqa-train-16917", "doc": "python check if integer inside l ist", "code": "def is_iterable_of_int(l):\n    r\"\"\" Checks if l is iterable and contains only integral types \"\"\"\n    if not is_iterable(l):\n        return False\n\n    return all(is_int(value) for value in l)", "code_tokens": "def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "docstring_tokens": "r Checks if l is iterable and contains only integral types", "label": 1}, {"idx": "cosqa-train-16918", "doc": "write a python function to check whether a string start with specified characters", "code": "def _startswith(expr, pat):\n    \"\"\"\n    Return boolean sequence or scalar indicating whether each string in the sequence or scalar\n    starts with passed pattern. Equivalent to str.startswith().\n\n    :param expr:\n    :param pat: Character sequence\n    :return: sequence or scalar\n    \"\"\"\n\n    return _string_op(expr, Startswith, output_type=types.boolean, _pat=pat)", "code_tokens": "def _startswith ( expr , pat ) : return _string_op ( expr , Startswith , output_type = types . boolean , _pat = pat )", "docstring_tokens": "Return boolean sequence or scalar indicating whether each string in the sequence or scalar starts with passed pattern . Equivalent to str . startswith () .", "label": 1}, {"idx": "cosqa-train-16919", "doc": "python check if it's no punctuation", "code": "def is_delimiter(line):\n    \"\"\" True if a line consists only of a single punctuation character.\"\"\"\n    return bool(line) and line[0] in punctuation and line[0]*len(line) == line", "code_tokens": "def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line", "docstring_tokens": "True if a line consists only of a single punctuation character .", "label": 0}, {"idx": "cosqa-train-16920", "doc": "write a python matrix into csv", "code": "def csv_matrix_print(classes, table):\n    \"\"\"\n    Return matrix as csv data.\n\n    :param classes: classes list\n    :type classes:list\n    :param table: table\n    :type table:dict\n    :return:\n    \"\"\"\n    result = \"\"\n    classes.sort()\n    for i in classes:\n        for j in classes:\n            result += str(table[i][j]) + \",\"\n        result = result[:-1] + \"\\n\"\n    return result[:-1]", "code_tokens": "def csv_matrix_print ( classes , table ) : result = \"\" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + \",\" result = result [ : - 1 ] + \"\\n\" return result [ : - 1 ]", "docstring_tokens": "Return matrix as csv data .", "label": 0}, {"idx": "cosqa-train-16921", "doc": "python check if key value is not in array of values", "code": "def isin(value, values):\n    \"\"\" Check that value is in values \"\"\"\n    for i, v in enumerate(value):\n        if v not in np.array(values)[:, i]:\n            return False\n    return True", "code_tokens": "def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "docstring_tokens": "Check that value is in values", "label": 1}, {"idx": "cosqa-train-16922", "doc": "write a python script to build rpm", "code": "def install_rpm_py():\n    \"\"\"Install RPM Python binding.\"\"\"\n    python_path = sys.executable\n    cmd = '{0} install.py'.format(python_path)\n    exit_status = os.system(cmd)\n    if exit_status != 0:\n        raise Exception('Command failed: {0}'.format(cmd))", "code_tokens": "def install_rpm_py ( ) : python_path = sys . executable cmd = '{0} install.py' . format ( python_path ) exit_status = os . system ( cmd ) if exit_status != 0 : raise Exception ( 'Command failed: {0}' . format ( cmd ) )", "docstring_tokens": "Install RPM Python binding .", "label": 0}, {"idx": "cosqa-train-16923", "doc": "python check if list of string or one single string", "code": "def all_strings(arr):\n        \"\"\"\n        Ensures that the argument is a list that either is empty or contains only strings\n        :param arr: list\n        :return:\n        \"\"\"\n        if not isinstance([], list):\n            raise TypeError(\"non-list value found where list is expected\")\n        return all(isinstance(x, str) for x in arr)", "code_tokens": "def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( \"non-list value found where list is expected\" ) return all ( isinstance ( x , str ) for x in arr )", "docstring_tokens": "Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :", "label": 1}, {"idx": "cosqa-train-16924", "doc": "write data into fits file python", "code": "def write_fits(self, fitsfile):\n        \"\"\"Write the ROI model to a FITS file.\"\"\"\n\n        tab = self.create_table()\n        hdu_data = fits.table_to_hdu(tab)\n        hdus = [fits.PrimaryHDU(), hdu_data]\n        fits_utils.write_hdus(hdus, fitsfile)", "code_tokens": "def write_fits ( self , fitsfile ) : tab = self . create_table ( ) hdu_data = fits . table_to_hdu ( tab ) hdus = [ fits . PrimaryHDU ( ) , hdu_data ] fits_utils . write_hdus ( hdus , fitsfile )", "docstring_tokens": "Write the ROI model to a FITS file .", "label": 1}, {"idx": "cosqa-train-16925", "doc": "python check if local port is on", "code": "def we_are_in_lyon():\n    \"\"\"Check if we are on a Lyon machine\"\"\"\n    import socket\n    try:\n        hostname = socket.gethostname()\n        ip = socket.gethostbyname(hostname)\n    except socket.gaierror:\n        return False\n    return ip.startswith(\"134.158.\")", "code_tokens": "def we_are_in_lyon ( ) : import socket try : hostname = socket . gethostname ( ) ip = socket . gethostbyname ( hostname ) except socket . gaierror : return False return ip . startswith ( \"134.158.\" )", "docstring_tokens": "Check if we are on a Lyon machine", "label": 0}, {"idx": "cosqa-train-16926", "doc": "write dict in json file python", "code": "def _write_json(file, contents):\n    \"\"\"Write a dict to a JSON file.\"\"\"\n    with open(file, 'w') as f:\n        return json.dump(contents, f, indent=2, sort_keys=True)", "code_tokens": "def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )", "docstring_tokens": "Write a dict to a JSON file .", "label": 0}, {"idx": "cosqa-train-16927", "doc": "python check if node is empty", "code": "def is_empty(self):\n    \"\"\"Returns True if this node has no children, or if all of its children are ParseNode instances\n    and are empty.\n    \"\"\"\n    return all(isinstance(c, ParseNode) and c.is_empty for c in self.children)", "code_tokens": "def is_empty ( self ) : return all ( isinstance ( c , ParseNode ) and c . is_empty for c in self . children )", "docstring_tokens": "Returns True if this node has no children or if all of its children are ParseNode instances and are empty .", "label": 1}, {"idx": "cosqa-train-16928", "doc": "write json object to file in python", "code": "def _serialize_json(obj, fp):\n    \"\"\" Serialize ``obj`` as a JSON formatted stream to ``fp`` \"\"\"\n    json.dump(obj, fp, indent=4, default=serialize)", "code_tokens": "def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )", "docstring_tokens": "Serialize obj as a JSON formatted stream to fp", "label": 0}, {"idx": "cosqa-train-16929", "doc": "python check if os is windows or linux", "code": "def is_archlinux():\n    \"\"\"return True if the current distribution is running on debian like OS.\"\"\"\n    if platform.system().lower() == 'linux':\n        if platform.linux_distribution() == ('', '', ''):\n            # undefined distribution. Fixed in python 3.\n            if os.path.exists('/etc/arch-release'):\n                return True\n    return False", "code_tokens": "def is_archlinux ( ) : if platform . system ( ) . lower ( ) == 'linux' : if platform . linux_distribution ( ) == ( '' , '' , '' ) : # undefined distribution. Fixed in python 3. if os . path . exists ( '/etc/arch-release' ) : return True return False", "docstring_tokens": "return True if the current distribution is running on debian like OS .", "label": 1}, {"idx": "cosqa-train-16930", "doc": "write regex to validate password python", "code": "def is_password_valid(password):\n    \"\"\"\n    Check if a password is valid\n    \"\"\"\n    pattern = re.compile(r\"^.{4,75}$\")\n    return bool(pattern.match(password))", "code_tokens": "def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "docstring_tokens": "Check if a password is valid", "label": 0}, {"idx": "cosqa-train-16931", "doc": "python check if range of numbers in another range of numbers", "code": "def are_in_interval(s, l, r, border = 'included'):\n        \"\"\"\n        Checks whether all number in the sequence s lie inside the interval formed by\n        l and r.\n        \"\"\"\n        return numpy.all([IntensityRangeStandardization.is_in_interval(x, l, r, border) for x in s])", "code_tokens": "def are_in_interval ( s , l , r , border = 'included' ) : return numpy . all ( [ IntensityRangeStandardization . is_in_interval ( x , l , r , border ) for x in s ] )", "docstring_tokens": "Checks whether all number in the sequence s lie inside the interval formed by l and r .", "label": 0}, {"idx": "cosqa-train-16932", "doc": "wxpython close dialog manually", "code": "def on_close(self, evt):\n    \"\"\"\n    Pop-up menu and wx.EVT_CLOSE closing event\n    \"\"\"\n    self.stop() # DoseWatcher\n    if evt.EventObject is not self: # Avoid deadlocks\n      self.Close() # wx.Frame\n    evt.Skip()", "code_tokens": "def on_close ( self , evt ) : self . stop ( ) # DoseWatcher if evt . EventObject is not self : # Avoid deadlocks self . Close ( ) # wx.Frame evt . Skip ( )", "docstring_tokens": "Pop - up menu and wx . EVT_CLOSE closing event", "label": 0}, {"idx": "cosqa-train-16933", "doc": "python check if stdin is tty", "code": "def intty(cls):\n        \"\"\" Check if we are in a tty. \"\"\"\n        # XXX: temporary hack until we can detect if we are in a pipe or not\n        return True\n\n        if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():\n            return True\n\n        return False", "code_tokens": "def intty ( cls ) : # XXX: temporary hack until we can detect if we are in a pipe or not return True if hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( ) : return True return False", "docstring_tokens": "Check if we are in a tty .", "label": 1}, {"idx": "cosqa-train-16934", "doc": "wxpython keeps scroll bar lastest", "code": "def list_view_changed(self, widget, event, data=None):\n        \"\"\"\n        Function shows last rows.\n        \"\"\"\n        adj = self.scrolled_window.get_vadjustment()\n        adj.set_value(adj.get_upper() - adj.get_page_size())", "code_tokens": "def list_view_changed ( self , widget , event , data = None ) : adj = self . scrolled_window . get_vadjustment ( ) adj . set_value ( adj . get_upper ( ) - adj . get_page_size ( ) )", "docstring_tokens": "Function shows last rows .", "label": 0}, {"idx": "cosqa-train-16935", "doc": "python check if super user", "code": "def has_permission(user, permission_name):\n    \"\"\"Check if a user has a given permission.\"\"\"\n    if user and user.is_superuser:\n        return True\n\n    return permission_name in available_perm_names(user)", "code_tokens": "def has_permission ( user , permission_name ) : if user and user . is_superuser : return True return permission_name in available_perm_names ( user )", "docstring_tokens": "Check if a user has a given permission .", "label": 1}, {"idx": "cosqa-train-16936", "doc": "x limit and y limit in python", "code": "def values(self):\n        \"\"\"Gets the user enter max and min values of where the \n        raster points should appear on the y-axis\n\n        :returns: (float, float) -- (min, max) y-values to bound the raster plot by\n        \"\"\"\n        lower = float(self.lowerSpnbx.value())\n        upper = float(self.upperSpnbx.value())\n        return (lower, upper)", "code_tokens": "def values ( self ) : lower = float ( self . lowerSpnbx . value ( ) ) upper = float ( self . upperSpnbx . value ( ) ) return ( lower , upper )", "docstring_tokens": "Gets the user enter max and min values of where the raster points should appear on the y - axis", "label": 1}, {"idx": "cosqa-train-16937", "doc": "python check if there are missing values in an array", "code": "def check_precomputed_distance_matrix(X):\n    \"\"\"Perform check_array(X) after removing infinite values (numpy.inf) from the given distance matrix.\n    \"\"\"\n    tmp = X.copy()\n    tmp[np.isinf(tmp)] = 1\n    check_array(tmp)", "code_tokens": "def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "docstring_tokens": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix .", "label": 0}, {"idx": "cosqa-train-16938", "doc": "yield regex function python", "code": "def iter_finds(regex_obj, s):\n    \"\"\"Generate all matches found within a string for a regex and yield each match as a string\"\"\"\n    if isinstance(regex_obj, str):\n        for m in re.finditer(regex_obj, s):\n            yield m.group()\n    else:\n        for m in regex_obj.finditer(s):\n            yield m.group()", "code_tokens": "def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )", "docstring_tokens": "Generate all matches found within a string for a regex and yield each match as a string", "label": 1}, {"idx": "cosqa-train-16939", "doc": "python check if there is a valid data in a column", "code": "def is_valid_row(cls, row):\n        \"\"\"Indicates whether or not the given row contains valid data.\"\"\"\n        for k in row.keys():\n            if row[k] is None:\n                return False\n        return True", "code_tokens": "def is_valid_row ( cls , row ) : for k in row . keys ( ) : if row [ k ] is None : return False return True", "docstring_tokens": "Indicates whether or not the given row contains valid data .", "label": 0}, {"idx": "cosqa-train-16940", "doc": "python check if two images are the same", "code": "def is_same_shape(self, other_im, check_channels=False):\n        \"\"\" Checks if two images have the same height and width (and optionally channels).\n\n        Parameters\n        ----------\n        other_im : :obj:`Image`\n            image to compare\n        check_channels : bool\n            whether or not to check equality of the channels\n\n        Returns\n        -------\n        bool\n            True if the images are the same shape, False otherwise\n        \"\"\"\n        if self.height == other_im.height and self.width == other_im.width:\n            if check_channels and self.channels != other_im.channels:\n                return False\n            return True\n        return False", "code_tokens": "def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False", "docstring_tokens": "Checks if two images have the same height and width ( and optionally channels ) .", "label": 1}, {"idx": "cosqa-train-16941", "doc": "python check if user is in a group", "code": "def user_in_all_groups(user, groups):\n    \"\"\"Returns True if the given user is in all given groups\"\"\"\n    return user_is_superuser(user) or all(user_in_group(user, group) for group in groups)", "code_tokens": "def user_in_all_groups ( user , groups ) : return user_is_superuser ( user ) or all ( user_in_group ( user , group ) for group in groups )", "docstring_tokens": "Returns True if the given user is in all given groups", "label": 0}, {"idx": "cosqa-train-16942", "doc": "python functional to check is number", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 1}, {"idx": "cosqa-train-16943", "doc": "python json specific string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 1}, {"idx": "cosqa-train-16944", "doc": "how to fetch last month data in python", "code": "def get_period_last_3_months() -> str:\n    \"\"\" Returns the last week as a period string \"\"\"\n    today = Datum()\n    today.today()\n\n    # start_date = today - timedelta(weeks=13)\n    start_date = today.clone()\n    start_date.subtract_months(3)\n\n    period = get_period(start_date.date, today.date)\n    return period", "code_tokens": "def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "docstring_tokens": "Returns the last week as a period string", "label": 0}, {"idx": "cosqa-train-16945", "doc": "how to make dictionary values float in python", "code": "def dictlist_convert_to_float(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, convert\n    (in place) ``d[key]`` to a float. If that fails, convert it to ``None``.\n    \"\"\"\n    for d in dict_list:\n        try:\n            d[key] = float(d[key])\n        except ValueError:\n            d[key] = None", "code_tokens": "def dictlist_convert_to_float ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : try : d [ key ] = float ( d [ key ] ) except ValueError : d [ key ] = None", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d convert ( in place ) d [ key ] to a float . If that fails convert it to None .", "label": 0}, {"idx": "cosqa-train-16946", "doc": "how to pass a function name in python", "code": "def method_caller(method_name, *args, **kwargs):\n\t\"\"\"\n\tReturn a function that will call a named method on the\n\ttarget object with optional positional and keyword\n\targuments.\n\n\t>>> lower = method_caller('lower')\n\t>>> lower('MyString')\n\t'mystring'\n\t\"\"\"\n\tdef call_method(target):\n\t\tfunc = getattr(target, method_name)\n\t\treturn func(*args, **kwargs)\n\treturn call_method", "code_tokens": "def method_caller ( method_name , * args , * * kwargs ) : def call_method ( target ) : func = getattr ( target , method_name ) return func ( * args , * * kwargs ) return call_method", "docstring_tokens": "Return a function that will call a named method on the target object with optional positional and keyword arguments .", "label": 1}, {"idx": "cosqa-train-16947", "doc": "python get last occurrence in string", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 1}, {"idx": "cosqa-train-16948", "doc": "python how to get working days before", "code": "def previous_workday(dt):\n    \"\"\"\n    returns previous weekday used for observances\n    \"\"\"\n    dt -= timedelta(days=1)\n    while dt.weekday() > 4:\n        # Mon-Fri are 0-4\n        dt -= timedelta(days=1)\n    return dt", "code_tokens": "def previous_workday ( dt ) : dt -= timedelta ( days = 1 ) while dt . weekday ( ) > 4 : # Mon-Fri are 0-4 dt -= timedelta ( days = 1 ) return dt", "docstring_tokens": "returns previous weekday used for observances", "label": 0}, {"idx": "cosqa-train-16949", "doc": "greater than string python", "code": "def __gt__(self, other):\n        \"\"\"Test for greater than.\"\"\"\n        if isinstance(other, Address):\n            return str(self) > str(other)\n        raise TypeError", "code_tokens": "def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError", "docstring_tokens": "Test for greater than .", "label": 1}, {"idx": "cosqa-train-16950", "doc": "how to split sentences on punctuation python", "code": "def batch_split_sentences(self, texts: List[str]) -> List[List[str]]:\n        \"\"\"\n        This method lets you take advantage of spacy's batch processing.\n        Default implementation is to just iterate over the texts and call ``split_sentences``.\n        \"\"\"\n        return [self.split_sentences(text) for text in texts]", "code_tokens": "def batch_split_sentences ( self , texts : List [ str ] ) -> List [ List [ str ] ] : return [ self . split_sentences ( text ) for text in texts ]", "docstring_tokens": "This method lets you take advantage of spacy s batch processing . Default implementation is to just iterate over the texts and call split_sentences .", "label": 0}, {"idx": "cosqa-train-16951", "doc": "turn a list into array python", "code": "def listify(a):\n    \"\"\"\n    Convert a scalar ``a`` to a list and all iterables to list as well.\n\n    Examples\n    --------\n    >>> listify(0)\n    [0]\n\n    >>> listify([1,2,3])\n    [1, 2, 3]\n\n    >>> listify('a')\n    ['a']\n\n    >>> listify(np.array([1,2,3]))\n    [1, 2, 3]\n\n    >>> listify('string')\n    ['string']\n    \"\"\"\n    if a is None:\n        return []\n    elif not isinstance(a, (tuple, list, np.ndarray)):\n        return [a]\n    return list(a)", "code_tokens": "def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "docstring_tokens": "Convert a scalar a to a list and all iterables to list as well .", "label": 0}, {"idx": "cosqa-train-16952", "doc": "get all the column names in python", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 0}, {"idx": "cosqa-train-16953", "doc": "recursion for depth of nested python lists", "code": "def list_depth(list_, func=max, _depth=0):\n    \"\"\"\n    Returns the deepest level of nesting within a list of lists\n\n    Args:\n       list_  : a nested listlike object\n       func   : depth aggregation strategy (defaults to max)\n       _depth : internal var\n\n    Example:\n        >>> # ENABLE_DOCTEST\n        >>> from utool.util_list import *  # NOQA\n        >>> list_ = [[[[[1]]], [3]], [[1], [3]], [[1], [3]]]\n        >>> result = (list_depth(list_, _depth=0))\n        >>> print(result)\n\n    \"\"\"\n    depth_list = [list_depth(item, func=func, _depth=_depth + 1)\n                  for item in  list_ if util_type.is_listlike(item)]\n    if len(depth_list) > 0:\n        return func(depth_list)\n    else:\n        return _depth", "code_tokens": "def list_depth ( list_ , func = max , _depth = 0 ) : depth_list = [ list_depth ( item , func = func , _depth = _depth + 1 ) for item in list_ if util_type . is_listlike ( item ) ] if len ( depth_list ) > 0 : return func ( depth_list ) else : return _depth", "docstring_tokens": "Returns the deepest level of nesting within a list of lists", "label": 1}, {"idx": "cosqa-train-16954", "doc": "python get time zone information", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 0}, {"idx": "cosqa-train-16955", "doc": "how to create an inverse dictionary python", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 0}, {"idx": "cosqa-train-16956", "doc": "python check if queue is empty", "code": "def full(self):\n        \"\"\"Return ``True`` if the queue is full, ``False``\n        otherwise (not reliable!).\n\n        Only applicable if :attr:`maxsize` is set.\n\n        \"\"\"\n        return self.maxsize and len(self.list) >= self.maxsize or False", "code_tokens": "def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False", "docstring_tokens": "Return True if the queue is full False otherwise ( not reliable! ) .", "label": 1}, {"idx": "cosqa-train-16957", "doc": "select top n python", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 1}, {"idx": "cosqa-train-16958", "doc": "python filter out text from a list of words", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 0}, {"idx": "cosqa-train-16959", "doc": "transition probability matrix for a random graph implementation in python", "code": "def get_pij_matrix(t, diag, A, A_inv):\n    \"\"\"\n    Calculates the probability matrix of substitutions i->j over time t,\n    given the normalised generator diagonalisation.\n\n\n    :param t: time\n    :type t: float\n    :return: probability matrix\n    :rtype: numpy.ndarray\n    \"\"\"\n    return A.dot(np.diag(np.exp(diag * t))).dot(A_inv)", "code_tokens": "def get_pij_matrix ( t , diag , A , A_inv ) : return A . dot ( np . diag ( np . exp ( diag * t ) ) ) . dot ( A_inv )", "docstring_tokens": "Calculates the probability matrix of substitutions i - > j over time t given the normalised generator diagonalisation .", "label": 1}, {"idx": "cosqa-train-16960", "doc": "python flush request cache", "code": "def flush(self):\n        \"\"\"\n        Flush all unwritten data to disk.\n        \"\"\"\n        if self._cache_modified_count > 0:\n            self.storage.write(self.cache)\n            self._cache_modified_count = 0", "code_tokens": "def flush ( self ) : if self . _cache_modified_count > 0 : self . storage . write ( self . cache ) self . _cache_modified_count = 0", "docstring_tokens": "Flush all unwritten data to disk .", "label": 1}, {"idx": "cosqa-train-16961", "doc": "python compare none with int", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 0}, {"idx": "cosqa-train-16962", "doc": "count of each token from a string in python", "code": "def _sum_cycles_from_tokens(self, tokens: List[str]) -> int:\n        \"\"\"Sum the total number of cycles over a list of tokens.\"\"\"\n        return sum((int(self._nonnumber_pattern.sub('', t)) for t in tokens))", "code_tokens": "def _sum_cycles_from_tokens ( self , tokens : List [ str ] ) -> int : return sum ( ( int ( self . _nonnumber_pattern . sub ( '' , t ) ) for t in tokens ) )", "docstring_tokens": "Sum the total number of cycles over a list of tokens .", "label": 1}, {"idx": "cosqa-train-16963", "doc": "python 3 iterator has next", "code": "def __next__(self):\n        \"\"\"\n        :return: int\n        \"\"\"\n        self.current += 1\n        if self.current > self.total:\n            raise StopIteration\n        else:\n            return self.iterable[self.current - 1]", "code_tokens": "def __next__ ( self ) : self . current += 1 if self . current > self . total : raise StopIteration else : return self . iterable [ self . current - 1 ]", "docstring_tokens": ": return : int", "label": 1}, {"idx": "cosqa-train-16964", "doc": "how to define the range with 5 margin in python", "code": "def get_margin(length):\n    \"\"\"Add enough tabs to align in two columns\"\"\"\n    if length > 23:\n        margin_left = \"\\t\"\n        chars = 1\n    elif length > 15:\n        margin_left = \"\\t\\t\"\n        chars = 2\n    elif length > 7:\n        margin_left = \"\\t\\t\\t\"\n        chars = 3\n    else:\n        margin_left = \"\\t\\t\\t\\t\"\n        chars = 4\n    return margin_left", "code_tokens": "def get_margin ( length ) : if length > 23 : margin_left = \"\\t\" chars = 1 elif length > 15 : margin_left = \"\\t\\t\" chars = 2 elif length > 7 : margin_left = \"\\t\\t\\t\" chars = 3 else : margin_left = \"\\t\\t\\t\\t\" chars = 4 return margin_left", "docstring_tokens": "Add enough tabs to align in two columns", "label": 0}, {"idx": "cosqa-train-16965", "doc": "is a json file a python dictinary", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 0}, {"idx": "cosqa-train-16966", "doc": "how to check the first n bytes of a file in python", "code": "def tail(filename, number_of_bytes):\n    \"\"\"Returns the last number_of_bytes of filename\"\"\"\n    with open(filename, \"rb\") as f:\n        if os.stat(filename).st_size > number_of_bytes:\n            f.seek(-number_of_bytes, 2)\n        return f.read()", "code_tokens": "def tail ( filename , number_of_bytes ) : with open ( filename , \"rb\" ) as f : if os . stat ( filename ) . st_size > number_of_bytes : f . seek ( - number_of_bytes , 2 ) return f . read ( )", "docstring_tokens": "Returns the last number_of_bytes of filename", "label": 1}, {"idx": "cosqa-train-16967", "doc": "python sql executemany dictionary", "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None:\n        \"\"\"Execute the given multiquery.\"\"\"\n        await self._execute(self._cursor.executemany, sql, parameters)", "code_tokens": "async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "docstring_tokens": "Execute the given multiquery .", "label": 0}, {"idx": "cosqa-train-16968", "doc": "change python object to string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 1}, {"idx": "cosqa-train-16969", "doc": "how to get timezone in python", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-16970", "doc": "python round float to higher int", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 1}, {"idx": "cosqa-train-16971", "doc": "if value isinteger python", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 1}, {"idx": "cosqa-train-16972", "doc": "python get png image dimensions", "code": "def getDimensionForImage(filename, maxsize):\n    \"\"\"Return scaled image size in (width, height) format.\n    The scaling preserves the aspect ratio.\n    If PIL is not found returns None.\"\"\"\n    try:\n        from PIL import Image\n    except ImportError:\n        return None\n    img = Image.open(filename)\n    width, height = img.size\n    if width > maxsize[0] or height > maxsize[1]:\n        img.thumbnail(maxsize)\n        out.info(\"Downscaled display size from %s to %s\" % ((width, height), img.size))\n    return img.size", "code_tokens": "def getDimensionForImage ( filename , maxsize ) : try : from PIL import Image except ImportError : return None img = Image . open ( filename ) width , height = img . size if width > maxsize [ 0 ] or height > maxsize [ 1 ] : img . thumbnail ( maxsize ) out . info ( \"Downscaled display size from %s to %s\" % ( ( width , height ) , img . size ) ) return img . size", "docstring_tokens": "Return scaled image size in ( width height ) format . The scaling preserves the aspect ratio . If PIL is not found returns None .", "label": 1}, {"idx": "cosqa-train-16973", "doc": "get the index of last occurance of a string in list python", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-16974", "doc": "python elementtree remove element", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 0}, {"idx": "cosqa-train-16975", "doc": "how to split sentence based on delimiter using python", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 0}, {"idx": "cosqa-train-16976", "doc": "remove multiple characters python", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 0}, {"idx": "cosqa-train-16977", "doc": "how to get index labels python", "code": "def indices_to_labels(self, indices: Sequence[int]) -> List[str]:\n        \"\"\" Converts a sequence of indices into their corresponding labels.\"\"\"\n\n        return [(self.INDEX_TO_LABEL[index]) for index in indices]", "code_tokens": "def indices_to_labels ( self , indices : Sequence [ int ] ) -> List [ str ] : return [ ( self . INDEX_TO_LABEL [ index ] ) for index in indices ]", "docstring_tokens": "Converts a sequence of indices into their corresponding labels .", "label": 0}, {"idx": "cosqa-train-16978", "doc": "python how to check if a key doesnt exist", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 0}, {"idx": "cosqa-train-16979", "doc": "how to switch python version, spyder", "code": "def get_versions(reporev=True):\n    \"\"\"Get version information for components used by Spyder\"\"\"\n    import sys\n    import platform\n\n    import qtpy\n    import qtpy.QtCore\n\n    revision = None\n    if reporev:\n        from spyder.utils import vcs\n        revision, branch = vcs.get_git_revision(os.path.dirname(__dir__))\n\n    if not sys.platform == 'darwin':  # To avoid a crash with our Mac app\n        system = platform.system()\n    else:\n        system = 'Darwin'\n\n    return {\n        'spyder': __version__,\n        'python': platform.python_version(),  # \"2.7.3\"\n        'bitness': 64 if sys.maxsize > 2**32 else 32,\n        'qt': qtpy.QtCore.__version__,\n        'qt_api': qtpy.API_NAME,      # PyQt5\n        'qt_api_ver': qtpy.PYQT_VERSION,\n        'system': system,   # Linux, Windows, ...\n        'release': platform.release(),  # XP, 10.6, 2.2.0, etc.\n        'revision': revision,  # '9fdf926eccce'\n    }", "code_tokens": "def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "docstring_tokens": "Get version information for components used by Spyder", "label": 1}, {"idx": "cosqa-train-16980", "doc": "telling python to skip next line", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 1}, {"idx": "cosqa-train-16981", "doc": "python sqlite open cursor with", "code": "async def cursor(self) -> Cursor:\n        \"\"\"Create an aiosqlite cursor wrapping a sqlite3 cursor object.\"\"\"\n        return Cursor(self, await self._execute(self._conn.cursor))", "code_tokens": "async def cursor ( self ) -> Cursor : return Cursor ( self , await self . _execute ( self . _conn . cursor ) )", "docstring_tokens": "Create an aiosqlite cursor wrapping a sqlite3 cursor object .", "label": 1}, {"idx": "cosqa-train-16982", "doc": "finding the minimum of a certain dataset python", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-16983", "doc": "top three in list python", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 0}, {"idx": "cosqa-train-16984", "doc": "using map inside a for loop in python", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-16985", "doc": "python new dictionary from existing dictionary", "code": "def extend(a: dict, b: dict) -> dict:\n    \"\"\"Merge two dicts and return a new dict. Much like subclassing works.\"\"\"\n    res = a.copy()\n    res.update(b)\n    return res", "code_tokens": "def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res", "docstring_tokens": "Merge two dicts and return a new dict . Much like subclassing works .", "label": 1}, {"idx": "cosqa-train-16986", "doc": "check if valid date python", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 1}, {"idx": "cosqa-train-16987", "doc": "skipping empty lines in python", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-16988", "doc": "python3 string codec detect", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 0}, {"idx": "cosqa-train-16989", "doc": "python elementtree xml remove", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 0}, {"idx": "cosqa-train-16990", "doc": "how to evaluate if strings are equal python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 1}, {"idx": "cosqa-train-16991", "doc": "python read file as one line", "code": "def read(self, count=0):\n        \"\"\" Read \"\"\"\n        return self.f.read(count) if count > 0 else self.f.read()", "code_tokens": "def read ( self , count = 0 ) : return self . f . read ( count ) if count > 0 else self . f . read ( )", "docstring_tokens": "Read", "label": 1}, {"idx": "cosqa-train-16992", "doc": "fastest way to take bitwise or python", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 1}, {"idx": "cosqa-train-16993", "doc": "if element is not in a list in python", "code": "def obj_in_list_always(target_list, obj):\n    \"\"\"\n    >>> l = [1,1,1]\n    >>> obj_in_list_always(l, 1)\n    True\n    >>> l.append(2)\n    >>> obj_in_list_always(l, 1)\n    False\n    \"\"\"\n    for item in set(target_list):\n        if item is not obj:\n            return False\n    return True", "code_tokens": "def obj_in_list_always ( target_list , obj ) : for item in set ( target_list ) : if item is not obj : return False return True", "docstring_tokens": ">>> l = [ 1 1 1 ] >>> obj_in_list_always ( l 1 ) True >>> l . append ( 2 ) >>> obj_in_list_always ( l 1 ) False", "label": 1}, {"idx": "cosqa-train-16994", "doc": "return the string in all lowercase except the last character is uppercase python", "code": "def lowercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the lowercase chars in the given string.\"\"\"\n        return ''.join([c if c.islower() else '' for c in str(string)])", "code_tokens": "def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the lowercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-16995", "doc": "check in python variable is str", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 1}, {"idx": "cosqa-train-16996", "doc": "how to give name validation from input python", "code": "def assert_valid_name(name: str) -> str:\n    \"\"\"Uphold the spec rules about naming.\"\"\"\n    error = is_valid_name_error(name)\n    if error:\n        raise error\n    return name", "code_tokens": "def assert_valid_name ( name : str ) -> str : error = is_valid_name_error ( name ) if error : raise error return name", "docstring_tokens": "Uphold the spec rules about naming .", "label": 1}, {"idx": "cosqa-train-16997", "doc": "python datetime isoformat layout", "code": "def datetime_iso_format(date):\n    \"\"\"\n    Return an ISO-8601 representation of a datetime object.\n    \"\"\"\n    return \"{0:0>4}-{1:0>2}-{2:0>2}T{3:0>2}:{4:0>2}:{5:0>2}Z\".format(\n        date.year, date.month, date.day, date.hour,\n        date.minute, date.second)", "code_tokens": "def datetime_iso_format ( date ) : return \"{0:0>4}-{1:0>2}-{2:0>2}T{3:0>2}:{4:0>2}:{5:0>2}Z\" . format ( date . year , date . month , date . day , date . hour , date . minute , date . second )", "docstring_tokens": "Return an ISO - 8601 representation of a datetime object .", "label": 1}, {"idx": "cosqa-train-16998", "doc": "python how to check if something is not a str", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 1}, {"idx": "cosqa-train-16999", "doc": "lower all items in list python", "code": "def gen_lower(x: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\"\n    Args:\n        x: iterable of strings\n\n    Yields:\n        each string in lower case\n    \"\"\"\n    for string in x:\n        yield string.lower()", "code_tokens": "def gen_lower ( x : Iterable [ str ] ) -> Generator [ str , None , None ] : for string in x : yield string . lower ( )", "docstring_tokens": "Args : x : iterable of strings", "label": 0}, {"idx": "cosqa-train-17000", "doc": "how to load commits in order python from gitlog", "code": "def last_commit(self) -> Tuple:\n        \"\"\"Returns a tuple (hash, and commit object)\"\"\"\n        from libs.repos import git\n\n        return git.get_last_commit(repo_path=self.path)", "code_tokens": "def last_commit ( self ) -> Tuple : from libs . repos import git return git . get_last_commit ( repo_path = self . path )", "docstring_tokens": "Returns a tuple ( hash and commit object )", "label": 1}, {"idx": "cosqa-train-17001", "doc": "how do i determine if two strings are equal in python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 0}, {"idx": "cosqa-train-17002", "doc": "how to delete an entry in a python dictionary", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-17003", "doc": "local variables with underscore python", "code": "def lower_camel_case_from_underscores(string):\n    \"\"\"generate a lower-cased camelCase string from an underscore_string.\n    For example: my_variable_name -> myVariableName\"\"\"\n    components = string.split('_')\n    string = components[0]\n    for component in components[1:]:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName", "label": 0}, {"idx": "cosqa-train-17004", "doc": "wordnet synsets implementation in python", "code": "def has_synset(word: str) -> list:\n    \"\"\"\" Returns a list of synsets of a word after lemmatization. \"\"\"\n\n    return wn.synsets(lemmatize(word, neverstem=True))", "code_tokens": "def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "docstring_tokens": "Returns a list of synsets of a word after lemmatization .", "label": 1}, {"idx": "cosqa-train-17005", "doc": "how to conveert data type of a column using python", "code": "def is_sqlatype_string(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type a string type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.String)", "code_tokens": "def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "docstring_tokens": "Is the SQLAlchemy column type a string type?", "label": 0}, {"idx": "cosqa-train-17006", "doc": "python join list to string comma separated", "code": "def list_to_str(lst):\n    \"\"\"\n    Turn a list into a comma- and/or and-separated string.\n\n    Parameters\n    ----------\n    lst : :obj:`list`\n        A list of strings to join into a single string.\n\n    Returns\n    -------\n    str_ : :obj:`str`\n        A string with commas and/or ands separating th elements from ``lst``.\n\n    \"\"\"\n    if len(lst) == 1:\n        str_ = lst[0]\n    elif len(lst) == 2:\n        str_ = ' and '.join(lst)\n    elif len(lst) > 2:\n        str_ = ', '.join(lst[:-1])\n        str_ += ', and {0}'.format(lst[-1])\n    else:\n        raise ValueError('List of length 0 provided.')\n    return str_", "code_tokens": "def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "docstring_tokens": "Turn a list into a comma - and / or and - separated string .", "label": 0}, {"idx": "cosqa-train-17007", "doc": "read json file and turn into dictionary using python", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 1}, {"idx": "cosqa-train-17008", "doc": "python lambda parsing arg", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 0}, {"idx": "cosqa-train-17009", "doc": "python remove words from sentences in a list", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 1}, {"idx": "cosqa-train-17010", "doc": "check all letters in a string in python", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-17011", "doc": "how to move curser using pywin32 in python code", "code": "def SetCursorPos(x: int, y: int) -> bool:\n    \"\"\"\n    SetCursorPos from Win32.\n    Set mouse cursor to point x, y.\n    x: int.\n    y: int.\n    Return bool, True if succeed otherwise False.\n    \"\"\"\n    return bool(ctypes.windll.user32.SetCursorPos(x, y))", "code_tokens": "def SetCursorPos ( x : int , y : int ) -> bool : return bool ( ctypes . windll . user32 . SetCursorPos ( x , y ) )", "docstring_tokens": "SetCursorPos from Win32 . Set mouse cursor to point x y . x : int . y : int . Return bool True if succeed otherwise False .", "label": 0}, {"idx": "cosqa-train-17012", "doc": "python string deciaml to int", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-17013", "doc": "python how to invert a dictionary", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 0}, {"idx": "cosqa-train-17014", "doc": "python 3 none compare with int", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 1}, {"idx": "cosqa-train-17015", "doc": "python code to print out index of largest element in numpy array", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 0}, {"idx": "cosqa-train-17016", "doc": "length of a vector (1,1) in python", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 0}, {"idx": "cosqa-train-17017", "doc": "python string list to datetime", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 0}, {"idx": "cosqa-train-17018", "doc": "filter non nan numpy python", "code": "def remove_nans_1D(*args) -> tuple:\n    \"\"\"Remove nans in a set of 1D arrays.\n\n    Removes indicies in all arrays if any array is nan at that index.\n    All input arrays must have the same size.\n\n    Parameters\n    ----------\n    args : 1D arrays\n\n    Returns\n    -------\n    tuple\n        Tuple of 1D arrays in same order as given, with nan indicies removed.\n    \"\"\"\n    vals = np.isnan(args[0])\n    for a in args:\n        vals |= np.isnan(a)\n    return tuple(np.array(a)[~vals] for a in args)", "code_tokens": "def remove_nans_1D ( * args ) -> tuple : vals = np . isnan ( args [ 0 ] ) for a in args : vals |= np . isnan ( a ) return tuple ( np . array ( a ) [ ~ vals ] for a in args )", "docstring_tokens": "Remove nans in a set of 1D arrays .", "label": 0}, {"idx": "cosqa-train-17019", "doc": "how do i ask if key exists python", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 0}, {"idx": "cosqa-train-17020", "doc": "how to make the secon character to capitalize in python", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 1}, {"idx": "cosqa-train-17021", "doc": "how to type in latex in python", "code": "def _latex_format(obj: Any) -> str:\n    \"\"\"Format an object as a latex string.\"\"\"\n    if isinstance(obj, float):\n        try:\n            return sympy.latex(symbolize(obj))\n        except ValueError:\n            return \"{0:.4g}\".format(obj)\n\n    return str(obj)", "code_tokens": "def _latex_format ( obj : Any ) -> str : if isinstance ( obj , float ) : try : return sympy . latex ( symbolize ( obj ) ) except ValueError : return \"{0:.4g}\" . format ( obj ) return str ( obj )", "docstring_tokens": "Format an object as a latex string .", "label": 0}, {"idx": "cosqa-train-17022", "doc": "check if object is empty python", "code": "def is_empty_shape(sh: ShExJ.Shape) -> bool:\n        \"\"\" Determine whether sh has any value \"\"\"\n        return sh.closed is None and sh.expression is None and sh.extra is None and \\\n            sh.semActs is None", "code_tokens": "def is_empty_shape ( sh : ShExJ . Shape ) -> bool : return sh . closed is None and sh . expression is None and sh . extra is None and sh . semActs is None", "docstring_tokens": "Determine whether sh has any value", "label": 0}, {"idx": "cosqa-train-17023", "doc": "python create a set containing all the unique characters in the string read from the text file", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 0}, {"idx": "cosqa-train-17024", "doc": "see if 2 strings are equal python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 0}, {"idx": "cosqa-train-17025", "doc": "create new dictionary from two dictionaries python", "code": "def extend(a: dict, b: dict) -> dict:\n    \"\"\"Merge two dicts and return a new dict. Much like subclassing works.\"\"\"\n    res = a.copy()\n    res.update(b)\n    return res", "code_tokens": "def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res", "docstring_tokens": "Merge two dicts and return a new dict . Much like subclassing works .", "label": 1}, {"idx": "cosqa-train-17026", "doc": "printing the month name from a month number in python", "code": "def pmon(month):\n\t\"\"\"\n\tP the month\n\n\t>>> print(pmon('2012-08'))\n\tAugust, 2012\n\t\"\"\"\n\tyear, month = month.split('-')\n\treturn '{month_name}, {year}'.format(\n\t\tmonth_name=calendar.month_name[int(month)],\n\t\tyear=year,\n\t)", "code_tokens": "def pmon ( month ) : year , month = month . split ( '-' ) return '{month_name}, {year}' . format ( month_name = calendar . month_name [ int ( month ) ] , year = year , )", "docstring_tokens": "P the month", "label": 0}, {"idx": "cosqa-train-17027", "doc": "delete xml element python", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 0}, {"idx": "cosqa-train-17028", "doc": "python extend the same list in lower case", "code": "def _lower(string):\n    \"\"\"Custom lower string function.\n    Examples:\n        FooBar -> foo_bar\n    \"\"\"\n    if not string:\n        return \"\"\n\n    new_string = [string[0].lower()]\n    for char in string[1:]:\n        if char.isupper():\n            new_string.append(\"_\")\n        new_string.append(char.lower())\n\n    return \"\".join(new_string)", "code_tokens": "def _lower ( string ) : if not string : return \"\" new_string = [ string [ 0 ] . lower ( ) ] for char in string [ 1 : ] : if char . isupper ( ) : new_string . append ( \"_\" ) new_string . append ( char . lower ( ) ) return \"\" . join ( new_string )", "docstring_tokens": "Custom lower string function . Examples : FooBar - > foo_bar", "label": 0}, {"idx": "cosqa-train-17029", "doc": "python 3 dictionary comprehension multiple iterators", "code": "def iterate_items(dictish):\n    \"\"\" Return a consistent (key, value) iterable on dict-like objects,\n    including lists of tuple pairs.\n\n    Example:\n\n        >>> list(iterate_items({'a': 1}))\n        [('a', 1)]\n        >>> list(iterate_items([('a', 1), ('b', 2)]))\n        [('a', 1), ('b', 2)]\n    \"\"\"\n    if hasattr(dictish, 'iteritems'):\n        return dictish.iteritems()\n    if hasattr(dictish, 'items'):\n        return dictish.items()\n    return dictish", "code_tokens": "def iterate_items ( dictish ) : if hasattr ( dictish , 'iteritems' ) : return dictish . iteritems ( ) if hasattr ( dictish , 'items' ) : return dictish . items ( ) return dictish", "docstring_tokens": "Return a consistent ( key value ) iterable on dict - like objects including lists of tuple pairs .", "label": 0}, {"idx": "cosqa-train-17030", "doc": "area of a polygon in python", "code": "def area (self):\n    \"\"\"area() -> number\n\n    Returns the area of this Polygon.\n    \"\"\"\n    area = 0.0\n    \n    for segment in self.segments():\n      area += ((segment.p.x * segment.q.y) - (segment.q.x * segment.p.y))/2\n\n    return area", "code_tokens": "def area ( self ) : area = 0.0 for segment in self . segments ( ) : area += ( ( segment . p . x * segment . q . y ) - ( segment . q . x * segment . p . y ) ) / 2 return area", "docstring_tokens": "area () - > number", "label": 0}, {"idx": "cosqa-train-17031", "doc": "get name of day of week python", "code": "def get_day_name(self) -> str:\n        \"\"\" Returns the day name \"\"\"\n        weekday = self.value.isoweekday() - 1\n        return calendar.day_name[weekday]", "code_tokens": "def get_day_name ( self ) -> str : weekday = self . value . isoweekday ( ) - 1 return calendar . day_name [ weekday ]", "docstring_tokens": "Returns the day name", "label": 1}, {"idx": "cosqa-train-17032", "doc": "python list of words return a dictionary mapping each unique word to an index", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 0}, {"idx": "cosqa-train-17033", "doc": "accuracy and precision recall in python", "code": "def recall_score(y_true, y_pred, average='micro', suffix=False):\n    \"\"\"Compute the recall.\n\n    The recall is the ratio ``tp / (tp + fn)`` where ``tp`` is the number of\n    true positives and ``fn`` the number of false negatives. The recall is\n    intuitively the ability of the classifier to find all the positive samples.\n\n    The best value is 1 and the worst value is 0.\n\n    Args:\n        y_true : 2d array. Ground truth (correct) target values.\n        y_pred : 2d array. Estimated targets as returned by a tagger.\n\n    Returns:\n        score : float.\n\n    Example:\n        >>> from seqeval.metrics import recall_score\n        >>> y_true = [['O', 'O', 'O', 'B-MISC', 'I-MISC', 'I-MISC', 'O'], ['B-PER', 'I-PER', 'O']]\n        >>> y_pred = [['O', 'O', 'B-MISC', 'I-MISC', 'I-MISC', 'I-MISC', 'O'], ['B-PER', 'I-PER', 'O']]\n        >>> recall_score(y_true, y_pred)\n        0.50\n    \"\"\"\n    true_entities = set(get_entities(y_true, suffix))\n    pred_entities = set(get_entities(y_pred, suffix))\n\n    nb_correct = len(true_entities & pred_entities)\n    nb_true = len(true_entities)\n\n    score = nb_correct / nb_true if nb_true > 0 else 0\n\n    return score", "code_tokens": "def recall_score ( y_true , y_pred , average = 'micro' , suffix = False ) : true_entities = set ( get_entities ( y_true , suffix ) ) pred_entities = set ( get_entities ( y_pred , suffix ) ) nb_correct = len ( true_entities & pred_entities ) nb_true = len ( true_entities ) score = nb_correct / nb_true if nb_true > 0 else 0 return score", "docstring_tokens": "Compute the recall .", "label": 0}, {"idx": "cosqa-train-17034", "doc": "list of objects, how to tell if none of them have a value python", "code": "def is_any_type_set(sett: Set[Type]) -> bool:\n    \"\"\"\n    Helper method to check if a set of types is the {AnyObject} singleton\n\n    :param sett:\n    :return:\n    \"\"\"\n    return len(sett) == 1 and is_any_type(min(sett))", "code_tokens": "def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )", "docstring_tokens": "Helper method to check if a set of types is the { AnyObject } singleton", "label": 1}, {"idx": "cosqa-train-17035", "doc": "spider python zoom out", "code": "def unzoom_all(self, event=None):\n        \"\"\" zoom out full data range \"\"\"\n        if len(self.conf.zoom_lims) > 0:\n            self.conf.zoom_lims = [self.conf.zoom_lims[0]]\n        self.unzoom(event)", "code_tokens": "def unzoom_all ( self , event = None ) : if len ( self . conf . zoom_lims ) > 0 : self . conf . zoom_lims = [ self . conf . zoom_lims [ 0 ] ] self . unzoom ( event )", "docstring_tokens": "zoom out full data range", "label": 0}, {"idx": "cosqa-train-17036", "doc": "how to write to a text file in python", "code": "def write_text(filename: str, text: str) -> None:\n    \"\"\"\n    Writes text to a file.\n    \"\"\"\n    with open(filename, 'w') as f:  # type: TextIO\n        print(text, file=f)", "code_tokens": "def write_text ( filename : str , text : str ) -> None : with open ( filename , 'w' ) as f : # type: TextIO print ( text , file = f )", "docstring_tokens": "Writes text to a file .", "label": 0}, {"idx": "cosqa-train-17037", "doc": "python string replace last occurance", "code": "def right_replace(string, old, new, count=1):\n    \"\"\"\n    Right replaces ``count`` occurrences of ``old`` with ``new`` in ``string``.\n    For example::\n\n        right_replace('one_two_two', 'two', 'three') -> 'one_two_three'\n    \"\"\"\n    if not string:\n        return string\n    return new.join(string.rsplit(old, count))", "code_tokens": "def right_replace ( string , old , new , count = 1 ) : if not string : return string return new . join ( string . rsplit ( old , count ) )", "docstring_tokens": "Right replaces count occurrences of old with new in string . For example ::", "label": 0}, {"idx": "cosqa-train-17038", "doc": "python matplotlib how to zoom out", "code": "def unzoom_all(self, event=None):\n        \"\"\" zoom out full data range \"\"\"\n        if len(self.conf.zoom_lims) > 0:\n            self.conf.zoom_lims = [self.conf.zoom_lims[0]]\n        self.unzoom(event)", "code_tokens": "def unzoom_all ( self , event = None ) : if len ( self . conf . zoom_lims ) > 0 : self . conf . zoom_lims = [ self . conf . zoom_lims [ 0 ] ] self . unzoom ( event )", "docstring_tokens": "zoom out full data range", "label": 1}, {"idx": "cosqa-train-17039", "doc": "python recursive print a tree networkx", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-17040", "doc": "python filter not none", "code": "def exclude(self, *args, **kwargs) -> \"QuerySet\":\n        \"\"\"\n        Same as .filter(), but with appends all args with NOT\n        \"\"\"\n        return self._filter_or_exclude(negate=True, *args, **kwargs)", "code_tokens": "def exclude ( self , * args , * * kwargs ) -> \"QuerySet\" : return self . _filter_or_exclude ( negate = True , * args , * * kwargs )", "docstring_tokens": "Same as . filter () but with appends all args with NOT", "label": 0}, {"idx": "cosqa-train-17041", "doc": "string is camel python", "code": "def camel_to_snake(s: str) -> str:\n    \"\"\"Convert string from camel case to snake case.\"\"\"\n\n    return CAMEL_CASE_RE.sub(r'_\\1', s).strip().lower()", "code_tokens": "def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "docstring_tokens": "Convert string from camel case to snake case .", "label": 0}, {"idx": "cosqa-train-17042", "doc": "python sqlalchemy different column different dtype", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 1}, {"idx": "cosqa-train-17043", "doc": "python get timezone info", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 0}, {"idx": "cosqa-train-17044", "doc": "how to pad zeros to string in python", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 0}, {"idx": "cosqa-train-17045", "doc": "python return most frequency of list", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 1}, {"idx": "cosqa-train-17046", "doc": "normalize percentage per row in python", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 1}, {"idx": "cosqa-train-17047", "doc": "get colunmn names in python", "code": "def attrname_to_colname_dict(cls) -> Dict[str, str]:\n    \"\"\"\n    Asks an SQLAlchemy class how its attribute names correspond to database\n    column names.\n\n    Args:\n        cls: SQLAlchemy ORM class\n\n    Returns:\n        a dictionary mapping attribute names to database column names\n    \"\"\"\n    attr_col = {}  # type: Dict[str, str]\n    for attrname, column in gen_columns(cls):\n        attr_col[attrname] = column.name\n    return attr_col", "code_tokens": "def attrname_to_colname_dict ( cls ) -> Dict [ str , str ] : attr_col = { } # type: Dict[str, str] for attrname , column in gen_columns ( cls ) : attr_col [ attrname ] = column . name return attr_col", "docstring_tokens": "Asks an SQLAlchemy class how its attribute names correspond to database column names .", "label": 1}, {"idx": "cosqa-train-17048", "doc": "python asyncio 'bare yield'", "code": "async def parallel_results(future_map: Sequence[Tuple]) -> Dict:\n    \"\"\"\n    Run parallel execution of futures and return mapping of their results to the provided keys.\n    Just a neat shortcut around ``asyncio.gather()``\n\n    :param future_map: Keys to futures mapping, e.g.: ( ('nav', get_nav()), ('content, get_content()) )\n    :return: Dict with futures results mapped to keys {'nav': {1:2}, 'content': 'xyz'}\n    \"\"\"\n    ctx_methods = OrderedDict(future_map)\n    fs = list(ctx_methods.values())\n    results = await asyncio.gather(*fs)\n    results = {\n        key: results[idx] for idx, key in enumerate(ctx_methods.keys())\n    }\n    return results", "code_tokens": "async def parallel_results ( future_map : Sequence [ Tuple ] ) -> Dict : ctx_methods = OrderedDict ( future_map ) fs = list ( ctx_methods . values ( ) ) results = await asyncio . gather ( * fs ) results = { key : results [ idx ] for idx , key in enumerate ( ctx_methods . keys ( ) ) } return results", "docstring_tokens": "Run parallel execution of futures and return mapping of their results to the provided keys . Just a neat shortcut around asyncio . gather ()", "label": 0}, {"idx": "cosqa-train-17049", "doc": "how to keep leading zeroes in python", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 1}, {"idx": "cosqa-train-17050", "doc": "replace all occurences of char in a string python", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 0}, {"idx": "cosqa-train-17051", "doc": "how to determine what data type something is in python", "code": "def maybe_infer_dtype_type(element):\n    \"\"\"Try to infer an object's dtype, for use in arithmetic ops\n\n    Uses `element.dtype` if that's available.\n    Objects implementing the iterator protocol are cast to a NumPy array,\n    and from there the array's type is used.\n\n    Parameters\n    ----------\n    element : object\n        Possibly has a `.dtype` attribute, and possibly the iterator\n        protocol.\n\n    Returns\n    -------\n    tipo : type\n\n    Examples\n    --------\n    >>> from collections import namedtuple\n    >>> Foo = namedtuple(\"Foo\", \"dtype\")\n    >>> maybe_infer_dtype_type(Foo(np.dtype(\"i8\")))\n    numpy.int64\n    \"\"\"\n    tipo = None\n    if hasattr(element, 'dtype'):\n        tipo = element.dtype\n    elif is_list_like(element):\n        element = np.asarray(element)\n        tipo = element.dtype\n    return tipo", "code_tokens": "def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "docstring_tokens": "Try to infer an object s dtype for use in arithmetic ops", "label": 0}, {"idx": "cosqa-train-17052", "doc": "python3 biopython bytes object expected", "code": "def bytes_hack(buf):\n    \"\"\"\n    Hacky workaround for old installs of the library on systems without python-future that were\n    keeping the 2to3 update from working after auto-update.\n    \"\"\"\n    ub = None\n    if sys.version_info > (3,):\n        ub = buf\n    else:\n        ub = bytes(buf)\n\n    return ub", "code_tokens": "def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "docstring_tokens": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update .", "label": 0}, {"idx": "cosqa-train-17053", "doc": "top values in list python", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 1}, {"idx": "cosqa-train-17054", "doc": "python property get with default", "code": "def get_prop_value(name, props, default=None):\n    # type: (str, Dict[str, Any], Any) -> Any\n    \"\"\"\n    Returns the value of a property or the default one\n\n    :param name: Name of a property\n    :param props: Dictionary of properties\n    :param default: Default value\n    :return: The value of the property or the default one\n    \"\"\"\n    if not props:\n        return default\n\n    try:\n        return props[name]\n    except KeyError:\n        return default", "code_tokens": "def get_prop_value ( name , props , default = None ) : # type: (str, Dict[str, Any], Any) -> Any if not props : return default try : return props [ name ] except KeyError : return default", "docstring_tokens": "Returns the value of a property or the default one", "label": 1}, {"idx": "cosqa-train-17055", "doc": "generate the hash values using perfect hash function in python", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 1}, {"idx": "cosqa-train-17056", "doc": "python largest index in array true", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 1}, {"idx": "cosqa-train-17057", "doc": "how to make a pie chart in python matplotlib", "code": "def create_pie_chart(self, snapshot, filename=''):\n        \"\"\"\n        Create a pie chart that depicts the distribution of the allocated memory\n        for a given `snapshot`. The chart is saved to `filename`.\n        \"\"\"\n        try:\n            from pylab import figure, title, pie, axes, savefig\n            from pylab import sum as pylab_sum\n        except ImportError:\n            return self.nopylab_msg % (\"pie_chart\")\n\n        # Don't bother illustrating a pie without pieces.\n        if not snapshot.tracked_total:\n            return ''\n\n        classlist = []\n        sizelist = []\n        for k, v in list(snapshot.classes.items()):\n            if v['pct'] > 3.0:\n                classlist.append(k)\n                sizelist.append(v['sum'])\n        sizelist.insert(0, snapshot.asizeof_total - pylab_sum(sizelist))\n        classlist.insert(0, 'Other')\n        #sizelist = [x*0.01 for x in sizelist]\n\n        title(\"Snapshot (%s) Memory Distribution\" % (snapshot.desc))\n        figure(figsize=(8,8))\n        axes([0.1, 0.1, 0.8, 0.8])\n        pie(sizelist, labels=classlist)\n        savefig(filename, dpi=50)\n\n        return self.chart_tag % (self.relative_path(filename))", "code_tokens": "def create_pie_chart ( self , snapshot , filename = '' ) : try : from pylab import figure , title , pie , axes , savefig from pylab import sum as pylab_sum except ImportError : return self . nopylab_msg % ( \"pie_chart\" ) # Don't bother illustrating a pie without pieces. if not snapshot . tracked_total : return '' classlist = [ ] sizelist = [ ] for k , v in list ( snapshot . classes . items ( ) ) : if v [ 'pct' ] > 3.0 : classlist . append ( k ) sizelist . append ( v [ 'sum' ] ) sizelist . insert ( 0 , snapshot . asizeof_total - pylab_sum ( sizelist ) ) classlist . insert ( 0 , 'Other' ) #sizelist = [x*0.01 for x in sizelist] title ( \"Snapshot (%s) Memory Distribution\" % ( snapshot . desc ) ) figure ( figsize = ( 8 , 8 ) ) axes ( [ 0.1 , 0.1 , 0.8 , 0.8 ] ) pie ( sizelist , labels = classlist ) savefig ( filename , dpi = 50 ) return self . chart_tag % ( self . relative_path ( filename ) )", "docstring_tokens": "Create a pie chart that depicts the distribution of the allocated memory for a given snapshot . The chart is saved to filename .", "label": 1}, {"idx": "cosqa-train-17058", "doc": "python turn list of str to int", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-17059", "doc": "python filter dictionary lambda key value", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-17060", "doc": "python datetime get last month number", "code": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day", "code_tokens": "def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "docstring_tokens": "Returns day number of the last day of the month : param t : datetime : return : int", "label": 1}, {"idx": "cosqa-train-17061", "doc": "python check two file path equal", "code": "def samefile(a: str, b: str) -> bool:\n    \"\"\"Check if two pathes represent the same file.\"\"\"\n    try:\n        return os.path.samefile(a, b)\n    except OSError:\n        return os.path.normpath(a) == os.path.normpath(b)", "code_tokens": "def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )", "docstring_tokens": "Check if two pathes represent the same file .", "label": 0}, {"idx": "cosqa-train-17062", "doc": "python json file reader", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 0}, {"idx": "cosqa-train-17063", "doc": "python downgrade got rid of spyder", "code": "def get_versions(reporev=True):\n    \"\"\"Get version information for components used by Spyder\"\"\"\n    import sys\n    import platform\n\n    import qtpy\n    import qtpy.QtCore\n\n    revision = None\n    if reporev:\n        from spyder.utils import vcs\n        revision, branch = vcs.get_git_revision(os.path.dirname(__dir__))\n\n    if not sys.platform == 'darwin':  # To avoid a crash with our Mac app\n        system = platform.system()\n    else:\n        system = 'Darwin'\n\n    return {\n        'spyder': __version__,\n        'python': platform.python_version(),  # \"2.7.3\"\n        'bitness': 64 if sys.maxsize > 2**32 else 32,\n        'qt': qtpy.QtCore.__version__,\n        'qt_api': qtpy.API_NAME,      # PyQt5\n        'qt_api_ver': qtpy.PYQT_VERSION,\n        'system': system,   # Linux, Windows, ...\n        'release': platform.release(),  # XP, 10.6, 2.2.0, etc.\n        'revision': revision,  # '9fdf926eccce'\n    }", "code_tokens": "def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "docstring_tokens": "Get version information for components used by Spyder", "label": 1}, {"idx": "cosqa-train-17064", "doc": "how to read image in python uint8", "code": "def read32(bytestream):\n  \"\"\"Read 4 bytes from bytestream as an unsigned 32-bit integer.\"\"\"\n  dt = np.dtype(np.uint32).newbyteorder('>')\n  return np.frombuffer(bytestream.read(4), dtype=dt)[0]", "code_tokens": "def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "docstring_tokens": "Read 4 bytes from bytestream as an unsigned 32 - bit integer .", "label": 1}, {"idx": "cosqa-train-17065", "doc": "python force stop event", "code": "def do_quit(self, _: argparse.Namespace) -> bool:\n        \"\"\"Exit this application\"\"\"\n        self._should_quit = True\n        return self._STOP_AND_EXIT", "code_tokens": "def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "docstring_tokens": "Exit this application", "label": 0}, {"idx": "cosqa-train-17066", "doc": "python transform a vector to a tensor", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 0}, {"idx": "cosqa-train-17067", "doc": "get first 50 rows python", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 0}, {"idx": "cosqa-train-17068", "doc": "python format string for all entries in numpy array", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 0}, {"idx": "cosqa-train-17069", "doc": "python argparse call from function", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 1}, {"idx": "cosqa-train-17070", "doc": "python shuffle columns of a matrix", "code": "def _reshuffle(mat, shape):\n    \"\"\"Reshuffle the indicies of a bipartite matrix A[ij,kl] -> A[lj,ki].\"\"\"\n    return np.reshape(\n        np.transpose(np.reshape(mat, shape), (3, 1, 2, 0)),\n        (shape[3] * shape[1], shape[0] * shape[2]))", "code_tokens": "def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )", "docstring_tokens": "Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] .", "label": 1}, {"idx": "cosqa-train-17071", "doc": "get number of cpu cores used python 3", "code": "def cpu_count() -> int:\n    \"\"\"Returns the number of processors on this machine.\"\"\"\n    if multiprocessing is None:\n        return 1\n    try:\n        return multiprocessing.cpu_count()\n    except NotImplementedError:\n        pass\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_CONF\")\n    except (AttributeError, ValueError):\n        pass\n    gen_log.error(\"Could not detect number of processors; assuming 1\")\n    return 1", "code_tokens": "def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( \"SC_NPROCESSORS_CONF\" ) except ( AttributeError , ValueError ) : pass gen_log . error ( \"Could not detect number of processors; assuming 1\" ) return 1", "docstring_tokens": "Returns the number of processors on this machine .", "label": 1}, {"idx": "cosqa-train-17072", "doc": "python pywin32 mouse events", "code": "def mouse_event(dwFlags: int, dx: int, dy: int, dwData: int, dwExtraInfo: int) -> None:\n    \"\"\"mouse_event from Win32.\"\"\"\n    ctypes.windll.user32.mouse_event(dwFlags, dx, dy, dwData, dwExtraInfo)", "code_tokens": "def mouse_event ( dwFlags : int , dx : int , dy : int , dwData : int , dwExtraInfo : int ) -> None : ctypes . windll . user32 . mouse_event ( dwFlags , dx , dy , dwData , dwExtraInfo )", "docstring_tokens": "mouse_event from Win32 .", "label": 0}, {"idx": "cosqa-train-17073", "doc": "numpy array to string with no bracket in python", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 0}, {"idx": "cosqa-train-17074", "doc": "make an array from iterator in python", "code": "def _izip(*iterables):\n    \"\"\" Iterate through multiple lists or arrays of equal size \"\"\"\n    # This izip routine is from itertools\n    # izip('ABCD', 'xy') --> Ax By\n\n    iterators = map(iter, iterables)\n    while iterators:\n        yield tuple(map(next, iterators))", "code_tokens": "def _izip ( * iterables ) : # This izip routine is from itertools # izip('ABCD', 'xy') --> Ax By iterators = map ( iter , iterables ) while iterators : yield tuple ( map ( next , iterators ) )", "docstring_tokens": "Iterate through multiple lists or arrays of equal size", "label": 0}, {"idx": "cosqa-train-17075", "doc": "python create new dict from two", "code": "def extend(a: dict, b: dict) -> dict:\n    \"\"\"Merge two dicts and return a new dict. Much like subclassing works.\"\"\"\n    res = a.copy()\n    res.update(b)\n    return res", "code_tokens": "def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res", "docstring_tokens": "Merge two dicts and return a new dict . Much like subclassing works .", "label": 0}, {"idx": "cosqa-train-17076", "doc": "python fetch file from s3", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 0}, {"idx": "cosqa-train-17077", "doc": "how to extract data from stream in python", "code": "def decode_value(stream):\n    \"\"\"Decode the contents of a value from a serialized stream.\n\n    :param stream: Source data stream\n    :type stream: io.BytesIO\n    :returns: Decoded value\n    :rtype: bytes\n    \"\"\"\n    length = decode_length(stream)\n    (value,) = unpack_value(\">{:d}s\".format(length), stream)\n    return value", "code_tokens": "def decode_value ( stream ) : length = decode_length ( stream ) ( value , ) = unpack_value ( \">{:d}s\" . format ( length ) , stream ) return value", "docstring_tokens": "Decode the contents of a value from a serialized stream .", "label": 1}, {"idx": "cosqa-train-17078", "doc": "python pysql send multiple queries", "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None:\n        \"\"\"Execute the given multiquery.\"\"\"\n        await self._execute(self._cursor.executemany, sql, parameters)", "code_tokens": "async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "docstring_tokens": "Execute the given multiquery .", "label": 1}, {"idx": "cosqa-train-17079", "doc": "python 3 flatten list of lists with list comprehension", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 0}, {"idx": "cosqa-train-17080", "doc": "turn string into int in python", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-17081", "doc": "check if value in column is null python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 0}, {"idx": "cosqa-train-17082", "doc": "python unblock lock acquire", "code": "def release_lock():\n    \"\"\"Release lock on compilation directory.\"\"\"\n    get_lock.n_lock -= 1\n    assert get_lock.n_lock >= 0\n    # Only really release lock once all lock requests have ended.\n    if get_lock.lock_is_enabled and get_lock.n_lock == 0:\n        get_lock.start_time = None\n        get_lock.unlocker.unlock()", "code_tokens": "def release_lock ( ) : get_lock . n_lock -= 1 assert get_lock . n_lock >= 0 # Only really release lock once all lock requests have ended. if get_lock . lock_is_enabled and get_lock . n_lock == 0 : get_lock . start_time = None get_lock . unlocker . unlock ( )", "docstring_tokens": "Release lock on compilation directory .", "label": 1}, {"idx": "cosqa-train-17083", "doc": "any way to make all of the characters in a string uppercase? python", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-17084", "doc": "python memoryview contact buffer fragment", "code": "def read(self, start_position: int, size: int) -> memoryview:\n        \"\"\"\n        Return a view into the memory\n        \"\"\"\n        return memoryview(self._bytes)[start_position:start_position + size]", "code_tokens": "def read ( self , start_position : int , size : int ) -> memoryview : return memoryview ( self . _bytes ) [ start_position : start_position + size ]", "docstring_tokens": "Return a view into the memory", "label": 1}, {"idx": "cosqa-train-17085", "doc": "get minimum value of column python", "code": "def min(self):\n        \"\"\"\n        :returns the minimum of the column\n        \"\"\"\n        res = self._qexec(\"min(%s)\" % self._name)\n        if len(res) > 0:\n            self._min = res[0][0]\n        return self._min", "code_tokens": "def min ( self ) : res = self . _qexec ( \"min(%s)\" % self . _name ) if len ( res ) > 0 : self . _min = res [ 0 ] [ 0 ] return self . _min", "docstring_tokens": ": returns the minimum of the column", "label": 1}, {"idx": "cosqa-train-17086", "doc": "how to return smallest magnitude vector in an array python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 0}, {"idx": "cosqa-train-17087", "doc": "check if input is an integer or boolean python", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 1}, {"idx": "cosqa-train-17088", "doc": "python formating the width of a column", "code": "def append_num_column(self, text: str, index: int):\n        \"\"\" Add value to the output row, width based on index \"\"\"\n        width = self.columns[index][\"width\"]\n        return f\"{text:>{width}}\"", "code_tokens": "def append_num_column ( self , text : str , index : int ) : width = self . columns [ index ] [ \"width\" ] return f\"{text:>{width}}\"", "docstring_tokens": "Add value to the output row width based on index", "label": 0}, {"idx": "cosqa-train-17089", "doc": "how to tell if running 64 bit python", "code": "def check64bit(current_system=\"python\"):\n    \"\"\"checks if you are on a 64 bit platform\"\"\"\n    if current_system == \"python\":\n        return sys.maxsize > 2147483647\n    elif current_system == \"os\":\n        import platform\n        pm = platform.machine()\n        if pm != \"..\" and pm.endswith('64'):  # recent Python (not Iron)\n            return True\n        else:\n            if 'PROCESSOR_ARCHITEW6432' in os.environ:\n                return True  # 32 bit program running on 64 bit Windows\n            try:\n                # 64 bit Windows 64 bit program\n                return os.environ['PROCESSOR_ARCHITECTURE'].endswith('64')\n            except IndexError:\n                pass  # not Windows\n            try:\n                # this often works in Linux\n                return '64' in platform.architecture()[0]\n            except Exception:\n                # is an older version of Python, assume also an older os@\n                # (best we can guess)\n                return False", "code_tokens": "def check64bit ( current_system = \"python\" ) : if current_system == \"python\" : return sys . maxsize > 2147483647 elif current_system == \"os\" : import platform pm = platform . machine ( ) if pm != \"..\" and pm . endswith ( '64' ) : # recent Python (not Iron) return True else : if 'PROCESSOR_ARCHITEW6432' in os . environ : return True # 32 bit program running on 64 bit Windows try : # 64 bit Windows 64 bit program return os . environ [ 'PROCESSOR_ARCHITECTURE' ] . endswith ( '64' ) except IndexError : pass # not Windows try : # this often works in Linux return '64' in platform . architecture ( ) [ 0 ] except Exception : # is an older version of Python, assume also an older os@ # (best we can guess) return False", "docstring_tokens": "checks if you are on a 64 bit platform", "label": 1}, {"idx": "cosqa-train-17090", "doc": "python key press exist", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 0}, {"idx": "cosqa-train-17091", "doc": "python print numpy array with string", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 1}, {"idx": "cosqa-train-17092", "doc": "python lastworking day of month", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 1}, {"idx": "cosqa-train-17093", "doc": "python range step of gaussian distribtuion", "code": "def _gaussian_function(self, datalength: int, values: np.ndarray,\n                           height: int, index: int) -> np.ndarray:\n        \"\"\"\n        i'th Regression Model Gaussian\n\n        :param: len(x)\n        :param: x values\n        :param: height of gaussian\n        :param: position of gaussian\n\n        :return: gaussian bumps over domain\n        \"\"\"\n        return height * np.exp(-(1 / (self.spread_number * datalength)) *\n                               (values - ((datalength / self.function_number) * index)) ** 2)", "code_tokens": "def _gaussian_function ( self , datalength : int , values : np . ndarray , height : int , index : int ) -> np . ndarray : return height * np . exp ( - ( 1 / ( self . spread_number * datalength ) ) * ( values - ( ( datalength / self . function_number ) * index ) ) ** 2 )", "docstring_tokens": "i th Regression Model Gaussian", "label": 0}, {"idx": "cosqa-train-17094", "doc": "python tuple string element without quotation marks", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 0}, {"idx": "cosqa-train-17095", "doc": "how to get the year from a dat in python", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 1}, {"idx": "cosqa-train-17096", "doc": "python stop service windows", "code": "def SvcStop(self) -> None:\n        \"\"\"\n        Called when the service is being shut down.\n        \"\"\"\n        # tell the SCM we're shutting down\n        # noinspection PyUnresolvedReferences\n        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)\n        # fire the stop event\n        win32event.SetEvent(self.h_stop_event)", "code_tokens": "def SvcStop ( self ) -> None : # tell the SCM we're shutting down # noinspection PyUnresolvedReferences self . ReportServiceStatus ( win32service . SERVICE_STOP_PENDING ) # fire the stop event win32event . SetEvent ( self . h_stop_event )", "docstring_tokens": "Called when the service is being shut down .", "label": 1}, {"idx": "cosqa-train-17097", "doc": "python translate a list of strings into int", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 0}, {"idx": "cosqa-train-17098", "doc": "python how to check a file for an empty line", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 0}, {"idx": "cosqa-train-17099", "doc": "how to obtain several matched strings from a single file in python", "code": "def grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''", "code_tokens": "def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "docstring_tokens": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .", "label": 0}, {"idx": "cosqa-train-17100", "doc": "python check file newer than other file", "code": "def _newer(a, b):\n    \"\"\"Inquire whether file a was written since file b.\"\"\"\n    if not os.path.exists(a):\n        return False\n    if not os.path.exists(b):\n        return True\n    return os.path.getmtime(a) >= os.path.getmtime(b)", "code_tokens": "def _newer ( a , b ) : if not os . path . exists ( a ) : return False if not os . path . exists ( b ) : return True return os . path . getmtime ( a ) >= os . path . getmtime ( b )", "docstring_tokens": "Inquire whether file a was written since file b .", "label": 0}, {"idx": "cosqa-train-17101", "doc": "substring or prefix in python", "code": "def remove_prefix(text, prefix):\n\t\"\"\"\n\tRemove the prefix from the text if it exists.\n\n\t>>> remove_prefix('underwhelming performance', 'underwhelming ')\n\t'performance'\n\n\t>>> remove_prefix('something special', 'sample')\n\t'something special'\n\t\"\"\"\n\tnull, prefix, rest = text.rpartition(prefix)\n\treturn rest", "code_tokens": "def remove_prefix ( text , prefix ) : null , prefix , rest = text . rpartition ( prefix ) return rest", "docstring_tokens": "Remove the prefix from the text if it exists .", "label": 1}, {"idx": "cosqa-train-17102", "doc": "get environ varibles in python", "code": "def _environment_variables() -> Dict[str, str]:\n    \"\"\"\n    Wraps `os.environ` to filter out non-encodable values.\n    \"\"\"\n    return {key: value\n            for key, value in os.environ.items()\n            if _is_encodable(value)}", "code_tokens": "def _environment_variables ( ) -> Dict [ str , str ] : return { key : value for key , value in os . environ . items ( ) if _is_encodable ( value ) }", "docstring_tokens": "Wraps os . environ to filter out non - encodable values .", "label": 1}, {"idx": "cosqa-train-17103", "doc": "python 3 check for keypress", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 0}, {"idx": "cosqa-train-17104", "doc": "python limit a string to have a max number of characters", "code": "def truncate_string(value, max_width=None):\n    \"\"\"Truncate string values.\"\"\"\n    if isinstance(value, text_type) and max_width is not None and len(value) > max_width:\n        return value[:max_width]\n    return value", "code_tokens": "def truncate_string ( value , max_width = None ) : if isinstance ( value , text_type ) and max_width is not None and len ( value ) > max_width : return value [ : max_width ] return value", "docstring_tokens": "Truncate string values .", "label": 0}, {"idx": "cosqa-train-17105", "doc": "how to select first 10 rows in python", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 1}, {"idx": "cosqa-train-17106", "doc": "python scaling image to zoom", "code": "def zoom_out(self):\n        \"\"\"Scale the image down by one scale step.\"\"\"\n        if self._scalefactor >= self._sfmin:\n            self._scalefactor -= 1\n            self.scale_image()\n            self._adjust_scrollbar(1/self._scalestep)\n            self.sig_zoom_changed.emit(self.get_scaling())", "code_tokens": "def zoom_out ( self ) : if self . _scalefactor >= self . _sfmin : self . _scalefactor -= 1 self . scale_image ( ) self . _adjust_scrollbar ( 1 / self . _scalestep ) self . sig_zoom_changed . emit ( self . get_scaling ( ) )", "docstring_tokens": "Scale the image down by one scale step .", "label": 1}, {"idx": "cosqa-train-17107", "doc": "instance of 'str' has no 'value' member python enum", "code": "def __init__(self, enum_obj: Any) -> None:\n        \"\"\"Initialize attributes for informative output.\n\n        :param enum_obj: Enum object.\n        \"\"\"\n        if enum_obj:\n            self.name = enum_obj\n            self.items = ', '.join([str(i) for i in enum_obj])\n        else:\n            self.items = ''", "code_tokens": "def __init__ ( self , enum_obj : Any ) -> None : if enum_obj : self . name = enum_obj self . items = ', ' . join ( [ str ( i ) for i in enum_obj ] ) else : self . items = ''", "docstring_tokens": "Initialize attributes for informative output .", "label": 0}, {"idx": "cosqa-train-17108", "doc": "get length of deque python", "code": "def count(self, elem):\n        \"\"\"\n        Return the number of elements equal to elem present in the queue\n\n        >>> pdeque([1, 2, 1]).count(1)\n        2\n        \"\"\"\n        return self._left_list.count(elem) + self._right_list.count(elem)", "code_tokens": "def count ( self , elem ) : return self . _left_list . count ( elem ) + self . _right_list . count ( elem )", "docstring_tokens": "Return the number of elements equal to elem present in the queue", "label": 0}, {"idx": "cosqa-train-17109", "doc": "python asyncio executor example", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 0}, {"idx": "cosqa-train-17110", "doc": "python boolean flag true false test", "code": "def to_bool(value: Any) -> bool:\n    \"\"\"Convert string or other Python object to boolean.\n\n    **Rationalle**\n\n    Passing flags is one of the most common cases of using environment vars and\n    as values are strings we need to have an easy way to convert them to\n    boolean Python value.\n\n    Without this function int or float string values can be converted as false\n    positives, e.g. ``bool('0') => True``, but using this function ensure that\n    digit flag be properly converted to boolean value.\n\n    :param value: String or other value.\n    \"\"\"\n    return bool(strtobool(value) if isinstance(value, str) else value)", "code_tokens": "def to_bool ( value : Any ) -> bool : return bool ( strtobool ( value ) if isinstance ( value , str ) else value )", "docstring_tokens": "Convert string or other Python object to boolean .", "label": 1}, {"idx": "cosqa-train-17111", "doc": "get previous 24 month in python", "code": "def get_period_last_3_months() -> str:\n    \"\"\" Returns the last week as a period string \"\"\"\n    today = Datum()\n    today.today()\n\n    # start_date = today - timedelta(weeks=13)\n    start_date = today.clone()\n    start_date.subtract_months(3)\n\n    period = get_period(start_date.date, today.date)\n    return period", "code_tokens": "def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "docstring_tokens": "Returns the last week as a period string", "label": 0}, {"idx": "cosqa-train-17112", "doc": "most frequent value in a list python", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 0}, {"idx": "cosqa-train-17113", "doc": "cv2 resize not working python", "code": "def resize(im, short, max_size):\n    \"\"\"\n    only resize input image to target size and return scale\n    :param im: BGR image input by opencv\n    :param short: one dimensional size (the short side)\n    :param max_size: one dimensional max size (the long side)\n    :return: resized image (NDArray) and scale (float)\n    \"\"\"\n    im_shape = im.shape\n    im_size_min = np.min(im_shape[0:2])\n    im_size_max = np.max(im_shape[0:2])\n    im_scale = float(short) / float(im_size_min)\n    # prevent bigger axis from being more than max_size:\n    if np.round(im_scale * im_size_max) > max_size:\n        im_scale = float(max_size) / float(im_size_max)\n    im = cv2.resize(im, None, None, fx=im_scale, fy=im_scale, interpolation=cv2.INTER_LINEAR)\n    return im, im_scale", "code_tokens": "def resize ( im , short , max_size ) : im_shape = im . shape im_size_min = np . min ( im_shape [ 0 : 2 ] ) im_size_max = np . max ( im_shape [ 0 : 2 ] ) im_scale = float ( short ) / float ( im_size_min ) # prevent bigger axis from being more than max_size: if np . round ( im_scale * im_size_max ) > max_size : im_scale = float ( max_size ) / float ( im_size_max ) im = cv2 . resize ( im , None , None , fx = im_scale , fy = im_scale , interpolation = cv2 . INTER_LINEAR ) return im , im_scale", "docstring_tokens": "only resize input image to target size and return scale : param im : BGR image input by opencv : param short : one dimensional size ( the short side ) : param max_size : one dimensional max size ( the long side ) : return : resized image ( NDArray ) and scale ( float )", "label": 1}, {"idx": "cosqa-train-17114", "doc": "make python tuple from list of strings", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 1}, {"idx": "cosqa-train-17115", "doc": "check two strings are same in python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 0}, {"idx": "cosqa-train-17116", "doc": "round to nearest provided value python", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 1}, {"idx": "cosqa-train-17117", "doc": "python normalize a distribution", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 1}, {"idx": "cosqa-train-17118", "doc": "first location of a char in a string python", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 1}, {"idx": "cosqa-train-17119", "doc": "how to grep a file in python", "code": "def grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''", "code_tokens": "def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "docstring_tokens": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .", "label": 0}, {"idx": "cosqa-train-17120", "doc": "how to limit memory by python like jvm", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 0}, {"idx": "cosqa-train-17121", "doc": "python get last day of each month", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 0}, {"idx": "cosqa-train-17122", "doc": "python round number to limit", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 1}, {"idx": "cosqa-train-17123", "doc": "python sort key by lexigraphy", "code": "def sorted_by(key: Callable[[raw_types.Qid], Any]) -> 'QubitOrder':\n        \"\"\"A basis that orders qubits ascending based on a key function.\n\n        Args:\n            key: A function that takes a qubit and returns a key value. The\n                basis will be ordered ascending according to these key values.\n\n\n        Returns:\n            A basis that orders qubits ascending based on a key function.\n        \"\"\"\n        return QubitOrder(lambda qubits: tuple(sorted(qubits, key=key)))", "code_tokens": "def sorted_by ( key : Callable [ [ raw_types . Qid ] , Any ] ) -> 'QubitOrder' : return QubitOrder ( lambda qubits : tuple ( sorted ( qubits , key = key ) ) )", "docstring_tokens": "A basis that orders qubits ascending based on a key function .", "label": 0}, {"idx": "cosqa-train-17124", "doc": "python how to evaluate if a float is null", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 0}, {"idx": "cosqa-train-17125", "doc": "python limit api call times", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 0}, {"idx": "cosqa-train-17126", "doc": "check if value is finite python", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 0}, {"idx": "cosqa-train-17127", "doc": "python get enum constructor from value", "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum:\n    \"\"\"\n    Converts an ``dict`` to a ``Enum``.\n    \"\"\"\n    return enum_class[d['name']]", "code_tokens": "def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "docstring_tokens": "Converts an dict to a Enum .", "label": 0}, {"idx": "cosqa-train-17128", "doc": "pythonic grep a file", "code": "def grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''", "code_tokens": "def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "docstring_tokens": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .", "label": 1}, {"idx": "cosqa-train-17129", "doc": "how to check the datatype of the column python", "code": "def is_sqlatype_string(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type a string type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.String)", "code_tokens": "def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "docstring_tokens": "Is the SQLAlchemy column type a string type?", "label": 1}, {"idx": "cosqa-train-17130", "doc": "python how to smooth an image skimage", "code": "def smooth_image(image, sigma, sigma_in_physical_coordinates=True, FWHM=False, max_kernel_width=32):\n    \"\"\"\n    Smooth an image\n\n    ANTsR function: `smoothImage`\n\n    Arguments\n    ---------\n    image   \n        Image to smooth\n    \n    sigma   \n        Smoothing factor. Can be scalar, in which case the same sigma is applied to each dimension, or a vector of length dim(inimage) to specify a unique smoothness for each dimension.\n    \n    sigma_in_physical_coordinates : boolean  \n        If true, the smoothing factor is in millimeters; if false, it is in pixels.\n    \n    FWHM : boolean    \n        If true, sigma is interpreted as the full-width-half-max (FWHM) of the filter, not the sigma of a Gaussian kernel.\n    \n    max_kernel_width : scalar    \n        Maximum kernel width\n    \n    Returns\n    -------\n    ANTsImage\n    \n    Example\n    -------\n    >>> import ants\n    >>> image = ants.image_read( ants.get_ants_data('r16'))\n    >>> simage = ants.smooth_image(image, (1.2,1.5))\n    \"\"\"\n    if image.components == 1:\n        return _smooth_image_helper(image, sigma, sigma_in_physical_coordinates, FWHM, max_kernel_width)\n    else:\n        imagelist = utils.split_channels(image)\n        newimages = []\n        for image in imagelist:\n            newimage = _smooth_image_helper(image, sigma, sigma_in_physical_coordinates, FWHM, max_kernel_width)\n            newimages.append(newimage)\n        return utils.merge_channels(newimages)", "code_tokens": "def smooth_image ( image , sigma , sigma_in_physical_coordinates = True , FWHM = False , max_kernel_width = 32 ) : if image . components == 1 : return _smooth_image_helper ( image , sigma , sigma_in_physical_coordinates , FWHM , max_kernel_width ) else : imagelist = utils . split_channels ( image ) newimages = [ ] for image in imagelist : newimage = _smooth_image_helper ( image , sigma , sigma_in_physical_coordinates , FWHM , max_kernel_width ) newimages . append ( newimage ) return utils . merge_channels ( newimages )", "docstring_tokens": "Smooth an image", "label": 0}, {"idx": "cosqa-train-17131", "doc": "python best way to see if file has changed", "code": "def has_changed (filename):\n    \"\"\"Check if filename has changed since the last check. If this\n    is the first check, assume the file is changed.\"\"\"\n    key = os.path.abspath(filename)\n    mtime = get_mtime(key)\n    if key not in _mtime_cache:\n        _mtime_cache[key] = mtime\n        return True\n    return mtime > _mtime_cache[key]", "code_tokens": "def has_changed ( filename ) : key = os . path . abspath ( filename ) mtime = get_mtime ( key ) if key not in _mtime_cache : _mtime_cache [ key ] = mtime return True return mtime > _mtime_cache [ key ]", "docstring_tokens": "Check if filename has changed since the last check . If this is the first check assume the file is changed .", "label": 1}, {"idx": "cosqa-train-17132", "doc": "how to cast a tensor to float python", "code": "def fcast(value: float) -> TensorLike:\n    \"\"\"Cast to float tensor\"\"\"\n    newvalue = tf.cast(value, FTYPE)\n    if DEVICE == 'gpu':\n        newvalue = newvalue.gpu()  # Why is this needed?  # pragma: no cover\n    return newvalue", "code_tokens": "def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "docstring_tokens": "Cast to float tensor", "label": 0}, {"idx": "cosqa-train-17133", "doc": "python numpy second largest value location", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 0}, {"idx": "cosqa-train-17134", "doc": "get file type from bytes python", "code": "def from_buffer(buffer, mime=False):\n    \"\"\"\n    Accepts a binary string and returns the detected filetype.  Return\n    value is the mimetype if mime=True, otherwise a human readable\n    name.\n\n    >>> magic.from_buffer(open(\"testdata/test.pdf\").read(1024))\n    'PDF document, version 1.2'\n    \"\"\"\n    m = _get_magic_type(mime)\n    return m.from_buffer(buffer)", "code_tokens": "def from_buffer ( buffer , mime = False ) : m = _get_magic_type ( mime ) return m . from_buffer ( buffer )", "docstring_tokens": "Accepts a binary string and returns the detected filetype . Return value is the mimetype if mime = True otherwise a human readable name .", "label": 0}, {"idx": "cosqa-train-17135", "doc": "python str number zero pad left", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 0}, {"idx": "cosqa-train-17136", "doc": "get the longest word using substrings from a string python", "code": "def long_substr(data):\n    \"\"\"Return the longest common substring in a list of strings.\n    \n    Credit: http://stackoverflow.com/questions/2892931/longest-common-substring-from-more-than-two-strings-python\n    \"\"\"\n    substr = ''\n    if len(data) > 1 and len(data[0]) > 0:\n        for i in range(len(data[0])):\n            for j in range(len(data[0])-i+1):\n                if j > len(substr) and all(data[0][i:i+j] in x for x in data):\n                    substr = data[0][i:i+j]\n    elif len(data) == 1:\n        substr = data[0]\n    return substr", "code_tokens": "def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "docstring_tokens": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python", "label": 0}, {"idx": "cosqa-train-17137", "doc": "python iterator has next", "code": "def __next__(self):\n        \"\"\"\n        :return: int\n        \"\"\"\n        self.current += 1\n        if self.current > self.total:\n            raise StopIteration\n        else:\n            return self.iterable[self.current - 1]", "code_tokens": "def __next__ ( self ) : self . current += 1 if self . current > self . total : raise StopIteration else : return self . iterable [ self . current - 1 ]", "docstring_tokens": ": return : int", "label": 0}, {"idx": "cosqa-train-17138", "doc": "python if last day of the month", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 0}, {"idx": "cosqa-train-17139", "doc": "how to get hostname with python", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 1}, {"idx": "cosqa-train-17140", "doc": "python is not negative", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 0}, {"idx": "cosqa-train-17141", "doc": "suppress shell output from python", "code": "def suppress_stdout():\n    \"\"\"\n    Context manager that suppresses stdout.\n\n    Examples:\n        >>> with suppress_stdout():\n        ...     print('Test print')\n\n        >>> print('test')\n        test\n\n    \"\"\"\n    save_stdout = sys.stdout\n    sys.stdout = DevNull()\n    yield\n    sys.stdout = save_stdout", "code_tokens": "def suppress_stdout ( ) : save_stdout = sys . stdout sys . stdout = DevNull ( ) yield sys . stdout = save_stdout", "docstring_tokens": "Context manager that suppresses stdout .", "label": 0}, {"idx": "cosqa-train-17142", "doc": "python return hostname from url", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 1}, {"idx": "cosqa-train-17143", "doc": "does python readlines skip empty line", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-17144", "doc": "get the row with the max value in the series python from agg", "code": "def first_location_of_maximum(x):\n    \"\"\"\n    Returns the first location of the maximum value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    if not isinstance(x, (np.ndarray, pd.Series)):\n        x = np.asarray(x)\n    return np.argmax(x) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def first_location_of_maximum ( x ) : if not isinstance ( x , ( np . ndarray , pd . Series ) ) : x = np . asarray ( x ) return np . argmax ( x ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the first location of the maximum value of x . The position is calculated relatively to the length of x .", "label": 1}, {"idx": "cosqa-train-17145", "doc": "python covert list of string to int", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-17146", "doc": "function name in python must be in lower case", "code": "def method_caller(method_name, *args, **kwargs):\n\t\"\"\"\n\tReturn a function that will call a named method on the\n\ttarget object with optional positional and keyword\n\targuments.\n\n\t>>> lower = method_caller('lower')\n\t>>> lower('MyString')\n\t'mystring'\n\t\"\"\"\n\tdef call_method(target):\n\t\tfunc = getattr(target, method_name)\n\t\treturn func(*args, **kwargs)\n\treturn call_method", "code_tokens": "def method_caller ( method_name , * args , * * kwargs ) : def call_method ( target ) : func = getattr ( target , method_name ) return func ( * args , * * kwargs ) return call_method", "docstring_tokens": "Return a function that will call a named method on the target object with optional positional and keyword arguments .", "label": 0}, {"idx": "cosqa-train-17147", "doc": "mannually set legend python", "code": "def impose_legend_limit(limit=30, axes=\"gca\", **kwargs):\n    \"\"\"\n    This will erase all but, say, 30 of the legend entries and remake the legend.\n    You'll probably have to move it back into your favorite position at this point.\n    \"\"\"\n    if axes==\"gca\": axes = _pylab.gca()\n\n    # make these axes current\n    _pylab.axes(axes)\n\n    # loop over all the lines_pylab.\n    for n in range(0,len(axes.lines)):\n        if n >  limit-1 and not n==len(axes.lines)-1: axes.lines[n].set_label(\"_nolegend_\")\n        if n == limit-1 and not n==len(axes.lines)-1: axes.lines[n].set_label(\"...\")\n\n    _pylab.legend(**kwargs)", "code_tokens": "def impose_legend_limit ( limit = 30 , axes = \"gca\" , * * kwargs ) : if axes == \"gca\" : axes = _pylab . gca ( ) # make these axes current _pylab . axes ( axes ) # loop over all the lines_pylab. for n in range ( 0 , len ( axes . lines ) ) : if n > limit - 1 and not n == len ( axes . lines ) - 1 : axes . lines [ n ] . set_label ( \"_nolegend_\" ) if n == limit - 1 and not n == len ( axes . lines ) - 1 : axes . lines [ n ] . set_label ( \"...\" ) _pylab . legend ( * * kwargs )", "docstring_tokens": "This will erase all but say 30 of the legend entries and remake the legend . You ll probably have to move it back into your favorite position at this point .", "label": 0}, {"idx": "cosqa-train-17148", "doc": "'pythonunbuffered' is not recognized as an internal or external command", "code": "def bytes_hack(buf):\n    \"\"\"\n    Hacky workaround for old installs of the library on systems without python-future that were\n    keeping the 2to3 update from working after auto-update.\n    \"\"\"\n    ub = None\n    if sys.version_info > (3,):\n        ub = buf\n    else:\n        ub = bytes(buf)\n\n    return ub", "code_tokens": "def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "docstring_tokens": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update .", "label": 0}, {"idx": "cosqa-train-17149", "doc": "python split with wild card", "code": "def multi_split(s, split):\n    # type: (S, Iterable[S]) -> List[S]\n    \"\"\"Splits on multiple given separators.\"\"\"\n    for r in split:\n        s = s.replace(r, \"|\")\n    return [i for i in s.split(\"|\") if len(i) > 0]", "code_tokens": "def multi_split ( s , split ) : # type: (S, Iterable[S]) -> List[S] for r in split : s = s . replace ( r , \"|\" ) return [ i for i in s . split ( \"|\" ) if len ( i ) > 0 ]", "docstring_tokens": "Splits on multiple given separators .", "label": 0}, {"idx": "cosqa-train-17150", "doc": "how to tell that value is int or float python", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 0}, {"idx": "cosqa-train-17151", "doc": "how to get the first few rows in python", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 0}, {"idx": "cosqa-train-17152", "doc": "filter dictionary by values python", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-17153", "doc": "apply function over list of python strings", "code": "def replace_in_list(stringlist: Iterable[str],\n                    replacedict: Dict[str, str]) -> List[str]:\n    \"\"\"\n    Returns a list produced by applying :func:`multiple_replace` to every\n    string in ``stringlist``.\n\n    Args:\n        stringlist: list of source strings\n        replacedict: dictionary mapping \"original\" to \"replacement\" strings\n\n    Returns:\n        list of final strings\n\n    \"\"\"\n    newlist = []\n    for fromstring in stringlist:\n        newlist.append(multiple_replace(fromstring, replacedict))\n    return newlist", "code_tokens": "def replace_in_list ( stringlist : Iterable [ str ] , replacedict : Dict [ str , str ] ) -> List [ str ] : newlist = [ ] for fromstring in stringlist : newlist . append ( multiple_replace ( fromstring , replacedict ) ) return newlist", "docstring_tokens": "Returns a list produced by applying : func : multiple_replace to every string in stringlist .", "label": 0}, {"idx": "cosqa-train-17154", "doc": "python list of int to space separated string", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 1}, {"idx": "cosqa-train-17155", "doc": "array of bytes into int python", "code": "def convert_bytes_to_ints(in_bytes, num):\n    \"\"\"Convert a byte array into an integer array. The number of bytes forming an integer\n    is defined by num\n\n    :param in_bytes: the input bytes\n    :param num: the number of bytes per int\n    :return the integer array\"\"\"\n    dt = numpy.dtype('>i' + str(num))\n    return numpy.frombuffer(in_bytes, dt)", "code_tokens": "def convert_bytes_to_ints ( in_bytes , num ) : dt = numpy . dtype ( '>i' + str ( num ) ) return numpy . frombuffer ( in_bytes , dt )", "docstring_tokens": "Convert a byte array into an integer array . The number of bytes forming an integer is defined by num", "label": 0}, {"idx": "cosqa-train-17156", "doc": "print first 10 rows from sql dataset in python", "code": "def fetchallfirstvalues(self, sql: str, *args) -> List[Any]:\n        \"\"\"Executes SQL; returns list of first values of each row.\"\"\"\n        rows = self.fetchall(sql, *args)\n        return [row[0] for row in rows]", "code_tokens": "def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "docstring_tokens": "Executes SQL ; returns list of first values of each row .", "label": 0}, {"idx": "cosqa-train-17157", "doc": "problem in reading las file using liblas and laspy in python", "code": "def read_las(source, closefd=True):\n    \"\"\" Entry point for reading las data in pylas\n\n    Reads the whole file into memory.\n\n    >>> las = read_las(\"pylastests/simple.las\")\n    >>> las.classification\n    array([1, 1, 1, ..., 1, 1, 1], dtype=uint8)\n\n    Parameters\n    ----------\n    source : str or io.BytesIO\n        The source to read data from\n\n    closefd: bool\n            if True and the source is a stream, the function will close it\n            after it is done reading\n\n\n    Returns\n    -------\n    pylas.lasdatas.base.LasBase\n        The object you can interact with to get access to the LAS points & VLRs\n    \"\"\"\n    with open_las(source, closefd=closefd) as reader:\n        return reader.read()", "code_tokens": "def read_las ( source , closefd = True ) : with open_las ( source , closefd = closefd ) as reader : return reader . read ( )", "docstring_tokens": "Entry point for reading las data in pylas", "label": 0}, {"idx": "cosqa-train-17158", "doc": "python different behavior if python2 or 3", "code": "def bytes_hack(buf):\n    \"\"\"\n    Hacky workaround for old installs of the library on systems without python-future that were\n    keeping the 2to3 update from working after auto-update.\n    \"\"\"\n    ub = None\n    if sys.version_info > (3,):\n        ub = buf\n    else:\n        ub = bytes(buf)\n\n    return ub", "code_tokens": "def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "docstring_tokens": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update .", "label": 0}, {"idx": "cosqa-train-17159", "doc": "python reduce the number of decimals in a float", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 0}, {"idx": "cosqa-train-17160", "doc": "write a function that flattens lists python", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 1}, {"idx": "cosqa-train-17161", "doc": "remove columns from a data frame in python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 1}, {"idx": "cosqa-train-17162", "doc": "python win32api move window", "code": "def MoveWindow(handle: int, x: int, y: int, width: int, height: int, repaint: int = 1) -> bool:\n    \"\"\"\n    MoveWindow from Win32.\n    handle: int, the handle of a native window.\n    x: int.\n    y: int.\n    width: int.\n    height: int.\n    repaint: int, use 1 or 0.\n    Return bool, True if succeed otherwise False.\n    \"\"\"\n    return bool(ctypes.windll.user32.MoveWindow(ctypes.c_void_p(handle), x, y, width, height, repaint))", "code_tokens": "def MoveWindow ( handle : int , x : int , y : int , width : int , height : int , repaint : int = 1 ) -> bool : return bool ( ctypes . windll . user32 . MoveWindow ( ctypes . c_void_p ( handle ) , x , y , width , height , repaint ) )", "docstring_tokens": "MoveWindow from Win32 . handle : int the handle of a native window . x : int . y : int . width : int . height : int . repaint : int use 1 or 0 . Return bool True if succeed otherwise False .", "label": 1}, {"idx": "cosqa-train-17163", "doc": "finding if a file has a line python", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 0}, {"idx": "cosqa-train-17164", "doc": "python split string with delimters into tuple", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 0}, {"idx": "cosqa-train-17165", "doc": "cast to bytestring python", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 1}, {"idx": "cosqa-train-17166", "doc": "python list filter all the empty element", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 1}, {"idx": "cosqa-train-17167", "doc": "python remove duplicate list not change", "code": "def de_duplicate(items):\n    \"\"\"Remove any duplicate item, preserving order\n\n    >>> de_duplicate([1, 2, 1, 2])\n    [1, 2]\n    \"\"\"\n    result = []\n    for item in items:\n        if item not in result:\n            result.append(item)\n    return result", "code_tokens": "def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "docstring_tokens": "Remove any duplicate item preserving order", "label": 0}, {"idx": "cosqa-train-17168", "doc": "backslash json python string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 1}, {"idx": "cosqa-train-17169", "doc": "python how to check if array row is 0", "code": "def non_zero_row(arr):\n    \"\"\"\n        0.  Empty row returns False.\n\n            >>> arr = array([])\n            >>> non_zero_row(arr)\n\n            False\n\n        1.  Row with a zero returns False.\n\n            >>> arr = array([1, 4, 3, 0, 5, -1, -2])\n            >>> non_zero_row(arr)\n\n            False\n        2.  Row with no zeros returns True.\n\n            >>> arr = array([-1, -0.1, 0.001, 2])\n            >>> non_zero_row(arr)\n\n            True\n\n        :param arr: array\n        :type arr: numpy array\n        :return empty: If row is completely free of zeros\n        :rtype empty: bool\n    \"\"\"\n\n    if len(arr) == 0:\n        return False\n\n    for item in arr:\n        if item == 0:\n            return False\n\n    return True", "code_tokens": "def non_zero_row ( arr ) : if len ( arr ) == 0 : return False for item in arr : if item == 0 : return False return True", "docstring_tokens": "0 . Empty row returns False .", "label": 1}, {"idx": "cosqa-train-17170", "doc": "define array python dyanmic boolean values", "code": "def unpackbools(integers, dtype='L'):\n    \"\"\"Yield booleans unpacking integers of dtype bit-length.\n\n    >>> list(unpackbools([42], 'B'))\n    [False, True, False, True, False, True, False, False]\n    \"\"\"\n    atoms = ATOMS[dtype]\n\n    for chunk in integers:\n        for a in atoms:\n            yield not not chunk & a", "code_tokens": "def unpackbools ( integers , dtype = 'L' ) : atoms = ATOMS [ dtype ] for chunk in integers : for a in atoms : yield not not chunk & a", "docstring_tokens": "Yield booleans unpacking integers of dtype bit - length .", "label": 0}, {"idx": "cosqa-train-17171", "doc": "check game won hangman python", "code": "def is_done(self):\n        \"\"\"True if the last two moves were Pass or if the position is at a move\n        greater than the max depth.\"\"\"\n        return self.position.is_game_over() or self.position.n >= FLAGS.max_game_length", "code_tokens": "def is_done ( self ) : return self . position . is_game_over ( ) or self . position . n >= FLAGS . max_game_length", "docstring_tokens": "True if the last two moves were Pass or if the position is at a move greater than the max depth .", "label": 1}, {"idx": "cosqa-train-17172", "doc": "how to iterate through files in documents in python", "code": "def _generate(self):\n        \"\"\"Parses a file or directory of files into a set of ``Document`` objects.\"\"\"\n        doc_count = 0\n        for fp in self.all_files:\n            for doc in self._get_docs_for_path(fp):\n                yield doc\n                doc_count += 1\n                if doc_count >= self.max_docs:\n                    return", "code_tokens": "def _generate ( self ) : doc_count = 0 for fp in self . all_files : for doc in self . _get_docs_for_path ( fp ) : yield doc doc_count += 1 if doc_count >= self . max_docs : return", "docstring_tokens": "Parses a file or directory of files into a set of Document objects .", "label": 0}, {"idx": "cosqa-train-17173", "doc": "spell check handling in python", "code": "def call_spellchecker(cmd, input_text=None, encoding=None):\n    \"\"\"Call spell checker with arguments.\"\"\"\n\n    process = get_process(cmd)\n\n    # A buffer has been provided\n    if input_text is not None:\n        for line in input_text.splitlines():\n            # Hunspell truncates lines at `0x1fff` (at least on Windows this has been observed)\n            # Avoid truncation by chunking the line on white space and inserting a new line to break it.\n            offset = 0\n            end = len(line)\n            while True:\n                chunk_end = offset + 0x1fff\n                m = None if chunk_end >= end else RE_LAST_SPACE_IN_CHUNK.search(line, offset, chunk_end)\n                if m:\n                    chunk_end = m.start(1)\n                    chunk = line[offset:m.start(1)]\n                    offset = m.end(1)\n                else:\n                    chunk = line[offset:chunk_end]\n                    offset = chunk_end\n                # Avoid wasted calls to empty strings\n                if chunk and not chunk.isspace():\n                    process.stdin.write(chunk + b'\\n')\n                if offset >= end:\n                    break\n\n    return get_process_output(process, encoding)", "code_tokens": "def call_spellchecker ( cmd , input_text = None , encoding = None ) : process = get_process ( cmd ) # A buffer has been provided if input_text is not None : for line in input_text . splitlines ( ) : # Hunspell truncates lines at `0x1fff` (at least on Windows this has been observed) # Avoid truncation by chunking the line on white space and inserting a new line to break it. offset = 0 end = len ( line ) while True : chunk_end = offset + 0x1fff m = None if chunk_end >= end else RE_LAST_SPACE_IN_CHUNK . search ( line , offset , chunk_end ) if m : chunk_end = m . start ( 1 ) chunk = line [ offset : m . start ( 1 ) ] offset = m . end ( 1 ) else : chunk = line [ offset : chunk_end ] offset = chunk_end # Avoid wasted calls to empty strings if chunk and not chunk . isspace ( ) : process . stdin . write ( chunk + b'\\n' ) if offset >= end : break return get_process_output ( process , encoding )", "docstring_tokens": "Call spell checker with arguments .", "label": 1}, {"idx": "cosqa-train-17174", "doc": "linear regression model in python tensorflow", "code": "def multivariate_normal_tril(x,\n                             dims,\n                             layer_fn=tf.compat.v1.layers.dense,\n                             loc_fn=lambda x: x,\n                             scale_fn=tril_with_diag_softplus_and_shift,\n                             name=None):\n  \"\"\"Constructs a trainable `tfd.MultivariateNormalTriL` distribution.\n\n  This function creates a MultivariateNormal (MVN) with lower-triangular scale\n  matrix. By default the MVN is parameterized via affine transformation of input\n  tensor `x`. Using default args, this function is mathematically equivalent to:\n\n  ```none\n  Y = MVN(loc=matmul(W, x) + b,\n          scale_tril=f(reshape_tril(matmul(M, x) + c)))\n\n  where,\n    W in R^[d, n]\n    M in R^[d*(d+1)/2, n]\n    b in R^d\n    c in R^d\n    f(S) = set_diag(S, softplus(matrix_diag_part(S)) + 1e-5)\n  ```\n\n  Observe that `f` makes the diagonal of the triangular-lower scale matrix be\n  positive and no smaller than `1e-5`.\n\n  #### Examples\n\n  ```python\n  # This example fits a multilinear regression loss.\n  import tensorflow as tf\n  import tensorflow_probability as tfp\n\n  # Create fictitious training data.\n  dtype = np.float32\n  n = 3000    # number of samples\n  x_size = 4  # size of single x\n  y_size = 2  # size of single y\n  def make_training_data():\n    np.random.seed(142)\n    x = np.random.randn(n, x_size).astype(dtype)\n    w = np.random.randn(x_size, y_size).astype(dtype)\n    b = np.random.randn(1, y_size).astype(dtype)\n    true_mean = np.tensordot(x, w, axes=[[-1], [0]]) + b\n    noise = np.random.randn(n, y_size).astype(dtype)\n    y = true_mean + noise\n    return y, x\n  y, x = make_training_data()\n\n  # Build TF graph for fitting MVNTriL maximum likelihood estimator.\n  mvn = tfp.trainable_distributions.multivariate_normal_tril(x, dims=y_size)\n  loss = -tf.reduce_mean(mvn.log_prob(y))\n  train_op = tf.train.AdamOptimizer(learning_rate=2.**-3).minimize(loss)\n  mse = tf.reduce_mean(tf.squared_difference(y, mvn.mean()))\n  init_op = tf.global_variables_initializer()\n\n  # Run graph 1000 times.\n  num_steps = 1000\n  loss_ = np.zeros(num_steps)   # Style: `_` to indicate sess.run result.\n  mse_ = np.zeros(num_steps)\n  with tf.Session() as sess:\n    sess.run(init_op)\n    for it in xrange(loss_.size):\n      _, loss_[it], mse_[it] = sess.run([train_op, loss, mse])\n      if it % 200 == 0 or it == loss_.size - 1:\n        print(\"iteration:{}  loss:{}  mse:{}\".format(it, loss_[it], mse_[it]))\n\n  # ==> iteration:0    loss:38.2020797729  mse:4.17175960541\n  #     iteration:200  loss:2.90179634094  mse:0.990987896919\n  #     iteration:400  loss:2.82727336884  mse:0.990926623344\n  #     iteration:600  loss:2.82726788521  mse:0.990926682949\n  #     iteration:800  loss:2.82726788521  mse:0.990926682949\n  #     iteration:999  loss:2.82726788521  mse:0.990926682949\n  ```\n\n  Args:\n    x: `Tensor` with floating type. Must have statically defined rank and\n      statically known right-most dimension.\n    dims: Scalar, `int`, `Tensor` indicated the MVN event size, i.e., the\n      created MVN will be distribution over length-`dims` vectors.\n    layer_fn: Python `callable` which takes input `x` and `int` scalar `d` and\n      returns a transformation of `x` with shape\n      `tf.concat([tf.shape(x)[:-1], [d]], axis=0)`.\n      Default value: `tf.layers.dense`.\n    loc_fn: Python `callable` which transforms the `loc` parameter. Takes a\n      (batch of) length-`dims` vectors and returns a `Tensor` of same shape and\n      `dtype`.\n      Default value: `lambda x: x`.\n    scale_fn: Python `callable` which transforms the `scale` parameters. Takes a\n      (batch of) length-`dims * (dims + 1) / 2` vectors and returns a\n      lower-triangular `Tensor` of same batch shape with rightmost dimensions\n      having shape `[dims, dims]`.\n      Default value: `tril_with_diag_softplus_and_shift`.\n    name: A `name_scope` name for operations created by this function.\n      Default value: `None` (i.e., \"multivariate_normal_tril\").\n\n  Returns:\n    mvntril: An instance of `tfd.MultivariateNormalTriL`.\n  \"\"\"\n  with tf.compat.v1.name_scope(name, 'multivariate_normal_tril', [x, dims]):\n    x = tf.convert_to_tensor(value=x, name='x')\n    x = layer_fn(x, dims + dims * (dims + 1) // 2)\n    return tfd.MultivariateNormalTriL(\n        loc=loc_fn(x[..., :dims]),\n        scale_tril=scale_fn(x[..., dims:]))", "code_tokens": "def multivariate_normal_tril ( x , dims , layer_fn = tf . compat . v1 . layers . dense , loc_fn = lambda x : x , scale_fn = tril_with_diag_softplus_and_shift , name = None ) : with tf . compat . v1 . name_scope ( name , 'multivariate_normal_tril' , [ x , dims ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) x = layer_fn ( x , dims + dims * ( dims + 1 ) // 2 ) return tfd . MultivariateNormalTriL ( loc = loc_fn ( x [ ... , : dims ] ) , scale_tril = scale_fn ( x [ ... , dims : ] ) )", "docstring_tokens": "Constructs a trainable tfd . MultivariateNormalTriL distribution .", "label": 0}, {"idx": "cosqa-train-17175", "doc": "python generate random binary number with certain number of bits", "code": "def binary(length):\n    \"\"\"\n        returns a a random string that represent a binary representation\n\n    :param length: number of bits\n    \"\"\"\n    num = randint(1, 999999)\n    mask = '0' * length\n    return (mask + ''.join([str(num >> i & 1) for i in range(7, -1, -1)]))[-length:]", "code_tokens": "def binary ( length ) : num = randint ( 1 , 999999 ) mask = '0' * length return ( mask + '' . join ( [ str ( num >> i & 1 ) for i in range ( 7 , - 1 , - 1 ) ] ) ) [ - length : ]", "docstring_tokens": "returns a a random string that represent a binary representation", "label": 1}, {"idx": "cosqa-train-17176", "doc": "average multiple 2d arrays python", "code": "def average_arrays(arrays: List[mx.nd.NDArray]) -> mx.nd.NDArray:\n    \"\"\"\n    Take a list of arrays of the same shape and take the element wise average.\n\n    :param arrays: A list of NDArrays with the same shape that will be averaged.\n    :return: The average of the NDArrays in the same context as arrays[0].\n    \"\"\"\n    if not arrays:\n        raise ValueError(\"arrays is empty.\")\n    if len(arrays) == 1:\n        return arrays[0]\n    check_condition(all(arrays[0].shape == a.shape for a in arrays), \"nd array shapes do not match\")\n    return mx.nd.add_n(*arrays) / len(arrays)", "code_tokens": "def average_arrays ( arrays : List [ mx . nd . NDArray ] ) -> mx . nd . NDArray : if not arrays : raise ValueError ( \"arrays is empty.\" ) if len ( arrays ) == 1 : return arrays [ 0 ] check_condition ( all ( arrays [ 0 ] . shape == a . shape for a in arrays ) , \"nd array shapes do not match\" ) return mx . nd . add_n ( * arrays ) / len ( arrays )", "docstring_tokens": "Take a list of arrays of the same shape and take the element wise average .", "label": 0}, {"idx": "cosqa-train-17177", "doc": "python rest requests delete", "code": "def delete(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP DELETE operation to API endpoint.\"\"\"\n\n        return self._request('DELETE', endpoint, **kwargs)", "code_tokens": "def delete ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'DELETE' , endpoint , * * kwargs )", "docstring_tokens": "HTTP DELETE operation to API endpoint .", "label": 1}, {"idx": "cosqa-train-17178", "doc": "how to check if the process is running or not in unix using python", "code": "def is_running(process_id: int) -> bool:\n    \"\"\"\n    Uses the Unix ``ps`` program to see if a process is running.\n    \"\"\"\n    pstr = str(process_id)\n    encoding = sys.getdefaultencoding()\n    s = subprocess.Popen([\"ps\", \"-p\", pstr], stdout=subprocess.PIPE)\n    for line in s.stdout:\n        strline = line.decode(encoding)\n        if pstr in strline:\n            return True\n    return False", "code_tokens": "def is_running ( process_id : int ) -> bool : pstr = str ( process_id ) encoding = sys . getdefaultencoding ( ) s = subprocess . Popen ( [ \"ps\" , \"-p\" , pstr ] , stdout = subprocess . PIPE ) for line in s . stdout : strline = line . decode ( encoding ) if pstr in strline : return True return False", "docstring_tokens": "Uses the Unix ps program to see if a process is running .", "label": 1}, {"idx": "cosqa-train-17179", "doc": "last item on a list in python", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 0}, {"idx": "cosqa-train-17180", "doc": "transfer string to int in python", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-17181", "doc": "cast python object to string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 0}, {"idx": "cosqa-train-17182", "doc": "python3 how to tell if a set is a subset of another set", "code": "def issubset(self, other):\n        \"\"\"\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        \"\"\"\n        if len(self) > len(other):  # Fast check for obvious cases\n            return False\n        return all(item in other for item in self)", "code_tokens": "def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "docstring_tokens": "Report whether another set contains this set .", "label": 0}, {"idx": "cosqa-train-17183", "doc": "python celery dynamic rate limit", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 1}, {"idx": "cosqa-train-17184", "doc": "how to tell what encoding is used on a bytes object python3", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 0}, {"idx": "cosqa-train-17185", "doc": "python delimited string to list", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 0}, {"idx": "cosqa-train-17186", "doc": "concatenate list in python with no spaces", "code": "def list_to_str(lst):\n    \"\"\"\n    Turn a list into a comma- and/or and-separated string.\n\n    Parameters\n    ----------\n    lst : :obj:`list`\n        A list of strings to join into a single string.\n\n    Returns\n    -------\n    str_ : :obj:`str`\n        A string with commas and/or ands separating th elements from ``lst``.\n\n    \"\"\"\n    if len(lst) == 1:\n        str_ = lst[0]\n    elif len(lst) == 2:\n        str_ = ' and '.join(lst)\n    elif len(lst) > 2:\n        str_ = ', '.join(lst[:-1])\n        str_ += ', and {0}'.format(lst[-1])\n    else:\n        raise ValueError('List of length 0 provided.')\n    return str_", "code_tokens": "def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "docstring_tokens": "Turn a list into a comma - and / or and - separated string .", "label": 1}, {"idx": "cosqa-train-17187", "doc": "python check if float is not 0", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 1}, {"idx": "cosqa-train-17188", "doc": "flatten a dictionary python", "code": "def flatten_multidict(multidict):\n    \"\"\"Return flattened dictionary from ``MultiDict``.\"\"\"\n    return dict([(key, value if len(value) > 1 else value[0])\n                 for (key, value) in multidict.iterlists()])", "code_tokens": "def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "docstring_tokens": "Return flattened dictionary from MultiDict .", "label": 1}, {"idx": "cosqa-train-17189", "doc": "python remove empty str", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 1}, {"idx": "cosqa-train-17190", "doc": "truncate floats to no decimals python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 0}, {"idx": "cosqa-train-17191", "doc": "python add a number to a metric", "code": "def incr(name, value=1, rate=1, tags=None):\n    \"\"\"Increment a metric by value.\n\n    >>> import statsdecor\n    >>> statsdecor.incr('my.metric')\n    \"\"\"\n    client().incr(name, value, rate, tags)", "code_tokens": "def incr ( name , value = 1 , rate = 1 , tags = None ) : client ( ) . incr ( name , value , rate , tags )", "docstring_tokens": "Increment a metric by value .", "label": 1}, {"idx": "cosqa-train-17192", "doc": "how to check if a file is empty or not in python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 0}, {"idx": "cosqa-train-17193", "doc": "python check name for illegal characters", "code": "def name_is_valid(name):\n    \"\"\"Return True if the dataset name is valid.\n\n    The name can only be 80 characters long.\n    Valid characters: Alpha numeric characters [0-9a-zA-Z]\n    Valid special characters: - _ .\n    \"\"\"\n    # The name can only be 80 characters long.\n    if len(name) > MAX_NAME_LENGTH:\n        return False\n    return bool(NAME_VALID_CHARS_REGEX.match(name))", "code_tokens": "def name_is_valid ( name ) : # The name can only be 80 characters long. if len ( name ) > MAX_NAME_LENGTH : return False return bool ( NAME_VALID_CHARS_REGEX . match ( name ) )", "docstring_tokens": "Return True if the dataset name is valid .", "label": 0}, {"idx": "cosqa-train-17194", "doc": "python list comprehension flatten list", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 0}, {"idx": "cosqa-train-17195", "doc": "python async method \"self is not defined\"", "code": "async def async_run(self) -> None:\n        \"\"\"\n        Asynchronously run the worker, does not close connections. Useful when testing.\n        \"\"\"\n        self.main_task = self.loop.create_task(self.main())\n        await self.main_task", "code_tokens": "async def async_run ( self ) -> None : self . main_task = self . loop . create_task ( self . main ( ) ) await self . main_task", "docstring_tokens": "Asynchronously run the worker does not close connections . Useful when testing .", "label": 1}, {"idx": "cosqa-train-17196", "doc": "python check if file update to date", "code": "def file_uptodate(fname, cmp_fname):\n    \"\"\"Check if a file exists, is non-empty and is more recent than cmp_fname.\n    \"\"\"\n    try:\n        return (file_exists(fname) and file_exists(cmp_fname) and\n                getmtime(fname) >= getmtime(cmp_fname))\n    except OSError:\n        return False", "code_tokens": "def file_uptodate ( fname , cmp_fname ) : try : return ( file_exists ( fname ) and file_exists ( cmp_fname ) and getmtime ( fname ) >= getmtime ( cmp_fname ) ) except OSError : return False", "docstring_tokens": "Check if a file exists is non - empty and is more recent than cmp_fname .", "label": 0}, {"idx": "cosqa-train-17197", "doc": "python read whitespace until first non empty line", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-17198", "doc": "python datetime get last day in a month", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 1}, {"idx": "cosqa-train-17199", "doc": "python matrix multiplication symbol", "code": "def __rmatmul__(self, other):\n        \"\"\"\n        Matrix multiplication using binary `@` operator in Python>=3.5.\n        \"\"\"\n        return self.T.dot(np.transpose(other)).T", "code_tokens": "def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T", "docstring_tokens": "Matrix multiplication using binary", "label": 1}, {"idx": "cosqa-train-17200", "doc": "python check if file is not empty", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 1}, {"idx": "cosqa-train-17201", "doc": "determine string encoding python 2", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 0}, {"idx": "cosqa-train-17202", "doc": "python parsing wordnet synsets", "code": "def has_synset(word: str) -> list:\n    \"\"\"\" Returns a list of synsets of a word after lemmatization. \"\"\"\n\n    return wn.synsets(lemmatize(word, neverstem=True))", "code_tokens": "def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "docstring_tokens": "Returns a list of synsets of a word after lemmatization .", "label": 0}, {"idx": "cosqa-train-17203", "doc": "python read file ofset", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 0}, {"idx": "cosqa-train-17204", "doc": "python csv replacing nulls with empty string", "code": "def tsv_escape(x: Any) -> str:\n    \"\"\"\n    Escape data for tab-separated value (TSV) format.\n    \"\"\"\n    if x is None:\n        return \"\"\n    x = str(x)\n    return x.replace(\"\\t\", \"\\\\t\").replace(\"\\n\", \"\\\\n\")", "code_tokens": "def tsv_escape ( x : Any ) -> str : if x is None : return \"\" x = str ( x ) return x . replace ( \"\\t\" , \"\\\\t\" ) . replace ( \"\\n\" , \"\\\\n\" )", "docstring_tokens": "Escape data for tab - separated value ( TSV ) format .", "label": 1}, {"idx": "cosqa-train-17205", "doc": "commands to detect if a key is being pressed in python 3", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 0}, {"idx": "cosqa-train-17206", "doc": "filter empty string python", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 0}, {"idx": "cosqa-train-17207", "doc": "python 3 get list of windows drives", "code": "def get_system_drives():\n    \"\"\"\n    Get the available drive names on the system. Always returns a list.\n    \"\"\"\n    drives = []\n    if os.name == 'nt':\n        import ctypes\n        bitmask = ctypes.windll.kernel32.GetLogicalDrives()\n        letter = ord('A')\n        while bitmask > 0:\n            if bitmask & 1:\n                name = chr(letter) + ':' + os.sep\n                if os.path.isdir(name):\n                    drives.append(name)\n            bitmask >>= 1\n            letter += 1\n    else:\n        current_drive = get_drive(os.getcwd())\n        if current_drive:\n            drive = current_drive\n        else:\n            drive = os.sep\n        drives.append(drive)\n\n    return drives", "code_tokens": "def get_system_drives ( ) : drives = [ ] if os . name == 'nt' : import ctypes bitmask = ctypes . windll . kernel32 . GetLogicalDrives ( ) letter = ord ( 'A' ) while bitmask > 0 : if bitmask & 1 : name = chr ( letter ) + ':' + os . sep if os . path . isdir ( name ) : drives . append ( name ) bitmask >>= 1 letter += 1 else : current_drive = get_drive ( os . getcwd ( ) ) if current_drive : drive = current_drive else : drive = os . sep drives . append ( drive ) return drives", "docstring_tokens": "Get the available drive names on the system . Always returns a list .", "label": 0}, {"idx": "cosqa-train-17208", "doc": "area of a polygon python", "code": "def area (self):\n    \"\"\"area() -> number\n\n    Returns the area of this Polygon.\n    \"\"\"\n    area = 0.0\n    \n    for segment in self.segments():\n      area += ((segment.p.x * segment.q.y) - (segment.q.x * segment.p.y))/2\n\n    return area", "code_tokens": "def area ( self ) : area = 0.0 for segment in self . segments ( ) : area += ( ( segment . p . x * segment . q . y ) - ( segment . q . x * segment . p . y ) ) / 2 return area", "docstring_tokens": "area () - > number", "label": 1}, {"idx": "cosqa-train-17209", "doc": "how to implement rate limit python", "code": "def is_rate_limited(response):\n        \"\"\"\n        Checks if the response has been rate limited by CARTO APIs\n\n        :param response: The response rate limited by CARTO APIs\n        :type response: requests.models.Response class\n\n        :return: Boolean\n        \"\"\"\n        if (response.status_code == codes.too_many_requests and 'Retry-After' in response.headers and\n                int(response.headers['Retry-After']) >= 0):\n            return True\n\n        return False", "code_tokens": "def is_rate_limited ( response ) : if ( response . status_code == codes . too_many_requests and 'Retry-After' in response . headers and int ( response . headers [ 'Retry-After' ] ) >= 0 ) : return True return False", "docstring_tokens": "Checks if the response has been rate limited by CARTO APIs", "label": 1}, {"idx": "cosqa-train-17210", "doc": "bytes to an array of int python", "code": "def convert_bytes_to_ints(in_bytes, num):\n    \"\"\"Convert a byte array into an integer array. The number of bytes forming an integer\n    is defined by num\n\n    :param in_bytes: the input bytes\n    :param num: the number of bytes per int\n    :return the integer array\"\"\"\n    dt = numpy.dtype('>i' + str(num))\n    return numpy.frombuffer(in_bytes, dt)", "code_tokens": "def convert_bytes_to_ints ( in_bytes , num ) : dt = numpy . dtype ( '>i' + str ( num ) ) return numpy . frombuffer ( in_bytes , dt )", "docstring_tokens": "Convert a byte array into an integer array . The number of bytes forming an integer is defined by num", "label": 0}, {"idx": "cosqa-train-17211", "doc": "minimum value location python", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 1}, {"idx": "cosqa-train-17212", "doc": "how to rotate list in python", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 0}, {"idx": "cosqa-train-17213", "doc": "python 3 shortcut if", "code": "def bytes_hack(buf):\n    \"\"\"\n    Hacky workaround for old installs of the library on systems without python-future that were\n    keeping the 2to3 update from working after auto-update.\n    \"\"\"\n    ub = None\n    if sys.version_info > (3,):\n        ub = buf\n    else:\n        ub = bytes(buf)\n\n    return ub", "code_tokens": "def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "docstring_tokens": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update .", "label": 0}, {"idx": "cosqa-train-17214", "doc": "is it a float or an integer python", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 1}, {"idx": "cosqa-train-17215", "doc": "python how to split sentence by multiple delimiters", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 0}, {"idx": "cosqa-train-17216", "doc": "python filter non empty from list", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 0}, {"idx": "cosqa-train-17217", "doc": "changing dtype in python to int", "code": "def to_int64(a):\n    \"\"\"Return view of the recarray with all int32 cast to int64.\"\"\"\n    # build new dtype and replace i4 --> i8\n    def promote_i4(typestr):\n        if typestr[1:] == 'i4':\n            typestr = typestr[0]+'i8'\n        return typestr\n\n    dtype = [(name, promote_i4(typestr)) for name,typestr in a.dtype.descr]\n    return a.astype(dtype)", "code_tokens": "def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )", "docstring_tokens": "Return view of the recarray with all int32 cast to int64 .", "label": 1}, {"idx": "cosqa-train-17218", "doc": "python asyncio behave different in linux window", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 0}, {"idx": "cosqa-train-17219", "doc": "how to index with duplicate indexs python", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 0}, {"idx": "cosqa-train-17220", "doc": "python check if input in correct date format", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 0}, {"idx": "cosqa-train-17221", "doc": "python elementtree delete namespace", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 1}, {"idx": "cosqa-train-17222", "doc": "python dialog choose directory", "code": "def browse_dialog_dir():\n    \"\"\"\n    Open up a GUI browse dialog window and let to user pick a target directory.\n    :return str: Target directory path\n    \"\"\"\n    _go_to_package()\n    logger_directory.info(\"enter browse_dialog\")\n    _path_bytes = subprocess.check_output(['python', 'gui_dir_browse.py'], shell=False)\n    _path = _fix_path_bytes(_path_bytes, file=False)\n    if len(_path) >= 1:\n        _path = _path[0]\n    else:\n        _path = \"\"\n    logger_directory.info(\"chosen path: {}\".format(_path))\n    logger_directory.info(\"exit browse_dialog\")\n    return _path", "code_tokens": "def browse_dialog_dir ( ) : _go_to_package ( ) logger_directory . info ( \"enter browse_dialog\" ) _path_bytes = subprocess . check_output ( [ 'python' , 'gui_dir_browse.py' ] , shell = False ) _path = _fix_path_bytes ( _path_bytes , file = False ) if len ( _path ) >= 1 : _path = _path [ 0 ] else : _path = \"\" logger_directory . info ( \"chosen path: {}\" . format ( _path ) ) logger_directory . info ( \"exit browse_dialog\" ) return _path", "docstring_tokens": "Open up a GUI browse dialog window and let to user pick a target directory . : return str : Target directory path", "label": 1}, {"idx": "cosqa-train-17223", "doc": "how to print timezone in python3", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-17224", "doc": "python binary data in 'decimal from signed 2's complement'", "code": "def read32(bytestream):\n  \"\"\"Read 4 bytes from bytestream as an unsigned 32-bit integer.\"\"\"\n  dt = np.dtype(np.uint32).newbyteorder('>')\n  return np.frombuffer(bytestream.read(4), dtype=dt)[0]", "code_tokens": "def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "docstring_tokens": "Read 4 bytes from bytestream as an unsigned 32 - bit integer .", "label": 0}, {"idx": "cosqa-train-17225", "doc": "running shell command from a container in python", "code": "def interact(self, container: Container) -> None:\n        \"\"\"\n        Connects to the PTY (pseudo-TTY) for a given container.\n        Blocks until the user exits the PTY.\n        \"\"\"\n        cmd = \"/bin/bash -c 'source /.environment && /bin/bash'\"\n        cmd = \"docker exec -it {} {}\".format(container.id, cmd)\n        subprocess.call(cmd, shell=True)", "code_tokens": "def interact ( self , container : Container ) -> None : cmd = \"/bin/bash -c 'source /.environment && /bin/bash'\" cmd = \"docker exec -it {} {}\" . format ( container . id , cmd ) subprocess . call ( cmd , shell = True )", "docstring_tokens": "Connects to the PTY ( pseudo - TTY ) for a given container . Blocks until the user exits the PTY .", "label": 1}, {"idx": "cosqa-train-17226", "doc": "python using underscore as variable", "code": "def lower_camel_case_from_underscores(string):\n    \"\"\"generate a lower-cased camelCase string from an underscore_string.\n    For example: my_variable_name -> myVariableName\"\"\"\n    components = string.split('_')\n    string = components[0]\n    for component in components[1:]:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName", "label": 0}, {"idx": "cosqa-train-17227", "doc": "python detect memory usage in subprocess", "code": "def psutil_phymem_usage():\n    \"\"\"\n    Return physical memory usage (float)\n    Requires the cross-platform psutil (>=v0.3) library\n    (https://github.com/giampaolo/psutil)\n    \"\"\"\n    import psutil\n    # This is needed to avoid a deprecation warning error with\n    # newer psutil versions\n    try:\n        percent = psutil.virtual_memory().percent\n    except:\n        percent = psutil.phymem_usage().percent\n    return percent", "code_tokens": "def psutil_phymem_usage ( ) : import psutil # This is needed to avoid a deprecation warning error with\n # newer psutil versions\n try : percent = psutil . virtual_memory ( ) . percent except : percent = psutil . phymem_usage ( ) . percent return percent", "docstring_tokens": "Return physical memory usage ( float ) Requires the cross - platform psutil ( > = v0 . 3 ) library ( https : // github . com / giampaolo / psutil )", "label": 0}, {"idx": "cosqa-train-17228", "doc": "list of list in python access last eleemnt of each list", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 1}, {"idx": "cosqa-train-17229", "doc": "how to check if input is a natural number in python", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 0}, {"idx": "cosqa-train-17230", "doc": "python check if config file exists", "code": "def file_exists(self) -> bool:\n        \"\"\" Check if the settings file exists or not \"\"\"\n        cfg_path = self.file_path\n        assert cfg_path\n\n        return path.isfile(cfg_path)", "code_tokens": "def file_exists ( self ) -> bool : cfg_path = self . file_path assert cfg_path return path . isfile ( cfg_path )", "docstring_tokens": "Check if the settings file exists or not", "label": 0}, {"idx": "cosqa-train-17231", "doc": "python how large can an object be", "code": "def _short_repr(obj):\n  \"\"\"Helper function returns a truncated repr() of an object.\"\"\"\n  stringified = pprint.saferepr(obj)\n  if len(stringified) > 200:\n    return '%s... (%d bytes)' % (stringified[:200], len(stringified))\n  return stringified", "code_tokens": "def _short_repr ( obj ) : stringified = pprint . saferepr ( obj ) if len ( stringified ) > 200 : return '%s... (%d bytes)' % ( stringified [ : 200 ] , len ( stringified ) ) return stringified", "docstring_tokens": "Helper function returns a truncated repr () of an object .", "label": 0}, {"idx": "cosqa-train-17232", "doc": "python lock requests hang", "code": "def release_lock():\n    \"\"\"Release lock on compilation directory.\"\"\"\n    get_lock.n_lock -= 1\n    assert get_lock.n_lock >= 0\n    # Only really release lock once all lock requests have ended.\n    if get_lock.lock_is_enabled and get_lock.n_lock == 0:\n        get_lock.start_time = None\n        get_lock.unlocker.unlock()", "code_tokens": "def release_lock ( ) : get_lock . n_lock -= 1 assert get_lock . n_lock >= 0 # Only really release lock once all lock requests have ended. if get_lock . lock_is_enabled and get_lock . n_lock == 0 : get_lock . start_time = None get_lock . unlocker . unlock ( )", "docstring_tokens": "Release lock on compilation directory .", "label": 0}, {"idx": "cosqa-train-17233", "doc": "delete an element from a set python", "code": "def remove_once(gset, elem):\n    \"\"\"Remove the element from a set, lists or dict.\n    \n        >>> L = [\"Lucy\"]; S = set([\"Sky\"]); D = { \"Diamonds\": True };\n        >>> remove_once(L, \"Lucy\"); remove_once(S, \"Sky\"); remove_once(D, \"Diamonds\");\n        >>> print L, S, D\n        [] set([]) {}\n\n    Returns the element if it was removed. Raises one of the exceptions in \n    :obj:`RemoveError` otherwise.\n    \"\"\"\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "code_tokens": "def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "docstring_tokens": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}", "label": 1}, {"idx": "cosqa-train-17234", "doc": "how to move grid to back of plot python", "code": "def prevPlot(self):\n        \"\"\"Moves the displayed plot to the previous one\"\"\"\n        if self.stacker.currentIndex() > 0:\n            self.stacker.setCurrentIndex(self.stacker.currentIndex()-1)", "code_tokens": "def prevPlot ( self ) : if self . stacker . currentIndex ( ) > 0 : self . stacker . setCurrentIndex ( self . stacker . currentIndex ( ) - 1 )", "docstring_tokens": "Moves the displayed plot to the previous one", "label": 1}, {"idx": "cosqa-train-17235", "doc": "python last day of a month", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 1}, {"idx": "cosqa-train-17236", "doc": "python code to check duplicates in a list", "code": "def find_duplicates(l: list) -> set:\n    \"\"\"\n    Return the duplicates in a list.\n\n    The function relies on\n    https://stackoverflow.com/questions/9835762/find-and-list-duplicates-in-a-list .\n    Parameters\n    ----------\n    l : list\n        Name\n\n    Returns\n    -------\n    set\n        Duplicated values\n\n    >>> find_duplicates([1,2,3])\n    set()\n    >>> find_duplicates([1,2,1])\n    {1}\n    \"\"\"\n    return set([x for x in l if l.count(x) > 1])", "code_tokens": "def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "docstring_tokens": "Return the duplicates in a list .", "label": 0}, {"idx": "cosqa-train-17237", "doc": "python kivy set conditions on button background color", "code": "def change_bgcolor_enable(self, state):\n        \"\"\"\n        This is implementet so column min/max is only active when bgcolor is\n        \"\"\"\n        self.dataModel.bgcolor(state)\n        self.bgcolor_global.setEnabled(not self.is_series and state > 0)", "code_tokens": "def change_bgcolor_enable ( self , state ) : self . dataModel . bgcolor ( state ) self . bgcolor_global . setEnabled ( not self . is_series and state > 0 )", "docstring_tokens": "This is implementet so column min / max is only active when bgcolor is", "label": 0}, {"idx": "cosqa-train-17238", "doc": "can you set a range on the sort function in python", "code": "def sorted_chain(*ranges: Iterable[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"Chain & sort ranges.\"\"\"\n    return sorted(itertools.chain(*ranges))", "code_tokens": "def sorted_chain ( * ranges : Iterable [ Tuple [ int , int ] ] ) -> List [ Tuple [ int , int ] ] : return sorted ( itertools . chain ( * ranges ) )", "docstring_tokens": "Chain & sort ranges .", "label": 1}, {"idx": "cosqa-train-17239", "doc": "python how to read csv into numpy array", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 1}, {"idx": "cosqa-train-17240", "doc": "how to delete an item from a set python", "code": "def remove_once(gset, elem):\n    \"\"\"Remove the element from a set, lists or dict.\n    \n        >>> L = [\"Lucy\"]; S = set([\"Sky\"]); D = { \"Diamonds\": True };\n        >>> remove_once(L, \"Lucy\"); remove_once(S, \"Sky\"); remove_once(D, \"Diamonds\");\n        >>> print L, S, D\n        [] set([]) {}\n\n    Returns the element if it was removed. Raises one of the exceptions in \n    :obj:`RemoveError` otherwise.\n    \"\"\"\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "code_tokens": "def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "docstring_tokens": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}", "label": 1}, {"idx": "cosqa-train-17241", "doc": "invertable hash function python", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 1}, {"idx": "cosqa-train-17242", "doc": "get the index of no zero entry in array python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 0}, {"idx": "cosqa-train-17243", "doc": "python open file and skip to next line", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 0}, {"idx": "cosqa-train-17244", "doc": "python return all column names", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 1}, {"idx": "cosqa-train-17245", "doc": "python filter empty strings", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 1}, {"idx": "cosqa-train-17246", "doc": "check if value is number or string with number python", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 0}, {"idx": "cosqa-train-17247", "doc": "if string contains whitespace python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 0}, {"idx": "cosqa-train-17248", "doc": "python filter nan from array", "code": "def remove_nans_1D(*args) -> tuple:\n    \"\"\"Remove nans in a set of 1D arrays.\n\n    Removes indicies in all arrays if any array is nan at that index.\n    All input arrays must have the same size.\n\n    Parameters\n    ----------\n    args : 1D arrays\n\n    Returns\n    -------\n    tuple\n        Tuple of 1D arrays in same order as given, with nan indicies removed.\n    \"\"\"\n    vals = np.isnan(args[0])\n    for a in args:\n        vals |= np.isnan(a)\n    return tuple(np.array(a)[~vals] for a in args)", "code_tokens": "def remove_nans_1D ( * args ) -> tuple : vals = np . isnan ( args [ 0 ] ) for a in args : vals |= np . isnan ( a ) return tuple ( np . array ( a ) [ ~ vals ] for a in args )", "docstring_tokens": "Remove nans in a set of 1D arrays .", "label": 0}, {"idx": "cosqa-train-17249", "doc": "limit function python as close as 100", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 0}, {"idx": "cosqa-train-17250", "doc": "python dic minus value all", "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": "def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "docstring_tokens": "Return a new copied dictionary without the keys with None values from the given Mapping object .", "label": 0}, {"idx": "cosqa-train-17251", "doc": "python3 pylint pylintrc path", "code": "def get_pylint_options(config_dir='.'):\n    # type: (str) -> List[str]\n    \"\"\"Checks for local config overrides for `pylint`\n    and add them in the correct `pylint` `options` format.\n\n    :param config_dir:\n    :return: List [str]\n    \"\"\"\n    if PYLINT_CONFIG_NAME in os.listdir(config_dir):\n        pylint_config_path = PYLINT_CONFIG_NAME\n    else:\n        pylint_config_path = DEFAULT_PYLINT_CONFIG_PATH\n\n    return ['--rcfile={}'.format(pylint_config_path)]", "code_tokens": "def get_pylint_options ( config_dir = '.' ) : # type: (str) -> List[str] if PYLINT_CONFIG_NAME in os . listdir ( config_dir ) : pylint_config_path = PYLINT_CONFIG_NAME else : pylint_config_path = DEFAULT_PYLINT_CONFIG_PATH return [ '--rcfile={}' . format ( pylint_config_path ) ]", "docstring_tokens": "Checks for local config overrides for pylint and add them in the correct pylint options format .", "label": 1}, {"idx": "cosqa-train-17252", "doc": "passing variables to a print function in python", "code": "def prin(*args, **kwargs):\n    r\"\"\"Like ``print``, but a function. I.e. prints out all arguments as\n    ``print`` would do. Specify output stream like this::\n\n      print('ERROR', `out=\"sys.stderr\"``).\n\n    \"\"\"\n    print >> kwargs.get('out',None), \" \".join([str(arg) for arg in args])", "code_tokens": "def prin ( * args , * * kwargs ) : print >> kwargs . get ( 'out' , None ) , \" \" . join ( [ str ( arg ) for arg in args ] )", "docstring_tokens": "r Like print but a function . I . e . prints out all arguments as print would do . Specify output stream like this ::", "label": 1}, {"idx": "cosqa-train-17253", "doc": "python readline skip blank lines", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-17254", "doc": "python to get hostname", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 0}, {"idx": "cosqa-train-17255", "doc": "how to check python versio", "code": "def validate_django_compatible_with_python():\n    \"\"\"\n    Verify Django 1.11 is present if Python 2.7 is active\n\n    Installation of pinax-cli requires the correct version of Django for\n    the active Python version. If the developer subsequently changes\n    the Python version the installed Django may no longer be compatible.\n    \"\"\"\n    python_version = sys.version[:5]\n    django_version = django.get_version()\n    if sys.version_info == (2, 7) and django_version >= \"2\":\n        click.BadArgumentUsage(\"Please install Django v1.11 for Python {}, or switch to Python >= v3.4\".format(python_version))", "code_tokens": "def validate_django_compatible_with_python ( ) : python_version = sys . version [ : 5 ] django_version = django . get_version ( ) if sys . version_info == ( 2 , 7 ) and django_version >= \"2\" : click . BadArgumentUsage ( \"Please install Django v1.11 for Python {}, or switch to Python >= v3.4\" . format ( python_version ) )", "docstring_tokens": "Verify Django 1 . 11 is present if Python 2 . 7 is active", "label": 0}, {"idx": "cosqa-train-17256", "doc": "how to get memory used or time to run code in python", "code": "def memory_usage():\n    \"\"\"return memory usage of python process in MB\n\n    from\n    http://fa.bianp.net/blog/2013/different-ways-to-get-memory-consumption-or-lessons-learned-from-memory_profiler/\n    psutil is quicker\n\n    >>> isinstance(memory_usage(),float)\n    True\n\n    \"\"\"\n    try:\n        import psutil\n        import os\n    except ImportError:\n        return _memory_usage_ps()\n\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info()[0] / float(2 ** 20)\n    return mem", "code_tokens": "def memory_usage ( ) : try : import psutil import os except ImportError : return _memory_usage_ps ( ) process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) [ 0 ] / float ( 2 ** 20 ) return mem", "docstring_tokens": "return memory usage of python process in MB", "label": 0}, {"idx": "cosqa-train-17257", "doc": "how to check for whitespace string in python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 0}, {"idx": "cosqa-train-17258", "doc": "remove xml element tree python", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 0}, {"idx": "cosqa-train-17259", "doc": "how to get cursor position in python on mac os x", "code": "def position(self) -> Position:\n        \"\"\"The current position of the cursor.\"\"\"\n        return Position(self._index, self._lineno, self._col_offset)", "code_tokens": "def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "docstring_tokens": "The current position of the cursor .", "label": 0}, {"idx": "cosqa-train-17260", "doc": "hoe to get a matching pattern in a file in python", "code": "def grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''", "code_tokens": "def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "docstring_tokens": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .", "label": 0}, {"idx": "cosqa-train-17261", "doc": "how to execute async in python", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 1}, {"idx": "cosqa-train-17262", "doc": "tokenizing a column python", "code": "def find_column(token):\n    \"\"\" Compute column:\n            input is the input text string\n            token is a token instance\n    \"\"\"\n    i = token.lexpos\n    input = token.lexer.lexdata\n\n    while i > 0:\n        if input[i - 1] == '\\n':\n            break\n        i -= 1\n\n    column = token.lexpos - i + 1\n\n    return column", "code_tokens": "def find_column ( token ) : i = token . lexpos input = token . lexer . lexdata while i > 0 : if input [ i - 1 ] == '\\n' : break i -= 1 column = token . lexpos - i + 1 return column", "docstring_tokens": "Compute column : input is the input text string token is a token instance", "label": 0}, {"idx": "cosqa-train-17263", "doc": "python check if file modified in last minute", "code": "def file_uptodate(fname, cmp_fname):\n    \"\"\"Check if a file exists, is non-empty and is more recent than cmp_fname.\n    \"\"\"\n    try:\n        return (file_exists(fname) and file_exists(cmp_fname) and\n                getmtime(fname) >= getmtime(cmp_fname))\n    except OSError:\n        return False", "code_tokens": "def file_uptodate ( fname , cmp_fname ) : try : return ( file_exists ( fname ) and file_exists ( cmp_fname ) and getmtime ( fname ) >= getmtime ( cmp_fname ) ) except OSError : return False", "docstring_tokens": "Check if a file exists is non - empty and is more recent than cmp_fname .", "label": 0}, {"idx": "cosqa-train-17264", "doc": "how to return half of a string in python", "code": "def numeric_part(s):\n    \"\"\"Returns the leading numeric part of a string.\n\n    >>> numeric_part(\"20-alpha\")\n    20\n    >>> numeric_part(\"foo\")\n    >>> numeric_part(\"16b\")\n    16\n    \"\"\"\n\n    m = re_numeric_part.match(s)\n    if m:\n        return int(m.group(1))\n    return None", "code_tokens": "def numeric_part ( s ) : m = re_numeric_part . match ( s ) if m : return int ( m . group ( 1 ) ) return None", "docstring_tokens": "Returns the leading numeric part of a string .", "label": 0}, {"idx": "cosqa-train-17265", "doc": "python opencv check number of channels in mat", "code": "def numchannels(samples:np.ndarray) -> int:\n    \"\"\"\n    return the number of channels present in samples\n\n    samples: a numpy array as returned by sndread\n\n    for multichannel audio, samples is always interleaved,\n    meaning that samples[n] returns always a frame, which\n    is either a single scalar for mono audio, or an array\n    for multichannel audio.\n    \"\"\"\n    if len(samples.shape) == 1:\n        return 1\n    else:\n        return samples.shape[1]", "code_tokens": "def numchannels ( samples : np . ndarray ) -> int : if len ( samples . shape ) == 1 : return 1 else : return samples . shape [ 1 ]", "docstring_tokens": "return the number of channels present in samples", "label": 0}, {"idx": "cosqa-train-17266", "doc": "implement exponential backoff in python 3", "code": "def exponential_backoff(attempt: int, cap: int=1200) -> timedelta:\n    \"\"\"Calculate a delay to retry using an exponential backoff algorithm.\n\n    It is an exponential backoff with random jitter to prevent failures\n    from being retried at the same time. It is a good fit for most\n    applications.\n\n    :arg attempt: the number of attempts made\n    :arg cap: maximum delay, defaults to 20 minutes\n    \"\"\"\n    base = 3\n    temp = min(base * 2 ** attempt, cap)\n    return timedelta(seconds=temp / 2 + random.randint(0, temp / 2))", "code_tokens": "def exponential_backoff ( attempt : int , cap : int = 1200 ) -> timedelta : base = 3 temp = min ( base * 2 ** attempt , cap ) return timedelta ( seconds = temp / 2 + random . randint ( 0 , temp / 2 ) )", "docstring_tokens": "Calculate a delay to retry using an exponential backoff algorithm .", "label": 1}, {"idx": "cosqa-train-17267", "doc": "how can i determine the encoding of bytes python3", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 0}, {"idx": "cosqa-train-17268", "doc": "python check if path is absolute path or relative path", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 1}, {"idx": "cosqa-train-17269", "doc": "how to combine asyncio python synchronize", "code": "async def parallel_results(future_map: Sequence[Tuple]) -> Dict:\n    \"\"\"\n    Run parallel execution of futures and return mapping of their results to the provided keys.\n    Just a neat shortcut around ``asyncio.gather()``\n\n    :param future_map: Keys to futures mapping, e.g.: ( ('nav', get_nav()), ('content, get_content()) )\n    :return: Dict with futures results mapped to keys {'nav': {1:2}, 'content': 'xyz'}\n    \"\"\"\n    ctx_methods = OrderedDict(future_map)\n    fs = list(ctx_methods.values())\n    results = await asyncio.gather(*fs)\n    results = {\n        key: results[idx] for idx, key in enumerate(ctx_methods.keys())\n    }\n    return results", "code_tokens": "async def parallel_results ( future_map : Sequence [ Tuple ] ) -> Dict : ctx_methods = OrderedDict ( future_map ) fs = list ( ctx_methods . values ( ) ) results = await asyncio . gather ( * fs ) results = { key : results [ idx ] for idx , key in enumerate ( ctx_methods . keys ( ) ) } return results", "docstring_tokens": "Run parallel execution of futures and return mapping of their results to the provided keys . Just a neat shortcut around asyncio . gather ()", "label": 0}, {"idx": "cosqa-train-17270", "doc": "python how to tell if there is at least one alpha character in a string", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-17271", "doc": "reversing key value into new dict python", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 1}, {"idx": "cosqa-train-17272", "doc": "python check if lists has same length", "code": "def check_consistent_length(*arrays):\n    \"\"\"Check that all arrays have consistent first dimensions.\n\n    Checks whether all objects in arrays have the same shape or length.\n\n    Parameters\n    ----------\n    arrays : list or tuple of input objects.\n        Objects that will be checked for consistent length.\n    \"\"\"\n\n    uniques = np.unique([_num_samples(X) for X in arrays if X is not None])\n    if len(uniques) > 1:\n        raise ValueError(\"Found arrays with inconsistent numbers of samples: %s\"\n                         % str(uniques))", "code_tokens": "def check_consistent_length ( * arrays ) : uniques = np . unique ( [ _num_samples ( X ) for X in arrays if X is not None ] ) if len ( uniques ) > 1 : raise ValueError ( \"Found arrays with inconsistent numbers of samples: %s\" % str ( uniques ) )", "docstring_tokens": "Check that all arrays have consistent first dimensions .", "label": 0}, {"idx": "cosqa-train-17273", "doc": "is python integer or float", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 0}, {"idx": "cosqa-train-17274", "doc": "bitwise operations not working in python", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-17275", "doc": "python fill zeroes in front of string", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 0}, {"idx": "cosqa-train-17276", "doc": "python determine dtype of object", "code": "def maybe_infer_dtype_type(element):\n    \"\"\"Try to infer an object's dtype, for use in arithmetic ops\n\n    Uses `element.dtype` if that's available.\n    Objects implementing the iterator protocol are cast to a NumPy array,\n    and from there the array's type is used.\n\n    Parameters\n    ----------\n    element : object\n        Possibly has a `.dtype` attribute, and possibly the iterator\n        protocol.\n\n    Returns\n    -------\n    tipo : type\n\n    Examples\n    --------\n    >>> from collections import namedtuple\n    >>> Foo = namedtuple(\"Foo\", \"dtype\")\n    >>> maybe_infer_dtype_type(Foo(np.dtype(\"i8\")))\n    numpy.int64\n    \"\"\"\n    tipo = None\n    if hasattr(element, 'dtype'):\n        tipo = element.dtype\n    elif is_list_like(element):\n        element = np.asarray(element)\n        tipo = element.dtype\n    return tipo", "code_tokens": "def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "docstring_tokens": "Try to infer an object s dtype for use in arithmetic ops", "label": 0}, {"idx": "cosqa-train-17277", "doc": "method to check for any whitespace in python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 0}, {"idx": "cosqa-train-17278", "doc": "list rotate function in python", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 1}, {"idx": "cosqa-train-17279", "doc": "recongnizing words in a sentence in python", "code": "def segment_str(text: str, phoneme_inventory: Set[str] = PHONEMES) -> str:\n    \"\"\"\n    Takes as input a string in Kunwinjku and segments it into phoneme-like\n    units based on the standard orthographic rules specified at\n    http://bininjgunwok.org.au/\n    \"\"\"\n\n    text = text.lower()\n    text = segment_into_tokens(text, phoneme_inventory)\n    return text", "code_tokens": "def segment_str ( text : str , phoneme_inventory : Set [ str ] = PHONEMES ) -> str : text = text . lower ( ) text = segment_into_tokens ( text , phoneme_inventory ) return text", "docstring_tokens": "Takes as input a string in Kunwinjku and segments it into phoneme - like units based on the standard orthographic rules specified at http : // bininjgunwok . org . au /", "label": 0}, {"idx": "cosqa-train-17280", "doc": "python get last modified date of file http header lines", "code": "def last_modified(self) -> Optional[datetime.datetime]:\n        \"\"\"The value of Last-Modified HTTP header, or None.\n\n        This header is represented as a `datetime` object.\n        \"\"\"\n        httpdate = self._headers.get(hdrs.LAST_MODIFIED)\n        if httpdate is not None:\n            timetuple = parsedate(httpdate)\n            if timetuple is not None:\n                return datetime.datetime(*timetuple[:6],\n                                         tzinfo=datetime.timezone.utc)\n        return None", "code_tokens": "def last_modified ( self ) -> Optional [ datetime . datetime ] : httpdate = self . _headers . get ( hdrs . LAST_MODIFIED ) if httpdate is not None : timetuple = parsedate ( httpdate ) if timetuple is not None : return datetime . datetime ( * timetuple [ : 6 ] , tzinfo = datetime . timezone . utc ) return None", "docstring_tokens": "The value of Last - Modified HTTP header or None .", "label": 1}, {"idx": "cosqa-train-17281", "doc": "how to print out cache in python", "code": "def tofile(self, fileobj):\n\t\t\"\"\"\n\t\twrite a cache object to the fileobj as a lal cache file\n\t\t\"\"\"\n\t\tfor entry in self:\n\t\t\tprint >>fileobj, str(entry)\n\t\tfileobj.close()", "code_tokens": "def tofile ( self , fileobj ) : for entry in self : print >> fileobj , str ( entry ) fileobj . close ( )", "docstring_tokens": "write a cache object to the fileobj as a lal cache file", "label": 1}, {"idx": "cosqa-train-17282", "doc": "python print list %s only certain length", "code": "def _brief_print_list(lst, limit=7):\n    \"\"\"Print at most `limit` elements of list.\"\"\"\n    lst = list(lst)\n    if len(lst) > limit:\n        return _brief_print_list(lst[:limit//2], limit) + ', ..., ' + \\\n            _brief_print_list(lst[-limit//2:], limit)\n    return ', '.join([\"'%s'\"%str(i) for i in lst])", "code_tokens": "def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "docstring_tokens": "Print at most limit elements of list .", "label": 0}, {"idx": "cosqa-train-17283", "doc": "creating a tree diagram in python", "code": "def _tree_line(self, no_type: bool = False) -> str:\n        \"\"\"Return the receiver's contribution to tree diagram.\"\"\"\n        return self._tree_line_prefix() + \" \" + self.iname()", "code_tokens": "def _tree_line ( self , no_type : bool = False ) -> str : return self . _tree_line_prefix ( ) + \" \" + self . iname ( )", "docstring_tokens": "Return the receiver s contribution to tree diagram .", "label": 1}, {"idx": "cosqa-train-17284", "doc": "python concatenate np arrays", "code": "def uconcatenate(arrs, axis=0):\n    \"\"\"Concatenate a sequence of arrays.\n\n    This wrapper around numpy.concatenate preserves units. All input arrays\n    must have the same units.  See the documentation of numpy.concatenate for\n    full details.\n\n    Examples\n    --------\n    >>> from unyt import cm\n    >>> A = [1, 2, 3]*cm\n    >>> B = [2, 3, 4]*cm\n    >>> uconcatenate((A, B))\n    unyt_array([1, 2, 3, 2, 3, 4], 'cm')\n\n    \"\"\"\n    v = np.concatenate(arrs, axis=axis)\n    v = _validate_numpy_wrapper_units(v, arrs)\n    return v", "code_tokens": "def uconcatenate ( arrs , axis = 0 ) : v = np . concatenate ( arrs , axis = axis ) v = _validate_numpy_wrapper_units ( v , arrs ) return v", "docstring_tokens": "Concatenate a sequence of arrays .", "label": 0}, {"idx": "cosqa-train-17285", "doc": "get 3 separate values froma tuple python", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 0}, {"idx": "cosqa-train-17286", "doc": "python 3 cast string to date", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-17287", "doc": "change a python value to uppercase", "code": "def camel_to_snake_case(string):\n    \"\"\"Converts 'string' presented in camel case to snake case.\n\n    e.g.: CamelCase => snake_case\n    \"\"\"\n    s = _1.sub(r'\\1_\\2', string)\n    return _2.sub(r'\\1_\\2', s).lower()", "code_tokens": "def camel_to_snake_case ( string ) : s = _1 . sub ( r'\\1_\\2' , string ) return _2 . sub ( r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Converts string presented in camel case to snake case .", "label": 0}, {"idx": "cosqa-train-17288", "doc": "count function in python for list", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 0}, {"idx": "cosqa-train-17289", "doc": "strings inside lists inside a dictionary python", "code": "def encode_list(key, list_):\n    # type: (str, Iterable) -> Dict[str, str]\n    \"\"\"\n    Converts a list into a space-separated string and puts it in a dictionary\n\n    :param key: Dictionary key to store the list\n    :param list_: A list of objects\n    :return: A dictionary key->string or an empty dictionary\n    \"\"\"\n    if not list_:\n        return {}\n    return {key: \" \".join(str(i) for i in list_)}", "code_tokens": "def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "docstring_tokens": "Converts a list into a space - separated string and puts it in a dictionary", "label": 1}, {"idx": "cosqa-train-17290", "doc": "sort the given list without using sort function in python", "code": "def natural_sort(list_to_sort: Iterable[str]) -> List[str]:\n    \"\"\"\n    Sorts a list of strings case insensitively as well as numerically.\n\n    For example: ['a1', 'A2', 'a3', 'A11', 'a22']\n\n    To sort a list in place, don't call this method, which makes a copy. Instead, do this:\n\n    my_list.sort(key=natural_keys)\n\n    :param list_to_sort: the list being sorted\n    :return: the list sorted naturally\n    \"\"\"\n    return sorted(list_to_sort, key=natural_keys)", "code_tokens": "def natural_sort ( list_to_sort : Iterable [ str ] ) -> List [ str ] : return sorted ( list_to_sort , key = natural_keys )", "docstring_tokens": "Sorts a list of strings case insensitively as well as numerically .", "label": 1}, {"idx": "cosqa-train-17291", "doc": "python return the index of the minimum", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-17292", "doc": "how to create acronyms with removed words using python", "code": "def has_synset(word: str) -> list:\n    \"\"\"\" Returns a list of synsets of a word after lemmatization. \"\"\"\n\n    return wn.synsets(lemmatize(word, neverstem=True))", "code_tokens": "def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "docstring_tokens": "Returns a list of synsets of a word after lemmatization .", "label": 0}, {"idx": "cosqa-train-17293", "doc": "python check list is sequential", "code": "def are_token_parallel(sequences: Sequence[Sized]) -> bool:\n    \"\"\"\n    Returns True if all sequences in the list have the same length.\n    \"\"\"\n    if not sequences or len(sequences) == 1:\n        return True\n    return all(len(s) == len(sequences[0]) for s in sequences)", "code_tokens": "def are_token_parallel ( sequences : Sequence [ Sized ] ) -> bool : if not sequences or len ( sequences ) == 1 : return True return all ( len ( s ) == len ( sequences [ 0 ] ) for s in sequences )", "docstring_tokens": "Returns True if all sequences in the list have the same length .", "label": 0}, {"idx": "cosqa-train-17294", "doc": "nodejs equivalent of lock python", "code": "def release_lock():\n    \"\"\"Release lock on compilation directory.\"\"\"\n    get_lock.n_lock -= 1\n    assert get_lock.n_lock >= 0\n    # Only really release lock once all lock requests have ended.\n    if get_lock.lock_is_enabled and get_lock.n_lock == 0:\n        get_lock.start_time = None\n        get_lock.unlocker.unlock()", "code_tokens": "def release_lock ( ) : get_lock . n_lock -= 1 assert get_lock . n_lock >= 0 # Only really release lock once all lock requests have ended. if get_lock . lock_is_enabled and get_lock . n_lock == 0 : get_lock . start_time = None get_lock . unlocker . unlock ( )", "docstring_tokens": "Release lock on compilation directory .", "label": 1}, {"idx": "cosqa-train-17295", "doc": "python filter value dict", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-17296", "doc": "numbers in a list to string python", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 1}, {"idx": "cosqa-train-17297", "doc": "is there a equivalent of a margin command in python", "code": "def margin(text):\n    r\"\"\"Add a margin to both ends of each line in the string.\n\n    Example:\n        >>> margin('line1\\nline2')\n        '  line1  \\n  line2  '\n    \"\"\"\n    lines = str(text).split('\\n')\n    return '\\n'.join('  {}  '.format(l) for l in lines)", "code_tokens": "def margin ( text ) : lines = str ( text ) . split ( '\\n' ) return '\\n' . join ( '  {}  ' . format ( l ) for l in lines )", "docstring_tokens": "r Add a margin to both ends of each line in the string .", "label": 0}, {"idx": "cosqa-train-17298", "doc": "python get last of previous month", "code": "def get_period_last_3_months() -> str:\n    \"\"\" Returns the last week as a period string \"\"\"\n    today = Datum()\n    today.today()\n\n    # start_date = today - timedelta(weeks=13)\n    start_date = today.clone()\n    start_date.subtract_months(3)\n\n    period = get_period(start_date.date, today.date)\n    return period", "code_tokens": "def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "docstring_tokens": "Returns the last week as a period string", "label": 1}, {"idx": "cosqa-train-17299", "doc": "split a particular sentence in a list with a delimiter in python", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 1}, {"idx": "cosqa-train-17300", "doc": "python how to inverse a dictionary", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 1}, {"idx": "cosqa-train-17301", "doc": "iterable items from dict python", "code": "def iterate_items(dictish):\n    \"\"\" Return a consistent (key, value) iterable on dict-like objects,\n    including lists of tuple pairs.\n\n    Example:\n\n        >>> list(iterate_items({'a': 1}))\n        [('a', 1)]\n        >>> list(iterate_items([('a', 1), ('b', 2)]))\n        [('a', 1), ('b', 2)]\n    \"\"\"\n    if hasattr(dictish, 'iteritems'):\n        return dictish.iteritems()\n    if hasattr(dictish, 'items'):\n        return dictish.items()\n    return dictish", "code_tokens": "def iterate_items ( dictish ) : if hasattr ( dictish , 'iteritems' ) : return dictish . iteritems ( ) if hasattr ( dictish , 'items' ) : return dictish . items ( ) return dictish", "docstring_tokens": "Return a consistent ( key value ) iterable on dict - like objects including lists of tuple pairs .", "label": 0}, {"idx": "cosqa-train-17302", "doc": "finding 2 closest items in 2 lists in python", "code": "def closest_values(L):\n    \"\"\"Closest values\n\n    :param L: list of values\n    :returns: two values from L with minimal distance\n    :modifies: the order of L\n    :complexity: O(n log n), for n=len(L)\n    \"\"\"\n    assert len(L) >= 2\n    L.sort()\n    valmin, argmin = min((L[i] - L[i - 1], i) for i in range(1, len(L)))\n    return L[argmin - 1], L[argmin]", "code_tokens": "def closest_values ( L ) : assert len ( L ) >= 2 L . sort ( ) valmin , argmin = min ( ( L [ i ] - L [ i - 1 ] , i ) for i in range ( 1 , len ( L ) ) ) return L [ argmin - 1 ] , L [ argmin ]", "docstring_tokens": "Closest values", "label": 1}, {"idx": "cosqa-train-17303", "doc": "how to fill an array with str in python", "code": "def toStringArray(name, a, width = 0):\n    \"\"\"\n    Returns an array (any sequence of floats, really) as a string.\n    \"\"\"\n    string = name + \": \"\n    cnt = 0\n    for i in a:\n        string += \"%4.2f  \" % i \n        if width > 0 and (cnt + 1) % width == 0:\n            string += '\\n'\n        cnt += 1\n    return string", "code_tokens": "def toStringArray ( name , a , width = 0 ) : string = name + \": \" cnt = 0 for i in a : string += \"%4.2f  \" % i if width > 0 and ( cnt + 1 ) % width == 0 : string += '\\n' cnt += 1 return string", "docstring_tokens": "Returns an array ( any sequence of floats really ) as a string .", "label": 0}, {"idx": "cosqa-train-17304", "doc": "python detect if int", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-17305", "doc": "how to track ram usage in python", "code": "def psutil_phymem_usage():\n    \"\"\"\n    Return physical memory usage (float)\n    Requires the cross-platform psutil (>=v0.3) library\n    (https://github.com/giampaolo/psutil)\n    \"\"\"\n    import psutil\n    # This is needed to avoid a deprecation warning error with\n    # newer psutil versions\n    try:\n        percent = psutil.virtual_memory().percent\n    except:\n        percent = psutil.phymem_usage().percent\n    return percent", "code_tokens": "def psutil_phymem_usage ( ) : import psutil # This is needed to avoid a deprecation warning error with\n # newer psutil versions\n try : percent = psutil . virtual_memory ( ) . percent except : percent = psutil . phymem_usage ( ) . percent return percent", "docstring_tokens": "Return physical memory usage ( float ) Requires the cross - platform psutil ( > = v0 . 3 ) library ( https : // github . com / giampaolo / psutil )", "label": 1}, {"idx": "cosqa-train-17306", "doc": "how to get string positions in python 3", "code": "def text_coords(string, position):\n    r\"\"\"\n    Transform a simple index into a human-readable position in a string.\n\n    This function accepts a string and an index, and will return a triple of\n    `(lineno, columnno, line)` representing the position through the text. It's\n    useful for displaying a string index in a human-readable way::\n\n        >>> s = \"abcdef\\nghijkl\\nmnopqr\\nstuvwx\\nyz\"\n        >>> text_coords(s, 0)\n        (0, 0, 'abcdef')\n        >>> text_coords(s, 4)\n        (0, 4, 'abcdef')\n        >>> text_coords(s, 6)\n        (0, 6, 'abcdef')\n        >>> text_coords(s, 7)\n        (1, 0, 'ghijkl')\n        >>> text_coords(s, 11)\n        (1, 4, 'ghijkl')\n        >>> text_coords(s, 15)\n        (2, 1, 'mnopqr')\n    \"\"\"\n    line_start = string.rfind('\\n', 0, position) + 1\n    line_end = string.find('\\n', position)\n    lineno = string.count('\\n', 0, position)\n    columnno = position - line_start\n    line = string[line_start:line_end]\n    return (lineno, columnno, line)", "code_tokens": "def text_coords ( string , position ) : line_start = string . rfind ( '\\n' , 0 , position ) + 1 line_end = string . find ( '\\n' , position ) lineno = string . count ( '\\n' , 0 , position ) columnno = position - line_start line = string [ line_start : line_end ] return ( lineno , columnno , line )", "docstring_tokens": "r Transform a simple index into a human - readable position in a string .", "label": 1}, {"idx": "cosqa-train-17307", "doc": "how to change color of highlight variable in python", "code": "def highlight(text: str, color_code: int, bold: bool=False) -> str:\n    \"\"\"Wraps the given string with terminal color codes.\n\n    Args:\n        text: The content to highlight.\n        color_code: The color to highlight with, e.g. 'shelltools.RED'.\n        bold: Whether to bold the content in addition to coloring.\n\n    Returns:\n        The highlighted string.\n    \"\"\"\n    return '{}\\033[{}m{}\\033[0m'.format(\n        '\\033[1m' if bold else '',\n        color_code,\n        text,)", "code_tokens": "def highlight ( text : str , color_code : int , bold : bool = False ) -> str : return '{}\\033[{}m{}\\033[0m' . format ( '\\033[1m' if bold else '' , color_code , text , )", "docstring_tokens": "Wraps the given string with terminal color codes .", "label": 1}, {"idx": "cosqa-train-17308", "doc": "get the parent node of a node using python", "code": "def assign_parent(node: astroid.node_classes.NodeNG) -> astroid.node_classes.NodeNG:\n    \"\"\"return the higher parent which is not an AssignName, Tuple or List node\n    \"\"\"\n    while node and isinstance(node, (astroid.AssignName, astroid.Tuple, astroid.List)):\n        node = node.parent\n    return node", "code_tokens": "def assign_parent ( node : astroid . node_classes . NodeNG ) -> astroid . node_classes . NodeNG : while node and isinstance ( node , ( astroid . AssignName , astroid . Tuple , astroid . List ) ) : node = node . parent return node", "docstring_tokens": "return the higher parent which is not an AssignName Tuple or List node", "label": 0}, {"idx": "cosqa-train-17309", "doc": "python how to repeat a list a set amount of times", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 0}, {"idx": "cosqa-train-17310", "doc": "excel numeric dates to python timestamp", "code": "def excel_datetime(timestamp, epoch=None):\n    \"\"\"Return datetime object from timestamp in Excel serial format.\n\n    Convert LSM time stamps.\n\n    >>> excel_datetime(40237.029999999795)\n    datetime.datetime(2010, 2, 28, 0, 43, 11, 999982)\n\n    \"\"\"\n    if epoch is None:\n        epoch = datetime.datetime.fromordinal(693594)\n    return epoch + datetime.timedelta(timestamp)", "code_tokens": "def excel_datetime ( timestamp , epoch = None ) : if epoch is None : epoch = datetime . datetime . fromordinal ( 693594 ) return epoch + datetime . timedelta ( timestamp )", "docstring_tokens": "Return datetime object from timestamp in Excel serial format .", "label": 0}, {"idx": "cosqa-train-17311", "doc": "invalid callable given python", "code": "def callable_validator(v: Any) -> AnyCallable:\n    \"\"\"\n    Perform a simple check if the value is callable.\n\n    Note: complete matching of argument type hints and return types is not performed\n    \"\"\"\n    if callable(v):\n        return v\n\n    raise errors.CallableError(value=v)", "code_tokens": "def callable_validator ( v : Any ) -> AnyCallable : if callable ( v ) : return v raise errors . CallableError ( value = v )", "docstring_tokens": "Perform a simple check if the value is callable .", "label": 0}, {"idx": "cosqa-train-17312", "doc": "how efficient are python bitmasks", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 0}, {"idx": "cosqa-train-17313", "doc": "detect the last element in a python 'for' loop", "code": "def enum_mark_last(iterable, start=0):\n    \"\"\"\n    Returns a generator over iterable that tells whether the current item is the last one.\n    Usage:\n        >>> iterable = range(10)\n        >>> for index, is_last, item in enum_mark_last(iterable):\n        >>>     print(index, item, end='\\n' if is_last else ', ')\n    \"\"\"\n    it = iter(iterable)\n    count = start\n    try:\n        last = next(it)\n    except StopIteration:\n        return\n    for val in it:\n        yield count, False, last\n        last = val\n        count += 1\n    yield count, True, last", "code_tokens": "def enum_mark_last ( iterable , start = 0 ) : it = iter ( iterable ) count = start try : last = next ( it ) except StopIteration : return for val in it : yield count , False , last last = val count += 1 yield count , True , last", "docstring_tokens": "Returns a generator over iterable that tells whether the current item is the last one . Usage : >>> iterable = range ( 10 ) >>> for index is_last item in enum_mark_last ( iterable ) : >>> print ( index item end = \\ n if is_last else )", "label": 0}, {"idx": "cosqa-train-17314", "doc": "python read from csv into numpy array", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 1}, {"idx": "cosqa-train-17315", "doc": "python dataset get first 50 rows", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 1}, {"idx": "cosqa-train-17316", "doc": "long number of bits python", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 1}, {"idx": "cosqa-train-17317", "doc": "python datetime enter date in isoformat", "code": "def to_iso_string(self) -> str:\n        \"\"\" Returns full ISO string for the given date \"\"\"\n        assert isinstance(self.value, datetime)\n        return datetime.isoformat(self.value)", "code_tokens": "def to_iso_string ( self ) -> str : assert isinstance ( self . value , datetime ) return datetime . isoformat ( self . value )", "docstring_tokens": "Returns full ISO string for the given date", "label": 1}, {"idx": "cosqa-train-17318", "doc": "how to print each item in a list until a certain limit is reached python", "code": "def _brief_print_list(lst, limit=7):\n    \"\"\"Print at most `limit` elements of list.\"\"\"\n    lst = list(lst)\n    if len(lst) > limit:\n        return _brief_print_list(lst[:limit//2], limit) + ', ..., ' + \\\n            _brief_print_list(lst[-limit//2:], limit)\n    return ', '.join([\"'%s'\"%str(i) for i in lst])", "code_tokens": "def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "docstring_tokens": "Print at most limit elements of list .", "label": 0}, {"idx": "cosqa-train-17319", "doc": "python get last months business day end", "code": "def get_period_last_3_months() -> str:\n    \"\"\" Returns the last week as a period string \"\"\"\n    today = Datum()\n    today.today()\n\n    # start_date = today - timedelta(weeks=13)\n    start_date = today.clone()\n    start_date.subtract_months(3)\n\n    period = get_period(start_date.date, today.date)\n    return period", "code_tokens": "def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "docstring_tokens": "Returns the last week as a period string", "label": 0}, {"idx": "cosqa-train-17320", "doc": "python truncate to number of decimals", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 0}, {"idx": "cosqa-train-17321", "doc": "python time a func timeit", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 0}, {"idx": "cosqa-train-17322", "doc": "python check the data type of a column", "code": "def is_sqlatype_string(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type a string type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.String)", "code_tokens": "def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "docstring_tokens": "Is the SQLAlchemy column type a string type?", "label": 0}, {"idx": "cosqa-train-17323", "doc": "how to do capitalize strings in python", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-17324", "doc": "python from list make a string with separator", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 1}, {"idx": "cosqa-train-17325", "doc": "speicify directory for output file python", "code": "def output_dir(self, *args) -> str:\n        \"\"\" Directory where to store output \"\"\"\n        return os.path.join(self.project_dir, 'output', *args)", "code_tokens": "def output_dir ( self , * args ) -> str : return os . path . join ( self . project_dir , 'output' , * args )", "docstring_tokens": "Directory where to store output", "label": 1}, {"idx": "cosqa-train-17326", "doc": "python check bytesio is empty", "code": "def writable_stream(handle):\n    \"\"\"Test whether a stream can be written to.\n    \"\"\"\n    if isinstance(handle, io.IOBase) and sys.version_info >= (3, 5):\n        return handle.writable()\n    try:\n        handle.write(b'')\n    except (io.UnsupportedOperation, IOError):\n        return False\n    else:\n        return True", "code_tokens": "def writable_stream ( handle ) : if isinstance ( handle , io . IOBase ) and sys . version_info >= ( 3 , 5 ) : return handle . writable ( ) try : handle . write ( b'' ) except ( io . UnsupportedOperation , IOError ) : return False else : return True", "docstring_tokens": "Test whether a stream can be written to .", "label": 1}, {"idx": "cosqa-train-17327", "doc": "python3 str to byte string", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 0}, {"idx": "cosqa-train-17328", "doc": "how to check if a token is in a list python", "code": "def contains(self, token: str) -> bool:\n        \"\"\"Return if the token is in the list or not.\"\"\"\n        self._validate_token(token)\n        return token in self", "code_tokens": "def contains ( self , token : str ) -> bool : self . _validate_token ( token ) return token in self", "docstring_tokens": "Return if the token is in the list or not .", "label": 0}, {"idx": "cosqa-train-17329", "doc": "extrac t model number from a string python", "code": "def detect_model_num(string):\n    \"\"\"Takes a string related to a model name and extract its model number.\n\n    For example:\n        '000000-bootstrap.index' => 0\n    \"\"\"\n    match = re.match(MODEL_NUM_REGEX, string)\n    if match:\n        return int(match.group())\n    return None", "code_tokens": "def detect_model_num ( string ) : match = re . match ( MODEL_NUM_REGEX , string ) if match : return int ( match . group ( ) ) return None", "docstring_tokens": "Takes a string related to a model name and extract its model number .", "label": 0}, {"idx": "cosqa-train-17330", "doc": "how to get columns for table in python", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 0}, {"idx": "cosqa-train-17331", "doc": "make variable all uppercase in python", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-17332", "doc": "check if line is not in text file in python", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 0}, {"idx": "cosqa-train-17333", "doc": "bin width in histogram python", "code": "def shape(self) -> Tuple[int, ...]:\n        \"\"\"Shape of histogram's data.\n\n        Returns\n        -------\n        One-element tuple with the number of bins along each axis.\n        \"\"\"\n        return tuple(bins.bin_count for bins in self._binnings)", "code_tokens": "def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )", "docstring_tokens": "Shape of histogram s data .", "label": 0}, {"idx": "cosqa-train-17334", "doc": "python sqlalchemy column enum", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 1}, {"idx": "cosqa-train-17335", "doc": "python filter dictionary and output subset", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-17336", "doc": "how to return 10 most frequent occurances in a list with python", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 0}, {"idx": "cosqa-train-17337", "doc": "python best way to compare attributes of an object to other objects", "code": "def simple_eq(one: Instance, two: Instance, attrs: List[str]) -> bool:\n    \"\"\"\n    Test if two objects are equal, based on a comparison of the specified\n    attributes ``attrs``.\n    \"\"\"\n    return all(getattr(one, a) == getattr(two, a) for a in attrs)", "code_tokens": "def simple_eq ( one : Instance , two : Instance , attrs : List [ str ] ) -> bool : return all ( getattr ( one , a ) == getattr ( two , a ) for a in attrs )", "docstring_tokens": "Test if two objects are equal based on a comparison of the specified attributes attrs .", "label": 1}, {"idx": "cosqa-train-17338", "doc": "python split on spaces but also tokenize punctuation", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 0}, {"idx": "cosqa-train-17339", "doc": "change dtype to int in python", "code": "def to_int64(a):\n    \"\"\"Return view of the recarray with all int32 cast to int64.\"\"\"\n    # build new dtype and replace i4 --> i8\n    def promote_i4(typestr):\n        if typestr[1:] == 'i4':\n            typestr = typestr[0]+'i8'\n        return typestr\n\n    dtype = [(name, promote_i4(typestr)) for name,typestr in a.dtype.descr]\n    return a.astype(dtype)", "code_tokens": "def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )", "docstring_tokens": "Return view of the recarray with all int32 cast to int64 .", "label": 1}, {"idx": "cosqa-train-17340", "doc": "python conver a string to a tup", "code": "def imt2tup(string):\n    \"\"\"\n    >>> imt2tup('PGA')\n    ('PGA',)\n    >>> imt2tup('SA(1.0)')\n    ('SA', 1.0)\n    >>> imt2tup('SA(1)')\n    ('SA', 1.0)\n    \"\"\"\n    s = string.strip()\n    if not s.endswith(')'):\n        # no parenthesis, PGA is considered the same as PGA()\n        return (s,)\n    name, rest = s.split('(', 1)\n    return (name,) + tuple(float(x) for x in ast.literal_eval(rest[:-1] + ','))", "code_tokens": "def imt2tup ( string ) : s = string . strip ( ) if not s . endswith ( ')' ) : # no parenthesis, PGA is considered the same as PGA() return ( s , ) name , rest = s . split ( '(' , 1 ) return ( name , ) + tuple ( float ( x ) for x in ast . literal_eval ( rest [ : - 1 ] + ',' ) )", "docstring_tokens": ">>> imt2tup ( PGA ) ( PGA ) >>> imt2tup ( SA ( 1 . 0 ) ) ( SA 1 . 0 ) >>> imt2tup ( SA ( 1 ) ) ( SA 1 . 0 )", "label": 0}, {"idx": "cosqa-train-17341", "doc": "python does read or readline return an empty string", "code": "def read(self, count=0):\n        \"\"\" Read \"\"\"\n        return self.f.read(count) if count > 0 else self.f.read()", "code_tokens": "def read ( self , count = 0 ) : return self . f . read ( count ) if count > 0 else self . f . read ( )", "docstring_tokens": "Read", "label": 1}, {"idx": "cosqa-train-17342", "doc": "python list of string to one string comma delimitted", "code": "def list_to_str(lst):\n    \"\"\"\n    Turn a list into a comma- and/or and-separated string.\n\n    Parameters\n    ----------\n    lst : :obj:`list`\n        A list of strings to join into a single string.\n\n    Returns\n    -------\n    str_ : :obj:`str`\n        A string with commas and/or ands separating th elements from ``lst``.\n\n    \"\"\"\n    if len(lst) == 1:\n        str_ = lst[0]\n    elif len(lst) == 2:\n        str_ = ' and '.join(lst)\n    elif len(lst) > 2:\n        str_ = ', '.join(lst[:-1])\n        str_ += ', and {0}'.format(lst[-1])\n    else:\n        raise ValueError('List of length 0 provided.')\n    return str_", "code_tokens": "def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "docstring_tokens": "Turn a list into a comma - and / or and - separated string .", "label": 1}, {"idx": "cosqa-train-17343", "doc": "python sqlalchemy execute store procedure", "code": "def _store_helper(model: Action, session: Optional[Session] = None) -> None:\n    \"\"\"Help store an action.\"\"\"\n    if session is None:\n        session = _make_session()\n\n    session.add(model)\n    session.commit()\n    session.close()", "code_tokens": "def _store_helper ( model : Action , session : Optional [ Session ] = None ) -> None : if session is None : session = _make_session ( ) session . add ( model ) session . commit ( ) session . close ( )", "docstring_tokens": "Help store an action .", "label": 0}, {"idx": "cosqa-train-17344", "doc": "check if a date is valid python", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 1}, {"idx": "cosqa-train-17345", "doc": "place the cursor on the next line after print python", "code": "def _cursorLeft(self):\n        \"\"\" Handles \"cursor left\" events \"\"\"\n        if self.cursorPos > 0:\n            self.cursorPos -= 1\n            sys.stdout.write(console.CURSOR_LEFT)\n            sys.stdout.flush()", "code_tokens": "def _cursorLeft ( self ) : if self . cursorPos > 0 : self . cursorPos -= 1 sys . stdout . write ( console . CURSOR_LEFT ) sys . stdout . flush ( )", "docstring_tokens": "Handles cursor left events", "label": 0}, {"idx": "cosqa-train-17346", "doc": "python if key exist complexity", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 1}, {"idx": "cosqa-train-17347", "doc": "python 3 codecs decode", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 0}, {"idx": "cosqa-train-17348", "doc": "python is last day in month", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 1}, {"idx": "cosqa-train-17349", "doc": "python change string value in variable to lower case", "code": "def camel_to_snake_case(string):\n    \"\"\"Converts 'string' presented in camel case to snake case.\n\n    e.g.: CamelCase => snake_case\n    \"\"\"\n    s = _1.sub(r'\\1_\\2', string)\n    return _2.sub(r'\\1_\\2', s).lower()", "code_tokens": "def camel_to_snake_case ( string ) : s = _1 . sub ( r'\\1_\\2' , string ) return _2 . sub ( r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Converts string presented in camel case to snake case .", "label": 0}, {"idx": "cosqa-train-17350", "doc": "how to get top 5 key values in python dictionary", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 1}, {"idx": "cosqa-train-17351", "doc": "flatten python list of list", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 1}, {"idx": "cosqa-train-17352", "doc": "read python datetime from isoformat", "code": "def datetime_from_isoformat(value: str):\n    \"\"\"Return a datetime object from an isoformat string.\n\n    Args:\n        value (str): Datetime string in isoformat.\n\n    \"\"\"\n    if sys.version_info >= (3, 7):\n        return datetime.fromisoformat(value)\n\n    return datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%f')", "code_tokens": "def datetime_from_isoformat ( value : str ) : if sys . version_info >= ( 3 , 7 ) : return datetime . fromisoformat ( value ) return datetime . strptime ( value , '%Y-%m-%dT%H:%M:%S.%f' )", "docstring_tokens": "Return a datetime object from an isoformat string .", "label": 1}, {"idx": "cosqa-train-17353", "doc": "domain specific language for python", "code": "def get_domain(url):\n    \"\"\"\n    Get domain part of an url.\n\n    For example: https://www.python.org/doc/ -> https://www.python.org\n    \"\"\"\n    parse_result = urlparse(url)\n    domain = \"{schema}://{netloc}\".format(\n        schema=parse_result.scheme, netloc=parse_result.netloc)\n    return domain", "code_tokens": "def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "docstring_tokens": "Get domain part of an url .", "label": 0}, {"idx": "cosqa-train-17354", "doc": "how to return max value in column python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 0}, {"idx": "cosqa-train-17355", "doc": "looking for similarity between 2 lists in python", "code": "def tanimoto_set_similarity(x: Iterable[X], y: Iterable[X]) -> float:\n    \"\"\"Calculate the tanimoto set similarity.\"\"\"\n    a, b = set(x), set(y)\n    union = a | b\n\n    if not union:\n        return 0.0\n\n    return len(a & b) / len(union)", "code_tokens": "def tanimoto_set_similarity ( x : Iterable [ X ] , y : Iterable [ X ] ) -> float : a , b = set ( x ) , set ( y ) union = a | b if not union : return 0.0 return len ( a & b ) / len ( union )", "docstring_tokens": "Calculate the tanimoto set similarity .", "label": 1}, {"idx": "cosqa-train-17356", "doc": "how do do opposite mapping in python", "code": "def reverse_mapping(mapping):\n\t\"\"\"\n\tFor every key, value pair, return the mapping for the\n\tequivalent value, key pair\n\n\t>>> reverse_mapping({'a': 'b'}) == {'b': 'a'}\n\tTrue\n\t\"\"\"\n\tkeys, values = zip(*mapping.items())\n\treturn dict(zip(values, keys))", "code_tokens": "def reverse_mapping ( mapping ) : keys , values = zip ( * mapping . items ( ) ) return dict ( zip ( values , keys ) )", "docstring_tokens": "For every key value pair return the mapping for the equivalent value key pair", "label": 1}, {"idx": "cosqa-train-17357", "doc": "python retry after 30 seconds", "code": "def exponential_backoff(attempt: int, cap: int=1200) -> timedelta:\n    \"\"\"Calculate a delay to retry using an exponential backoff algorithm.\n\n    It is an exponential backoff with random jitter to prevent failures\n    from being retried at the same time. It is a good fit for most\n    applications.\n\n    :arg attempt: the number of attempts made\n    :arg cap: maximum delay, defaults to 20 minutes\n    \"\"\"\n    base = 3\n    temp = min(base * 2 ** attempt, cap)\n    return timedelta(seconds=temp / 2 + random.randint(0, temp / 2))", "code_tokens": "def exponential_backoff ( attempt : int , cap : int = 1200 ) -> timedelta : base = 3 temp = min ( base * 2 ** attempt , cap ) return timedelta ( seconds = temp / 2 + random . randint ( 0 , temp / 2 ) )", "docstring_tokens": "Calculate a delay to retry using an exponential backoff algorithm .", "label": 0}, {"idx": "cosqa-train-17358", "doc": "python load oracle database tabls in sql alchemy metadata", "code": "def get_table_names_from_metadata(metadata: MetaData) -> List[str]:\n    \"\"\"\n    Returns all database table names found in an SQLAlchemy :class:`MetaData`\n    object.\n    \"\"\"\n    return [table.name for table in metadata.tables.values()]", "code_tokens": "def get_table_names_from_metadata ( metadata : MetaData ) -> List [ str ] : return [ table . name for table in metadata . tables . values ( ) ]", "docstring_tokens": "Returns all database table names found in an SQLAlchemy : class : MetaData object .", "label": 1}, {"idx": "cosqa-train-17359", "doc": "python remove all dictionary values equal to none", "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": "def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "docstring_tokens": "Return a new copied dictionary without the keys with None values from the given Mapping object .", "label": 0}, {"idx": "cosqa-train-17360", "doc": "get datatype of columns in python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 0}, {"idx": "cosqa-train-17361", "doc": "python is list or float", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 0}, {"idx": "cosqa-train-17362", "doc": "python flatten a dictionary of dictionaries", "code": "def flatten_multidict(multidict):\n    \"\"\"Return flattened dictionary from ``MultiDict``.\"\"\"\n    return dict([(key, value if len(value) > 1 else value[0])\n                 for (key, value) in multidict.iterlists()])", "code_tokens": "def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "docstring_tokens": "Return flattened dictionary from MultiDict .", "label": 0}, {"idx": "cosqa-train-17363", "doc": "create enum object from value python", "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum:\n    \"\"\"\n    Converts an ``dict`` to a ``Enum``.\n    \"\"\"\n    return enum_class[d['name']]", "code_tokens": "def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "docstring_tokens": "Converts an dict to a Enum .", "label": 0}, {"idx": "cosqa-train-17364", "doc": "how to check if a matrix is hermitian python", "code": "def almost_hermitian(gate: Gate) -> bool:\n    \"\"\"Return true if gate tensor is (almost) Hermitian\"\"\"\n    return np.allclose(asarray(gate.asoperator()),\n                       asarray(gate.H.asoperator()))", "code_tokens": "def almost_hermitian ( gate : Gate ) -> bool : return np . allclose ( asarray ( gate . asoperator ( ) ) , asarray ( gate . H . asoperator ( ) ) )", "docstring_tokens": "Return true if gate tensor is ( almost ) Hermitian", "label": 0}, {"idx": "cosqa-train-17365", "doc": "python xml elementtree remove node", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 0}, {"idx": "cosqa-train-17366", "doc": "normal distribution with n samples python", "code": "def sample_normal(mean, var, rng):\n    \"\"\"Sample from independent normal distributions\n\n    Each element is an independent normal distribution.\n\n    Parameters\n    ----------\n    mean : numpy.ndarray\n      Means of the normal distribution. Shape --> (batch_num, sample_dim)\n    var : numpy.ndarray\n      Variance of the normal distribution. Shape --> (batch_num, sample_dim)\n    rng : numpy.random.RandomState\n\n    Returns\n    -------\n    ret : numpy.ndarray\n       The sampling result. Shape --> (batch_num, sample_dim)\n    \"\"\"\n    ret = numpy.sqrt(var) * rng.randn(*mean.shape) + mean\n    return ret", "code_tokens": "def sample_normal ( mean , var , rng ) : ret = numpy . sqrt ( var ) * rng . randn ( * mean . shape ) + mean return ret", "docstring_tokens": "Sample from independent normal distributions", "label": 1}, {"idx": "cosqa-train-17367", "doc": "how to quickly ad hash to python", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 1}, {"idx": "cosqa-train-17368", "doc": "reading a file into a set python", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 0}, {"idx": "cosqa-train-17369", "doc": "pass function variable in timeit python", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 1}, {"idx": "cosqa-train-17370", "doc": "convrt dtypes to int in python", "code": "def to_int64(a):\n    \"\"\"Return view of the recarray with all int32 cast to int64.\"\"\"\n    # build new dtype and replace i4 --> i8\n    def promote_i4(typestr):\n        if typestr[1:] == 'i4':\n            typestr = typestr[0]+'i8'\n        return typestr\n\n    dtype = [(name, promote_i4(typestr)) for name,typestr in a.dtype.descr]\n    return a.astype(dtype)", "code_tokens": "def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )", "docstring_tokens": "Return view of the recarray with all int32 cast to int64 .", "label": 0}, {"idx": "cosqa-train-17371", "doc": "how to fetch one value from one row from mysql query in python", "code": "def fetchvalue(self, sql: str, *args) -> Optional[Any]:\n        \"\"\"Executes SQL; returns the first value of the first row, or None.\"\"\"\n        row = self.fetchone(sql, *args)\n        if row is None:\n            return None\n        return row[0]", "code_tokens": "def fetchvalue ( self , sql : str , * args ) -> Optional [ Any ] : row = self . fetchone ( sql , * args ) if row is None : return None return row [ 0 ]", "docstring_tokens": "Executes SQL ; returns the first value of the first row or None .", "label": 1}, {"idx": "cosqa-train-17372", "doc": "python null value dictionary", "code": "def inject_nulls(data: Mapping, field_names) -> dict:\n    \"\"\"Insert None as value for missing fields.\"\"\"\n\n    record = dict()\n\n    for field in field_names:\n        record[field] = data.get(field, None)\n\n    return record", "code_tokens": "def inject_nulls ( data : Mapping , field_names ) -> dict : record = dict ( ) for field in field_names : record [ field ] = data . get ( field , None ) return record", "docstring_tokens": "Insert None as value for missing fields .", "label": 0}, {"idx": "cosqa-train-17373", "doc": "how to remove columns from python data frame", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 0}, {"idx": "cosqa-train-17374", "doc": "update stale python 3 bytecode", "code": "def bytes_hack(buf):\n    \"\"\"\n    Hacky workaround for old installs of the library on systems without python-future that were\n    keeping the 2to3 update from working after auto-update.\n    \"\"\"\n    ub = None\n    if sys.version_info > (3,):\n        ub = buf\n    else:\n        ub = bytes(buf)\n\n    return ub", "code_tokens": "def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "docstring_tokens": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update .", "label": 0}, {"idx": "cosqa-train-17375", "doc": "finding all non alphanumeric characters in a string python", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 1}, {"idx": "cosqa-train-17376", "doc": "python read lines from file until next blank line", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-17377", "doc": "python check if path is valid", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 0}, {"idx": "cosqa-train-17378", "doc": "python pass argparse to main", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 0}, {"idx": "cosqa-train-17379", "doc": "setting bit fields with python", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 1}, {"idx": "cosqa-train-17380", "doc": "python if string matches return next lines", "code": "def grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''", "code_tokens": "def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "docstring_tokens": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .", "label": 0}, {"idx": "cosqa-train-17381", "doc": "how to flatten a list in a list in python", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 0}, {"idx": "cosqa-train-17382", "doc": "python how to mark as deprecated", "code": "def get_deprecation_reason(\n    node: Union[EnumValueDefinitionNode, FieldDefinitionNode]\n) -> Optional[str]:\n    \"\"\"Given a field or enum value node, get deprecation reason as string.\"\"\"\n    from ..execution import get_directive_values\n\n    deprecated = get_directive_values(GraphQLDeprecatedDirective, node)\n    return deprecated[\"reason\"] if deprecated else None", "code_tokens": "def get_deprecation_reason ( node : Union [ EnumValueDefinitionNode , FieldDefinitionNode ] ) -> Optional [ str ] : from . . execution import get_directive_values deprecated = get_directive_values ( GraphQLDeprecatedDirective , node ) return deprecated [ \"reason\" ] if deprecated else None", "docstring_tokens": "Given a field or enum value node get deprecation reason as string .", "label": 1}, {"idx": "cosqa-train-17383", "doc": "data type of python columns", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-17384", "doc": "return max length of string for list of strings python", "code": "def _prm_get_longest_stringsize(string_list):\n        \"\"\" Returns the longest string size for a string entry across data.\"\"\"\n        maxlength = 1\n\n        for stringar in string_list:\n            if isinstance(stringar, np.ndarray):\n                if stringar.ndim > 0:\n                    for string in stringar.ravel():\n                        maxlength = max(len(string), maxlength)\n                else:\n                    maxlength = max(len(stringar.tolist()), maxlength)\n            else:\n                maxlength = max(len(stringar), maxlength)\n\n        # Make the string Col longer than needed in order to allow later on slightly larger strings\n        return int(maxlength * 1.5)", "code_tokens": "def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "docstring_tokens": "Returns the longest string size for a string entry across data .", "label": 0}, {"idx": "cosqa-train-17385", "doc": "max value in a series in python", "code": "def first_location_of_maximum(x):\n    \"\"\"\n    Returns the first location of the maximum value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    if not isinstance(x, (np.ndarray, pd.Series)):\n        x = np.asarray(x)\n    return np.argmax(x) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def first_location_of_maximum ( x ) : if not isinstance ( x , ( np . ndarray , pd . Series ) ) : x = np . asarray ( x ) return np . argmax ( x ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the first location of the maximum value of x . The position is calculated relatively to the length of x .", "label": 1}, {"idx": "cosqa-train-17386", "doc": "to covert matrix to tensorflow in python", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 1}, {"idx": "cosqa-train-17387", "doc": "visualize dot file python", "code": "def cmd_dot(conf: Config):\n    \"\"\"Print out a neat targets dependency tree based on requested targets.\n\n    Use graphviz to render the dot file, e.g.:\n\n    > ybt dot :foo :bar | dot -Tpng -o graph.png\n    \"\"\"\n    build_context = BuildContext(conf)\n    populate_targets_graph(build_context, conf)\n    if conf.output_dot_file is None:\n        write_dot(build_context, conf, sys.stdout)\n    else:\n        with open(conf.output_dot_file, 'w') as out_file:\n            write_dot(build_context, conf, out_file)", "code_tokens": "def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "docstring_tokens": "Print out a neat targets dependency tree based on requested targets .", "label": 1}, {"idx": "cosqa-train-17388", "doc": "python check if a value is in an enum", "code": "def has_value(cls, value: int) -> bool:\n        \"\"\"True if specified value exists in int enum; otherwise, False.\"\"\"\n        return any(value == item.value for item in cls)", "code_tokens": "def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "docstring_tokens": "True if specified value exists in int enum ; otherwise False .", "label": 0}, {"idx": "cosqa-train-17389", "doc": "how to get the last index of something python", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 1}, {"idx": "cosqa-train-17390", "doc": "how to manually skip a line in python", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 0}, {"idx": "cosqa-train-17391", "doc": "python call post api data dict data", "code": "def post(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP POST operation to API endpoint.\"\"\"\n\n        return self._request('POST', endpoint, **kwargs)", "code_tokens": "def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "docstring_tokens": "HTTP POST operation to API endpoint .", "label": 1}, {"idx": "cosqa-train-17392", "doc": "how to go back to the previous line in python", "code": "def auto_up(self, count=1, go_to_start_of_line_if_history_changes=False):\n        \"\"\"\n        If we're not on the first line (of a multiline input) go a line up,\n        otherwise go back in history. (If nothing is selected.)\n        \"\"\"\n        if self.complete_state:\n            self.complete_previous(count=count)\n        elif self.document.cursor_position_row > 0:\n            self.cursor_up(count=count)\n        elif not self.selection_state:\n            self.history_backward(count=count)\n\n            # Go to the start of the line?\n            if go_to_start_of_line_if_history_changes:\n                self.cursor_position += self.document.get_start_of_line_position()", "code_tokens": "def auto_up ( self , count = 1 , go_to_start_of_line_if_history_changes = False ) : if self . complete_state : self . complete_previous ( count = count ) elif self . document . cursor_position_row > 0 : self . cursor_up ( count = count ) elif not self . selection_state : self . history_backward ( count = count ) # Go to the start of the line? if go_to_start_of_line_if_history_changes : self . cursor_position += self . document . get_start_of_line_position ( )", "docstring_tokens": "If we re not on the first line ( of a multiline input ) go a line up otherwise go back in history . ( If nothing is selected . )", "label": 0}, {"idx": "cosqa-train-17393", "doc": "python ndarray make zero array", "code": "def to_0d_array(value: Any) -> np.ndarray:\n    \"\"\"Given a value, wrap it in a 0-D numpy.ndarray.\n    \"\"\"\n    if np.isscalar(value) or (isinstance(value, np.ndarray) and\n                              value.ndim == 0):\n        return np.array(value)\n    else:\n        return to_0d_object_array(value)", "code_tokens": "def to_0d_array ( value : Any ) -> np . ndarray : if np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and value . ndim == 0 ) : return np . array ( value ) else : return to_0d_object_array ( value )", "docstring_tokens": "Given a value wrap it in a 0 - D numpy . ndarray .", "label": 0}, {"idx": "cosqa-train-17394", "doc": "greatest common divisor function in python", "code": "def gcd_float(numbers, tol=1e-8):\n    \"\"\"\n    Returns the greatest common divisor for a sequence of numbers.\n    Uses a numerical tolerance, so can be used on floats\n\n    Args:\n        numbers: Sequence of numbers.\n        tol: Numerical tolerance\n\n    Returns:\n        (int) Greatest common divisor of numbers.\n    \"\"\"\n\n    def pair_gcd_tol(a, b):\n        \"\"\"Calculate the Greatest Common Divisor of a and b.\n\n        Unless b==0, the result will have the same sign as b (so that when\n        b is divided by it, the result comes out positive).\n        \"\"\"\n        while b > tol:\n            a, b = b, a % b\n        return a\n\n    n = numbers[0]\n    for i in numbers:\n        n = pair_gcd_tol(n, i)\n    return n", "code_tokens": "def gcd_float ( numbers , tol = 1e-8 ) : def pair_gcd_tol ( a , b ) : \"\"\"Calculate the Greatest Common Divisor of a and b.\n\n        Unless b==0, the result will have the same sign as b (so that when\n        b is divided by it, the result comes out positive).\n        \"\"\" while b > tol : a , b = b , a % b return a n = numbers [ 0 ] for i in numbers : n = pair_gcd_tol ( n , i ) return n", "docstring_tokens": "Returns the greatest common divisor for a sequence of numbers . Uses a numerical tolerance so can be used on floats", "label": 1}, {"idx": "cosqa-train-17395", "doc": "python generate hash from list", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 0}, {"idx": "cosqa-train-17396", "doc": "array to tensor tf python", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 0}, {"idx": "cosqa-train-17397", "doc": "how do you check if a data frame has null values python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-17398", "doc": "python main function argparse", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 0}, {"idx": "cosqa-train-17399", "doc": "python elementwise product vector and matrix", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 1}, {"idx": "cosqa-train-17400", "doc": "python split a string to a tuple", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 0}, {"idx": "cosqa-train-17401", "doc": "how i check dimensions image python", "code": "def calculate_dimensions(image, long_side, short_side):\n    \"\"\"Returns the thumbnail dimensions depending on the images format.\"\"\"\n    if image.width >= image.height:\n        return '{0}x{1}'.format(long_side, short_side)\n    return '{0}x{1}'.format(short_side, long_side)", "code_tokens": "def calculate_dimensions ( image , long_side , short_side ) : if image . width >= image . height : return '{0}x{1}' . format ( long_side , short_side ) return '{0}x{1}' . format ( short_side , long_side )", "docstring_tokens": "Returns the thumbnail dimensions depending on the images format .", "label": 1}, {"idx": "cosqa-train-17402", "doc": "how to capitalize first item in list python", "code": "def fmt_camel(name):\n    \"\"\"\n    Converts name to lower camel case. Words are identified by capitalization,\n    dashes, and underscores.\n    \"\"\"\n    words = split_words(name)\n    assert len(words) > 0\n    first = words.pop(0).lower()\n    return first + ''.join([word.capitalize() for word in words])", "code_tokens": "def fmt_camel ( name ) : words = split_words ( name ) assert len ( words ) > 0 first = words . pop ( 0 ) . lower ( ) return first + '' . join ( [ word . capitalize ( ) for word in words ] )", "docstring_tokens": "Converts name to lower camel case . Words are identified by capitalization dashes and underscores .", "label": 1}, {"idx": "cosqa-train-17403", "doc": "python how to determine file is pdf type", "code": "def from_file(filename, mime=False):\n    \"\"\"\"\n    Accepts a filename and returns the detected filetype.  Return\n    value is the mimetype if mime=True, otherwise a human readable\n    name.\n\n    >>> magic.from_file(\"testdata/test.pdf\", mime=True)\n    'application/pdf'\n    \"\"\"\n    m = _get_magic_type(mime)\n    return m.from_file(filename)", "code_tokens": "def from_file ( filename , mime = False ) : m = _get_magic_type ( mime ) return m . from_file ( filename )", "docstring_tokens": "Accepts a filename and returns the detected filetype . Return value is the mimetype if mime = True otherwise a human readable name .", "label": 0}, {"idx": "cosqa-train-17404", "doc": "python change list of int to string", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 0}, {"idx": "cosqa-train-17405", "doc": "cast str as int in python", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-17406", "doc": "remove columns from df python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 0}, {"idx": "cosqa-train-17407", "doc": "how to make a comma seprated list into a one string in python", "code": "def list_to_str(lst):\n    \"\"\"\n    Turn a list into a comma- and/or and-separated string.\n\n    Parameters\n    ----------\n    lst : :obj:`list`\n        A list of strings to join into a single string.\n\n    Returns\n    -------\n    str_ : :obj:`str`\n        A string with commas and/or ands separating th elements from ``lst``.\n\n    \"\"\"\n    if len(lst) == 1:\n        str_ = lst[0]\n    elif len(lst) == 2:\n        str_ = ' and '.join(lst)\n    elif len(lst) > 2:\n        str_ = ', '.join(lst[:-1])\n        str_ += ', and {0}'.format(lst[-1])\n    else:\n        raise ValueError('List of length 0 provided.')\n    return str_", "code_tokens": "def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "docstring_tokens": "Turn a list into a comma - and / or and - separated string .", "label": 0}, {"idx": "cosqa-train-17408", "doc": "using a for loop to evaluate the first index in a list python", "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:\n    \"\"\"\n    Finds the index of an item in list, which satisfies predicate\n    :param predicateFn: predicate function to run on items of list\n    :param items: list of tuples\n    :return: first index for which predicate function returns True\n    \"\"\"\n    try:\n        return next(i for i, v in enumerate(items) if predicateFn(v))\n    except StopIteration:\n        return -1", "code_tokens": "def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "docstring_tokens": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True", "label": 0}, {"idx": "cosqa-train-17409", "doc": "how to check all items in an array python", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 1}, {"idx": "cosqa-train-17410", "doc": "python match single or double quoted strings", "code": "def is_quoted(arg: str) -> bool:\n    \"\"\"\n    Checks if a string is quoted\n    :param arg: the string being checked for quotes\n    :return: True if a string is quoted\n    \"\"\"\n    return len(arg) > 1 and arg[0] == arg[-1] and arg[0] in constants.QUOTES", "code_tokens": "def is_quoted ( arg : str ) -> bool : return len ( arg ) > 1 and arg [ 0 ] == arg [ - 1 ] and arg [ 0 ] in constants . QUOTES", "docstring_tokens": "Checks if a string is quoted : param arg : the string being checked for quotes : return : True if a string is quoted", "label": 1}, {"idx": "cosqa-train-17411", "doc": "detect language to english python", "code": "def get_language():\n    \"\"\"\n    Wrapper around Django's `get_language` utility.\n    For Django >= 1.8, `get_language` returns None in case no translation is activate.\n    Here we patch this behavior e.g. for back-end functionality requiring access to translated fields\n    \"\"\"\n    from parler import appsettings\n    language = dj_get_language()\n    if language is None and appsettings.PARLER_DEFAULT_ACTIVATE:\n        return appsettings.PARLER_DEFAULT_LANGUAGE_CODE\n    else:\n        return language", "code_tokens": "def get_language ( ) : from parler import appsettings language = dj_get_language ( ) if language is None and appsettings . PARLER_DEFAULT_ACTIVATE : return appsettings . PARLER_DEFAULT_LANGUAGE_CODE else : return language", "docstring_tokens": "Wrapper around Django s get_language utility . For Django > = 1 . 8 get_language returns None in case no translation is activate . Here we patch this behavior e . g . for back - end functionality requiring access to translated fields", "label": 1}, {"idx": "cosqa-train-17412", "doc": "python check a sting is all alpha", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-17413", "doc": "python get a specific format file name", "code": "def infer_format(filename:str) -> str:\n    \"\"\"Return extension identifying format of given filename\"\"\"\n    _, ext = os.path.splitext(filename)\n    return ext", "code_tokens": "def infer_format ( filename : str ) -> str : _ , ext = os . path . splitext ( filename ) return ext", "docstring_tokens": "Return extension identifying format of given filename", "label": 0}, {"idx": "cosqa-train-17414", "doc": "python limit the execution time of the given functio", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 1}, {"idx": "cosqa-train-17415", "doc": "how to set conda and python path in windows", "code": "def _find_conda():\n    \"\"\"Find the conda executable robustly across conda versions.\n\n    Returns\n    -------\n    conda : str\n        Path to the conda executable.\n\n    Raises\n    ------\n    IOError\n        If the executable cannot be found in either the CONDA_EXE environment\n        variable or in the PATH.\n\n    Notes\n    -----\n    In POSIX platforms in conda >= 4.4, conda can be set up as a bash function\n    rather than an executable. (This is to enable the syntax\n    ``conda activate env-name``.) In this case, the environment variable\n    ``CONDA_EXE`` contains the path to the conda executable. In other cases,\n    we use standard search for the appropriate name in the PATH.\n\n    See https://github.com/airspeed-velocity/asv/issues/645 for more details.\n    \"\"\"\n    if 'CONDA_EXE' in os.environ:\n        conda = os.environ['CONDA_EXE']\n    else:\n        conda = util.which('conda')\n    return conda", "code_tokens": "def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda", "docstring_tokens": "Find the conda executable robustly across conda versions .", "label": 1}, {"idx": "cosqa-train-17416", "doc": "how to print something x amount of times in python on the same line", "code": "def nTimes(n, f, *args, **kwargs):\n    r\"\"\"Call `f` `n` times with `args` and `kwargs`.\n    Useful e.g. for simplistic timing.\n\n    Examples:\n\n    >>> nTimes(3, sys.stdout.write, 'hallo\\n')\n    hallo\n    hallo\n    hallo\n\n    \"\"\"\n    for i in xrange(n): f(*args, **kwargs)", "code_tokens": "def nTimes ( n , f , * args , * * kwargs ) : for i in xrange ( n ) : f ( * args , * * kwargs )", "docstring_tokens": "r Call f n times with args and kwargs . Useful e . g . for simplistic timing .", "label": 1}, {"idx": "cosqa-train-17417", "doc": "how to get accuracy percentage in python mlp", "code": "def elmo_loss2ppl(losses: List[np.ndarray]) -> float:\n    \"\"\" Calculates perplexity by loss\n\n    Args:\n        losses: list of numpy arrays of model losses\n\n    Returns:\n        perplexity : float\n    \"\"\"\n    avg_loss = np.mean(losses)\n    return float(np.exp(avg_loss))", "code_tokens": "def elmo_loss2ppl ( losses : List [ np . ndarray ] ) -> float : avg_loss = np . mean ( losses ) return float ( np . exp ( avg_loss ) )", "docstring_tokens": "Calculates perplexity by loss", "label": 1}, {"idx": "cosqa-train-17418", "doc": "python build url with query string", "code": "def url_concat(url, args):\n    \"\"\"Concatenate url and argument dictionary regardless of whether\n    url has existing query parameters.\n\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    \"\"\"\n    if not args: return url\n    if url[-1] not in ('?', '&'):\n        url += '&' if ('?' in url) else '?'\n    return url + urllib.urlencode(args)", "code_tokens": "def url_concat ( url , args ) : if not args : return url if url [ - 1 ] not in ( '?' , '&' ) : url += '&' if ( '?' in url ) else '?' return url + urllib . urlencode ( args )", "docstring_tokens": "Concatenate url and argument dictionary regardless of whether url has existing query parameters .", "label": 0}, {"idx": "cosqa-train-17419", "doc": "how to open spyder 3 on python 3", "code": "def get_versions(reporev=True):\n    \"\"\"Get version information for components used by Spyder\"\"\"\n    import sys\n    import platform\n\n    import qtpy\n    import qtpy.QtCore\n\n    revision = None\n    if reporev:\n        from spyder.utils import vcs\n        revision, branch = vcs.get_git_revision(os.path.dirname(__dir__))\n\n    if not sys.platform == 'darwin':  # To avoid a crash with our Mac app\n        system = platform.system()\n    else:\n        system = 'Darwin'\n\n    return {\n        'spyder': __version__,\n        'python': platform.python_version(),  # \"2.7.3\"\n        'bitness': 64 if sys.maxsize > 2**32 else 32,\n        'qt': qtpy.QtCore.__version__,\n        'qt_api': qtpy.API_NAME,      # PyQt5\n        'qt_api_ver': qtpy.PYQT_VERSION,\n        'system': system,   # Linux, Windows, ...\n        'release': platform.release(),  # XP, 10.6, 2.2.0, etc.\n        'revision': revision,  # '9fdf926eccce'\n    }", "code_tokens": "def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "docstring_tokens": "Get version information for components used by Spyder", "label": 0}, {"idx": "cosqa-train-17420", "doc": "check if 2 strings are same python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 0}, {"idx": "cosqa-train-17421", "doc": "python finding the first location of a character in a string", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 0}, {"idx": "cosqa-train-17422", "doc": "python read csv to a numpy nd array", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 0}, {"idx": "cosqa-train-17423", "doc": "count occurrences in a list python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 0}, {"idx": "cosqa-train-17424", "doc": "python 3 check if string is int", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-17425", "doc": "width of bins python histogram", "code": "def shape(self) -> Tuple[int, ...]:\n        \"\"\"Shape of histogram's data.\n\n        Returns\n        -------\n        One-element tuple with the number of bins along each axis.\n        \"\"\"\n        return tuple(bins.bin_count for bins in self._binnings)", "code_tokens": "def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )", "docstring_tokens": "Shape of histogram s data .", "label": 0}, {"idx": "cosqa-train-17426", "doc": "10 largest values from dictionary python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 0}, {"idx": "cosqa-train-17427", "doc": "python 3 create a set with size limit", "code": "def pset(iterable=(), pre_size=8):\n    \"\"\"\n    Creates a persistent set from iterable. Optionally takes a sizing parameter equivalent to that\n    used for :py:func:`pmap`.\n\n    >>> s1 = pset([1, 2, 3, 2])\n    >>> s1\n    pset([1, 2, 3])\n    \"\"\"\n    if not iterable:\n        return _EMPTY_PSET\n\n    return PSet._from_iterable(iterable, pre_size=pre_size)", "code_tokens": "def pset ( iterable = ( ) , pre_size = 8 ) : if not iterable : return _EMPTY_PSET return PSet . _from_iterable ( iterable , pre_size = pre_size )", "docstring_tokens": "Creates a persistent set from iterable . Optionally takes a sizing parameter equivalent to that used for : py : func : pmap .", "label": 0}, {"idx": "cosqa-train-17428", "doc": "cv2 python brightness hsv", "code": "def hsv2rgb_spectrum(hsv):\n    \"\"\"Generates RGB values from HSV values in line with a typical light\n    spectrum.\"\"\"\n    h, s, v = hsv\n    return hsv2rgb_raw(((h * 192) >> 8, s, v))", "code_tokens": "def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "docstring_tokens": "Generates RGB values from HSV values in line with a typical light spectrum .", "label": 0}, {"idx": "cosqa-train-17429", "doc": "python call post rest service", "code": "def post(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP POST operation to API endpoint.\"\"\"\n\n        return self._request('POST', endpoint, **kwargs)", "code_tokens": "def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "docstring_tokens": "HTTP POST operation to API endpoint .", "label": 0}, {"idx": "cosqa-train-17430", "doc": "how to remove chinesse characters from a hypertext in a string python", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 1}, {"idx": "cosqa-train-17431", "doc": "python list feilds of json array]", "code": "def __as_list(value: List[JsonObjTypes]) -> List[JsonTypes]:\n        \"\"\" Return a json array as a list\n\n        :param value: array\n        :return: array with JsonObj instances removed\n        \"\"\"\n        return [e._as_dict if isinstance(e, JsonObj) else e for e in value]", "code_tokens": "def __as_list ( value : List [ JsonObjTypes ] ) -> List [ JsonTypes ] : return [ e . _as_dict if isinstance ( e , JsonObj ) else e for e in value ]", "docstring_tokens": "Return a json array as a list", "label": 1}, {"idx": "cosqa-train-17432", "doc": "patch a dictionary that values are method calls python", "code": "def __add_method(m: lmap.Map, key: T, method: Method) -> lmap.Map:\n        \"\"\"Swap the methods atom to include method with key.\"\"\"\n        return m.assoc(key, method)", "code_tokens": "def __add_method ( m : lmap . Map , key : T , method : Method ) -> lmap . Map : return m . assoc ( key , method )", "docstring_tokens": "Swap the methods atom to include method with key .", "label": 1}, {"idx": "cosqa-train-17433", "doc": "python test if file empty", "code": "def isfile_notempty(inputfile: str) -> bool:\n        \"\"\"Check if the input filename with path is a file and is not empty.\"\"\"\n        try:\n            return isfile(inputfile) and getsize(inputfile) > 0\n        except TypeError:\n            raise TypeError('inputfile is not a valid type')", "code_tokens": "def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )", "docstring_tokens": "Check if the input filename with path is a file and is not empty .", "label": 0}, {"idx": "cosqa-train-17434", "doc": "python change to 64 bit", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 1}, {"idx": "cosqa-train-17435", "doc": "python generator' object has no attribute", "code": "def __iter__(self):\n        \"\"\"Define a generator function and return it\"\"\"\n        def generator():\n            for i, obj in enumerate(self._sequence):\n                if i >= self._limit:\n                    break\n                yield obj\n            raise StopIteration\n        return generator", "code_tokens": "def __iter__ ( self ) : def generator ( ) : for i , obj in enumerate ( self . _sequence ) : if i >= self . _limit : break yield obj raise StopIteration return generator", "docstring_tokens": "Define a generator function and return it", "label": 0}, {"idx": "cosqa-train-17436", "doc": "python form validation numbers only", "code": "def clean_int(x) -> int:\n    \"\"\"\n    Returns its parameter as an integer, or raises\n    ``django.forms.ValidationError``.\n    \"\"\"\n    try:\n        return int(x)\n    except ValueError:\n        raise forms.ValidationError(\n            \"Cannot convert to integer: {}\".format(repr(x)))", "code_tokens": "def clean_int ( x ) -> int : try : return int ( x ) except ValueError : raise forms . ValidationError ( \"Cannot convert to integer: {}\" . format ( repr ( x ) ) )", "docstring_tokens": "Returns its parameter as an integer or raises django . forms . ValidationError .", "label": 0}, {"idx": "cosqa-train-17437", "doc": "python iterating through delimited text file that has no line breaks", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-17438", "doc": "how to check if i have 32 or 64 bit python", "code": "def check64bit(current_system=\"python\"):\n    \"\"\"checks if you are on a 64 bit platform\"\"\"\n    if current_system == \"python\":\n        return sys.maxsize > 2147483647\n    elif current_system == \"os\":\n        import platform\n        pm = platform.machine()\n        if pm != \"..\" and pm.endswith('64'):  # recent Python (not Iron)\n            return True\n        else:\n            if 'PROCESSOR_ARCHITEW6432' in os.environ:\n                return True  # 32 bit program running on 64 bit Windows\n            try:\n                # 64 bit Windows 64 bit program\n                return os.environ['PROCESSOR_ARCHITECTURE'].endswith('64')\n            except IndexError:\n                pass  # not Windows\n            try:\n                # this often works in Linux\n                return '64' in platform.architecture()[0]\n            except Exception:\n                # is an older version of Python, assume also an older os@\n                # (best we can guess)\n                return False", "code_tokens": "def check64bit ( current_system = \"python\" ) : if current_system == \"python\" : return sys . maxsize > 2147483647 elif current_system == \"os\" : import platform pm = platform . machine ( ) if pm != \"..\" and pm . endswith ( '64' ) : # recent Python (not Iron) return True else : if 'PROCESSOR_ARCHITEW6432' in os . environ : return True # 32 bit program running on 64 bit Windows try : # 64 bit Windows 64 bit program return os . environ [ 'PROCESSOR_ARCHITECTURE' ] . endswith ( '64' ) except IndexError : pass # not Windows try : # this often works in Linux return '64' in platform . architecture ( ) [ 0 ] except Exception : # is an older version of Python, assume also an older os@ # (best we can guess) return False", "docstring_tokens": "checks if you are on a 64 bit platform", "label": 0}, {"idx": "cosqa-train-17439", "doc": "python2 string to byte array", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 0}, {"idx": "cosqa-train-17440", "doc": "python skip current line", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 0}, {"idx": "cosqa-train-17441", "doc": "pythonconvert list of strings to int", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-17442", "doc": "python check if value is infinity", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 1}, {"idx": "cosqa-train-17443", "doc": "how to make a string of an object in python", "code": "def format_repr(obj, attributes) -> str:\n    \"\"\"Format an object's repr method with specific attributes.\"\"\"\n\n    attribute_repr = ', '.join(('{}={}'.format(attr, repr(getattr(obj, attr)))\n                                for attr in attributes))\n    return \"{0}({1})\".format(obj.__class__.__qualname__, attribute_repr)", "code_tokens": "def format_repr ( obj , attributes ) -> str : attribute_repr = ', ' . join ( ( '{}={}' . format ( attr , repr ( getattr ( obj , attr ) ) ) for attr in attributes ) ) return \"{0}({1})\" . format ( obj . __class__ . __qualname__ , attribute_repr )", "docstring_tokens": "Format an object s repr method with specific attributes .", "label": 0}, {"idx": "cosqa-train-17444", "doc": "python tensorflow read text file", "code": "def _read_words(filename):\n  \"\"\"Reads words from a file.\"\"\"\n  with tf.gfile.GFile(filename, \"r\") as f:\n    if sys.version_info[0] >= 3:\n      return f.read().replace(\"\\n\", \" %s \" % EOS).split()\n    else:\n      return f.read().decode(\"utf-8\").replace(\"\\n\", \" %s \" % EOS).split()", "code_tokens": "def _read_words ( filename ) : with tf . gfile . GFile ( filename , \"r\" ) as f : if sys . version_info [ 0 ] >= 3 : return f . read ( ) . replace ( \"\\n\" , \" %s \" % EOS ) . split ( ) else : return f . read ( ) . decode ( \"utf-8\" ) . replace ( \"\\n\" , \" %s \" % EOS ) . split ( )", "docstring_tokens": "Reads words from a file .", "label": 0}, {"idx": "cosqa-train-17445", "doc": "hash function generates fixed length code in python", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 1}, {"idx": "cosqa-train-17446", "doc": "python 16bit list to bytearray", "code": "def u16le_list_to_byte_list(data):\n    \"\"\"! @brief Convert a halfword array into a byte array\"\"\"\n    byteData = []\n    for h in data:\n        byteData.extend([h & 0xff, (h >> 8) & 0xff])\n    return byteData", "code_tokens": "def u16le_list_to_byte_list ( data ) : byteData = [ ] for h in data : byteData . extend ( [ h & 0xff , ( h >> 8 ) & 0xff ] ) return byteData", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-17447", "doc": "python detect keypress hardware", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 0}, {"idx": "cosqa-train-17448", "doc": "how to turn python list into an array", "code": "def listify(a):\n    \"\"\"\n    Convert a scalar ``a`` to a list and all iterables to list as well.\n\n    Examples\n    --------\n    >>> listify(0)\n    [0]\n\n    >>> listify([1,2,3])\n    [1, 2, 3]\n\n    >>> listify('a')\n    ['a']\n\n    >>> listify(np.array([1,2,3]))\n    [1, 2, 3]\n\n    >>> listify('string')\n    ['string']\n    \"\"\"\n    if a is None:\n        return []\n    elif not isinstance(a, (tuple, list, np.ndarray)):\n        return [a]\n    return list(a)", "code_tokens": "def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "docstring_tokens": "Convert a scalar a to a list and all iterables to list as well .", "label": 0}, {"idx": "cosqa-train-17449", "doc": "python sort the files according to the change time", "code": "def sort_by_modified(files_or_folders: list) -> list:\n    \"\"\"\n    Sort files or folders by modified time\n\n    Args:\n        files_or_folders: list of files or folders\n\n    Returns:\n        list\n    \"\"\"\n    return sorted(files_or_folders, key=os.path.getmtime, reverse=True)", "code_tokens": "def sort_by_modified ( files_or_folders : list ) -> list : return sorted ( files_or_folders , key = os . path . getmtime , reverse = True )", "docstring_tokens": "Sort files or folders by modified time", "label": 0}, {"idx": "cosqa-train-17450", "doc": "to know curremt position of file cursor the function use in python", "code": "def position(self) -> Position:\n        \"\"\"The current position of the cursor.\"\"\"\n        return Position(self._index, self._lineno, self._col_offset)", "code_tokens": "def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "docstring_tokens": "The current position of the cursor .", "label": 0}, {"idx": "cosqa-train-17451", "doc": "how to get pylint ot work for python 3", "code": "def lint(fmt='colorized'):\n    \"\"\"Run verbose PyLint on source. Optionally specify fmt=html for HTML output.\"\"\"\n    if fmt == 'html':\n        outfile = 'pylint_report.html'\n        local('pylint -f %s davies > %s || true' % (fmt, outfile))\n        local('open %s' % outfile)\n    else:\n        local('pylint -f %s davies || true' % fmt)", "code_tokens": "def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "docstring_tokens": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output .", "label": 0}, {"idx": "cosqa-train-17452", "doc": "how to remove data columns in python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 0}, {"idx": "cosqa-train-17453", "doc": "python check if path is directory or file", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-17454", "doc": "generation of random numbers with given mean, sd, min and max value python", "code": "def _gauss(mean: int, sigma: int) -> int:\n        \"\"\"\n        Creates a variation from a base value\n\n        Args:\n            mean: base value\n            sigma: gaussian sigma\n\n        Returns: random value\n\n        \"\"\"\n        return int(random.gauss(mean, sigma))", "code_tokens": "def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "docstring_tokens": "Creates a variation from a base value", "label": 1}, {"idx": "cosqa-train-17455", "doc": "split each sentence token and stoe in list using python", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 1}, {"idx": "cosqa-train-17456", "doc": "how to extract the number that appears the most frequently in a list in python", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 0}, {"idx": "cosqa-train-17457", "doc": "python delete glob files", "code": "def rmglob(pattern: str) -> None:\n    \"\"\"\n    Deletes all files whose filename matches the glob ``pattern`` (via\n    :func:`glob.glob`).\n    \"\"\"\n    for f in glob.glob(pattern):\n        os.remove(f)", "code_tokens": "def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "docstring_tokens": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .", "label": 0}, {"idx": "cosqa-train-17458", "doc": "how can i cast a string in int python", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-17459", "doc": "how to delete quotes in python so that the string will turn into a tuple", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 0}, {"idx": "cosqa-train-17460", "doc": "how toget all the column names in a database python", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 1}, {"idx": "cosqa-train-17461", "doc": "last weekday of month in python", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 0}, {"idx": "cosqa-train-17462", "doc": "python random number with gaussian distribution", "code": "def _gauss(mean: int, sigma: int) -> int:\n        \"\"\"\n        Creates a variation from a base value\n\n        Args:\n            mean: base value\n            sigma: gaussian sigma\n\n        Returns: random value\n\n        \"\"\"\n        return int(random.gauss(mean, sigma))", "code_tokens": "def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "docstring_tokens": "Creates a variation from a base value", "label": 1}, {"idx": "cosqa-train-17463", "doc": "extract first row froma table in python sql", "code": "def fetchallfirstvalues(self, sql: str, *args) -> List[Any]:\n        \"\"\"Executes SQL; returns list of first values of each row.\"\"\"\n        rows = self.fetchall(sql, *args)\n        return [row[0] for row in rows]", "code_tokens": "def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "docstring_tokens": "Executes SQL ; returns list of first values of each row .", "label": 1}, {"idx": "cosqa-train-17464", "doc": "python long tensor to float tensor", "code": "def fcast(value: float) -> TensorLike:\n    \"\"\"Cast to float tensor\"\"\"\n    newvalue = tf.cast(value, FTYPE)\n    if DEVICE == 'gpu':\n        newvalue = newvalue.gpu()  # Why is this needed?  # pragma: no cover\n    return newvalue", "code_tokens": "def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "docstring_tokens": "Cast to float tensor", "label": 0}, {"idx": "cosqa-train-17465", "doc": "python write a list indent line", "code": "def PrintIndented(self, file, ident, code):\n        \"\"\"Takes an array, add indentation to each entry and prints it.\"\"\"\n        for entry in code:\n            print >>file, '%s%s' % (ident, entry)", "code_tokens": "def PrintIndented ( self , file , ident , code ) : for entry in code : print >> file , '%s%s' % ( ident , entry )", "docstring_tokens": "Takes an array add indentation to each entry and prints it .", "label": 0}, {"idx": "cosqa-train-17466", "doc": "how to a truncate decimals in python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 1}, {"idx": "cosqa-train-17467", "doc": "python new dictionary using old key", "code": "def replace_keys(record: Mapping, key_map: Mapping) -> dict:\n    \"\"\"New record with renamed keys including keys only found in key_map.\"\"\"\n\n    return {key_map[k]: v for k, v in record.items() if k in key_map}", "code_tokens": "def replace_keys ( record : Mapping , key_map : Mapping ) -> dict : return { key_map [ k ] : v for k , v in record . items ( ) if k in key_map }", "docstring_tokens": "New record with renamed keys including keys only found in key_map .", "label": 1}, {"idx": "cosqa-train-17468", "doc": "sort files based on modified time on python", "code": "def sort_by_modified(files_or_folders: list) -> list:\n    \"\"\"\n    Sort files or folders by modified time\n\n    Args:\n        files_or_folders: list of files or folders\n\n    Returns:\n        list\n    \"\"\"\n    return sorted(files_or_folders, key=os.path.getmtime, reverse=True)", "code_tokens": "def sort_by_modified ( files_or_folders : list ) -> list : return sorted ( files_or_folders , key = os . path . getmtime , reverse = True )", "docstring_tokens": "Sort files or folders by modified time", "label": 0}, {"idx": "cosqa-train-17469", "doc": "python print tree values", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-17470", "doc": "python check for files edited within time", "code": "def has_changed (filename):\n    \"\"\"Check if filename has changed since the last check. If this\n    is the first check, assume the file is changed.\"\"\"\n    key = os.path.abspath(filename)\n    mtime = get_mtime(key)\n    if key not in _mtime_cache:\n        _mtime_cache[key] = mtime\n        return True\n    return mtime > _mtime_cache[key]", "code_tokens": "def has_changed ( filename ) : key = os . path . abspath ( filename ) mtime = get_mtime ( key ) if key not in _mtime_cache : _mtime_cache [ key ] = mtime return True return mtime > _mtime_cache [ key ]", "docstring_tokens": "Check if filename has changed since the last check . If this is the first check assume the file is changed .", "label": 1}, {"idx": "cosqa-train-17471", "doc": "max elemet in a column python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 0}, {"idx": "cosqa-train-17472", "doc": "python underscore line above", "code": "def lower_camel_case_from_underscores(string):\n    \"\"\"generate a lower-cased camelCase string from an underscore_string.\n    For example: my_variable_name -> myVariableName\"\"\"\n    components = string.split('_')\n    string = components[0]\n    for component in components[1:]:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName", "label": 0}, {"idx": "cosqa-train-17473", "doc": "python3 from str to bytes", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 1}, {"idx": "cosqa-train-17474", "doc": "python flask cap memory limit", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 1}, {"idx": "cosqa-train-17475", "doc": "using dot file with python graphviz", "code": "def cmd_dot(conf: Config):\n    \"\"\"Print out a neat targets dependency tree based on requested targets.\n\n    Use graphviz to render the dot file, e.g.:\n\n    > ybt dot :foo :bar | dot -Tpng -o graph.png\n    \"\"\"\n    build_context = BuildContext(conf)\n    populate_targets_graph(build_context, conf)\n    if conf.output_dot_file is None:\n        write_dot(build_context, conf, sys.stdout)\n    else:\n        with open(conf.output_dot_file, 'w') as out_file:\n            write_dot(build_context, conf, out_file)", "code_tokens": "def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "docstring_tokens": "Print out a neat targets dependency tree based on requested targets .", "label": 1}, {"idx": "cosqa-train-17476", "doc": "substring string indices must be integers python", "code": "def valid_substitution(strlen, index):\n    \"\"\"\n    skip performing substitutions that are outside the bounds of the string\n    \"\"\"\n    values = index[0]\n    return all([strlen > i for i in values])", "code_tokens": "def valid_substitution ( strlen , index ) : values = index [ 0 ] return all ( [ strlen > i for i in values ] )", "docstring_tokens": "skip performing substitutions that are outside the bounds of the string", "label": 0}, {"idx": "cosqa-train-17477", "doc": "python test if array contains an element", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 1}, {"idx": "cosqa-train-17478", "doc": "python tuple dict key to nested dict", "code": "def flatten_multidict(multidict):\n    \"\"\"Return flattened dictionary from ``MultiDict``.\"\"\"\n    return dict([(key, value if len(value) > 1 else value[0])\n                 for (key, value) in multidict.iterlists()])", "code_tokens": "def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "docstring_tokens": "Return flattened dictionary from MultiDict .", "label": 0}, {"idx": "cosqa-train-17479", "doc": "python detect alpha characters in string", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-17480", "doc": "how to check for invalid whitespace in python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 1}, {"idx": "cosqa-train-17481", "doc": "how to generate random numbers on normal distribution with python", "code": "def _gauss(mean: int, sigma: int) -> int:\n        \"\"\"\n        Creates a variation from a base value\n\n        Args:\n            mean: base value\n            sigma: gaussian sigma\n\n        Returns: random value\n\n        \"\"\"\n        return int(random.gauss(mean, sigma))", "code_tokens": "def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "docstring_tokens": "Creates a variation from a base value", "label": 0}, {"idx": "cosqa-train-17482", "doc": "threading multiple asyncrous python threads in teststand", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 0}, {"idx": "cosqa-train-17483", "doc": "replace in for loop from a string using python", "code": "def replace_in_list(stringlist: Iterable[str],\n                    replacedict: Dict[str, str]) -> List[str]:\n    \"\"\"\n    Returns a list produced by applying :func:`multiple_replace` to every\n    string in ``stringlist``.\n\n    Args:\n        stringlist: list of source strings\n        replacedict: dictionary mapping \"original\" to \"replacement\" strings\n\n    Returns:\n        list of final strings\n\n    \"\"\"\n    newlist = []\n    for fromstring in stringlist:\n        newlist.append(multiple_replace(fromstring, replacedict))\n    return newlist", "code_tokens": "def replace_in_list ( stringlist : Iterable [ str ] , replacedict : Dict [ str , str ] ) -> List [ str ] : newlist = [ ] for fromstring in stringlist : newlist . append ( multiple_replace ( fromstring , replacedict ) ) return newlist", "docstring_tokens": "Returns a list produced by applying : func : multiple_replace to every string in stringlist .", "label": 1}, {"idx": "cosqa-train-17484", "doc": "javascript equivalent of python string literal", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 0}, {"idx": "cosqa-train-17485", "doc": "how to add items to a set in python", "code": "def dict_of_sets_add(dictionary, key, value):\n    # type: (DictUpperBound, Any, Any) -> None\n    \"\"\"Add value to a set in a dictionary by key\n\n    Args:\n        dictionary (DictUpperBound): Dictionary to which to add values\n        key (Any): Key within dictionary\n        value (Any): Value to add to set in dictionary\n\n    Returns:\n        None\n\n    \"\"\"\n    set_objs = dictionary.get(key, set())\n    set_objs.add(value)\n    dictionary[key] = set_objs", "code_tokens": "def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "docstring_tokens": "Add value to a set in a dictionary by key", "label": 1}, {"idx": "cosqa-train-17486", "doc": "compute points on a sphere python", "code": "def arcball_map_to_sphere(point, center, radius):\n    \"\"\"Return unit sphere coordinates from window coordinates.\"\"\"\n    v0 = (point[0] - center[0]) / radius\n    v1 = (center[1] - point[1]) / radius\n    n = v0*v0 + v1*v1\n    if n > 1.0:\n        # position outside of sphere\n        n = math.sqrt(n)\n        return numpy.array([v0/n, v1/n, 0.0])\n    else:\n        return numpy.array([v0, v1, math.sqrt(1.0 - n)])", "code_tokens": "def arcball_map_to_sphere ( point , center , radius ) : v0 = ( point [ 0 ] - center [ 0 ] ) / radius v1 = ( center [ 1 ] - point [ 1 ] ) / radius n = v0 * v0 + v1 * v1 if n > 1.0 : # position outside of sphere n = math . sqrt ( n ) return numpy . array ( [ v0 / n , v1 / n , 0.0 ] ) else : return numpy . array ( [ v0 , v1 , math . sqrt ( 1.0 - n ) ] )", "docstring_tokens": "Return unit sphere coordinates from window coordinates .", "label": 1}, {"idx": "cosqa-train-17487", "doc": "python rate limit function", "code": "def is_rate_limited(response):\n        \"\"\"\n        Checks if the response has been rate limited by CARTO APIs\n\n        :param response: The response rate limited by CARTO APIs\n        :type response: requests.models.Response class\n\n        :return: Boolean\n        \"\"\"\n        if (response.status_code == codes.too_many_requests and 'Retry-After' in response.headers and\n                int(response.headers['Retry-After']) >= 0):\n            return True\n\n        return False", "code_tokens": "def is_rate_limited ( response ) : if ( response . status_code == codes . too_many_requests and 'Retry-After' in response . headers and int ( response . headers [ 'Retry-After' ] ) >= 0 ) : return True return False", "docstring_tokens": "Checks if the response has been rate limited by CARTO APIs", "label": 0}, {"idx": "cosqa-train-17488", "doc": "make empty array python without numpy", "code": "def _create_empty_array(self, frames, always_2d, dtype):\n        \"\"\"Create an empty array with appropriate shape.\"\"\"\n        import numpy as np\n        if always_2d or self.channels > 1:\n            shape = frames, self.channels\n        else:\n            shape = frames,\n        return np.empty(shape, dtype, order='C')", "code_tokens": "def _create_empty_array ( self , frames , always_2d , dtype ) : import numpy as np if always_2d or self . channels > 1 : shape = frames , self . channels else : shape = frames , return np . empty ( shape , dtype , order = 'C' )", "docstring_tokens": "Create an empty array with appropriate shape .", "label": 0}, {"idx": "cosqa-train-17489", "doc": "python check if float equals to int", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 0}, {"idx": "cosqa-train-17490", "doc": "how to get the number of columns in an matrix python", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 1}, {"idx": "cosqa-train-17491", "doc": "how to use timeit on a function in python", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 0}, {"idx": "cosqa-train-17492", "doc": "python bit shift on large values", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 1}, {"idx": "cosqa-train-17493", "doc": "python assert equals dict", "code": "def assert_equal(first, second, msg_fmt=\"{msg}\"):\n    \"\"\"Fail unless first equals second, as determined by the '==' operator.\n\n    >>> assert_equal(5, 5.0)\n    >>> assert_equal(\"Hello World!\", \"Goodbye!\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'Hello World!' != 'Goodbye!'\n\n    The following msg_fmt arguments are supported:\n    * msg - the default error message\n    * first - the first argument\n    * second - the second argument\n    \"\"\"\n\n    if isinstance(first, dict) and isinstance(second, dict):\n        assert_dict_equal(first, second, msg_fmt)\n    elif not first == second:\n        msg = \"{!r} != {!r}\".format(first, second)\n        fail(msg_fmt.format(msg=msg, first=first, second=second))", "code_tokens": "def assert_equal ( first , second , msg_fmt = \"{msg}\" ) : if isinstance ( first , dict ) and isinstance ( second , dict ) : assert_dict_equal ( first , second , msg_fmt ) elif not first == second : msg = \"{!r} != {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "docstring_tokens": "Fail unless first equals second as determined by the == operator .", "label": 0}, {"idx": "cosqa-train-17494", "doc": "python get last index of", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 1}, {"idx": "cosqa-train-17495", "doc": "how to not read blank lines from file in python", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 1}, {"idx": "cosqa-train-17496", "doc": "python using \"0\" to quit", "code": "def do_quit(self, _: argparse.Namespace) -> bool:\n        \"\"\"Exit this application\"\"\"\n        self._should_quit = True\n        return self._STOP_AND_EXIT", "code_tokens": "def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "docstring_tokens": "Exit this application", "label": 1}, {"idx": "cosqa-train-17497", "doc": "how to set width for cell with python openyxl", "code": "def set_cell_value(cell, value):\n    \"\"\"\n    Convenience method for setting the value of an openpyxl cell\n\n    This is necessary since the value property changed from internal_value\n    to value between version 1.* and 2.*.\n    \"\"\"\n    if OPENPYXL_MAJOR_VERSION > 1:\n        cell.value = value\n    else:\n        cell.internal_value = value", "code_tokens": "def set_cell_value ( cell , value ) : if OPENPYXL_MAJOR_VERSION > 1 : cell . value = value else : cell . internal_value = value", "docstring_tokens": "Convenience method for setting the value of an openpyxl cell", "label": 1}, {"idx": "cosqa-train-17498", "doc": "how to calculate product of two strings in python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 0}, {"idx": "cosqa-train-17499", "doc": "selecting the max value in a column python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 0}, {"idx": "cosqa-train-17500", "doc": "calculate mid of two points from lat long python", "code": "def _mid(pt1, pt2):\n    \"\"\"\n    (Point, Point) -> Point\n    Return the point that lies in between the two input points.\n    \"\"\"\n    (x0, y0), (x1, y1) = pt1, pt2\n    return 0.5 * (x0 + x1), 0.5 * (y0 + y1)", "code_tokens": "def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "docstring_tokens": "( Point Point ) - > Point Return the point that lies in between the two input points .", "label": 1}, {"idx": "cosqa-train-17501", "doc": "how to know the data type of an element in python", "code": "def maybe_infer_dtype_type(element):\n    \"\"\"Try to infer an object's dtype, for use in arithmetic ops\n\n    Uses `element.dtype` if that's available.\n    Objects implementing the iterator protocol are cast to a NumPy array,\n    and from there the array's type is used.\n\n    Parameters\n    ----------\n    element : object\n        Possibly has a `.dtype` attribute, and possibly the iterator\n        protocol.\n\n    Returns\n    -------\n    tipo : type\n\n    Examples\n    --------\n    >>> from collections import namedtuple\n    >>> Foo = namedtuple(\"Foo\", \"dtype\")\n    >>> maybe_infer_dtype_type(Foo(np.dtype(\"i8\")))\n    numpy.int64\n    \"\"\"\n    tipo = None\n    if hasattr(element, 'dtype'):\n        tipo = element.dtype\n    elif is_list_like(element):\n        element = np.asarray(element)\n        tipo = element.dtype\n    return tipo", "code_tokens": "def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "docstring_tokens": "Try to infer an object s dtype for use in arithmetic ops", "label": 0}, {"idx": "cosqa-train-17502", "doc": "extract date object from a string in python", "code": "def _parse_date(string: str) -> datetime.date:\n    \"\"\"Parse an ISO format date (YYYY-mm-dd).\n\n    >>> _parse_date('1990-01-02')\n    datetime.date(1990, 1, 2)\n    \"\"\"\n    return datetime.datetime.strptime(string, '%Y-%m-%d').date()", "code_tokens": "def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )", "docstring_tokens": "Parse an ISO format date ( YYYY - mm - dd ) .", "label": 1}, {"idx": "cosqa-train-17503", "doc": "python file hash md5", "code": "def hash_file(fileobj):\n    \"\"\"\n    :param fileobj: a file object\n    :return: a hash of the file content\n    \"\"\"\n    hasher = hashlib.md5()\n    buf = fileobj.read(65536)\n    while len(buf) > 0:\n        hasher.update(buf)\n        buf = fileobj.read(65536)\n    return hasher.hexdigest()", "code_tokens": "def hash_file ( fileobj ) : hasher = hashlib . md5 ( ) buf = fileobj . read ( 65536 ) while len ( buf ) > 0 : hasher . update ( buf ) buf = fileobj . read ( 65536 ) return hasher . hexdigest ( )", "docstring_tokens": ": param fileobj : a file object : return : a hash of the file content", "label": 1}, {"idx": "cosqa-train-17504", "doc": "python how to ndarray string to one string", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 0}, {"idx": "cosqa-train-17505", "doc": "python filter list not equal to space", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 0}, {"idx": "cosqa-train-17506", "doc": "python flask cache per request", "code": "def setup_cache(app: Flask, cache_config) -> Optional[Cache]:\n    \"\"\"Setup the flask-cache on a flask app\"\"\"\n    if cache_config and cache_config.get('CACHE_TYPE') != 'null':\n        return Cache(app, config=cache_config)\n\n    return None", "code_tokens": "def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None", "docstring_tokens": "Setup the flask - cache on a flask app", "label": 0}, {"idx": "cosqa-train-17507", "doc": "python 3 unsignedchar 8bit data", "code": "def read32(bytestream):\n  \"\"\"Read 4 bytes from bytestream as an unsigned 32-bit integer.\"\"\"\n  dt = np.dtype(np.uint32).newbyteorder('>')\n  return np.frombuffer(bytestream.read(4), dtype=dt)[0]", "code_tokens": "def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "docstring_tokens": "Read 4 bytes from bytestream as an unsigned 32 - bit integer .", "label": 0}, {"idx": "cosqa-train-17508", "doc": "how to make a flat list within list in python", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 0}, {"idx": "cosqa-train-17509", "doc": "detect string is camel python", "code": "def camel_to_snake(s: str) -> str:\n    \"\"\"Convert string from camel case to snake case.\"\"\"\n\n    return CAMEL_CASE_RE.sub(r'_\\1', s).strip().lower()", "code_tokens": "def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "docstring_tokens": "Convert string from camel case to snake case .", "label": 0}, {"idx": "cosqa-train-17510", "doc": "python using the map function with a constant and a list", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-17511", "doc": "finding the last occurrence of a character in a string in python", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 0}, {"idx": "cosqa-train-17512", "doc": "iterate a specific number of times in python", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 0}, {"idx": "cosqa-train-17513", "doc": "python variable in a json string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 1}, {"idx": "cosqa-train-17514", "doc": "python iterate list last element", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 0}, {"idx": "cosqa-train-17515", "doc": "how to get inverse dict in python", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 1}, {"idx": "cosqa-train-17516", "doc": "python this transaction is inactive", "code": "def in_transaction(self):\n        \"\"\"Check if this database is in a transactional context.\"\"\"\n        if not hasattr(self.local, 'tx'):\n            return False\n        return len(self.local.tx) > 0", "code_tokens": "def in_transaction ( self ) : if not hasattr ( self . local , 'tx' ) : return False return len ( self . local . tx ) > 0", "docstring_tokens": "Check if this database is in a transactional context .", "label": 1}, {"idx": "cosqa-train-17517", "doc": "the final score for fantasy teaam based on the selected coding using python", "code": "def score_small_straight_yatzy(dice: List[int]) -> int:\n    \"\"\"\n    Small straight scoring according to yatzy rules\n    \"\"\"\n    dice_set = set(dice)\n    if _are_two_sets_equal({1, 2, 3, 4, 5}, dice_set):\n        return sum(dice)\n    return 0", "code_tokens": "def score_small_straight_yatzy ( dice : List [ int ] ) -> int : dice_set = set ( dice ) if _are_two_sets_equal ( { 1 , 2 , 3 , 4 , 5 } , dice_set ) : return sum ( dice ) return 0", "docstring_tokens": "Small straight scoring according to yatzy rules", "label": 0}, {"idx": "cosqa-train-17518", "doc": "python build a list from a string delimited by space", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 1}, {"idx": "cosqa-train-17519", "doc": "most frequent item in list python", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 1}, {"idx": "cosqa-train-17520", "doc": "strip a list of string python", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 1}, {"idx": "cosqa-train-17521", "doc": "python not recognizing numpy uint8 as integer", "code": "def read32(bytestream):\n  \"\"\"Read 4 bytes from bytestream as an unsigned 32-bit integer.\"\"\"\n  dt = np.dtype(np.uint32).newbyteorder('>')\n  return np.frombuffer(bytestream.read(4), dtype=dt)[0]", "code_tokens": "def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "docstring_tokens": "Read 4 bytes from bytestream as an unsigned 32 - bit integer .", "label": 0}, {"idx": "cosqa-train-17522", "doc": "get datatypes columns python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-17523", "doc": "remove a set of characters in python", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 1}, {"idx": "cosqa-train-17524", "doc": "python mongodb int to str", "code": "def process_literal_param(self, value: Optional[List[int]],\n                              dialect: Dialect) -> str:\n        \"\"\"Convert things on the way from Python to the database.\"\"\"\n        retval = self._intlist_to_dbstr(value)\n        return retval", "code_tokens": "def process_literal_param ( self , value : Optional [ List [ int ] ] , dialect : Dialect ) -> str : retval = self . _intlist_to_dbstr ( value ) return retval", "docstring_tokens": "Convert things on the way from Python to the database .", "label": 0}, {"idx": "cosqa-train-17525", "doc": "python protobuf parsefromstring get int value", "code": "def label_from_bin(buf):\n    \"\"\"\n    Converts binary representation label to integer.\n\n    :param buf: Binary representation of label.\n    :return: MPLS Label and BoS bit.\n    \"\"\"\n\n    mpls_label = type_desc.Int3.to_user(six.binary_type(buf))\n    return mpls_label >> 4, mpls_label & 1", "code_tokens": "def label_from_bin ( buf ) : mpls_label = type_desc . Int3 . to_user ( six . binary_type ( buf ) ) return mpls_label >> 4 , mpls_label & 1", "docstring_tokens": "Converts binary representation label to integer .", "label": 1}, {"idx": "cosqa-train-17526", "doc": "how to cut off a calculated number to two decimals in python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 1}, {"idx": "cosqa-train-17527", "doc": "sqllite python entry exist", "code": "def has_table(self, name):\n        \"\"\"Return ``True`` if the table *name* exists in the database.\"\"\"\n        return len(self.sql(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\",\n                            parameters=(name,), asrecarray=False, cache=False)) > 0", "code_tokens": "def has_table ( self , name ) : return len ( self . sql ( \"SELECT name FROM sqlite_master WHERE type='table' AND name=?\" , parameters = ( name , ) , asrecarray = False , cache = False ) ) > 0", "docstring_tokens": "Return True if the table * name * exists in the database .", "label": 1}, {"idx": "cosqa-train-17528", "doc": "python how to evaluate if a variable is equal to an integer", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 1}, {"idx": "cosqa-train-17529", "doc": "using string to generate datetime date in python", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 1}, {"idx": "cosqa-train-17530", "doc": "turn list of lists into one list in python", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 1}, {"idx": "cosqa-train-17531", "doc": "remove leading zeroes python", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 0}, {"idx": "cosqa-train-17532", "doc": "python ctype get cursor position", "code": "def rl_get_point() -> int:  # pragma: no cover\n    \"\"\"\n    Returns the offset of the current cursor position in rl_line_buffer\n    \"\"\"\n    if rl_type == RlType.GNU:\n        return ctypes.c_int.in_dll(readline_lib, \"rl_point\").value\n\n    elif rl_type == RlType.PYREADLINE:\n        return readline.rl.mode.l_buffer.point\n\n    else:\n        return 0", "code_tokens": "def rl_get_point ( ) -> int : # pragma: no cover if rl_type == RlType . GNU : return ctypes . c_int . in_dll ( readline_lib , \"rl_point\" ) . value elif rl_type == RlType . PYREADLINE : return readline . rl . mode . l_buffer . point else : return 0", "docstring_tokens": "Returns the offset of the current cursor position in rl_line_buffer", "label": 1}, {"idx": "cosqa-train-17533", "doc": "top n value in last dimension python", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 0}, {"idx": "cosqa-train-17534", "doc": "python camel case to snake", "code": "def camel_to_snake(s: str) -> str:\n    \"\"\"Convert string from camel case to snake case.\"\"\"\n\n    return CAMEL_CASE_RE.sub(r'_\\1', s).strip().lower()", "code_tokens": "def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "docstring_tokens": "Convert string from camel case to snake case .", "label": 0}, {"idx": "cosqa-train-17535", "doc": "python how to cast a string char to an int", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-17536", "doc": "how to test for a key being used in python", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 0}, {"idx": "cosqa-train-17537", "doc": "python if element in array meets conditions", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 1}, {"idx": "cosqa-train-17538", "doc": "python strip if stirng is not empty", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 1}, {"idx": "cosqa-train-17539", "doc": "how to add an item to a set in python", "code": "def dict_of_sets_add(dictionary, key, value):\n    # type: (DictUpperBound, Any, Any) -> None\n    \"\"\"Add value to a set in a dictionary by key\n\n    Args:\n        dictionary (DictUpperBound): Dictionary to which to add values\n        key (Any): Key within dictionary\n        value (Any): Value to add to set in dictionary\n\n    Returns:\n        None\n\n    \"\"\"\n    set_objs = dictionary.get(key, set())\n    set_objs.add(value)\n    dictionary[key] = set_objs", "code_tokens": "def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "docstring_tokens": "Add value to a set in a dictionary by key", "label": 0}, {"idx": "cosqa-train-17540", "doc": "retrieve s3 file from python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 0}, {"idx": "cosqa-train-17541", "doc": "how to read content of text file from python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-17542", "doc": "python what checks string characters for whitespaces", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 0}, {"idx": "cosqa-train-17543", "doc": "python get timezone in windows", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 0}, {"idx": "cosqa-train-17544", "doc": "remove all instance of char in string python", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 1}, {"idx": "cosqa-train-17545", "doc": "python check type as string", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 1}, {"idx": "cosqa-train-17546", "doc": "python variable limit in a function", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 0}, {"idx": "cosqa-train-17547", "doc": "how to check if current day is last day of month in python", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 0}, {"idx": "cosqa-train-17548", "doc": "testing if a matrix is an upper triangle python", "code": "def is_unitary(matrix: np.ndarray) -> bool:\n    \"\"\"\n    A helper function that checks if a matrix is unitary.\n\n    :param matrix: a matrix to test unitarity of\n    :return: true if and only if matrix is unitary\n    \"\"\"\n    rows, cols = matrix.shape\n    if rows != cols:\n        return False\n    return np.allclose(np.eye(rows), matrix.dot(matrix.T.conj()))", "code_tokens": "def is_unitary ( matrix : np . ndarray ) -> bool : rows , cols = matrix . shape if rows != cols : return False return np . allclose ( np . eye ( rows ) , matrix . dot ( matrix . T . conj ( ) ) )", "docstring_tokens": "A helper function that checks if a matrix is unitary .", "label": 0}, {"idx": "cosqa-train-17549", "doc": "two greater than signs python", "code": "def SGT(self, a, b):\n        \"\"\"Signed greater-than comparison\"\"\"\n        # http://gavwood.com/paper.pdf\n        s0, s1 = to_signed(a), to_signed(b)\n        return Operators.ITEBV(256, s0 > s1, 1, 0)", "code_tokens": "def SGT ( self , a , b ) : # http://gavwood.com/paper.pdf s0 , s1 = to_signed ( a ) , to_signed ( b ) return Operators . ITEBV ( 256 , s0 > s1 , 1 , 0 )", "docstring_tokens": "Signed greater - than comparison", "label": 0}, {"idx": "cosqa-train-17550", "doc": "how to capitalize first letter input python", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 1}, {"idx": "cosqa-train-17551", "doc": "how to check forfirst index python string", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 0}, {"idx": "cosqa-train-17552", "doc": "python substitute values in string", "code": "def replaceStrs(s, *args):\n    r\"\"\"Replace all ``(frm, to)`` tuples in `args` in string `s`.\n\n    >>> replaceStrs(\"nothing is better than warm beer\",\n    ...             ('nothing','warm beer'), ('warm beer','nothing'))\n    'warm beer is better than nothing'\n\n    \"\"\"\n    if args == (): return s\n    mapping = dict((frm, to) for frm, to in args)\n    return re.sub(\"|\".join(map(re.escape, mapping.keys())),\n                  lambda match:mapping[match.group(0)], s)", "code_tokens": "def replaceStrs ( s , * args ) : if args == ( ) : return s mapping = dict ( ( frm , to ) for frm , to in args ) return re . sub ( \"|\" . join ( map ( re . escape , mapping . keys ( ) ) ) , lambda match : mapping [ match . group ( 0 ) ] , s )", "docstring_tokens": "r Replace all ( frm to ) tuples in args in string s .", "label": 0}, {"idx": "cosqa-train-17553", "doc": "how to test if a string in python is all letters", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 1}, {"idx": "cosqa-train-17554", "doc": "check if the dirctionary is null or empty python", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 0}, {"idx": "cosqa-train-17555", "doc": "calling arg parse file from python", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 1}, {"idx": "cosqa-train-17556", "doc": "how to shuffle the items in a matrix python", "code": "def _reshuffle(mat, shape):\n    \"\"\"Reshuffle the indicies of a bipartite matrix A[ij,kl] -> A[lj,ki].\"\"\"\n    return np.reshape(\n        np.transpose(np.reshape(mat, shape), (3, 1, 2, 0)),\n        (shape[3] * shape[1], shape[0] * shape[2]))", "code_tokens": "def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )", "docstring_tokens": "Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] .", "label": 1}, {"idx": "cosqa-train-17557", "doc": "remove all nan values from dictionary python", "code": "def remove_falsy_values(counter: Mapping[Any, int]) -> Mapping[Any, int]:\n    \"\"\"Remove all values that are zero.\"\"\"\n    return {\n        label: count\n        for label, count in counter.items()\n        if count\n    }", "code_tokens": "def remove_falsy_values ( counter : Mapping [ Any , int ] ) -> Mapping [ Any , int ] : return { label : count for label , count in counter . items ( ) if count }", "docstring_tokens": "Remove all values that are zero .", "label": 1}, {"idx": "cosqa-train-17558", "doc": "python pyobc cursor executemany", "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None:\n        \"\"\"Execute the given multiquery.\"\"\"\n        await self._execute(self._cursor.executemany, sql, parameters)", "code_tokens": "async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "docstring_tokens": "Execute the given multiquery .", "label": 1}, {"idx": "cosqa-train-17559", "doc": "continuous normalizing with cdf with python", "code": "def normcdf(x, log=False):\n    \"\"\"Normal cumulative density function.\"\"\"\n    y = np.atleast_1d(x).copy()\n    flib.normcdf(y)\n    if log:\n        if (y>0).all():\n            return np.log(y)\n        return -np.inf\n    return y", "code_tokens": "def normcdf ( x , log = False ) : y = np . atleast_1d ( x ) . copy ( ) flib . normcdf ( y ) if log : if ( y > 0 ) . all ( ) : return np . log ( y ) return - np . inf return y", "docstring_tokens": "Normal cumulative density function .", "label": 1}, {"idx": "cosqa-train-17560", "doc": "reduce bit depth to 8 from 24 in python", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 0}, {"idx": "cosqa-train-17561", "doc": "how to parse string into date python", "code": "def _parse_date(string: str) -> datetime.date:\n    \"\"\"Parse an ISO format date (YYYY-mm-dd).\n\n    >>> _parse_date('1990-01-02')\n    datetime.date(1990, 1, 2)\n    \"\"\"\n    return datetime.datetime.strptime(string, '%Y-%m-%d').date()", "code_tokens": "def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )", "docstring_tokens": "Parse an ISO format date ( YYYY - mm - dd ) .", "label": 1}, {"idx": "cosqa-train-17562", "doc": "determine if url is absolute or relative in python", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 1}, {"idx": "cosqa-train-17563", "doc": "reversing a dictionary in python", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 1}, {"idx": "cosqa-train-17564", "doc": "python normalize sum 1", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 1}, {"idx": "cosqa-train-17565", "doc": "python 3 dealing with gzipped json", "code": "def zlib_compress(data):\n    \"\"\"\n    Compress things in a py2/3 safe fashion\n    >>> json_str = '{\"test\": 1}'\n    >>> blob = zlib_compress(json_str)\n    \"\"\"\n    if PY3K:\n        if isinstance(data, str):\n            return zlib.compress(bytes(data, 'utf-8'))\n        return zlib.compress(data)\n    return zlib.compress(data)", "code_tokens": "def zlib_compress ( data ) : if PY3K : if isinstance ( data , str ) : return zlib . compress ( bytes ( data , 'utf-8' ) ) return zlib . compress ( data ) return zlib . compress ( data )", "docstring_tokens": "Compress things in a py2 / 3 safe fashion >>> json_str = { test : 1 } >>> blob = zlib_compress ( json_str )", "label": 0}, {"idx": "cosqa-train-17566", "doc": "asyncio not working python", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 0}, {"idx": "cosqa-train-17567", "doc": "how to get hover position of cursor python", "code": "def get_cursor(self):\n        \"\"\"Return the virtual cursor position.\n\n        The cursor can be moved with the :any:`move` method.\n\n        Returns:\n            Tuple[int, int]: The (x, y) coordinate of where :any:`print_str`\n                will continue from.\n\n        .. seealso:: :any:move`\n        \"\"\"\n        x, y = self._cursor\n        width, height = self.parent.get_size()\n        while x >= width:\n            x -= width\n            y += 1\n        if y >= height and self.scrollMode == 'scroll':\n            y = height - 1\n        return x, y", "code_tokens": "def get_cursor ( self ) : x , y = self . _cursor width , height = self . parent . get_size ( ) while x >= width : x -= width y += 1 if y >= height and self . scrollMode == 'scroll' : y = height - 1 return x , y", "docstring_tokens": "Return the virtual cursor position .", "label": 0}, {"idx": "cosqa-train-17568", "doc": "python3 how to read and filter lines from a file", "code": "def file_lines(bblfile:str) -> iter:\n    \"\"\"Yield lines found in given file\"\"\"\n    with open(bblfile) as fd:\n        yield from (line.rstrip() for line in fd if line.rstrip())", "code_tokens": "def file_lines ( bblfile : str ) -> iter : with open ( bblfile ) as fd : yield from ( line . rstrip ( ) for line in fd if line . rstrip ( ) )", "docstring_tokens": "Yield lines found in given file", "label": 0}, {"idx": "cosqa-train-17569", "doc": "how to skip blank lines in python", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 1}, {"idx": "cosqa-train-17570", "doc": "how to represent tree in python", "code": "def _tree_line(self, no_type: bool = False) -> str:\n        \"\"\"Return the receiver's contribution to tree diagram.\"\"\"\n        return self._tree_line_prefix() + \" \" + self.iname()", "code_tokens": "def _tree_line ( self , no_type : bool = False ) -> str : return self . _tree_line_prefix ( ) + \" \" + self . iname ( )", "docstring_tokens": "Return the receiver s contribution to tree diagram .", "label": 1}, {"idx": "cosqa-train-17571", "doc": "python check if set is subset of another", "code": "def issubset(self, other):\n        \"\"\"\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        \"\"\"\n        if len(self) > len(other):  # Fast check for obvious cases\n            return False\n        return all(item in other for item in self)", "code_tokens": "def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "docstring_tokens": "Report whether another set contains this set .", "label": 0}, {"idx": "cosqa-train-17572", "doc": "how to generate random binary tree in python", "code": "def getRandomBinaryTreeLeafNode(binaryTree):\n    \"\"\"Get random binary tree node.\n    \"\"\"\n    if binaryTree.internal == True:\n        if random.random() > 0.5:\n            return getRandomBinaryTreeLeafNode(binaryTree.left)\n        else:\n            return getRandomBinaryTreeLeafNode(binaryTree.right)\n    else:\n        return binaryTree", "code_tokens": "def getRandomBinaryTreeLeafNode ( binaryTree ) : if binaryTree . internal == True : if random . random ( ) > 0.5 : return getRandomBinaryTreeLeafNode ( binaryTree . left ) else : return getRandomBinaryTreeLeafNode ( binaryTree . right ) else : return binaryTree", "docstring_tokens": "Get random binary tree node .", "label": 1}, {"idx": "cosqa-train-17573", "doc": "python3 urllib urlparse domain", "code": "def get_domain(url):\n    \"\"\"\n    Get domain part of an url.\n\n    For example: https://www.python.org/doc/ -> https://www.python.org\n    \"\"\"\n    parse_result = urlparse(url)\n    domain = \"{schema}://{netloc}\".format(\n        schema=parse_result.scheme, netloc=parse_result.netloc)\n    return domain", "code_tokens": "def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "docstring_tokens": "Get domain part of an url .", "label": 1}, {"idx": "cosqa-train-17574", "doc": "how to check for real number python", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 0}, {"idx": "cosqa-train-17575", "doc": "python tensorflow casting int to float", "code": "def fcast(value: float) -> TensorLike:\n    \"\"\"Cast to float tensor\"\"\"\n    newvalue = tf.cast(value, FTYPE)\n    if DEVICE == 'gpu':\n        newvalue = newvalue.gpu()  # Why is this needed?  # pragma: no cover\n    return newvalue", "code_tokens": "def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "docstring_tokens": "Cast to float tensor", "label": 1}, {"idx": "cosqa-train-17576", "doc": "round float to nearest whole python", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 0}, {"idx": "cosqa-train-17577", "doc": "python3 extract host from url", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 1}, {"idx": "cosqa-train-17578", "doc": "python count occurrences in a list", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 1}, {"idx": "cosqa-train-17579", "doc": "python repeat n times in list", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 1}, {"idx": "cosqa-train-17580", "doc": "gaussian random variable in python", "code": "def _gauss(mean: int, sigma: int) -> int:\n        \"\"\"\n        Creates a variation from a base value\n\n        Args:\n            mean: base value\n            sigma: gaussian sigma\n\n        Returns: random value\n\n        \"\"\"\n        return int(random.gauss(mean, sigma))", "code_tokens": "def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "docstring_tokens": "Creates a variation from a base value", "label": 0}, {"idx": "cosqa-train-17581", "doc": "how to select the top 5 in a sorted dictionary python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 0}, {"idx": "cosqa-train-17582", "doc": "python flatten dict of dicts", "code": "def flatten_multidict(multidict):\n    \"\"\"Return flattened dictionary from ``MultiDict``.\"\"\"\n    return dict([(key, value if len(value) > 1 else value[0])\n                 for (key, value) in multidict.iterlists()])", "code_tokens": "def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "docstring_tokens": "Return flattened dictionary from MultiDict .", "label": 0}, {"idx": "cosqa-train-17583", "doc": "python forcing the immediate release of memory", "code": "def release_lock():\n    \"\"\"Release lock on compilation directory.\"\"\"\n    get_lock.n_lock -= 1\n    assert get_lock.n_lock >= 0\n    # Only really release lock once all lock requests have ended.\n    if get_lock.lock_is_enabled and get_lock.n_lock == 0:\n        get_lock.start_time = None\n        get_lock.unlocker.unlock()", "code_tokens": "def release_lock ( ) : get_lock . n_lock -= 1 assert get_lock . n_lock >= 0 # Only really release lock once all lock requests have ended. if get_lock . lock_is_enabled and get_lock . n_lock == 0 : get_lock . start_time = None get_lock . unlocker . unlock ( )", "docstring_tokens": "Release lock on compilation directory .", "label": 1}, {"idx": "cosqa-train-17584", "doc": "access files in s3 with python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 1}, {"idx": "cosqa-train-17585", "doc": "normalize to 1 in python", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 1}, {"idx": "cosqa-train-17586", "doc": "conda activate \"python\" is not recognized as an internal or external", "code": "def _find_conda():\n    \"\"\"Find the conda executable robustly across conda versions.\n\n    Returns\n    -------\n    conda : str\n        Path to the conda executable.\n\n    Raises\n    ------\n    IOError\n        If the executable cannot be found in either the CONDA_EXE environment\n        variable or in the PATH.\n\n    Notes\n    -----\n    In POSIX platforms in conda >= 4.4, conda can be set up as a bash function\n    rather than an executable. (This is to enable the syntax\n    ``conda activate env-name``.) In this case, the environment variable\n    ``CONDA_EXE`` contains the path to the conda executable. In other cases,\n    we use standard search for the appropriate name in the PATH.\n\n    See https://github.com/airspeed-velocity/asv/issues/645 for more details.\n    \"\"\"\n    if 'CONDA_EXE' in os.environ:\n        conda = os.environ['CONDA_EXE']\n    else:\n        conda = util.which('conda')\n    return conda", "code_tokens": "def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda", "docstring_tokens": "Find the conda executable robustly across conda versions .", "label": 0}, {"idx": "cosqa-train-17587", "doc": "turn list of str to int python", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-17588", "doc": "max length limit of string python", "code": "def truncate_string(value, max_width=None):\n    \"\"\"Truncate string values.\"\"\"\n    if isinstance(value, text_type) and max_width is not None and len(value) > max_width:\n        return value[:max_width]\n    return value", "code_tokens": "def truncate_string ( value , max_width = None ) : if isinstance ( value , text_type ) and max_width is not None and len ( value ) > max_width : return value [ : max_width ] return value", "docstring_tokens": "Truncate string values .", "label": 0}, {"idx": "cosqa-train-17589", "doc": "python check if hash key exists", "code": "def check_key(self, key: str) -> bool:\n        \"\"\"\n        Checks if key exists in datastore. True if yes, False if no.\n\n        :param: SHA512 hash key\n\n        :return: whether or key not exists in datastore\n        \"\"\"\n        keys = self.get_keys()\n        return key in keys", "code_tokens": "def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "docstring_tokens": "Checks if key exists in datastore . True if yes False if no .", "label": 1}, {"idx": "cosqa-train-17590", "doc": "separate a number and units in python using regular expressions", "code": "def split_unit(value):\n    \"\"\" Split a number from its unit\n        1px -> (q, 'px')\n    Args:\n        value (str): input\n    returns:\n        tuple\n    \"\"\"\n    r = re.search('^(\\-?[\\d\\.]+)(.*)$', str(value))\n    return r.groups() if r else ('', '')", "code_tokens": "def split_unit ( value ) : r = re . search ( '^(\\-?[\\d\\.]+)(.*)$' , str ( value ) ) return r . groups ( ) if r else ( '' , '' )", "docstring_tokens": "Split a number from its unit 1px - > ( q px ) Args : value ( str ) : input returns : tuple", "label": 1}, {"idx": "cosqa-train-17591", "doc": "add values to a set in python", "code": "def dict_of_sets_add(dictionary, key, value):\n    # type: (DictUpperBound, Any, Any) -> None\n    \"\"\"Add value to a set in a dictionary by key\n\n    Args:\n        dictionary (DictUpperBound): Dictionary to which to add values\n        key (Any): Key within dictionary\n        value (Any): Value to add to set in dictionary\n\n    Returns:\n        None\n\n    \"\"\"\n    set_objs = dictionary.get(key, set())\n    set_objs.add(value)\n    dictionary[key] = set_objs", "code_tokens": "def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "docstring_tokens": "Add value to a set in a dictionary by key", "label": 1}, {"idx": "cosqa-train-17592", "doc": "how to change python versions in spyder", "code": "def get_versions(reporev=True):\n    \"\"\"Get version information for components used by Spyder\"\"\"\n    import sys\n    import platform\n\n    import qtpy\n    import qtpy.QtCore\n\n    revision = None\n    if reporev:\n        from spyder.utils import vcs\n        revision, branch = vcs.get_git_revision(os.path.dirname(__dir__))\n\n    if not sys.platform == 'darwin':  # To avoid a crash with our Mac app\n        system = platform.system()\n    else:\n        system = 'Darwin'\n\n    return {\n        'spyder': __version__,\n        'python': platform.python_version(),  # \"2.7.3\"\n        'bitness': 64 if sys.maxsize > 2**32 else 32,\n        'qt': qtpy.QtCore.__version__,\n        'qt_api': qtpy.API_NAME,      # PyQt5\n        'qt_api_ver': qtpy.PYQT_VERSION,\n        'system': system,   # Linux, Windows, ...\n        'release': platform.release(),  # XP, 10.6, 2.2.0, etc.\n        'revision': revision,  # '9fdf926eccce'\n    }", "code_tokens": "def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "docstring_tokens": "Get version information for components used by Spyder", "label": 0}, {"idx": "cosqa-train-17593", "doc": "using python from conda path in windows", "code": "def _find_conda():\n    \"\"\"Find the conda executable robustly across conda versions.\n\n    Returns\n    -------\n    conda : str\n        Path to the conda executable.\n\n    Raises\n    ------\n    IOError\n        If the executable cannot be found in either the CONDA_EXE environment\n        variable or in the PATH.\n\n    Notes\n    -----\n    In POSIX platforms in conda >= 4.4, conda can be set up as a bash function\n    rather than an executable. (This is to enable the syntax\n    ``conda activate env-name``.) In this case, the environment variable\n    ``CONDA_EXE`` contains the path to the conda executable. In other cases,\n    we use standard search for the appropriate name in the PATH.\n\n    See https://github.com/airspeed-velocity/asv/issues/645 for more details.\n    \"\"\"\n    if 'CONDA_EXE' in os.environ:\n        conda = os.environ['CONDA_EXE']\n    else:\n        conda = util.which('conda')\n    return conda", "code_tokens": "def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda", "docstring_tokens": "Find the conda executable robustly across conda versions .", "label": 1}, {"idx": "cosqa-train-17594", "doc": "eliminate nan from dictionary as values python", "code": "def remove_falsy_values(counter: Mapping[Any, int]) -> Mapping[Any, int]:\n    \"\"\"Remove all values that are zero.\"\"\"\n    return {\n        label: count\n        for label, count in counter.items()\n        if count\n    }", "code_tokens": "def remove_falsy_values ( counter : Mapping [ Any , int ] ) -> Mapping [ Any , int ] : return { label : count for label , count in counter . items ( ) if count }", "docstring_tokens": "Remove all values that are zero .", "label": 1}, {"idx": "cosqa-train-17595", "doc": "how to write code for an rms average equation in python", "code": "def rms(x):\n    \"\"\"\"Root Mean Square\"\n\n    Arguments:\n        x (seq of float): A sequence of numerical values\n\n    Returns:\n        The square root of the average of the squares of the values\n\n        math.sqrt(sum(x_i**2 for x_i in x) / len(x))\n\n        or\n\n        return (np.array(x) ** 2).mean() ** 0.5\n\n    >>> rms([0, 2, 4, 4])\n    3.0\n    \"\"\"\n    try:\n        return (np.array(x) ** 2).mean() ** 0.5\n    except:\n        x = np.array(dropna(x))\n        invN = 1.0 / len(x)\n        return (sum(invN * (x_i ** 2) for x_i in x)) ** .5", "code_tokens": "def rms ( x ) : try : return ( np . array ( x ) ** 2 ) . mean ( ) ** 0.5 except : x = np . array ( dropna ( x ) ) invN = 1.0 / len ( x ) return ( sum ( invN * ( x_i ** 2 ) for x_i in x ) ) ** .5", "docstring_tokens": "Root Mean Square", "label": 1}, {"idx": "cosqa-train-17596", "doc": "does python have template literals", "code": "def templategetter(tmpl):\n    \"\"\"\n    This is a dirty little template function generator that turns single-brace\n    Mustache-style template strings into functions that interpolate dict keys:\n\n    >>> get_name = templategetter(\"{first} {last}\")\n    >>> get_name({'first': 'Shawn', 'last': 'Allen'})\n    'Shawn Allen'\n    \"\"\"\n    tmpl = tmpl.replace('{', '%(')\n    tmpl = tmpl.replace('}', ')s')\n    return lambda data: tmpl % data", "code_tokens": "def templategetter ( tmpl ) : tmpl = tmpl . replace ( '{' , '%(' ) tmpl = tmpl . replace ( '}' , ')s' ) return lambda data : tmpl % data", "docstring_tokens": "This is a dirty little template function generator that turns single - brace Mustache - style template strings into functions that interpolate dict keys :", "label": 0}, {"idx": "cosqa-train-17597", "doc": "make a list of multiple lists into one list python3", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 1}, {"idx": "cosqa-train-17598", "doc": "select an copy to clipboard a column to clipboard in excel python", "code": "def to_clipboard(self, excel=True, sep=None, **kwargs):\n        r\"\"\"\n        Copy object to the system clipboard.\n\n        Write a text representation of object to the system clipboard.\n        This can be pasted into Excel, for example.\n\n        Parameters\n        ----------\n        excel : bool, default True\n            - True, use the provided separator, writing in a csv format for\n              allowing easy pasting into excel.\n            - False, write a string representation of the object to the\n              clipboard.\n\n        sep : str, default ``'\\t'``\n            Field delimiter.\n        **kwargs\n            These parameters will be passed to DataFrame.to_csv.\n\n        See Also\n        --------\n        DataFrame.to_csv : Write a DataFrame to a comma-separated values\n            (csv) file.\n        read_clipboard : Read text from clipboard and pass to read_table.\n\n        Notes\n        -----\n        Requirements for your platform.\n\n          - Linux : `xclip`, or `xsel` (with `gtk` or `PyQt4` modules)\n          - Windows : none\n          - OS X : none\n\n        Examples\n        --------\n        Copy the contents of a DataFrame to the clipboard.\n\n        >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=['A', 'B', 'C'])\n        >>> df.to_clipboard(sep=',')\n        ... # Wrote the following to the system clipboard:\n        ... # ,A,B,C\n        ... # 0,1,2,3\n        ... # 1,4,5,6\n\n        We can omit the the index by passing the keyword `index` and setting\n        it to false.\n\n        >>> df.to_clipboard(sep=',', index=False)\n        ... # Wrote the following to the system clipboard:\n        ... # A,B,C\n        ... # 1,2,3\n        ... # 4,5,6\n        \"\"\"\n        from pandas.io import clipboards\n        clipboards.to_clipboard(self, excel=excel, sep=sep, **kwargs)", "code_tokens": "def to_clipboard ( self , excel = True , sep = None , * * kwargs ) : from pandas . io import clipboards clipboards . to_clipboard ( self , excel = excel , sep = sep , * * kwargs )", "docstring_tokens": "r Copy object to the system clipboard .", "label": 1}, {"idx": "cosqa-train-17599", "doc": "python set bits off", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 0}, {"idx": "cosqa-train-17600", "doc": "limit memory allocated python gpu", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 0}, {"idx": "cosqa-train-17601", "doc": "python checking if value is in enum", "code": "def has_value(cls, value: int) -> bool:\n        \"\"\"True if specified value exists in int enum; otherwise, False.\"\"\"\n        return any(value == item.value for item in cls)", "code_tokens": "def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "docstring_tokens": "True if specified value exists in int enum ; otherwise False .", "label": 0}, {"idx": "cosqa-train-17602", "doc": "determine datatype of column python", "code": "def get_datatype(self, table: str, column: str) -> str:\n        \"\"\"Returns database SQL datatype for a column: e.g. VARCHAR.\"\"\"\n        return self.flavour.get_datatype(self, table, column).upper()", "code_tokens": "def get_datatype ( self , table : str , column : str ) -> str : return self . flavour . get_datatype ( self , table , column ) . upper ( )", "docstring_tokens": "Returns database SQL datatype for a column : e . g . VARCHAR .", "label": 0}, {"idx": "cosqa-train-17603", "doc": "add a type to the enum python", "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum:\n    \"\"\"\n    Converts an ``dict`` to a ``Enum``.\n    \"\"\"\n    return enum_class[d['name']]", "code_tokens": "def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "docstring_tokens": "Converts an dict to a Enum .", "label": 1}, {"idx": "cosqa-train-17604", "doc": "python how to replace multiple characters of a string", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 1}, {"idx": "cosqa-train-17605", "doc": "transfer serise string to datetime python", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 0}, {"idx": "cosqa-train-17606", "doc": "python user32 windll send to back window", "code": "def SwitchToThisWindow(handle: int) -> None:\n    \"\"\"\n    SwitchToThisWindow from Win32.\n    handle: int, the handle of a native window.\n    \"\"\"\n    ctypes.windll.user32.SwitchToThisWindow(ctypes.c_void_p(handle), 1)", "code_tokens": "def SwitchToThisWindow ( handle : int ) -> None : ctypes . windll . user32 . SwitchToThisWindow ( ctypes . c_void_p ( handle ) , 1 )", "docstring_tokens": "SwitchToThisWindow from Win32 . handle : int the handle of a native window .", "label": 0}, {"idx": "cosqa-train-17607", "doc": "python tensor change dtype float", "code": "def fcast(value: float) -> TensorLike:\n    \"\"\"Cast to float tensor\"\"\"\n    newvalue = tf.cast(value, FTYPE)\n    if DEVICE == 'gpu':\n        newvalue = newvalue.gpu()  # Why is this needed?  # pragma: no cover\n    return newvalue", "code_tokens": "def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "docstring_tokens": "Cast to float tensor", "label": 0}, {"idx": "cosqa-train-17608", "doc": "spyder change from python 2 to 3", "code": "def get_versions(reporev=True):\n    \"\"\"Get version information for components used by Spyder\"\"\"\n    import sys\n    import platform\n\n    import qtpy\n    import qtpy.QtCore\n\n    revision = None\n    if reporev:\n        from spyder.utils import vcs\n        revision, branch = vcs.get_git_revision(os.path.dirname(__dir__))\n\n    if not sys.platform == 'darwin':  # To avoid a crash with our Mac app\n        system = platform.system()\n    else:\n        system = 'Darwin'\n\n    return {\n        'spyder': __version__,\n        'python': platform.python_version(),  # \"2.7.3\"\n        'bitness': 64 if sys.maxsize > 2**32 else 32,\n        'qt': qtpy.QtCore.__version__,\n        'qt_api': qtpy.API_NAME,      # PyQt5\n        'qt_api_ver': qtpy.PYQT_VERSION,\n        'system': system,   # Linux, Windows, ...\n        'release': platform.release(),  # XP, 10.6, 2.2.0, etc.\n        'revision': revision,  # '9fdf926eccce'\n    }", "code_tokens": "def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "docstring_tokens": "Get version information for components used by Spyder", "label": 0}, {"idx": "cosqa-train-17609", "doc": "python array to tensor object", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 0}, {"idx": "cosqa-train-17610", "doc": "python pretty print of dict", "code": "def pretty_dict(d):\n    \"\"\"Return dictionary d's repr but with the items sorted.\n    >>> pretty_dict({'m': 'M', 'a': 'A', 'r': 'R', 'k': 'K'})\n    \"{'a': 'A', 'k': 'K', 'm': 'M', 'r': 'R'}\"\n    >>> pretty_dict({z: C, y: B, x: A})\n    '{x: A, y: B, z: C}'\n    \"\"\"\n    return '{%s}' % ', '.join('%r: %r' % (k, v)\n                              for k, v in sorted(d.items(), key=repr))", "code_tokens": "def pretty_dict ( d ) : return '{%s}' % ', ' . join ( '%r: %r' % ( k , v ) for k , v in sorted ( d . items ( ) , key = repr ) )", "docstring_tokens": "Return dictionary d s repr but with the items sorted . >>> pretty_dict ( { m : M a : A r : R k : K } ) { a : A k : K m : M r : R } >>> pretty_dict ( { z : C y : B x : A } ) { x : A y : B z : C }", "label": 1}, {"idx": "cosqa-train-17611", "doc": "python numpy dumps to", "code": "def array_to_npy(array_like):  # type: (np.array or Iterable or int or float) -> object\n    \"\"\"Convert an array like object to the NPY format.\n\n    To understand better what an array like object is see:\n    https://docs.scipy.org/doc/numpy/user/basics.creation.html#converting-python-array-like-objects-to-numpy-arrays\n\n    Args:\n        array_like (np.array or Iterable or int or float): array like object to be converted to NPY.\n\n    Returns:\n        (obj): NPY array.\n    \"\"\"\n    buffer = BytesIO()\n    np.save(buffer, array_like)\n    return buffer.getvalue()", "code_tokens": "def array_to_npy ( array_like ) : # type: (np.array or Iterable or int or float) -> object buffer = BytesIO ( ) np . save ( buffer , array_like ) return buffer . getvalue ( )", "docstring_tokens": "Convert an array like object to the NPY format .", "label": 0}, {"idx": "cosqa-train-17612", "doc": "read byte data smbus python", "code": "def read_byte_data(self, addr, cmd):\n        \"\"\"read_byte_data(addr, cmd) -> result\n\n        Perform SMBus Read Byte Data transaction.\n        \"\"\"\n        self._set_addr(addr)\n        res = SMBUS.i2c_smbus_read_byte_data(self._fd, ffi.cast(\"__u8\", cmd))\n        if res == -1:\n            raise IOError(ffi.errno)\n        return res", "code_tokens": "def read_byte_data ( self , addr , cmd ) : self . _set_addr ( addr ) res = SMBUS . i2c_smbus_read_byte_data ( self . _fd , ffi . cast ( \"__u8\" , cmd ) ) if res == - 1 : raise IOError ( ffi . errno ) return res", "docstring_tokens": "read_byte_data ( addr cmd ) - > result", "label": 1}, {"idx": "cosqa-train-17613", "doc": "print the uppercase letters in the string python", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 0}, {"idx": "cosqa-train-17614", "doc": "python get last of month", "code": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day", "code_tokens": "def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "docstring_tokens": "Returns day number of the last day of the month : param t : datetime : return : int", "label": 0}, {"idx": "cosqa-train-17615", "doc": "how to check if date format is correct python", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 0}, {"idx": "cosqa-train-17616", "doc": "python protobyf parse from byte", "code": "def decode(self, bytes, raw=False):\n        \"\"\"decode(bytearray, raw=False) -> value\n\n        Decodes the given bytearray according to this PrimitiveType\n        definition.\n\n        NOTE: The parameter ``raw`` is present to adhere to the\n        ``decode()`` inteface, but has no effect for PrimitiveType\n        definitions.\n        \"\"\"\n        return struct.unpack(self.format, buffer(bytes))[0]", "code_tokens": "def decode ( self , bytes , raw = False ) : return struct . unpack ( self . format , buffer ( bytes ) ) [ 0 ]", "docstring_tokens": "decode ( bytearray raw = False ) - > value", "label": 1}, {"idx": "cosqa-train-17617", "doc": "parsing a childnode's attribute in python 3", "code": "def _parse_property(self, node):\n        # type: (ElementTree.Element) -> Tuple[str, Any]\n        \"\"\"\n        Parses a property node\n\n        :param node: The property node\n        :return: A (name, value) tuple\n        :raise KeyError: Attribute missing\n        \"\"\"\n        # Get information\n        name = node.attrib[ATTR_NAME]\n        vtype = node.attrib.get(ATTR_VALUE_TYPE, TYPE_STRING)\n\n        # Look for a value as a single child node\n        try:\n            value_node = next(iter(node))\n            value = self._parse_value_node(vtype, value_node)\n        except StopIteration:\n            # Value is an attribute\n            value = self._convert_value(vtype, node.attrib[ATTR_VALUE])\n\n        return name, value", "code_tokens": "def _parse_property ( self , node ) : # type: (ElementTree.Element) -> Tuple[str, Any] # Get information name = node . attrib [ ATTR_NAME ] vtype = node . attrib . get ( ATTR_VALUE_TYPE , TYPE_STRING ) # Look for a value as a single child node try : value_node = next ( iter ( node ) ) value = self . _parse_value_node ( vtype , value_node ) except StopIteration : # Value is an attribute value = self . _convert_value ( vtype , node . attrib [ ATTR_VALUE ] ) return name , value", "docstring_tokens": "Parses a property node", "label": 0}, {"idx": "cosqa-train-17618", "doc": "checking the current python versipn", "code": "def validate_django_compatible_with_python():\n    \"\"\"\n    Verify Django 1.11 is present if Python 2.7 is active\n\n    Installation of pinax-cli requires the correct version of Django for\n    the active Python version. If the developer subsequently changes\n    the Python version the installed Django may no longer be compatible.\n    \"\"\"\n    python_version = sys.version[:5]\n    django_version = django.get_version()\n    if sys.version_info == (2, 7) and django_version >= \"2\":\n        click.BadArgumentUsage(\"Please install Django v1.11 for Python {}, or switch to Python >= v3.4\".format(python_version))", "code_tokens": "def validate_django_compatible_with_python ( ) : python_version = sys . version [ : 5 ] django_version = django . get_version ( ) if sys . version_info == ( 2 , 7 ) and django_version >= \"2\" : click . BadArgumentUsage ( \"Please install Django v1.11 for Python {}, or switch to Python >= v3.4\" . format ( python_version ) )", "docstring_tokens": "Verify Django 1 . 11 is present if Python 2 . 7 is active", "label": 0}, {"idx": "cosqa-train-17619", "doc": "how to check if edge intersects in igraph python", "code": "def is_intersection(g, n):\n    \"\"\"\n    Determine if a node is an intersection\n\n    graph: 1 -->-- 2 -->-- 3\n\n    >>> is_intersection(g, 2)\n    False\n\n    graph:\n     1 -- 2 -- 3\n          |\n          4\n\n    >>> is_intersection(g, 2)\n    True\n\n    Parameters\n    ----------\n    g : networkx DiGraph\n    n : node id\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n    return len(set(g.predecessors(n) + g.successors(n))) > 2", "code_tokens": "def is_intersection ( g , n ) : return len ( set ( g . predecessors ( n ) + g . successors ( n ) ) ) > 2", "docstring_tokens": "Determine if a node is an intersection", "label": 0}, {"idx": "cosqa-train-17620", "doc": "blender python fcurves interpolation", "code": "def interpolate(f1: float, f2: float, factor: float) -> float:\n    \"\"\" Linearly interpolate between two float values. \"\"\"\n    return f1 + (f2 - f1) * factor", "code_tokens": "def interpolate ( f1 : float , f2 : float , factor : float ) -> float : return f1 + ( f2 - f1 ) * factor", "docstring_tokens": "Linearly interpolate between two float values .", "label": 0}, {"idx": "cosqa-train-17621", "doc": "split sentence by delimiter python", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 1}, {"idx": "cosqa-train-17622", "doc": "cast a list of string in integer in python", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-17623", "doc": "python delete all occurrences of character in string", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 0}, {"idx": "cosqa-train-17624", "doc": "how to make a function return a fuction in python", "code": "def reduce(function, initval=None):\n\t\"\"\"\n\tCurried version of the built-in reduce.\n\t\n\t>>> reduce(lambda x,y: x+y)( [1, 2, 3, 4, 5] )\n\t15\n\t\"\"\"\n\tif initval is None:\n\t\treturn lambda s: __builtin__.reduce(function, s)\n\telse:\n\t\treturn lambda s: __builtin__.reduce(function, s, initval)", "code_tokens": "def reduce ( function , initval = None ) : if initval is None : return lambda s : __builtin__ . reduce ( function , s ) else : return lambda s : __builtin__ . reduce ( function , s , initval )", "docstring_tokens": "Curried version of the built - in reduce . >>> reduce ( lambda x y : x + y ) ( [ 1 2 3 4 5 ] ) 15", "label": 0}, {"idx": "cosqa-train-17625", "doc": "python get url domain", "code": "def get_domain(url):\n    \"\"\"\n    Get domain part of an url.\n\n    For example: https://www.python.org/doc/ -> https://www.python.org\n    \"\"\"\n    parse_result = urlparse(url)\n    domain = \"{schema}://{netloc}\".format(\n        schema=parse_result.scheme, netloc=parse_result.netloc)\n    return domain", "code_tokens": "def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "docstring_tokens": "Get domain part of an url .", "label": 0}, {"idx": "cosqa-train-17626", "doc": "python replace nulls with string in csv", "code": "def tsv_escape(x: Any) -> str:\n    \"\"\"\n    Escape data for tab-separated value (TSV) format.\n    \"\"\"\n    if x is None:\n        return \"\"\n    x = str(x)\n    return x.replace(\"\\t\", \"\\\\t\").replace(\"\\n\", \"\\\\n\")", "code_tokens": "def tsv_escape ( x : Any ) -> str : if x is None : return \"\" x = str ( x ) return x . replace ( \"\\t\" , \"\\\\t\" ) . replace ( \"\\n\" , \"\\\\n\" )", "docstring_tokens": "Escape data for tab - separated value ( TSV ) format .", "label": 0}, {"idx": "cosqa-train-17627", "doc": "how to check memory leak in python", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 0}, {"idx": "cosqa-train-17628", "doc": "python limit times in a minute", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 0}, {"idx": "cosqa-train-17629", "doc": "read a file from s3 bucket python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 0}, {"idx": "cosqa-train-17630", "doc": "how to read a text file into a set in python", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 1}, {"idx": "cosqa-train-17631", "doc": "python xml delete all atributes from element", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 0}, {"idx": "cosqa-train-17632", "doc": "python stringify list back to list", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 0}, {"idx": "cosqa-train-17633", "doc": "least frequent element in a list python", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 1}, {"idx": "cosqa-train-17634", "doc": "how to turn a list of numbers into integers in python", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-17635", "doc": "python change array dtype to int", "code": "def to_int64(a):\n    \"\"\"Return view of the recarray with all int32 cast to int64.\"\"\"\n    # build new dtype and replace i4 --> i8\n    def promote_i4(typestr):\n        if typestr[1:] == 'i4':\n            typestr = typestr[0]+'i8'\n        return typestr\n\n    dtype = [(name, promote_i4(typestr)) for name,typestr in a.dtype.descr]\n    return a.astype(dtype)", "code_tokens": "def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )", "docstring_tokens": "Return view of the recarray with all int32 cast to int64 .", "label": 1}, {"idx": "cosqa-train-17636", "doc": "python cast str into int", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 0}, {"idx": "cosqa-train-17637", "doc": "python validate a file path or uri", "code": "def _validate_authority_uri_abs_path(host, path):\n        \"\"\"Ensure that path in URL with authority starts with a leading slash.\n\n        Raise ValueError if not.\n        \"\"\"\n        if len(host) > 0 and len(path) > 0 and not path.startswith(\"/\"):\n            raise ValueError(\n                \"Path in a URL with authority \" \"should start with a slash ('/') if set\"\n            )", "code_tokens": "def _validate_authority_uri_abs_path ( host , path ) : if len ( host ) > 0 and len ( path ) > 0 and not path . startswith ( \"/\" ) : raise ValueError ( \"Path in a URL with authority \" \"should start with a slash ('/') if set\" )", "docstring_tokens": "Ensure that path in URL with authority starts with a leading slash .", "label": 1}, {"idx": "cosqa-train-17638", "doc": "condition to see if nan in python", "code": "def warn_if_nans_exist(X):\n    \"\"\"Warn if nans exist in a numpy array.\"\"\"\n    null_count = count_rows_with_nans(X)\n    total = len(X)\n    percent = 100 * null_count / total\n\n    if null_count > 0:\n        warning_message = \\\n            'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\\n            'complete rows will be plotted.'.format(null_count, total, percent)\n        warnings.warn(warning_message, DataWarning)", "code_tokens": "def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "docstring_tokens": "Warn if nans exist in a numpy array .", "label": 1}, {"idx": "cosqa-train-17639", "doc": "python pyparsing two separate parsers", "code": "def _get_parsing_plan_for_multifile_children(self, obj_on_fs: PersistedObject, desired_type: Type[Any],\n                                                 logger: Logger) -> Dict[str, Any]:\n        \"\"\"\n        Implementation of AnyParser API\n        \"\"\"\n        raise Exception('This should never happen, since this parser relies on underlying parsers')", "code_tokens": "def _get_parsing_plan_for_multifile_children ( self , obj_on_fs : PersistedObject , desired_type : Type [ Any ] , logger : Logger ) -> Dict [ str , Any ] : raise Exception ( 'This should never happen, since this parser relies on underlying parsers' )", "docstring_tokens": "Implementation of AnyParser API", "label": 0}, {"idx": "cosqa-train-17640", "doc": "delete an element from set python", "code": "def remove_once(gset, elem):\n    \"\"\"Remove the element from a set, lists or dict.\n    \n        >>> L = [\"Lucy\"]; S = set([\"Sky\"]); D = { \"Diamonds\": True };\n        >>> remove_once(L, \"Lucy\"); remove_once(S, \"Sky\"); remove_once(D, \"Diamonds\");\n        >>> print L, S, D\n        [] set([]) {}\n\n    Returns the element if it was removed. Raises one of the exceptions in \n    :obj:`RemoveError` otherwise.\n    \"\"\"\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "code_tokens": "def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "docstring_tokens": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}", "label": 1}, {"idx": "cosqa-train-17641", "doc": "how to create a sort key in python", "code": "def sort_key(x):\n    \"\"\"\n    >>> sort_key(('name', ('ROUTE', 'URL')))\n    -3\n    \"\"\"\n    name, (r, u) = x\n    return - len(u) + u.count('}') * 100", "code_tokens": "def sort_key ( x ) : name , ( r , u ) = x return - len ( u ) + u . count ( '}' ) * 100", "docstring_tokens": ">>> sort_key (( name ( ROUTE URL ))) - 3", "label": 1}, {"idx": "cosqa-train-17642", "doc": "return inverted dictionary in python", "code": "def inverted_dict_of_lists(d):\n    \"\"\"Return a dict where the keys are all the values listed in the values of the original dict\n\n    >>> inverted_dict_of_lists({0: ['a', 'b'], 1: 'cd'}) == {'a': 0, 'b': 0, 'cd': 1}\n    True\n    \"\"\"\n    new_dict = {}\n    for (old_key, old_value_list) in viewitems(dict(d)):\n        for new_key in listify(old_value_list):\n            new_dict[new_key] = old_key\n    return new_dict", "code_tokens": "def inverted_dict_of_lists ( d ) : new_dict = { } for ( old_key , old_value_list ) in viewitems ( dict ( d ) ) : for new_key in listify ( old_value_list ) : new_dict [ new_key ] = old_key return new_dict", "docstring_tokens": "Return a dict where the keys are all the values listed in the values of the original dict", "label": 1}, {"idx": "cosqa-train-17643", "doc": "multiply dot product of lists python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 1}, {"idx": "cosqa-train-17644", "doc": "get the text off the clipboard python", "code": "def copy_without_prompts(self):\n        \"\"\"Copy text to clipboard without prompts\"\"\"\n        text = self.get_selected_text()\n        lines = text.split(os.linesep)\n        for index, line in enumerate(lines):\n            if line.startswith('>>> ') or line.startswith('... '):\n                lines[index] = line[4:]\n        text = os.linesep.join(lines)\n        QApplication.clipboard().setText(text)", "code_tokens": "def copy_without_prompts ( self ) : text = self . get_selected_text ( ) lines = text . split ( os . linesep ) for index , line in enumerate ( lines ) : if line . startswith ( '>>> ' ) or line . startswith ( '... ' ) : lines [ index ] = line [ 4 : ] text = os . linesep . join ( lines ) QApplication . clipboard ( ) . setText ( text )", "docstring_tokens": "Copy text to clipboard without prompts", "label": 1}, {"idx": "cosqa-train-17645", "doc": "python check if a file path contains a file", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 0}, {"idx": "cosqa-train-17646", "doc": "dot product python using itertools", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 0}, {"idx": "cosqa-train-17647", "doc": "how to get domain from url netloc python", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 1}, {"idx": "cosqa-train-17648", "doc": "how to identify the data type in python without the built in function", "code": "def maybe_infer_dtype_type(element):\n    \"\"\"Try to infer an object's dtype, for use in arithmetic ops\n\n    Uses `element.dtype` if that's available.\n    Objects implementing the iterator protocol are cast to a NumPy array,\n    and from there the array's type is used.\n\n    Parameters\n    ----------\n    element : object\n        Possibly has a `.dtype` attribute, and possibly the iterator\n        protocol.\n\n    Returns\n    -------\n    tipo : type\n\n    Examples\n    --------\n    >>> from collections import namedtuple\n    >>> Foo = namedtuple(\"Foo\", \"dtype\")\n    >>> maybe_infer_dtype_type(Foo(np.dtype(\"i8\")))\n    numpy.int64\n    \"\"\"\n    tipo = None\n    if hasattr(element, 'dtype'):\n        tipo = element.dtype\n    elif is_list_like(element):\n        element = np.asarray(element)\n        tipo = element.dtype\n    return tipo", "code_tokens": "def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "docstring_tokens": "Try to infer an object s dtype for use in arithmetic ops", "label": 1}, {"idx": "cosqa-train-17649", "doc": "python wordnet lemmatize a word", "code": "def has_synset(word: str) -> list:\n    \"\"\"\" Returns a list of synsets of a word after lemmatization. \"\"\"\n\n    return wn.synsets(lemmatize(word, neverstem=True))", "code_tokens": "def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "docstring_tokens": "Returns a list of synsets of a word after lemmatization .", "label": 0}, {"idx": "cosqa-train-17650", "doc": "hex to integer converter in python", "code": "def hex_to_int(value):\n    \"\"\"\n    Convert hex string like \"\\x0A\\xE3\" to 2787.\n    \"\"\"\n    if version_info.major >= 3:\n        return int.from_bytes(value, \"big\")\n    return int(value.encode(\"hex\"), 16)", "code_tokens": "def hex_to_int ( value ) : if version_info . major >= 3 : return int . from_bytes ( value , \"big\" ) return int ( value . encode ( \"hex\" ) , 16 )", "docstring_tokens": "Convert hex string like \\ x0A \\ xE3 to 2787 .", "label": 0}, {"idx": "cosqa-train-17651", "doc": "python count occurences in a list", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 1}, {"idx": "cosqa-train-17652", "doc": "make python string uppercase", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-17653", "doc": "how to change string to a date in python", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-17654", "doc": "python design to break into equal sizes in 26 bins", "code": "def partition_items(count, bin_size):\n\t\"\"\"\n\tGiven the total number of items, determine the number of items that\n\tcan be added to each bin with a limit on the bin size.\n\n\tSo if you want to partition 11 items into groups of 3, you'll want\n\tthree of three and one of two.\n\n\t>>> partition_items(11, 3)\n\t[3, 3, 3, 2]\n\n\tBut if you only have ten items, you'll have two groups of three and\n\ttwo of two.\n\n\t>>> partition_items(10, 3)\n\t[3, 3, 2, 2]\n\t\"\"\"\n\tnum_bins = int(math.ceil(count / float(bin_size)))\n\tbins = [0] * num_bins\n\tfor i in range(count):\n\t\tbins[i % num_bins] += 1\n\treturn bins", "code_tokens": "def partition_items ( count , bin_size ) : num_bins = int ( math . ceil ( count / float ( bin_size ) ) ) bins = [ 0 ] * num_bins for i in range ( count ) : bins [ i % num_bins ] += 1 return bins", "docstring_tokens": "Given the total number of items determine the number of items that can be added to each bin with a limit on the bin size .", "label": 0}, {"idx": "cosqa-train-17655", "doc": "python thread spawn async", "code": "async def async_run(self) -> None:\n        \"\"\"\n        Asynchronously run the worker, does not close connections. Useful when testing.\n        \"\"\"\n        self.main_task = self.loop.create_task(self.main())\n        await self.main_task", "code_tokens": "async def async_run ( self ) -> None : self . main_task = self . loop . create_task ( self . main ( ) ) await self . main_task", "docstring_tokens": "Asynchronously run the worker does not close connections . Useful when testing .", "label": 1}, {"idx": "cosqa-train-17656", "doc": "python read last lines of file", "code": "def _read_section(self):\n        \"\"\"Read and return an entire section\"\"\"\n        lines = [self._last[self._last.find(\":\")+1:]]\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            lines.append(self._last)\n            self._last = self._f.readline()\n        return lines", "code_tokens": "def _read_section ( self ) : lines = [ self . _last [ self . _last . find ( \":\" ) + 1 : ] ] self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : lines . append ( self . _last ) self . _last = self . _f . readline ( ) return lines", "docstring_tokens": "Read and return an entire section", "label": 1}, {"idx": "cosqa-train-17657", "doc": "how to get the maximum value of the columns in python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 0}, {"idx": "cosqa-train-17658", "doc": "python most negative number in an array", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 0}, {"idx": "cosqa-train-17659", "doc": "python3 check if string validte date", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 0}, {"idx": "cosqa-train-17660", "doc": "most frequent element in list in python", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 1}, {"idx": "cosqa-train-17661", "doc": "python unpack ip packets", "code": "def _get_ipv6_from_binary(self, bin_addr):\n        \"\"\"Converts binary address to Ipv6 format.\"\"\"\n\n        hi = bin_addr >> 64\n        lo = bin_addr & 0xFFFFFFFF\n        return socket.inet_ntop(socket.AF_INET6, struct.pack(\"!QQ\", hi, lo))", "code_tokens": "def _get_ipv6_from_binary ( self , bin_addr ) : hi = bin_addr >> 64 lo = bin_addr & 0xFFFFFFFF return socket . inet_ntop ( socket . AF_INET6 , struct . pack ( \"!QQ\" , hi , lo ) )", "docstring_tokens": "Converts binary address to Ipv6 format .", "label": 1}, {"idx": "cosqa-train-17662", "doc": "how to rotate the elements present in the list in python", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 1}, {"idx": "cosqa-train-17663", "doc": "check if value in enum python", "code": "def has_value(cls, value: int) -> bool:\n        \"\"\"True if specified value exists in int enum; otherwise, False.\"\"\"\n        return any(value == item.value for item in cls)", "code_tokens": "def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "docstring_tokens": "True if specified value exists in int enum ; otherwise False .", "label": 1}, {"idx": "cosqa-train-17664", "doc": "python how to connect to an established odbc connection oracle", "code": "def connect_to_database_odbc_access(self,\n                                        dsn: str,\n                                        autocommit: bool = True) -> None:\n        \"\"\"Connects to an Access database via ODBC, with the DSN\n        prespecified.\"\"\"\n        self.connect(engine=ENGINE_ACCESS, interface=INTERFACE_ODBC,\n                     dsn=dsn, autocommit=autocommit)", "code_tokens": "def connect_to_database_odbc_access ( self , dsn : str , autocommit : bool = True ) -> None : self . connect ( engine = ENGINE_ACCESS , interface = INTERFACE_ODBC , dsn = dsn , autocommit = autocommit )", "docstring_tokens": "Connects to an Access database via ODBC with the DSN prespecified .", "label": 1}, {"idx": "cosqa-train-17665", "doc": "how to create a dictonary from a list of words in python", "code": "def encode_list(key, list_):\n    # type: (str, Iterable) -> Dict[str, str]\n    \"\"\"\n    Converts a list into a space-separated string and puts it in a dictionary\n\n    :param key: Dictionary key to store the list\n    :param list_: A list of objects\n    :return: A dictionary key->string or an empty dictionary\n    \"\"\"\n    if not list_:\n        return {}\n    return {key: \" \".join(str(i) for i in list_)}", "code_tokens": "def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "docstring_tokens": "Converts a list into a space - separated string and puts it in a dictionary", "label": 0}, {"idx": "cosqa-train-17666", "doc": "check a path is valid or not python", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-17667", "doc": "how to test whether the date is valid in python", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 0}, {"idx": "cosqa-train-17668", "doc": "how to check whether a namespace exists or not in gae python", "code": "def has_enumerated_namespace_name(self, namespace: str, name: str) -> bool:\n        \"\"\"Check that the namespace is defined by an enumeration and that the name is a member.\"\"\"\n        return self.has_enumerated_namespace(namespace) and name in self.namespace_to_terms[namespace]", "code_tokens": "def has_enumerated_namespace_name ( self , namespace : str , name : str ) -> bool : return self . has_enumerated_namespace ( namespace ) and name in self . namespace_to_terms [ namespace ]", "docstring_tokens": "Check that the namespace is defined by an enumeration and that the name is a member .", "label": 0}, {"idx": "cosqa-train-17669", "doc": "python create string from list without commas", "code": "def list_to_str(lst):\n    \"\"\"\n    Turn a list into a comma- and/or and-separated string.\n\n    Parameters\n    ----------\n    lst : :obj:`list`\n        A list of strings to join into a single string.\n\n    Returns\n    -------\n    str_ : :obj:`str`\n        A string with commas and/or ands separating th elements from ``lst``.\n\n    \"\"\"\n    if len(lst) == 1:\n        str_ = lst[0]\n    elif len(lst) == 2:\n        str_ = ' and '.join(lst)\n    elif len(lst) > 2:\n        str_ = ', '.join(lst[:-1])\n        str_ += ', and {0}'.format(lst[-1])\n    else:\n        raise ValueError('List of length 0 provided.')\n    return str_", "code_tokens": "def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "docstring_tokens": "Turn a list into a comma - and / or and - separated string .", "label": 1}, {"idx": "cosqa-train-17670", "doc": "python limit function time", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 1}, {"idx": "cosqa-train-17671", "doc": "extract number of channels in an image python", "code": "def numchannels(samples:np.ndarray) -> int:\n    \"\"\"\n    return the number of channels present in samples\n\n    samples: a numpy array as returned by sndread\n\n    for multichannel audio, samples is always interleaved,\n    meaning that samples[n] returns always a frame, which\n    is either a single scalar for mono audio, or an array\n    for multichannel audio.\n    \"\"\"\n    if len(samples.shape) == 1:\n        return 1\n    else:\n        return samples.shape[1]", "code_tokens": "def numchannels ( samples : np . ndarray ) -> int : if len ( samples . shape ) == 1 : return 1 else : return samples . shape [ 1 ]", "docstring_tokens": "return the number of channels present in samples", "label": 1}, {"idx": "cosqa-train-17672", "doc": "check if a sttring has whitespaces in python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 1}, {"idx": "cosqa-train-17673", "doc": "python pytorch change byte tensor to float tensor", "code": "def fcast(value: float) -> TensorLike:\n    \"\"\"Cast to float tensor\"\"\"\n    newvalue = tf.cast(value, FTYPE)\n    if DEVICE == 'gpu':\n        newvalue = newvalue.gpu()  # Why is this needed?  # pragma: no cover\n    return newvalue", "code_tokens": "def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "docstring_tokens": "Cast to float tensor", "label": 0}, {"idx": "cosqa-train-17674", "doc": "return to exit a function python", "code": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)", "code_tokens": "def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "docstring_tokens": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting", "label": 1}, {"idx": "cosqa-train-17675", "doc": "all dtype of columns python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 0}, {"idx": "cosqa-train-17676", "doc": "python get last index of char", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-17677", "doc": "python delete all files mathing regex", "code": "def rmglob(pattern: str) -> None:\n    \"\"\"\n    Deletes all files whose filename matches the glob ``pattern`` (via\n    :func:`glob.glob`).\n    \"\"\"\n    for f in glob.glob(pattern):\n        os.remove(f)", "code_tokens": "def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "docstring_tokens": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .", "label": 0}, {"idx": "cosqa-train-17678", "doc": "python timing the execution of a function", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 0}, {"idx": "cosqa-train-17679", "doc": "python check is list is sequential", "code": "def are_token_parallel(sequences: Sequence[Sized]) -> bool:\n    \"\"\"\n    Returns True if all sequences in the list have the same length.\n    \"\"\"\n    if not sequences or len(sequences) == 1:\n        return True\n    return all(len(s) == len(sequences[0]) for s in sequences)", "code_tokens": "def are_token_parallel ( sequences : Sequence [ Sized ] ) -> bool : if not sequences or len ( sequences ) == 1 : return True return all ( len ( s ) == len ( sequences [ 0 ] ) for s in sequences )", "docstring_tokens": "Returns True if all sequences in the list have the same length .", "label": 0}, {"idx": "cosqa-train-17680", "doc": "check queue empty python", "code": "def full(self):\n        \"\"\"Return ``True`` if the queue is full, ``False``\n        otherwise (not reliable!).\n\n        Only applicable if :attr:`maxsize` is set.\n\n        \"\"\"\n        return self.maxsize and len(self.list) >= self.maxsize or False", "code_tokens": "def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False", "docstring_tokens": "Return True if the queue is full False otherwise ( not reliable! ) .", "label": 0}, {"idx": "cosqa-train-17681", "doc": "python check if list is empy", "code": "def is_iterable(etype) -> bool:\n    \"\"\" Determine whether etype is a List or other iterable \"\"\"\n    return type(etype) is GenericMeta and issubclass(etype.__extra__, Iterable)", "code_tokens": "def is_iterable ( etype ) -> bool : return type ( etype ) is GenericMeta and issubclass ( etype . __extra__ , Iterable )", "docstring_tokens": "Determine whether etype is a List or other iterable", "label": 0}, {"idx": "cosqa-train-17682", "doc": "python dict from another python dict", "code": "def extend(a: dict, b: dict) -> dict:\n    \"\"\"Merge two dicts and return a new dict. Much like subclassing works.\"\"\"\n    res = a.copy()\n    res.update(b)\n    return res", "code_tokens": "def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res", "docstring_tokens": "Merge two dicts and return a new dict . Much like subclassing works .", "label": 1}, {"idx": "cosqa-train-17683", "doc": "how to skip the first line while looping over a file in python", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 0}, {"idx": "cosqa-train-17684", "doc": "giving the time a function took to execute python", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 1}, {"idx": "cosqa-train-17685", "doc": "removing a duplicate number in list python", "code": "def de_duplicate(items):\n    \"\"\"Remove any duplicate item, preserving order\n\n    >>> de_duplicate([1, 2, 1, 2])\n    [1, 2]\n    \"\"\"\n    result = []\n    for item in items:\n        if item not in result:\n            result.append(item)\n    return result", "code_tokens": "def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "docstring_tokens": "Remove any duplicate item preserving order", "label": 1}, {"idx": "cosqa-train-17686", "doc": "python variable names starting with underscore", "code": "def lower_camel_case_from_underscores(string):\n    \"\"\"generate a lower-cased camelCase string from an underscore_string.\n    For example: my_variable_name -> myVariableName\"\"\"\n    components = string.split('_')\n    string = components[0]\n    for component in components[1:]:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName", "label": 1}, {"idx": "cosqa-train-17687", "doc": "python loop skip the last element of a list", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 1}, {"idx": "cosqa-train-17688", "doc": "get timing of functions python", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 0}, {"idx": "cosqa-train-17689", "doc": "python get the index of element in a list with condition", "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:\n    \"\"\"\n    Finds the index of an item in list, which satisfies predicate\n    :param predicateFn: predicate function to run on items of list\n    :param items: list of tuples\n    :return: first index for which predicate function returns True\n    \"\"\"\n    try:\n        return next(i for i, v in enumerate(items) if predicateFn(v))\n    except StopIteration:\n        return -1", "code_tokens": "def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "docstring_tokens": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True", "label": 1}, {"idx": "cosqa-train-17690", "doc": "python cursor select fetchall", "code": "async def fetchall(self) -> Iterable[sqlite3.Row]:\n        \"\"\"Fetch all remaining rows.\"\"\"\n        return await self._execute(self._cursor.fetchall)", "code_tokens": "async def fetchall ( self ) -> Iterable [ sqlite3 . Row ] : return await self . _execute ( self . _cursor . fetchall )", "docstring_tokens": "Fetch all remaining rows .", "label": 1}, {"idx": "cosqa-train-17691", "doc": "how to disallow negative numbers in python", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 0}, {"idx": "cosqa-train-17692", "doc": "how to check if a string is an int in python", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-17693", "doc": "check if directory is empty or has files with python", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 1}, {"idx": "cosqa-train-17694", "doc": "show types python columns", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-17695", "doc": "elementtree remove element xml python", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 0}, {"idx": "cosqa-train-17696", "doc": "python check type of variable is string", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 0}, {"idx": "cosqa-train-17697", "doc": "how to read file from s3 bucket python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 1}, {"idx": "cosqa-train-17698", "doc": "python track the time it takes to run a function", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 0}, {"idx": "cosqa-train-17699", "doc": "python call string positions from a line in a list", "code": "def get_line_number(line_map, offset):\n    \"\"\"Find a line number, given a line map and a character offset.\"\"\"\n    for lineno, line_offset in enumerate(line_map, start=1):\n        if line_offset > offset:\n            return lineno\n    return -1", "code_tokens": "def get_line_number ( line_map , offset ) : for lineno , line_offset in enumerate ( line_map , start = 1 ) : if line_offset > offset : return lineno return - 1", "docstring_tokens": "Find a line number given a line map and a character offset .", "label": 0}, {"idx": "cosqa-train-17700", "doc": "midpoints between two points python", "code": "def _mid(pt1, pt2):\n    \"\"\"\n    (Point, Point) -> Point\n    Return the point that lies in between the two input points.\n    \"\"\"\n    (x0, y0), (x1, y1) = pt1, pt2\n    return 0.5 * (x0 + x1), 0.5 * (y0 + y1)", "code_tokens": "def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "docstring_tokens": "( Point Point ) - > Point Return the point that lies in between the two input points .", "label": 0}, {"idx": "cosqa-train-17701", "doc": "python covert string to camel case", "code": "def snake_to_camel(value):\n    \"\"\"\n    Converts a snake_case_string to a camelCaseString.\n\n    >>> snake_to_camel(\"foo_bar_baz\")\n    'fooBarBaz'\n    \"\"\"\n    camel = \"\".join(word.title() for word in value.split(\"_\"))\n    return value[:1].lower() + camel[1:]", "code_tokens": "def snake_to_camel ( value ) : camel = \"\" . join ( word . title ( ) for word in value . split ( \"_\" ) ) return value [ : 1 ] . lower ( ) + camel [ 1 : ]", "docstring_tokens": "Converts a snake_case_string to a camelCaseString .", "label": 0}, {"idx": "cosqa-train-17702", "doc": "python how to write a factorial", "code": "def factorial(n, mod=None):\n    \"\"\"Calculates factorial iteratively.\n    If mod is not None, then return (n! % mod)\n    Time Complexity - O(n)\"\"\"\n    if not (isinstance(n, int) and n >= 0):\n        raise ValueError(\"'n' must be a non-negative integer.\")\n    if mod is not None and not (isinstance(mod, int) and mod > 0):\n        raise ValueError(\"'mod' must be a positive integer\")\n    result = 1\n    if n == 0:\n        return 1\n    for i in range(2, n+1):\n        result *= i\n        if mod:\n            result %= mod\n    return result", "code_tokens": "def factorial ( n , mod = None ) : if not ( isinstance ( n , int ) and n >= 0 ) : raise ValueError ( \"'n' must be a non-negative integer.\" ) if mod is not None and not ( isinstance ( mod , int ) and mod > 0 ) : raise ValueError ( \"'mod' must be a positive integer\" ) result = 1 if n == 0 : return 1 for i in range ( 2 , n + 1 ) : result *= i if mod : result %= mod return result", "docstring_tokens": "Calculates factorial iteratively . If mod is not None then return ( n! % mod ) Time Complexity - O ( n )", "label": 1}, {"idx": "cosqa-train-17703", "doc": "reset window color python", "code": "def ResetConsoleColor() -> bool:\n    \"\"\"\n    Reset to the default text color on console window.\n    Return bool, True if succeed otherwise False.\n    \"\"\"\n    if sys.stdout:\n        sys.stdout.flush()\n    bool(ctypes.windll.kernel32.SetConsoleTextAttribute(_ConsoleOutputHandle, _DefaultConsoleColor))", "code_tokens": "def ResetConsoleColor ( ) -> bool : if sys . stdout : sys . stdout . flush ( ) bool ( ctypes . windll . kernel32 . SetConsoleTextAttribute ( _ConsoleOutputHandle , _DefaultConsoleColor ) )", "docstring_tokens": "Reset to the default text color on console window . Return bool True if succeed otherwise False .", "label": 0}, {"idx": "cosqa-train-17704", "doc": "how to return the second smallest value in an array python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 0}, {"idx": "cosqa-train-17705", "doc": "exit not defined python", "code": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)", "code_tokens": "def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "docstring_tokens": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting", "label": 0}, {"idx": "cosqa-train-17706", "doc": "python how to lemmatize wordnetlemmatizer", "code": "def has_synset(word: str) -> list:\n    \"\"\"\" Returns a list of synsets of a word after lemmatization. \"\"\"\n\n    return wn.synsets(lemmatize(word, neverstem=True))", "code_tokens": "def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "docstring_tokens": "Returns a list of synsets of a word after lemmatization .", "label": 0}, {"idx": "cosqa-train-17707", "doc": "generating random number with gaussian distribution in python", "code": "def _gauss(mean: int, sigma: int) -> int:\n        \"\"\"\n        Creates a variation from a base value\n\n        Args:\n            mean: base value\n            sigma: gaussian sigma\n\n        Returns: random value\n\n        \"\"\"\n        return int(random.gauss(mean, sigma))", "code_tokens": "def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "docstring_tokens": "Creates a variation from a base value", "label": 0}, {"idx": "cosqa-train-17708", "doc": "integer and returns a random bitstring of size python", "code": "def binary(length):\n    \"\"\"\n        returns a a random string that represent a binary representation\n\n    :param length: number of bits\n    \"\"\"\n    num = randint(1, 999999)\n    mask = '0' * length\n    return (mask + ''.join([str(num >> i & 1) for i in range(7, -1, -1)]))[-length:]", "code_tokens": "def binary ( length ) : num = randint ( 1 , 999999 ) mask = '0' * length return ( mask + '' . join ( [ str ( num >> i & 1 ) for i in range ( 7 , - 1 , - 1 ) ] ) ) [ - length : ]", "docstring_tokens": "returns a a random string that represent a binary representation", "label": 1}, {"idx": "cosqa-train-17709", "doc": "python apply min to column", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-17710", "doc": "get single file from s3 python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 1}, {"idx": "cosqa-train-17711", "doc": "list comprehension python flatten", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 1}, {"idx": "cosqa-train-17712", "doc": "how to get domain part of a url in python", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 1}, {"idx": "cosqa-train-17713", "doc": "python access if key exists", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 0}, {"idx": "cosqa-train-17714", "doc": "python index of largest value of array", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 1}, {"idx": "cosqa-train-17715", "doc": "python how to check the queue lenght", "code": "def full(self):\n        \"\"\"Return ``True`` if the queue is full, ``False``\n        otherwise (not reliable!).\n\n        Only applicable if :attr:`maxsize` is set.\n\n        \"\"\"\n        return self.maxsize and len(self.list) >= self.maxsize or False", "code_tokens": "def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False", "docstring_tokens": "Return True if the queue is full False otherwise ( not reliable! ) .", "label": 1}, {"idx": "cosqa-train-17716", "doc": "python conver megabyte to number", "code": "def val_mb(valstr: Union[int, str]) -> str:\n    \"\"\"\n    Converts a value in bytes (in string format) to megabytes.\n    \"\"\"\n    try:\n        return \"{:.3f}\".format(int(valstr) / (1024 * 1024))\n    except (TypeError, ValueError):\n        return '?'", "code_tokens": "def val_mb ( valstr : Union [ int , str ] ) -> str : try : return \"{:.3f}\" . format ( int ( valstr ) / ( 1024 * 1024 ) ) except ( TypeError , ValueError ) : return '?'", "docstring_tokens": "Converts a value in bytes ( in string format ) to megabytes .", "label": 0}, {"idx": "cosqa-train-17717", "doc": "python request limit bandwidth", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 1}, {"idx": "cosqa-train-17718", "doc": "python moving average nested loop", "code": "def moving_average(iterable, n):\n    \"\"\"\n    From Python collections module documentation\n\n    moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0\n    \"\"\"\n    it = iter(iterable)\n    d = collections.deque(itertools.islice(it, n - 1))\n    d.appendleft(0)\n    s = sum(d)\n    for elem in it:\n        s += elem - d.popleft()\n        d.append(elem)\n        yield s / float(n)", "code_tokens": "def moving_average ( iterable , n ) : it = iter ( iterable ) d = collections . deque ( itertools . islice ( it , n - 1 ) ) d . appendleft ( 0 ) s = sum ( d ) for elem in it : s += elem - d . popleft ( ) d . append ( elem ) yield s / float ( n )", "docstring_tokens": "From Python collections module documentation", "label": 0}, {"idx": "cosqa-train-17719", "doc": "build a dict python using keys and value lists", "code": "def encode_list(key, list_):\n    # type: (str, Iterable) -> Dict[str, str]\n    \"\"\"\n    Converts a list into a space-separated string and puts it in a dictionary\n\n    :param key: Dictionary key to store the list\n    :param list_: A list of objects\n    :return: A dictionary key->string or an empty dictionary\n    \"\"\"\n    if not list_:\n        return {}\n    return {key: \" \".join(str(i) for i in list_)}", "code_tokens": "def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "docstring_tokens": "Converts a list into a space - separated string and puts it in a dictionary", "label": 1}, {"idx": "cosqa-train-17720", "doc": "how to detect if a string is an int in python", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-17721", "doc": "reset usb device python windows", "code": "def _close(self):\n        \"\"\"\n        Release the USB interface again.\n        \"\"\"\n        self._usb_handle.releaseInterface()\n        try:\n            # If we're using PyUSB >= 1.0 we can re-attach the kernel driver here.\n            self._usb_handle.dev.attach_kernel_driver(0)\n        except:\n            pass\n        self._usb_int = None\n        self._usb_handle = None\n        return True", "code_tokens": "def _close ( self ) : self . _usb_handle . releaseInterface ( ) try : # If we're using PyUSB >= 1.0 we can re-attach the kernel driver here. self . _usb_handle . dev . attach_kernel_driver ( 0 ) except : pass self . _usb_int = None self . _usb_handle = None return True", "docstring_tokens": "Release the USB interface again .", "label": 0}, {"idx": "cosqa-train-17722", "doc": "whats the best way to calculate the shortest path in a python graph", "code": "def dag_longest_path(graph, source, target):\n    \"\"\"\n    Finds the longest path in a dag between two nodes\n    \"\"\"\n    if source == target:\n        return [source]\n    allpaths = nx.all_simple_paths(graph, source, target)\n    longest_path = []\n    for l in allpaths:\n        if len(l) > len(longest_path):\n            longest_path = l\n    return longest_path", "code_tokens": "def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "docstring_tokens": "Finds the longest path in a dag between two nodes", "label": 0}, {"idx": "cosqa-train-17723", "doc": "python most frequent item in a list", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 0}, {"idx": "cosqa-train-17724", "doc": "change values to as a percentage python", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 0}, {"idx": "cosqa-train-17725", "doc": "python hash function from big number to smaller", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 1}, {"idx": "cosqa-train-17726", "doc": "python how to truncate decimals", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 0}, {"idx": "cosqa-train-17727", "doc": "networkx python recursive print a tree", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-17728", "doc": "how to add somethign to a set in python", "code": "def dict_of_sets_add(dictionary, key, value):\n    # type: (DictUpperBound, Any, Any) -> None\n    \"\"\"Add value to a set in a dictionary by key\n\n    Args:\n        dictionary (DictUpperBound): Dictionary to which to add values\n        key (Any): Key within dictionary\n        value (Any): Value to add to set in dictionary\n\n    Returns:\n        None\n\n    \"\"\"\n    set_objs = dictionary.get(key, set())\n    set_objs.add(value)\n    dictionary[key] = set_objs", "code_tokens": "def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "docstring_tokens": "Add value to a set in a dictionary by key", "label": 0}, {"idx": "cosqa-train-17729", "doc": "string camel case method python", "code": "def camel_to_snake(s: str) -> str:\n    \"\"\"Convert string from camel case to snake case.\"\"\"\n\n    return CAMEL_CASE_RE.sub(r'_\\1', s).strip().lower()", "code_tokens": "def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "docstring_tokens": "Convert string from camel case to snake case .", "label": 1}, {"idx": "cosqa-train-17730", "doc": "turn list of strings into numbers python", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 0}, {"idx": "cosqa-train-17731", "doc": "return most frequent element in list python", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 1}, {"idx": "cosqa-train-17732", "doc": "how to hash a list in python", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 0}, {"idx": "cosqa-train-17733", "doc": "python first letter large caps the rest small", "code": "def fmt_camel(name):\n    \"\"\"\n    Converts name to lower camel case. Words are identified by capitalization,\n    dashes, and underscores.\n    \"\"\"\n    words = split_words(name)\n    assert len(words) > 0\n    first = words.pop(0).lower()\n    return first + ''.join([word.capitalize() for word in words])", "code_tokens": "def fmt_camel ( name ) : words = split_words ( name ) assert len ( words ) > 0 first = words . pop ( 0 ) . lower ( ) return first + '' . join ( [ word . capitalize ( ) for word in words ] )", "docstring_tokens": "Converts name to lower camel case . Words are identified by capitalization dashes and underscores .", "label": 0}, {"idx": "cosqa-train-17734", "doc": "python is double or float", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 0}, {"idx": "cosqa-train-17735", "doc": "does python have a method to generate random numbers with a normal distribution", "code": "def _gauss(mean: int, sigma: int) -> int:\n        \"\"\"\n        Creates a variation from a base value\n\n        Args:\n            mean: base value\n            sigma: gaussian sigma\n\n        Returns: random value\n\n        \"\"\"\n        return int(random.gauss(mean, sigma))", "code_tokens": "def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "docstring_tokens": "Creates a variation from a base value", "label": 0}, {"idx": "cosqa-train-17736", "doc": "python 3 specify string width and padding", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 0}, {"idx": "cosqa-train-17737", "doc": "python function name should be lowercase", "code": "def method_caller(method_name, *args, **kwargs):\n\t\"\"\"\n\tReturn a function that will call a named method on the\n\ttarget object with optional positional and keyword\n\targuments.\n\n\t>>> lower = method_caller('lower')\n\t>>> lower('MyString')\n\t'mystring'\n\t\"\"\"\n\tdef call_method(target):\n\t\tfunc = getattr(target, method_name)\n\t\treturn func(*args, **kwargs)\n\treturn call_method", "code_tokens": "def method_caller ( method_name , * args , * * kwargs ) : def call_method ( target ) : func = getattr ( target , method_name ) return func ( * args , * * kwargs ) return call_method", "docstring_tokens": "Return a function that will call a named method on the target object with optional positional and keyword arguments .", "label": 0}, {"idx": "cosqa-train-17738", "doc": "python function for not in list", "code": "def obj_in_list_always(target_list, obj):\n    \"\"\"\n    >>> l = [1,1,1]\n    >>> obj_in_list_always(l, 1)\n    True\n    >>> l.append(2)\n    >>> obj_in_list_always(l, 1)\n    False\n    \"\"\"\n    for item in set(target_list):\n        if item is not obj:\n            return False\n    return True", "code_tokens": "def obj_in_list_always ( target_list , obj ) : for item in set ( target_list ) : if item is not obj : return False return True", "docstring_tokens": ">>> l = [ 1 1 1 ] >>> obj_in_list_always ( l 1 ) True >>> l . append ( 2 ) >>> obj_in_list_always ( l 1 ) False", "label": 0}, {"idx": "cosqa-train-17739", "doc": "how can you create a dictionary of letters and their counts based on a list of strings in python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 0}, {"idx": "cosqa-train-17740", "doc": "removing columnsns in data frame python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 1}, {"idx": "cosqa-train-17741", "doc": "buffer dtype mismatch, expected 'python object' but got 'unsigned long'", "code": "def read32(bytestream):\n  \"\"\"Read 4 bytes from bytestream as an unsigned 32-bit integer.\"\"\"\n  dt = np.dtype(np.uint32).newbyteorder('>')\n  return np.frombuffer(bytestream.read(4), dtype=dt)[0]", "code_tokens": "def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "docstring_tokens": "Read 4 bytes from bytestream as an unsigned 32 - bit integer .", "label": 0}, {"idx": "cosqa-train-17742", "doc": "python filter lambda two dict", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-17743", "doc": "python length of column in numpy array", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 0}, {"idx": "cosqa-train-17744", "doc": "python execute dot graphviz", "code": "def cmd_dot(conf: Config):\n    \"\"\"Print out a neat targets dependency tree based on requested targets.\n\n    Use graphviz to render the dot file, e.g.:\n\n    > ybt dot :foo :bar | dot -Tpng -o graph.png\n    \"\"\"\n    build_context = BuildContext(conf)\n    populate_targets_graph(build_context, conf)\n    if conf.output_dot_file is None:\n        write_dot(build_context, conf, sys.stdout)\n    else:\n        with open(conf.output_dot_file, 'w') as out_file:\n            write_dot(build_context, conf, out_file)", "code_tokens": "def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "docstring_tokens": "Print out a neat targets dependency tree based on requested targets .", "label": 0}, {"idx": "cosqa-train-17745", "doc": "python openpyxl set color", "code": "def set_cell_value(cell, value):\n    \"\"\"\n    Convenience method for setting the value of an openpyxl cell\n\n    This is necessary since the value property changed from internal_value\n    to value between version 1.* and 2.*.\n    \"\"\"\n    if OPENPYXL_MAJOR_VERSION > 1:\n        cell.value = value\n    else:\n        cell.internal_value = value", "code_tokens": "def set_cell_value ( cell , value ) : if OPENPYXL_MAJOR_VERSION > 1 : cell . value = value else : cell . internal_value = value", "docstring_tokens": "Convenience method for setting the value of an openpyxl cell", "label": 1}, {"idx": "cosqa-train-17746", "doc": "check if a variable is a file in python", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-17747", "doc": "python3 map 2d list", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 1}, {"idx": "cosqa-train-17748", "doc": "how to calculate a similarity score of two synsets using nltk in python", "code": "def tanimoto_set_similarity(x: Iterable[X], y: Iterable[X]) -> float:\n    \"\"\"Calculate the tanimoto set similarity.\"\"\"\n    a, b = set(x), set(y)\n    union = a | b\n\n    if not union:\n        return 0.0\n\n    return len(a & b) / len(union)", "code_tokens": "def tanimoto_set_similarity ( x : Iterable [ X ] , y : Iterable [ X ] ) -> float : a , b = set ( x ) , set ( y ) union = a | b if not union : return 0.0 return len ( a & b ) / len ( union )", "docstring_tokens": "Calculate the tanimoto set similarity .", "label": 1}, {"idx": "cosqa-train-17749", "doc": "get table column names from database python", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 1}, {"idx": "cosqa-train-17750", "doc": "turn list of lists into list python", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 1}, {"idx": "cosqa-train-17751", "doc": "extract row with max value in python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 1}, {"idx": "cosqa-train-17752", "doc": "python pass argparse to function", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 1}, {"idx": "cosqa-train-17753", "doc": "python map remove without raise", "code": "def __remove_method(m: lmap.Map, key: T) -> lmap.Map:\n        \"\"\"Swap the methods atom to remove method with key.\"\"\"\n        return m.dissoc(key)", "code_tokens": "def __remove_method ( m : lmap . Map , key : T ) -> lmap . Map : return m . dissoc ( key )", "docstring_tokens": "Swap the methods atom to remove method with key .", "label": 0}, {"idx": "cosqa-train-17754", "doc": "set random number from normal distribution in python", "code": "def _gauss(mean: int, sigma: int) -> int:\n        \"\"\"\n        Creates a variation from a base value\n\n        Args:\n            mean: base value\n            sigma: gaussian sigma\n\n        Returns: random value\n\n        \"\"\"\n        return int(random.gauss(mean, sigma))", "code_tokens": "def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "docstring_tokens": "Creates a variation from a base value", "label": 1}, {"idx": "cosqa-train-17755", "doc": "random walk with bound in python", "code": "def returned(n):\n\t\"\"\"Generate a random walk and return True if the walker has returned to\n\tthe origin after taking `n` steps.\n\t\"\"\"\n\t## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk\n\tfor pos in randwalk() >> drop(1) >> takei(xrange(n-1)):\n\t\tif pos == Origin:\n\t\t\treturn True\n\treturn False", "code_tokens": "def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "docstring_tokens": "Generate a random walk and return True if the walker has returned to the origin after taking n steps .", "label": 1}, {"idx": "cosqa-train-17756", "doc": "python if str is url", "code": "def looks_like_url(url):\n    \"\"\" Simplified check to see if the text appears to be a URL.\n\n    Similar to `urlparse` but much more basic.\n\n    Returns:\n      True if the url str appears to be valid.\n      False otherwise.\n\n    >>> url = looks_like_url(\"totalgood.org\")\n    >>> bool(url)\n    True\n    \"\"\"\n    if not isinstance(url, basestring):\n        return False\n    if not isinstance(url, basestring) or len(url) >= 1024 or not cre_url.match(url):\n        return False\n    return True", "code_tokens": "def looks_like_url ( url ) : if not isinstance ( url , basestring ) : return False if not isinstance ( url , basestring ) or len ( url ) >= 1024 or not cre_url . match ( url ) : return False return True", "docstring_tokens": "Simplified check to see if the text appears to be a URL .", "label": 0}, {"idx": "cosqa-train-17757", "doc": "remove columns from data frame python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 1}, {"idx": "cosqa-train-17758", "doc": "get url schema problem python", "code": "def get_domain(url):\n    \"\"\"\n    Get domain part of an url.\n\n    For example: https://www.python.org/doc/ -> https://www.python.org\n    \"\"\"\n    parse_result = urlparse(url)\n    domain = \"{schema}://{netloc}\".format(\n        schema=parse_result.scheme, netloc=parse_result.netloc)\n    return domain", "code_tokens": "def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "docstring_tokens": "Get domain part of an url .", "label": 0}, {"idx": "cosqa-train-17759", "doc": "python redis connection pool max size2**31", "code": "def preconnect(self, size=-1):\n        \"\"\"(pre)Connects some or all redis clients inside the pool.\n\n        Args:\n            size (int): number of redis clients to build and to connect\n                (-1 means all clients if pool max_size > -1)\n\n        Raises:\n            ClientError: when size == -1 and pool max_size == -1\n        \"\"\"\n        if size == -1 and self.max_size == -1:\n            raise ClientError(\"size=-1 not allowed with pool max_size=-1\")\n        limit = min(size, self.max_size) if size != -1 else self.max_size\n        clients = yield [self.get_connected_client() for _ in range(0, limit)]\n        for client in clients:\n            self.release_client(client)", "code_tokens": "def preconnect ( self , size = - 1 ) : if size == - 1 and self . max_size == - 1 : raise ClientError ( \"size=-1 not allowed with pool max_size=-1\" ) limit = min ( size , self . max_size ) if size != - 1 else self . max_size clients = yield [ self . get_connected_client ( ) for _ in range ( 0 , limit ) ] for client in clients : self . release_client ( client )", "docstring_tokens": "( pre ) Connects some or all redis clients inside the pool .", "label": 0}, {"idx": "cosqa-train-17760", "doc": "python get min val of column", "code": "def min(self):\n        \"\"\"\n        :returns the minimum of the column\n        \"\"\"\n        res = self._qexec(\"min(%s)\" % self._name)\n        if len(res) > 0:\n            self._min = res[0][0]\n        return self._min", "code_tokens": "def min ( self ) : res = self . _qexec ( \"min(%s)\" % self . _name ) if len ( res ) > 0 : self . _min = res [ 0 ] [ 0 ] return self . _min", "docstring_tokens": ": returns the minimum of the column", "label": 0}, {"idx": "cosqa-train-17761", "doc": "python padding zeros in bytestring", "code": "def left_zero_pad(s, blocksize):\n    \"\"\"\n    Left padding with zero bytes to a given block size\n\n    :param s:\n    :param blocksize:\n    :return:\n    \"\"\"\n    if blocksize > 0 and len(s) % blocksize:\n        s = (blocksize - len(s) % blocksize) * b('\\000') + s\n    return s", "code_tokens": "def left_zero_pad ( s , blocksize ) : if blocksize > 0 and len ( s ) % blocksize : s = ( blocksize - len ( s ) % blocksize ) * b ( '\\000' ) + s return s", "docstring_tokens": "Left padding with zero bytes to a given block size", "label": 1}, {"idx": "cosqa-train-17762", "doc": "sum elements of two vectors python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 0}, {"idx": "cosqa-train-17763", "doc": "access s3 files from python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 1}, {"idx": "cosqa-train-17764", "doc": "python get year from date string", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 0}, {"idx": "cosqa-train-17765", "doc": "how to make string into int on python", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-17766", "doc": "python column to upper", "code": "def str_upper(x):\n    \"\"\"Converts all strings in a column to uppercase.\n\n    :returns: an expression containing the converted strings.\n\n    Example:\n\n    >>> import vaex\n    >>> text = ['Something', 'very pretty', 'is coming', 'our', 'way.']\n    >>> df = vaex.from_arrays(text=text)\n    >>> df\n      #  text\n      0  Something\n      1  very pretty\n      2  is coming\n      3  our\n      4  way.\n\n\n    >>> df.text.str.upper()\n    Expression = str_upper(text)\n    Length: 5 dtype: str (expression)\n    ---------------------------------\n    0    SOMETHING\n    1  VERY PRETTY\n    2    IS COMING\n    3          OUR\n    4         WAY.\n\n    \"\"\"\n    sl = _to_string_sequence(x).upper()\n    return column.ColumnStringArrow(sl.bytes, sl.indices, sl.length, sl.offset, string_sequence=sl)", "code_tokens": "def str_upper ( x ) : sl = _to_string_sequence ( x ) . upper ( ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "docstring_tokens": "Converts all strings in a column to uppercase .", "label": 1}, {"idx": "cosqa-train-17767", "doc": "how to get the size of the matrix in python", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 0}, {"idx": "cosqa-train-17768", "doc": "python3 generate random uuid", "code": "def uuid(self, version: int = None) -> str:\n        \"\"\"Generate random UUID.\n\n        :param version: UUID version.\n        :return: UUID\n        \"\"\"\n        bits = self.random.getrandbits(128)\n        return str(uuid.UUID(int=bits, version=version))", "code_tokens": "def uuid ( self , version : int = None ) -> str : bits = self . random . getrandbits ( 128 ) return str ( uuid . UUID ( int = bits , version = version ) )", "docstring_tokens": "Generate random UUID .", "label": 0}, {"idx": "cosqa-train-17769", "doc": "read in csv as numpy array python", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 1}, {"idx": "cosqa-train-17770", "doc": "remove cache python flask", "code": "def setup_cache(app: Flask, cache_config) -> Optional[Cache]:\n    \"\"\"Setup the flask-cache on a flask app\"\"\"\n    if cache_config and cache_config.get('CACHE_TYPE') != 'null':\n        return Cache(app, config=cache_config)\n\n    return None", "code_tokens": "def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None", "docstring_tokens": "Setup the flask - cache on a flask app", "label": 0}, {"idx": "cosqa-train-17771", "doc": "flaten a list of list python", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 1}, {"idx": "cosqa-train-17772", "doc": "how to write or sympole in python", "code": "def fprint(expr, print_ascii=False):\n    r\"\"\"This function chooses whether to use ascii characters to represent\n    a symbolic expression in the notebook or to use sympy's pprint.\n\n    >>> from sympy import cos\n    >>> omega=Symbol(\"omega\")\n    >>> fprint(cos(omega),print_ascii=True)\n    cos(omega)\n\n\n    \"\"\"\n    if print_ascii:\n        pprint(expr, use_unicode=False, num_columns=120)\n    else:\n        return expr", "code_tokens": "def fprint ( expr , print_ascii = False ) : if print_ascii : pprint ( expr , use_unicode = False , num_columns = 120 ) else : return expr", "docstring_tokens": "r This function chooses whether to use ascii characters to represent a symbolic expression in the notebook or to use sympy s pprint .", "label": 1}, {"idx": "cosqa-train-17773", "doc": "python mysql query executemany", "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None:\n        \"\"\"Execute the given multiquery.\"\"\"\n        await self._execute(self._cursor.executemany, sql, parameters)", "code_tokens": "async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "docstring_tokens": "Execute the given multiquery .", "label": 0}, {"idx": "cosqa-train-17774", "doc": "python cursor fetchone iterable", "code": "async def fetchall(self) -> Iterable[sqlite3.Row]:\n        \"\"\"Fetch all remaining rows.\"\"\"\n        return await self._execute(self._cursor.fetchall)", "code_tokens": "async def fetchall ( self ) -> Iterable [ sqlite3 . Row ] : return await self . _execute ( self . _cursor . fetchall )", "docstring_tokens": "Fetch all remaining rows .", "label": 1}, {"idx": "cosqa-train-17775", "doc": "python integer rounded to closest value", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 0}, {"idx": "cosqa-train-17776", "doc": "python api calls limit calls per limit", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 0}, {"idx": "cosqa-train-17777", "doc": "how to compare 'none' with none in python", "code": "def is_none(string_, default='raise'):\n    \"\"\"\n    Check if a string is equivalent to None.\n\n    Parameters\n    ----------\n    string_ : str\n    default : {'raise', False}\n        Default behaviour if none of the \"None\" strings is detected.\n\n    Returns\n    -------\n    is_none : bool\n\n    Examples\n    --------\n    >>> is_none('2', default=False)\n    False\n    >>> is_none('undefined', default=False)\n    True\n    \"\"\"\n    none = ['none', 'undefined', 'unknown', 'null', '']\n    if string_.lower() in none:\n        return True\n    elif not default:\n        return False\n    else:\n        raise ValueError('The value \\'{}\\' cannot be mapped to none.'\n                         .format(string_))", "code_tokens": "def is_none ( string_ , default = 'raise' ) : none = [ 'none' , 'undefined' , 'unknown' , 'null' , '' ] if string_ . lower ( ) in none : return True elif not default : return False else : raise ValueError ( 'The value \\'{}\\' cannot be mapped to none.' . format ( string_ ) )", "docstring_tokens": "Check if a string is equivalent to None .", "label": 0}, {"idx": "cosqa-train-17778", "doc": "python check if paths are same", "code": "def samefile(a: str, b: str) -> bool:\n    \"\"\"Check if two pathes represent the same file.\"\"\"\n    try:\n        return os.path.samefile(a, b)\n    except OSError:\n        return os.path.normpath(a) == os.path.normpath(b)", "code_tokens": "def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )", "docstring_tokens": "Check if two pathes represent the same file .", "label": 0}, {"idx": "cosqa-train-17779", "doc": "how to login to jira dynamically using rest apis and python", "code": "async def login(\n        username: str, password: str, brand: str,\n        websession: ClientSession = None) -> API:\n    \"\"\"Log in to the API.\"\"\"\n    api = API(brand, websession)\n    await api.authenticate(username, password)\n    return api", "code_tokens": "async def login ( username : str , password : str , brand : str , websession : ClientSession = None ) -> API : api = API ( brand , websession ) await api . authenticate ( username , password ) return api", "docstring_tokens": "Log in to the API .", "label": 1}, {"idx": "cosqa-train-17780", "doc": "python check for a roll over counter", "code": "def should_rollover(self, record: LogRecord) -> bool:\n        \"\"\"\n        Determine if rollover should occur.\n\n        record is not used, as we are just comparing times, but it is needed so\n        the method signatures are the same\n        \"\"\"\n        t = int(time.time())\n        if t >= self.rollover_at:\n            return True\n        return False", "code_tokens": "def should_rollover ( self , record : LogRecord ) -> bool : t = int ( time . time ( ) ) if t >= self . rollover_at : return True return False", "docstring_tokens": "Determine if rollover should occur .", "label": 1}, {"idx": "cosqa-train-17781", "doc": "stop python none end", "code": "def do_quit(self, _: argparse.Namespace) -> bool:\n        \"\"\"Exit this application\"\"\"\n        self._should_quit = True\n        return self._STOP_AND_EXIT", "code_tokens": "def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "docstring_tokens": "Exit this application", "label": 0}, {"idx": "cosqa-train-17782", "doc": "python apply median filter to part of the image", "code": "def fast_median(a):\n    \"\"\"Fast median operation for masked array using 50th-percentile\n    \"\"\"\n    a = checkma(a)\n    #return scoreatpercentile(a.compressed(), 50)\n    if a.count() > 0:\n        out = np.percentile(a.compressed(), 50)\n    else:\n        out = np.ma.masked\n    return out", "code_tokens": "def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out", "docstring_tokens": "Fast median operation for masked array using 50th - percentile", "label": 1}, {"idx": "cosqa-train-17783", "doc": "how to turn list of strings into integers python", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 0}, {"idx": "cosqa-train-17784", "doc": "python judge relative url", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 1}, {"idx": "cosqa-train-17785", "doc": "remove the blank in python string", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 1}, {"idx": "cosqa-train-17786", "doc": "python rest call header", "code": "def _request(self, method: str, endpoint: str, params: dict = None, data: dict = None, headers: dict = None) -> dict:\n        \"\"\"HTTP request method of interface implementation.\"\"\"", "code_tokens": "def _request ( self , method : str , endpoint : str , params : dict = None , data : dict = None , headers : dict = None ) -> dict :", "docstring_tokens": "HTTP request method of interface implementation .", "label": 0}, {"idx": "cosqa-train-17787", "doc": "how to sav model after epoch python", "code": "def after_epoch(self, **_) -> None:\n        \"\"\"Save/override the latest model after every epoch.\"\"\"\n        SaveEvery.save_model(model=self._model, name_suffix=self._OUTPUT_NAME, on_failure=self._on_save_failure)", "code_tokens": "def after_epoch ( self , * * _ ) -> None : SaveEvery . save_model ( model = self . _model , name_suffix = self . _OUTPUT_NAME , on_failure = self . _on_save_failure )", "docstring_tokens": "Save / override the latest model after every epoch .", "label": 1}, {"idx": "cosqa-train-17788", "doc": "how to get the last item in a series python", "code": "def last(self):\n        \"\"\"Last time step available.\n\n        Example:\n            >>> sdat = StagyyData('path/to/run')\n            >>> assert(sdat.steps.last is sdat.steps[-1])\n        \"\"\"\n        if self._last is UNDETERMINED:\n            # not necessarily the last one...\n            self._last = self.sdat.tseries.index[-1]\n        return self[self._last]", "code_tokens": "def last ( self ) : if self . _last is UNDETERMINED : # not necessarily the last one... self . _last = self . sdat . tseries . index [ - 1 ] return self [ self . _last ]", "docstring_tokens": "Last time step available .", "label": 0}, {"idx": "cosqa-train-17789", "doc": "python last poststep not showing on plot", "code": "def prevPlot(self):\n        \"\"\"Moves the displayed plot to the previous one\"\"\"\n        if self.stacker.currentIndex() > 0:\n            self.stacker.setCurrentIndex(self.stacker.currentIndex()-1)", "code_tokens": "def prevPlot ( self ) : if self . stacker . currentIndex ( ) > 0 : self . stacker . setCurrentIndex ( self . stacker . currentIndex ( ) - 1 )", "docstring_tokens": "Moves the displayed plot to the previous one", "label": 0}, {"idx": "cosqa-train-17790", "doc": "python3 decode not defined", "code": "def decodebytes(input):\n    \"\"\"Decode base64 string to byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _decodebytes_py3(input)\n    return _decodebytes_py2(input)", "code_tokens": "def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )", "docstring_tokens": "Decode base64 string to byte array .", "label": 0}, {"idx": "cosqa-train-17791", "doc": "how to check if you have 64bit python", "code": "def check64bit(current_system=\"python\"):\n    \"\"\"checks if you are on a 64 bit platform\"\"\"\n    if current_system == \"python\":\n        return sys.maxsize > 2147483647\n    elif current_system == \"os\":\n        import platform\n        pm = platform.machine()\n        if pm != \"..\" and pm.endswith('64'):  # recent Python (not Iron)\n            return True\n        else:\n            if 'PROCESSOR_ARCHITEW6432' in os.environ:\n                return True  # 32 bit program running on 64 bit Windows\n            try:\n                # 64 bit Windows 64 bit program\n                return os.environ['PROCESSOR_ARCHITECTURE'].endswith('64')\n            except IndexError:\n                pass  # not Windows\n            try:\n                # this often works in Linux\n                return '64' in platform.architecture()[0]\n            except Exception:\n                # is an older version of Python, assume also an older os@\n                # (best we can guess)\n                return False", "code_tokens": "def check64bit ( current_system = \"python\" ) : if current_system == \"python\" : return sys . maxsize > 2147483647 elif current_system == \"os\" : import platform pm = platform . machine ( ) if pm != \"..\" and pm . endswith ( '64' ) : # recent Python (not Iron) return True else : if 'PROCESSOR_ARCHITEW6432' in os . environ : return True # 32 bit program running on 64 bit Windows try : # 64 bit Windows 64 bit program return os . environ [ 'PROCESSOR_ARCHITECTURE' ] . endswith ( '64' ) except IndexError : pass # not Windows try : # this often works in Linux return '64' in platform . architecture ( ) [ 0 ] except Exception : # is an older version of Python, assume also an older os@ # (best we can guess) return False", "docstring_tokens": "checks if you are on a 64 bit platform", "label": 1}, {"idx": "cosqa-train-17792", "doc": "python function to determine if boolean is prime", "code": "def is_prime(n):\n    \"\"\"\n    Check if n is a prime number\n    \"\"\"\n    if n % 2 == 0 and n > 2:\n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))", "code_tokens": "def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "docstring_tokens": "Check if n is a prime number", "label": 1}, {"idx": "cosqa-train-17793", "doc": "deleting xml elements with python element tree", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 1}, {"idx": "cosqa-train-17794", "doc": "python print string formate numpy array", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 1}, {"idx": "cosqa-train-17795", "doc": "python dynamo query partition key and sort key", "code": "def sortBy(self, keyfunc, ascending=True, numPartitions=None):\n        \"\"\"\n        Sorts this RDD by the given keyfunc\n\n        >>> tmp = [('a', 1), ('b', 2), ('1', 3), ('d', 4), ('2', 5)]\n        >>> sc.parallelize(tmp).sortBy(lambda x: x[0]).collect()\n        [('1', 3), ('2', 5), ('a', 1), ('b', 2), ('d', 4)]\n        >>> sc.parallelize(tmp).sortBy(lambda x: x[1]).collect()\n        [('a', 1), ('b', 2), ('1', 3), ('d', 4), ('2', 5)]\n        \"\"\"\n        return self.keyBy(keyfunc).sortByKey(ascending, numPartitions).values()", "code_tokens": "def sortBy ( self , keyfunc , ascending = True , numPartitions = None ) : return self . keyBy ( keyfunc ) . sortByKey ( ascending , numPartitions ) . values ( )", "docstring_tokens": "Sorts this RDD by the given keyfunc", "label": 1}, {"idx": "cosqa-train-17796", "doc": "return top ten in python", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 0}, {"idx": "cosqa-train-17797", "doc": "python replace multiple strings with same string", "code": "def multiple_replace(string, replacements):\n    # type: (str, Dict[str,str]) -> str\n    \"\"\"Simultaneously replace multiple strigns in a string\n\n    Args:\n        string (str): Input string\n        replacements (Dict[str,str]): Replacements dictionary\n\n    Returns:\n        str: String with replacements\n\n    \"\"\"\n    pattern = re.compile(\"|\".join([re.escape(k) for k in sorted(replacements, key=len, reverse=True)]), flags=re.DOTALL)\n    return pattern.sub(lambda x: replacements[x.group(0)], string)", "code_tokens": "def multiple_replace ( string , replacements ) : # type: (str, Dict[str,str]) -> str pattern = re . compile ( \"|\" . join ( [ re . escape ( k ) for k in sorted ( replacements , key = len , reverse = True ) ] ) , flags = re . DOTALL ) return pattern . sub ( lambda x : replacements [ x . group ( 0 ) ] , string )", "docstring_tokens": "Simultaneously replace multiple strigns in a string", "label": 1}, {"idx": "cosqa-train-17798", "doc": "median of an array of arrays, python", "code": "def fast_median(a):\n    \"\"\"Fast median operation for masked array using 50th-percentile\n    \"\"\"\n    a = checkma(a)\n    #return scoreatpercentile(a.compressed(), 50)\n    if a.count() > 0:\n        out = np.percentile(a.compressed(), 50)\n    else:\n        out = np.ma.masked\n    return out", "code_tokens": "def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out", "docstring_tokens": "Fast median operation for masked array using 50th - percentile", "label": 1}, {"idx": "cosqa-train-17799", "doc": "how to keep unqiue value in a list python", "code": "def uniqued(iterable):\n    \"\"\"Return unique list of ``iterable`` items preserving order.\n\n    >>> uniqued('spameggs')\n    ['s', 'p', 'a', 'm', 'e', 'g']\n    \"\"\"\n    seen = set()\n    return [item for item in iterable if item not in seen and not seen.add(item)]", "code_tokens": "def uniqued ( iterable ) : seen = set ( ) return [ item for item in iterable if item not in seen and not seen . add ( item ) ]", "docstring_tokens": "Return unique list of iterable items preserving order .", "label": 0}, {"idx": "cosqa-train-17800", "doc": "python identify duplicate observations", "code": "def _check_samples_nodups(fnames):\n    \"\"\"Ensure a set of input VCFs do not have duplicate samples.\n    \"\"\"\n    counts = defaultdict(int)\n    for f in fnames:\n        for s in get_samples(f):\n            counts[s] += 1\n    duplicates = [s for s, c in counts.items() if c > 1]\n    if duplicates:\n        raise ValueError(\"Duplicate samples found in inputs %s: %s\" % (duplicates, fnames))", "code_tokens": "def _check_samples_nodups ( fnames ) : counts = defaultdict ( int ) for f in fnames : for s in get_samples ( f ) : counts [ s ] += 1 duplicates = [ s for s , c in counts . items ( ) if c > 1 ] if duplicates : raise ValueError ( \"Duplicate samples found in inputs %s: %s\" % ( duplicates , fnames ) )", "docstring_tokens": "Ensure a set of input VCFs do not have duplicate samples .", "label": 0}, {"idx": "cosqa-train-17801", "doc": "python get dimensions of a window", "code": "def get_window_dim():\n    \"\"\" gets the dimensions depending on python version and os\"\"\"\n    version = sys.version_info\n\n    if version >= (3, 3):\n        return _size_36()\n    if platform.system() == 'Windows':\n        return _size_windows()\n    return _size_27()", "code_tokens": "def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )", "docstring_tokens": "gets the dimensions depending on python version and os", "label": 1}, {"idx": "cosqa-train-17802", "doc": "trim off specific number of leading zeros python", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 0}, {"idx": "cosqa-train-17803", "doc": "python base64 incorrect padding", "code": "def decode_base64(data: str) -> bytes:\n    \"\"\"Decode base64, padding being optional.\n\n    :param data: Base64 data as an ASCII byte string\n    :returns: The decoded byte string.\n    \"\"\"\n    missing_padding = len(data) % 4\n    if missing_padding != 0:\n        data += \"=\" * (4 - missing_padding)\n    return base64.decodebytes(data.encode(\"utf-8\"))", "code_tokens": "def decode_base64 ( data : str ) -> bytes : missing_padding = len ( data ) % 4 if missing_padding != 0 : data += \"=\" * ( 4 - missing_padding ) return base64 . decodebytes ( data . encode ( \"utf-8\" ) )", "docstring_tokens": "Decode base64 padding being optional .", "label": 0}, {"idx": "cosqa-train-17804", "doc": "get last day of the month data python", "code": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day", "code_tokens": "def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "docstring_tokens": "Returns day number of the last day of the month : param t : datetime : return : int", "label": 1}, {"idx": "cosqa-train-17805", "doc": "how to know if a object is in a list twice in python", "code": "def obj_in_list_always(target_list, obj):\n    \"\"\"\n    >>> l = [1,1,1]\n    >>> obj_in_list_always(l, 1)\n    True\n    >>> l.append(2)\n    >>> obj_in_list_always(l, 1)\n    False\n    \"\"\"\n    for item in set(target_list):\n        if item is not obj:\n            return False\n    return True", "code_tokens": "def obj_in_list_always ( target_list , obj ) : for item in set ( target_list ) : if item is not obj : return False return True", "docstring_tokens": ">>> l = [ 1 1 1 ] >>> obj_in_list_always ( l 1 ) True >>> l . append ( 2 ) >>> obj_in_list_always ( l 1 ) False", "label": 1}, {"idx": "cosqa-train-17806", "doc": "python check if float has no floating points", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 1}, {"idx": "cosqa-train-17807", "doc": "python check datatype of column", "code": "def is_sqlatype_string(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type a string type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.String)", "code_tokens": "def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "docstring_tokens": "Is the SQLAlchemy column type a string type?", "label": 1}, {"idx": "cosqa-train-17808", "doc": "python check whether file is updated first time", "code": "def has_changed (filename):\n    \"\"\"Check if filename has changed since the last check. If this\n    is the first check, assume the file is changed.\"\"\"\n    key = os.path.abspath(filename)\n    mtime = get_mtime(key)\n    if key not in _mtime_cache:\n        _mtime_cache[key] = mtime\n        return True\n    return mtime > _mtime_cache[key]", "code_tokens": "def has_changed ( filename ) : key = os . path . abspath ( filename ) mtime = get_mtime ( key ) if key not in _mtime_cache : _mtime_cache [ key ] = mtime return True return mtime > _mtime_cache [ key ]", "docstring_tokens": "Check if filename has changed since the last check . If this is the first check assume the file is changed .", "label": 1}, {"idx": "cosqa-train-17809", "doc": "pasting data from clipboard in python", "code": "def copy_without_prompts(self):\n        \"\"\"Copy text to clipboard without prompts\"\"\"\n        text = self.get_selected_text()\n        lines = text.split(os.linesep)\n        for index, line in enumerate(lines):\n            if line.startswith('>>> ') or line.startswith('... '):\n                lines[index] = line[4:]\n        text = os.linesep.join(lines)\n        QApplication.clipboard().setText(text)", "code_tokens": "def copy_without_prompts ( self ) : text = self . get_selected_text ( ) lines = text . split ( os . linesep ) for index , line in enumerate ( lines ) : if line . startswith ( '>>> ' ) or line . startswith ( '... ' ) : lines [ index ] = line [ 4 : ] text = os . linesep . join ( lines ) QApplication . clipboard ( ) . setText ( text )", "docstring_tokens": "Copy text to clipboard without prompts", "label": 1}, {"idx": "cosqa-train-17810", "doc": "check datatype of datatable column python", "code": "def is_sqlatype_numeric(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type one that inherits from :class:`Numeric`,\n    such as :class:`Float`, :class:`Decimal`?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Numeric)", "code_tokens": "def is_sqlatype_numeric ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Numeric )", "docstring_tokens": "Is the SQLAlchemy column type one that inherits from : class : Numeric such as : class : Float : class : Decimal ?", "label": 1}, {"idx": "cosqa-train-17811", "doc": "how to check if there is nan in an array python", "code": "def warn_if_nans_exist(X):\n    \"\"\"Warn if nans exist in a numpy array.\"\"\"\n    null_count = count_rows_with_nans(X)\n    total = len(X)\n    percent = 100 * null_count / total\n\n    if null_count > 0:\n        warning_message = \\\n            'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\\n            'complete rows will be plotted.'.format(null_count, total, percent)\n        warnings.warn(warning_message, DataWarning)", "code_tokens": "def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "docstring_tokens": "Warn if nans exist in a numpy array .", "label": 0}, {"idx": "cosqa-train-17812", "doc": "python check data shape", "code": "def check_lengths(*arrays):\n    \"\"\"\n    tool to ensure input and output data have the same number of samples\n\n    Parameters\n    ----------\n    *arrays : iterable of arrays to be checked\n\n    Returns\n    -------\n    None\n    \"\"\"\n    lengths = [len(array) for array in arrays]\n    if len(np.unique(lengths)) > 1:\n        raise ValueError('Inconsistent data lengths: {}'.format(lengths))", "code_tokens": "def check_lengths ( * arrays ) : lengths = [ len ( array ) for array in arrays ] if len ( np . unique ( lengths ) ) > 1 : raise ValueError ( 'Inconsistent data lengths: {}' . format ( lengths ) )", "docstring_tokens": "tool to ensure input and output data have the same number of samples", "label": 1}, {"idx": "cosqa-train-17813", "doc": "minimum of a column python", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-17814", "doc": "python numpy array from csv file", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 1}, {"idx": "cosqa-train-17815", "doc": "python networkx get longest path", "code": "def dag_longest_path(graph, source, target):\n    \"\"\"\n    Finds the longest path in a dag between two nodes\n    \"\"\"\n    if source == target:\n        return [source]\n    allpaths = nx.all_simple_paths(graph, source, target)\n    longest_path = []\n    for l in allpaths:\n        if len(l) > len(longest_path):\n            longest_path = l\n    return longest_path", "code_tokens": "def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "docstring_tokens": "Finds the longest path in a dag between two nodes", "label": 1}, {"idx": "cosqa-train-17816", "doc": "python list duplicate index", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 1}, {"idx": "cosqa-train-17817", "doc": "python 3 iter every n items", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 0}, {"idx": "cosqa-train-17818", "doc": "python xml elementtree delete child", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 1}, {"idx": "cosqa-train-17819", "doc": "list of lists into a flat list python", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 0}, {"idx": "cosqa-train-17820", "doc": "conditional if a variable is not an empty set python", "code": "def is_any_type_set(sett: Set[Type]) -> bool:\n    \"\"\"\n    Helper method to check if a set of types is the {AnyObject} singleton\n\n    :param sett:\n    :return:\n    \"\"\"\n    return len(sett) == 1 and is_any_type(min(sett))", "code_tokens": "def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )", "docstring_tokens": "Helper method to check if a set of types is the { AnyObject } singleton", "label": 1}, {"idx": "cosqa-train-17821", "doc": "python ndarray nonzero indics", "code": "def isfinite(data: mx.nd.NDArray) -> mx.nd.NDArray:\n    \"\"\"Performs an element-wise check to determine if the NDArray contains an infinite element or not.\n       TODO: remove this funciton after upgrade to MXNet 1.4.* in favor of mx.ndarray.contrib.isfinite()\n    \"\"\"\n    is_data_not_nan = data == data\n    is_data_not_infinite = data.abs() != np.inf\n    return mx.nd.logical_and(is_data_not_infinite, is_data_not_nan)", "code_tokens": "def isfinite ( data : mx . nd . NDArray ) -> mx . nd . NDArray : is_data_not_nan = data == data is_data_not_infinite = data . abs ( ) != np . inf return mx . nd . logical_and ( is_data_not_infinite , is_data_not_nan )", "docstring_tokens": "Performs an element - wise check to determine if the NDArray contains an infinite element or not . TODO : remove this funciton after upgrade to MXNet 1 . 4 . * in favor of mx . ndarray . contrib . isfinite ()", "label": 0}, {"idx": "cosqa-train-17822", "doc": "how is python binary string encoded", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 1}, {"idx": "cosqa-train-17823", "doc": "set ranges on colormap python", "code": "def set_range(self, min_val, max_val):\n        \"\"\"Set the range of the colormap to [*min_val*, *max_val*]\n        \"\"\"\n        if min_val > max_val:\n            max_val, min_val = min_val, max_val\n        self.values = (((self.values * 1.0 - self.values.min()) /\n                        (self.values.max() - self.values.min()))\n                       * (max_val - min_val) + min_val)", "code_tokens": "def set_range ( self , min_val , max_val ) : if min_val > max_val : max_val , min_val = min_val , max_val self . values = ( ( ( self . values * 1.0 - self . values . min ( ) ) / ( self . values . max ( ) - self . values . min ( ) ) ) * ( max_val - min_val ) + min_val )", "docstring_tokens": "Set the range of the colormap to [ * min_val * * max_val * ]", "label": 1}, {"idx": "cosqa-train-17824", "doc": "minimum distance in a list of pair no in python", "code": "def closest_values(L):\n    \"\"\"Closest values\n\n    :param L: list of values\n    :returns: two values from L with minimal distance\n    :modifies: the order of L\n    :complexity: O(n log n), for n=len(L)\n    \"\"\"\n    assert len(L) >= 2\n    L.sort()\n    valmin, argmin = min((L[i] - L[i - 1], i) for i in range(1, len(L)))\n    return L[argmin - 1], L[argmin]", "code_tokens": "def closest_values ( L ) : assert len ( L ) >= 2 L . sort ( ) valmin , argmin = min ( ( L [ i ] - L [ i - 1 ] , i ) for i in range ( 1 , len ( L ) ) ) return L [ argmin - 1 ] , L [ argmin ]", "docstring_tokens": "Closest values", "label": 1}, {"idx": "cosqa-train-17825", "doc": "get the sql query result python postgresql", "code": "def execute_sql(self, query):\n        \"\"\"\n        Executes a given query string on an open postgres database.\n\n        \"\"\"\n        c = self.con.cursor()\n        c.execute(query)\n        result = []\n        if c.rowcount > 0:\n            try:\n                result = c.fetchall()\n            except psycopg2.ProgrammingError:\n                pass\n        return result", "code_tokens": "def execute_sql ( self , query ) : c = self . con . cursor ( ) c . execute ( query ) result = [ ] if c . rowcount > 0 : try : result = c . fetchall ( ) except psycopg2 . ProgrammingError : pass return result", "docstring_tokens": "Executes a given query string on an open postgres database .", "label": 0}, {"idx": "cosqa-train-17826", "doc": "python create tuple from part of a list", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 1}, {"idx": "cosqa-train-17827", "doc": "python check if something is equal to any of a set of objects", "code": "def is_any_type_set(sett: Set[Type]) -> bool:\n    \"\"\"\n    Helper method to check if a set of types is the {AnyObject} singleton\n\n    :param sett:\n    :return:\n    \"\"\"\n    return len(sett) == 1 and is_any_type(min(sett))", "code_tokens": "def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )", "docstring_tokens": "Helper method to check if a set of types is the { AnyObject } singleton", "label": 1}, {"idx": "cosqa-train-17828", "doc": "python flattent list of list", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 0}, {"idx": "cosqa-train-17829", "doc": "python check if a date is valid", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 1}, {"idx": "cosqa-train-17830", "doc": "to know the current postion of the file cursor the function used is in python", "code": "def position(self) -> Position:\n        \"\"\"The current position of the cursor.\"\"\"\n        return Position(self._index, self._lineno, self._col_offset)", "code_tokens": "def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "docstring_tokens": "The current position of the cursor .", "label": 1}, {"idx": "cosqa-train-17831", "doc": "how to check for whitespace in python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 0}, {"idx": "cosqa-train-17832", "doc": "change column values to uppercase in python", "code": "def str_upper(x):\n    \"\"\"Converts all strings in a column to uppercase.\n\n    :returns: an expression containing the converted strings.\n\n    Example:\n\n    >>> import vaex\n    >>> text = ['Something', 'very pretty', 'is coming', 'our', 'way.']\n    >>> df = vaex.from_arrays(text=text)\n    >>> df\n      #  text\n      0  Something\n      1  very pretty\n      2  is coming\n      3  our\n      4  way.\n\n\n    >>> df.text.str.upper()\n    Expression = str_upper(text)\n    Length: 5 dtype: str (expression)\n    ---------------------------------\n    0    SOMETHING\n    1  VERY PRETTY\n    2    IS COMING\n    3          OUR\n    4         WAY.\n\n    \"\"\"\n    sl = _to_string_sequence(x).upper()\n    return column.ColumnStringArrow(sl.bytes, sl.indices, sl.length, sl.offset, string_sequence=sl)", "code_tokens": "def str_upper ( x ) : sl = _to_string_sequence ( x ) . upper ( ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "docstring_tokens": "Converts all strings in a column to uppercase .", "label": 0}, {"idx": "cosqa-train-17833", "doc": "how to see if string is an int python", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-17834", "doc": "if condition for between values python", "code": "def non_increasing(values):\n    \"\"\"True if values are not increasing.\"\"\"\n    return all(x >= y for x, y in zip(values, values[1:]))", "code_tokens": "def non_increasing ( values ) : return all ( x >= y for x , y in zip ( values , values [ 1 : ] ) )", "docstring_tokens": "True if values are not increasing .", "label": 0}, {"idx": "cosqa-train-17835", "doc": "python to get min of a column", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-17836", "doc": "python memoryview memory fragments", "code": "def read(self, start_position: int, size: int) -> memoryview:\n        \"\"\"\n        Return a view into the memory\n        \"\"\"\n        return memoryview(self._bytes)[start_position:start_position + size]", "code_tokens": "def read ( self , start_position : int , size : int ) -> memoryview : return memoryview ( self . _bytes ) [ start_position : start_position + size ]", "docstring_tokens": "Return a view into the memory", "label": 1}, {"idx": "cosqa-train-17837", "doc": "python to determine longest string in list", "code": "def _prm_get_longest_stringsize(string_list):\n        \"\"\" Returns the longest string size for a string entry across data.\"\"\"\n        maxlength = 1\n\n        for stringar in string_list:\n            if isinstance(stringar, np.ndarray):\n                if stringar.ndim > 0:\n                    for string in stringar.ravel():\n                        maxlength = max(len(string), maxlength)\n                else:\n                    maxlength = max(len(stringar.tolist()), maxlength)\n            else:\n                maxlength = max(len(stringar), maxlength)\n\n        # Make the string Col longer than needed in order to allow later on slightly larger strings\n        return int(maxlength * 1.5)", "code_tokens": "def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "docstring_tokens": "Returns the longest string size for a string entry across data .", "label": 0}, {"idx": "cosqa-train-17838", "doc": "python read process output as a stream", "code": "async def stdout(self) -> AsyncGenerator[str, None]:\n        \"\"\"Asynchronous generator for lines from subprocess stdout.\"\"\"\n        await self.wait_running()\n        async for line in self._subprocess.stdout:  # type: ignore\n            yield line", "code_tokens": "async def stdout ( self ) -> AsyncGenerator [ str , None ] : await self . wait_running ( ) async for line in self . _subprocess . stdout : # type: ignore yield line", "docstring_tokens": "Asynchronous generator for lines from subprocess stdout .", "label": 0}, {"idx": "cosqa-train-17839", "doc": "implement a function to check if a binary tree is balanced python", "code": "def same_network(atree, btree) -> bool:\n    \"\"\"True if given trees share the same structure of powernodes,\n    independently of (power)node names,\n    and same edge topology between (power)nodes.\n\n    \"\"\"\n    return same_hierarchy(atree, btree) and same_topology(atree, btree)", "code_tokens": "def same_network ( atree , btree ) -> bool : return same_hierarchy ( atree , btree ) and same_topology ( atree , btree )", "docstring_tokens": "True if given trees share the same structure of powernodes independently of ( power ) node names and same edge topology between ( power ) nodes .", "label": 0}, {"idx": "cosqa-train-17840", "doc": "is python a strict typed language", "code": "def is_strict_numeric(n: Node) -> bool:\n    \"\"\" numeric denotes typed literals with datatypes xsd:integer, xsd:decimal, xsd:float, and xsd:double. \"\"\"\n    return is_typed_literal(n) and cast(Literal, n).datatype in [XSD.integer, XSD.decimal, XSD.float, XSD.double]", "code_tokens": "def is_strict_numeric ( n : Node ) -> bool : return is_typed_literal ( n ) and cast ( Literal , n ) . datatype in [ XSD . integer , XSD . decimal , XSD . float , XSD . double ]", "docstring_tokens": "numeric denotes typed literals with datatypes xsd : integer xsd : decimal xsd : float and xsd : double .", "label": 1}, {"idx": "cosqa-train-17841", "doc": "listing all types of variable in datframe python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 0}, {"idx": "cosqa-train-17842", "doc": "boost python3 bytes extrac", "code": "def bytes_hack(buf):\n    \"\"\"\n    Hacky workaround for old installs of the library on systems without python-future that were\n    keeping the 2to3 update from working after auto-update.\n    \"\"\"\n    ub = None\n    if sys.version_info > (3,):\n        ub = buf\n    else:\n        ub = bytes(buf)\n\n    return ub", "code_tokens": "def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "docstring_tokens": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update .", "label": 1}, {"idx": "cosqa-train-17843", "doc": "python camel to snake", "code": "def camel_to_snake(s: str) -> str:\n    \"\"\"Convert string from camel case to snake case.\"\"\"\n\n    return CAMEL_CASE_RE.sub(r'_\\1', s).strip().lower()", "code_tokens": "def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "docstring_tokens": "Convert string from camel case to snake case .", "label": 0}, {"idx": "cosqa-train-17844", "doc": "selecting the first 10 rows in python", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 1}, {"idx": "cosqa-train-17845", "doc": "python language key not found", "code": "def get_language():\n    \"\"\"\n    Wrapper around Django's `get_language` utility.\n    For Django >= 1.8, `get_language` returns None in case no translation is activate.\n    Here we patch this behavior e.g. for back-end functionality requiring access to translated fields\n    \"\"\"\n    from parler import appsettings\n    language = dj_get_language()\n    if language is None and appsettings.PARLER_DEFAULT_ACTIVATE:\n        return appsettings.PARLER_DEFAULT_LANGUAGE_CODE\n    else:\n        return language", "code_tokens": "def get_language ( ) : from parler import appsettings language = dj_get_language ( ) if language is None and appsettings . PARLER_DEFAULT_ACTIVATE : return appsettings . PARLER_DEFAULT_LANGUAGE_CODE else : return language", "docstring_tokens": "Wrapper around Django s get_language utility . For Django > = 1 . 8 get_language returns None in case no translation is activate . Here we patch this behavior e . g . for back - end functionality requiring access to translated fields", "label": 0}, {"idx": "cosqa-train-17846", "doc": "python check if a file path is a file or directory", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-17847", "doc": "dictionary python many values to key tuple", "code": "def flatten_multidict(multidict):\n    \"\"\"Return flattened dictionary from ``MultiDict``.\"\"\"\n    return dict([(key, value if len(value) > 1 else value[0])\n                 for (key, value) in multidict.iterlists()])", "code_tokens": "def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "docstring_tokens": "Return flattened dictionary from MultiDict .", "label": 0}, {"idx": "cosqa-train-17848", "doc": "delete all non alphanumeric characters in a program python", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 0}, {"idx": "cosqa-train-17849", "doc": "python list get most frequent item", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 0}, {"idx": "cosqa-train-17850", "doc": "python base64 encode incorrect padding", "code": "def b64_decode(data: bytes) -> bytes:\n    \"\"\"\n    :param data: Base 64 encoded data to decode.\n    :type data: bytes\n    :return: Base 64 decoded data.\n    :rtype: bytes\n    \"\"\"\n    missing_padding = len(data) % 4\n    if missing_padding != 0:\n        data += b'=' * (4 - missing_padding)\n    return urlsafe_b64decode(data)", "code_tokens": "def b64_decode ( data : bytes ) -> bytes : missing_padding = len ( data ) % 4 if missing_padding != 0 : data += b'=' * ( 4 - missing_padding ) return urlsafe_b64decode ( data )", "docstring_tokens": ": param data : Base 64 encoded data to decode . : type data : bytes : return : Base 64 decoded data . : rtype : bytes", "label": 0}, {"idx": "cosqa-train-17851", "doc": "how to flatten a list of lists in python", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 1}, {"idx": "cosqa-train-17852", "doc": "miliseconds in python datetime from string", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 0}, {"idx": "cosqa-train-17853", "doc": "creating block diagonal matrices in python", "code": "def block_diag(*blocks: np.ndarray) -> np.ndarray:\n    \"\"\"Concatenates blocks into a block diagonal matrix.\n\n    Args:\n        *blocks: Square matrices to place along the diagonal of the result.\n\n    Returns:\n        A block diagonal matrix with the given blocks along its diagonal.\n\n    Raises:\n        ValueError: A block isn't square.\n    \"\"\"\n    for b in blocks:\n        if b.shape[0] != b.shape[1]:\n            raise ValueError('Blocks must be square.')\n\n    if not blocks:\n        return np.zeros((0, 0), dtype=np.complex128)\n\n    n = sum(b.shape[0] for b in blocks)\n    dtype = functools.reduce(_merge_dtypes, (b.dtype for b in blocks))\n\n    result = np.zeros(shape=(n, n), dtype=dtype)\n    i = 0\n    for b in blocks:\n        j = i + b.shape[0]\n        result[i:j, i:j] = b\n        i = j\n\n    return result", "code_tokens": "def block_diag ( * blocks : np . ndarray ) -> np . ndarray : for b in blocks : if b . shape [ 0 ] != b . shape [ 1 ] : raise ValueError ( 'Blocks must be square.' ) if not blocks : return np . zeros ( ( 0 , 0 ) , dtype = np . complex128 ) n = sum ( b . shape [ 0 ] for b in blocks ) dtype = functools . reduce ( _merge_dtypes , ( b . dtype for b in blocks ) ) result = np . zeros ( shape = ( n , n ) , dtype = dtype ) i = 0 for b in blocks : j = i + b . shape [ 0 ] result [ i : j , i : j ] = b i = j return result", "docstring_tokens": "Concatenates blocks into a block diagonal matrix .", "label": 1}, {"idx": "cosqa-train-17854", "doc": "python sqlite3 cursor select iterable", "code": "async def fetchall(self) -> Iterable[sqlite3.Row]:\n        \"\"\"Fetch all remaining rows.\"\"\"\n        return await self._execute(self._cursor.fetchall)", "code_tokens": "async def fetchall ( self ) -> Iterable [ sqlite3 . Row ] : return await self . _execute ( self . _cursor . fetchall )", "docstring_tokens": "Fetch all remaining rows .", "label": 1}, {"idx": "cosqa-train-17855", "doc": "tensorflow python tensor to numpy array", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 0}, {"idx": "cosqa-train-17856", "doc": "python split on whitespace or punctuation", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 1}, {"idx": "cosqa-train-17857", "doc": "replace multiple characters in python string", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 0}, {"idx": "cosqa-train-17858", "doc": "python 3 dict iteriterms", "code": "def iterate_items(dictish):\n    \"\"\" Return a consistent (key, value) iterable on dict-like objects,\n    including lists of tuple pairs.\n\n    Example:\n\n        >>> list(iterate_items({'a': 1}))\n        [('a', 1)]\n        >>> list(iterate_items([('a', 1), ('b', 2)]))\n        [('a', 1), ('b', 2)]\n    \"\"\"\n    if hasattr(dictish, 'iteritems'):\n        return dictish.iteritems()\n    if hasattr(dictish, 'items'):\n        return dictish.items()\n    return dictish", "code_tokens": "def iterate_items ( dictish ) : if hasattr ( dictish , 'iteritems' ) : return dictish . iteritems ( ) if hasattr ( dictish , 'items' ) : return dictish . items ( ) return dictish", "docstring_tokens": "Return a consistent ( key value ) iterable on dict - like objects including lists of tuple pairs .", "label": 1}, {"idx": "cosqa-train-17859", "doc": "if safe to have both python 2 and 3", "code": "def bytes_hack(buf):\n    \"\"\"\n    Hacky workaround for old installs of the library on systems without python-future that were\n    keeping the 2to3 update from working after auto-update.\n    \"\"\"\n    ub = None\n    if sys.version_info > (3,):\n        ub = buf\n    else:\n        ub = bytes(buf)\n\n    return ub", "code_tokens": "def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "docstring_tokens": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update .", "label": 0}, {"idx": "cosqa-train-17860", "doc": "python delete value from set", "code": "def remove_once(gset, elem):\n    \"\"\"Remove the element from a set, lists or dict.\n    \n        >>> L = [\"Lucy\"]; S = set([\"Sky\"]); D = { \"Diamonds\": True };\n        >>> remove_once(L, \"Lucy\"); remove_once(S, \"Sky\"); remove_once(D, \"Diamonds\");\n        >>> print L, S, D\n        [] set([]) {}\n\n    Returns the element if it was removed. Raises one of the exceptions in \n    :obj:`RemoveError` otherwise.\n    \"\"\"\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "code_tokens": "def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "docstring_tokens": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}", "label": 0}, {"idx": "cosqa-train-17861", "doc": "def is prime in python", "code": "def is_prime(n):\n    \"\"\"\n    Check if n is a prime number\n    \"\"\"\n    if n % 2 == 0 and n > 2:\n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))", "code_tokens": "def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "docstring_tokens": "Check if n is a prime number", "label": 0}, {"idx": "cosqa-train-17862", "doc": "python get datetime now for mysql", "code": "def get_now_sql_datetime():\n    \"\"\"\n    *A datetime stamp in MySQL format: ``YYYY-MM-DDTHH:MM:SS``*\n\n    **Return:**\n        - ``now`` -- current time and date in MySQL format\n\n    **Usage:**\n        .. code-block:: python \n\n            from fundamentals import times\n            now = times.get_now_sql_datetime()\n            print now\n\n            # OUT: 2016-03-18T11:08:23 \n    \"\"\"\n    ## > IMPORTS ##\n    from datetime import datetime, date, time\n    now = datetime.now()\n    now = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    return now", "code_tokens": "def get_now_sql_datetime ( ) : ## > IMPORTS ## from datetime import datetime , date , time now = datetime . now ( ) now = now . strftime ( \"%Y-%m-%dT%H:%M:%S\" ) return now", "docstring_tokens": "* A datetime stamp in MySQL format : YYYY - MM - DDTHH : MM : SS *", "label": 0}, {"idx": "cosqa-train-17863", "doc": "how to check in python string for only contain alphabets, numbers and underscore", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-17864", "doc": "cast python list of strings to int", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-17865", "doc": "python testing if string is int", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-17866", "doc": "python pylint too strict", "code": "def lint(fmt='colorized'):\n    \"\"\"Run verbose PyLint on source. Optionally specify fmt=html for HTML output.\"\"\"\n    if fmt == 'html':\n        outfile = 'pylint_report.html'\n        local('pylint -f %s davies > %s || true' % (fmt, outfile))\n        local('open %s' % outfile)\n    else:\n        local('pylint -f %s davies || true' % fmt)", "code_tokens": "def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "docstring_tokens": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output .", "label": 0}, {"idx": "cosqa-train-17867", "doc": "function that counts the number o variabes equal to a certain value in a list python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 0}, {"idx": "cosqa-train-17868", "doc": "python sqlalchemy get table column names", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 0}, {"idx": "cosqa-train-17869", "doc": "python get hostip from url", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 1}, {"idx": "cosqa-train-17870", "doc": "return row with max value python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 1}, {"idx": "cosqa-train-17871", "doc": "how to get random variable normal distribution with python", "code": "def sample_normal(mean, var, rng):\n    \"\"\"Sample from independent normal distributions\n\n    Each element is an independent normal distribution.\n\n    Parameters\n    ----------\n    mean : numpy.ndarray\n      Means of the normal distribution. Shape --> (batch_num, sample_dim)\n    var : numpy.ndarray\n      Variance of the normal distribution. Shape --> (batch_num, sample_dim)\n    rng : numpy.random.RandomState\n\n    Returns\n    -------\n    ret : numpy.ndarray\n       The sampling result. Shape --> (batch_num, sample_dim)\n    \"\"\"\n    ret = numpy.sqrt(var) * rng.randn(*mean.shape) + mean\n    return ret", "code_tokens": "def sample_normal ( mean , var , rng ) : ret = numpy . sqrt ( var ) * rng . randn ( * mean . shape ) + mean return ret", "docstring_tokens": "Sample from independent normal distributions", "label": 0}, {"idx": "cosqa-train-17872", "doc": "python 3 list map lambda", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-17873", "doc": "how to check length of dequeue in python", "code": "def count(self, elem):\n        \"\"\"\n        Return the number of elements equal to elem present in the queue\n\n        >>> pdeque([1, 2, 1]).count(1)\n        2\n        \"\"\"\n        return self._left_list.count(elem) + self._right_list.count(elem)", "code_tokens": "def count ( self , elem ) : return self . _left_list . count ( elem ) + self . _right_list . count ( elem )", "docstring_tokens": "Return the number of elements equal to elem present in the queue", "label": 0}, {"idx": "cosqa-train-17874", "doc": "how to drop an element from a python dictionary", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 0}, {"idx": "cosqa-train-17875", "doc": "python trim blank space from string", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 1}, {"idx": "cosqa-train-17876", "doc": "finding last occorance in a string python", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 0}, {"idx": "cosqa-train-17877", "doc": "deleting an element from a dictionary python", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 0}, {"idx": "cosqa-train-17878", "doc": "how to track a tree python", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-17879", "doc": "transforming tokens into a count python", "code": "def _sum_cycles_from_tokens(self, tokens: List[str]) -> int:\n        \"\"\"Sum the total number of cycles over a list of tokens.\"\"\"\n        return sum((int(self._nonnumber_pattern.sub('', t)) for t in tokens))", "code_tokens": "def _sum_cycles_from_tokens ( self , tokens : List [ str ] ) -> int : return sum ( ( int ( self . _nonnumber_pattern . sub ( '' , t ) ) for t in tokens ) )", "docstring_tokens": "Sum the total number of cycles over a list of tokens .", "label": 1}, {"idx": "cosqa-train-17880", "doc": "get percentile of a value in a list python", "code": "def percentile(sorted_list, percent, key=lambda x: x):\n    \"\"\"Find the percentile of a sorted list of values.\n\n    Arguments\n    ---------\n    sorted_list : list\n        A sorted (ascending) list of values.\n    percent : float\n        A float value from 0.0 to 1.0.\n    key : function, optional\n        An optional function to compute a value from each element of N.\n\n    Returns\n    -------\n    float\n        The desired percentile of the value list.\n\n    Examples\n    --------\n    >>> sorted_list = [4,6,8,9,11]\n    >>> percentile(sorted_list, 0.4)\n    7.0\n    >>> percentile(sorted_list, 0.44)\n    8.0\n    >>> percentile(sorted_list, 0.6)\n    8.5\n    >>> percentile(sorted_list, 0.99)\n    11.0\n    >>> percentile(sorted_list, 1)\n    11.0\n    >>> percentile(sorted_list, 0)\n    4.0\n    \"\"\"\n    if not sorted_list:\n        return None\n    if percent == 1:\n        return float(sorted_list[-1])\n    if percent == 0:\n        return float(sorted_list[0])\n    n = len(sorted_list)\n    i = percent * n\n    if ceil(i) == i:\n        i = int(i)\n        return (sorted_list[i-1] + sorted_list[i]) / 2\n    return float(sorted_list[ceil(i)-1])", "code_tokens": "def percentile ( sorted_list , percent , key = lambda x : x ) : if not sorted_list : return None if percent == 1 : return float ( sorted_list [ - 1 ] ) if percent == 0 : return float ( sorted_list [ 0 ] ) n = len ( sorted_list ) i = percent * n if ceil ( i ) == i : i = int ( i ) return ( sorted_list [ i - 1 ] + sorted_list [ i ] ) / 2 return float ( sorted_list [ ceil ( i ) - 1 ] )", "docstring_tokens": "Find the percentile of a sorted list of values .", "label": 1}, {"idx": "cosqa-train-17881", "doc": "make a string into a date python", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-17882", "doc": "only keep index of the minimum of each row python", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-17883", "doc": "fibonacci python code using sentinel loop", "code": "def fib(n):\n    \"\"\"Fibonacci example function\n\n    Args:\n      n (int): integer\n\n    Returns:\n      int: n-th Fibonacci number\n    \"\"\"\n    assert n > 0\n    a, b = 1, 1\n    for i in range(n - 1):\n        a, b = b, a + b\n    return a", "code_tokens": "def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a", "docstring_tokens": "Fibonacci example function", "label": 1}, {"idx": "cosqa-train-17884", "doc": "most frequent item in a list python", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 0}, {"idx": "cosqa-train-17885", "doc": "how to check if a path is valid in python", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-17886", "doc": "python covert str to bytearray", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 0}, {"idx": "cosqa-train-17887", "doc": "how to download file from s3 bucket using python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 0}, {"idx": "cosqa-train-17888", "doc": "how to tell if an init has been called python", "code": "def try_instance_init(self, instance, late_start=False):\n        \"\"\"Try to \"initialize\" the given module instance.\n\n        :param instance: instance to init\n        :type instance: object\n        :param late_start: If late_start, don't look for last_init_try\n        :type late_start: bool\n        :return: True on successful init. False if instance init method raised any Exception.\n        :rtype: bool\n        \"\"\"\n        try:\n            instance.init_try += 1\n            # Maybe it's a retry\n            if not late_start and instance.init_try > 1:\n                # Do not try until too frequently, or it's too loopy\n                if instance.last_init_try > time.time() - MODULE_INIT_PERIOD:\n                    logger.info(\"Too early to retry initialization, retry period is %d seconds\",\n                                MODULE_INIT_PERIOD)\n                    # logger.info(\"%s / %s\", instance.last_init_try, time.time())\n                    return False\n            instance.last_init_try = time.time()\n\n            logger.info(\"Trying to initialize module: %s\", instance.name)\n\n            # If it's an external module, create/update Queues()\n            if instance.is_external:\n                instance.create_queues(self.daemon.sync_manager)\n\n            # The module instance init function says if initialization is ok\n            if not instance.init():\n                logger.warning(\"Module %s initialisation failed.\", instance.name)\n                return False\n            logger.info(\"Module %s is initialized.\", instance.name)\n        except Exception as exp:  # pylint: disable=broad-except\n            # pragma: no cover, simple protection\n            msg = \"The module instance %s raised an exception \" \\\n                  \"on initialization: %s, I remove it!\" % (instance.name, str(exp))\n            self.configuration_errors.append(msg)\n            logger.error(msg)\n            logger.exception(exp)\n            return False\n\n        return True", "code_tokens": "def try_instance_init ( self , instance , late_start = False ) : try : instance . init_try += 1 # Maybe it's a retry if not late_start and instance . init_try > 1 : # Do not try until too frequently, or it's too loopy if instance . last_init_try > time . time ( ) - MODULE_INIT_PERIOD : logger . info ( \"Too early to retry initialization, retry period is %d seconds\" , MODULE_INIT_PERIOD ) # logger.info(\"%s / %s\", instance.last_init_try, time.time()) return False instance . last_init_try = time . time ( ) logger . info ( \"Trying to initialize module: %s\" , instance . name ) # If it's an external module, create/update Queues() if instance . is_external : instance . create_queues ( self . daemon . sync_manager ) # The module instance init function says if initialization is ok if not instance . init ( ) : logger . warning ( \"Module %s initialisation failed.\" , instance . name ) return False logger . info ( \"Module %s is initialized.\" , instance . name ) except Exception as exp : # pylint: disable=broad-except # pragma: no cover, simple protection msg = \"The module instance %s raised an exception \" \"on initialization: %s, I remove it!\" % ( instance . name , str ( exp ) ) self . configuration_errors . append ( msg ) logger . error ( msg ) logger . exception ( exp ) return False return True", "docstring_tokens": "Try to initialize the given module instance .", "label": 0}, {"idx": "cosqa-train-17889", "doc": "how to cancatinate semi coloumn in python", "code": "def add_colons(s):\n    \"\"\"Add colons after every second digit.\n\n    This function is used in functions to prettify serials.\n\n    >>> add_colons('teststring')\n    'te:st:st:ri:ng'\n    \"\"\"\n    return ':'.join([s[i:i + 2] for i in range(0, len(s), 2)])", "code_tokens": "def add_colons ( s ) : return ':' . join ( [ s [ i : i + 2 ] for i in range ( 0 , len ( s ) , 2 ) ] )", "docstring_tokens": "Add colons after every second digit .", "label": 0}, {"idx": "cosqa-train-17890", "doc": "check each character in string pythong", "code": "def has_jongsung(letter):\n    \"\"\"Check whether this letter contains Jongsung\"\"\"\n    if len(letter) != 1:\n        raise Exception('The target string must be one letter.')\n    if not is_hangul(letter):\n        raise NotHangulException('The target string must be Hangul')\n\n    code = lt.hangul_index(letter)\n    return code % NUM_JONG > 0", "code_tokens": "def has_jongsung ( letter ) : if len ( letter ) != 1 : raise Exception ( 'The target string must be one letter.' ) if not is_hangul ( letter ) : raise NotHangulException ( 'The target string must be Hangul' ) code = lt . hangul_index ( letter ) return code % NUM_JONG > 0", "docstring_tokens": "Check whether this letter contains Jongsung", "label": 1}, {"idx": "cosqa-train-17891", "doc": "if a string contains whitespace python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 1}, {"idx": "cosqa-train-17892", "doc": "cast a string to a digit in python", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-17893", "doc": "how to clean python idle cache", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 0}, {"idx": "cosqa-train-17894", "doc": "checking for uppercase in a string python", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 0}, {"idx": "cosqa-train-17895", "doc": "python string formatting zeropadding", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 0}, {"idx": "cosqa-train-17896", "doc": "python skip rest of a loop", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 0}, {"idx": "cosqa-train-17897", "doc": "python normalize a set of numbers", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 1}, {"idx": "cosqa-train-17898", "doc": "python get date from string without datetime", "code": "def iso_string_to_python_datetime(\n        isostring: str) -> Optional[datetime.datetime]:\n    \"\"\"\n    Takes an ISO-8601 string and returns a ``datetime``.\n    \"\"\"\n    if not isostring:\n        return None  # if you parse() an empty string, you get today's date\n    return dateutil.parser.parse(isostring)", "code_tokens": "def iso_string_to_python_datetime ( isostring : str ) -> Optional [ datetime . datetime ] : if not isostring : return None # if you parse() an empty string, you get today's date return dateutil . parser . parse ( isostring )", "docstring_tokens": "Takes an ISO - 8601 string and returns a datetime .", "label": 0}, {"idx": "cosqa-train-17899", "doc": "how to round answer to nearest tenth python", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 1}, {"idx": "cosqa-train-17900", "doc": "case independent lookup in python dictionary", "code": "def get_case_insensitive_dict_key(d: Dict, k: str) -> Optional[str]:\n    \"\"\"\n    Within the dictionary ``d``, find a key that matches (in case-insensitive\n    fashion) the key ``k``, and return it (or ``None`` if there isn't one).\n    \"\"\"\n    for key in d.keys():\n        if k.lower() == key.lower():\n            return key\n    return None", "code_tokens": "def get_case_insensitive_dict_key ( d : Dict , k : str ) -> Optional [ str ] : for key in d . keys ( ) : if k . lower ( ) == key . lower ( ) : return key return None", "docstring_tokens": "Within the dictionary d find a key that matches ( in case - insensitive fashion ) the key k and return it ( or None if there isn t one ) .", "label": 0}, {"idx": "cosqa-train-17901", "doc": "python retrive list index based on its content", "code": "def find_index(segmentation, stroke_id):\n    \"\"\"\n    >>> find_index([[0, 1, 2], [3, 4], [5, 6, 7]], 0)\n    0\n    >>> find_index([[0, 1, 2], [3, 4], [5, 6, 7]], 1)\n    0\n    >>> find_index([[0, 1, 2], [3, 4], [5, 6, 7]], 5)\n    2\n    >>> find_index([[0, 1, 2], [3, 4], [5, 6, 7]], 6)\n    2\n    \"\"\"\n    for i, symbol in enumerate(segmentation):\n        for sid in symbol:\n            if sid == stroke_id:\n                return i\n    return -1", "code_tokens": "def find_index ( segmentation , stroke_id ) : for i , symbol in enumerate ( segmentation ) : for sid in symbol : if sid == stroke_id : return i return - 1", "docstring_tokens": ">>> find_index ( [[ 0 1 2 ] [ 3 4 ] [ 5 6 7 ]] 0 ) 0 >>> find_index ( [[ 0 1 2 ] [ 3 4 ] [ 5 6 7 ]] 1 ) 0 >>> find_index ( [[ 0 1 2 ] [ 3 4 ] [ 5 6 7 ]] 5 ) 2 >>> find_index ( [[ 0 1 2 ] [ 3 4 ] [ 5 6 7 ]] 6 ) 2", "label": 1}, {"idx": "cosqa-train-17902", "doc": "python read json from file into dictionary", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 0}, {"idx": "cosqa-train-17903", "doc": "python how to make an inverted dictionary", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 0}, {"idx": "cosqa-train-17904", "doc": "get index of first true in array python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 1}, {"idx": "cosqa-train-17905", "doc": "truncate first 32 bits in python", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 0}, {"idx": "cosqa-train-17906", "doc": "python check if kargs empty", "code": "def check_oneof(**kwargs):\n    \"\"\"Raise ValueError if more than one keyword argument is not none.\n\n    Args:\n        kwargs (dict): The keyword arguments sent to the function.\n\n    Returns: None\n\n    Raises:\n        ValueError: If more than one entry in kwargs is not none.\n    \"\"\"\n    # Sanity check: If no keyword arguments were sent, this is fine.\n    if not kwargs:\n        return None\n\n    not_nones = [val for val in kwargs.values() if val is not None]\n    if len(not_nones) > 1:\n        raise ValueError('Only one of {fields} should be set.'.format(\n            fields=', '.join(sorted(kwargs.keys())),\n        ))", "code_tokens": "def check_oneof ( * * kwargs ) : # Sanity check: If no keyword arguments were sent, this is fine. if not kwargs : return None not_nones = [ val for val in kwargs . values ( ) if val is not None ] if len ( not_nones ) > 1 : raise ValueError ( 'Only one of {fields} should be set.' . format ( fields = ', ' . join ( sorted ( kwargs . keys ( ) ) ) , ) )", "docstring_tokens": "Raise ValueError if more than one keyword argument is not none .", "label": 0}, {"idx": "cosqa-train-17907", "doc": "python check if certain length of input equals something", "code": "def check_lengths(*arrays):\n    \"\"\"\n    tool to ensure input and output data have the same number of samples\n\n    Parameters\n    ----------\n    *arrays : iterable of arrays to be checked\n\n    Returns\n    -------\n    None\n    \"\"\"\n    lengths = [len(array) for array in arrays]\n    if len(np.unique(lengths)) > 1:\n        raise ValueError('Inconsistent data lengths: {}'.format(lengths))", "code_tokens": "def check_lengths ( * arrays ) : lengths = [ len ( array ) for array in arrays ] if len ( np . unique ( lengths ) ) > 1 : raise ValueError ( 'Inconsistent data lengths: {}' . format ( lengths ) )", "docstring_tokens": "tool to ensure input and output data have the same number of samples", "label": 1}, {"idx": "cosqa-train-17908", "doc": "in python how do you use grep in a file", "code": "def grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''", "code_tokens": "def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "docstring_tokens": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .", "label": 1}, {"idx": "cosqa-train-17909", "doc": "sql code in strings in python", "code": "def execute(cur, *args):\n    \"\"\"Utility function to print sqlite queries before executing.\n\n    Use instead of cur.execute().  First argument is cursor.\n\n    cur.execute(stmt)\n    becomes\n    util.execute(cur, stmt)\n    \"\"\"\n    stmt = args[0]\n    if len(args) > 1:\n        stmt = stmt.replace('%', '%%').replace('?', '%r')\n        print(stmt % (args[1]))\n    return cur.execute(*args)", "code_tokens": "def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )", "docstring_tokens": "Utility function to print sqlite queries before executing .", "label": 0}, {"idx": "cosqa-train-17910", "doc": "python code for last in list", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 0}, {"idx": "cosqa-train-17911", "doc": "python print *args keys", "code": "def prin(*args, **kwargs):\n    r\"\"\"Like ``print``, but a function. I.e. prints out all arguments as\n    ``print`` would do. Specify output stream like this::\n\n      print('ERROR', `out=\"sys.stderr\"``).\n\n    \"\"\"\n    print >> kwargs.get('out',None), \" \".join([str(arg) for arg in args])", "code_tokens": "def prin ( * args , * * kwargs ) : print >> kwargs . get ( 'out' , None ) , \" \" . join ( [ str ( arg ) for arg in args ] )", "docstring_tokens": "r Like print but a function . I . e . prints out all arguments as print would do . Specify output stream like this ::", "label": 1}, {"idx": "cosqa-train-17912", "doc": "capitalizing the first letter of a variable in python", "code": "def camelize(key):\n    \"\"\"Convert a python_style_variable_name to lowerCamelCase.\n\n    Examples\n    --------\n    >>> camelize('variable_name')\n    'variableName'\n    >>> camelize('variableName')\n    'variableName'\n    \"\"\"\n    return ''.join(x.capitalize() if i > 0 else x\n                   for i, x in enumerate(key.split('_')))", "code_tokens": "def camelize ( key ) : return '' . join ( x . capitalize ( ) if i > 0 else x for i , x in enumerate ( key . split ( '_' ) ) )", "docstring_tokens": "Convert a python_style_variable_name to lowerCamelCase .", "label": 0}, {"idx": "cosqa-train-17913", "doc": "map function between python2 and python3", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-17914", "doc": "enum python print name instead of object by default", "code": "def __init__(self, enum_obj: Any) -> None:\n        \"\"\"Initialize attributes for informative output.\n\n        :param enum_obj: Enum object.\n        \"\"\"\n        if enum_obj:\n            self.name = enum_obj\n            self.items = ', '.join([str(i) for i in enum_obj])\n        else:\n            self.items = ''", "code_tokens": "def __init__ ( self , enum_obj : Any ) -> None : if enum_obj : self . name = enum_obj self . items = ', ' . join ( [ str ( i ) for i in enum_obj ] ) else : self . items = ''", "docstring_tokens": "Initialize attributes for informative output .", "label": 0}, {"idx": "cosqa-train-17915", "doc": "python scikit median of array", "code": "def fast_median(a):\n    \"\"\"Fast median operation for masked array using 50th-percentile\n    \"\"\"\n    a = checkma(a)\n    #return scoreatpercentile(a.compressed(), 50)\n    if a.count() > 0:\n        out = np.percentile(a.compressed(), 50)\n    else:\n        out = np.ma.masked\n    return out", "code_tokens": "def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out", "docstring_tokens": "Fast median operation for masked array using 50th - percentile", "label": 0}, {"idx": "cosqa-train-17916", "doc": "how to get the datatypes in python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-17917", "doc": "maximum size of iterable python", "code": "def _groups_of_size(iterable, n, fillvalue=None):\n    \"\"\"Collect data into fixed-length chunks or blocks.\"\"\"\n    # _groups_of_size('ABCDEFG', 3, 'x') --> ABC DEF Gxx\n    args = [iter(iterable)] * n\n    return zip_longest(fillvalue=fillvalue, *args)", "code_tokens": "def _groups_of_size ( iterable , n , fillvalue = None ) : # _groups_of_size('ABCDEFG', 3, 'x') --> ABC DEF Gxx args = [ iter ( iterable ) ] * n return zip_longest ( fillvalue = fillvalue , * args )", "docstring_tokens": "Collect data into fixed - length chunks or blocks .", "label": 0}, {"idx": "cosqa-train-17918", "doc": "spyder change from python 2 to 2", "code": "def get_versions(reporev=True):\n    \"\"\"Get version information for components used by Spyder\"\"\"\n    import sys\n    import platform\n\n    import qtpy\n    import qtpy.QtCore\n\n    revision = None\n    if reporev:\n        from spyder.utils import vcs\n        revision, branch = vcs.get_git_revision(os.path.dirname(__dir__))\n\n    if not sys.platform == 'darwin':  # To avoid a crash with our Mac app\n        system = platform.system()\n    else:\n        system = 'Darwin'\n\n    return {\n        'spyder': __version__,\n        'python': platform.python_version(),  # \"2.7.3\"\n        'bitness': 64 if sys.maxsize > 2**32 else 32,\n        'qt': qtpy.QtCore.__version__,\n        'qt_api': qtpy.API_NAME,      # PyQt5\n        'qt_api_ver': qtpy.PYQT_VERSION,\n        'system': system,   # Linux, Windows, ...\n        'release': platform.release(),  # XP, 10.6, 2.2.0, etc.\n        'revision': revision,  # '9fdf926eccce'\n    }", "code_tokens": "def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "docstring_tokens": "Get version information for components used by Spyder", "label": 0}, {"idx": "cosqa-train-17919", "doc": "finding the similar part of two strings in python", "code": "def long_substring(str_a, str_b):\n    \"\"\"\n    Looks for a longest common string between any two given strings passed\n    :param str_a: str\n    :param str_b: str\n\n    Big Thanks to Pulkit Kathuria(@kevincobain2000) for the function\n    The function is derived from jProcessing toolkit suite\n    \"\"\"\n    data = [str_a, str_b]\n    substr = ''\n    if len(data) > 1 and len(data[0]) > 0:\n        for i in range(len(data[0])):\n            for j in range(len(data[0])-i+1):\n                if j > len(substr) and all(data[0][i:i+j] in x for x in data):\n                    substr = data[0][i:i+j]\n    return substr.strip()", "code_tokens": "def long_substring ( str_a , str_b ) : data = [ str_a , str_b ] substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] return substr . strip ( )", "docstring_tokens": "Looks for a longest common string between any two given strings passed : param str_a : str : param str_b : str", "label": 0}, {"idx": "cosqa-train-17920", "doc": "how to say if not isnumeric in python", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 0}, {"idx": "cosqa-train-17921", "doc": "all combinations of two iterables python list comprhension", "code": "def squash(self, a, b):\n        \"\"\"\n        Returns a generator that squashes two iterables into one.\n\n        ```\n        ['this', 'that'], [[' and', ' or']] => ['this and', 'this or', 'that and', 'that or']\n        ```\n        \"\"\"\n\n        return ((''.join(x) if isinstance(x, tuple) else x) for x in itertools.product(a, b))", "code_tokens": "def squash ( self , a , b ) : return ( ( '' . join ( x ) if isinstance ( x , tuple ) else x ) for x in itertools . product ( a , b ) )", "docstring_tokens": "Returns a generator that squashes two iterables into one .", "label": 0}, {"idx": "cosqa-train-17922", "doc": "python win32api mouse position", "code": "def SetCursorPos(x: int, y: int) -> bool:\n    \"\"\"\n    SetCursorPos from Win32.\n    Set mouse cursor to point x, y.\n    x: int.\n    y: int.\n    Return bool, True if succeed otherwise False.\n    \"\"\"\n    return bool(ctypes.windll.user32.SetCursorPos(x, y))", "code_tokens": "def SetCursorPos ( x : int , y : int ) -> bool : return bool ( ctypes . windll . user32 . SetCursorPos ( x , y ) )", "docstring_tokens": "SetCursorPos from Win32 . Set mouse cursor to point x y . x : int . y : int . Return bool True if succeed otherwise False .", "label": 1}, {"idx": "cosqa-train-17923", "doc": "who check upper case in python", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-17924", "doc": "how to normalize numbers with python", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 1}, {"idx": "cosqa-train-17925", "doc": "python dictionary delete key with empty value", "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": "def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "docstring_tokens": "Return a new copied dictionary without the keys with None values from the given Mapping object .", "label": 0}, {"idx": "cosqa-train-17926", "doc": "python check variable type is string", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 1}, {"idx": "cosqa-train-17927", "doc": "extract bits from large numbers python", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 1}, {"idx": "cosqa-train-17928", "doc": "python delete all rows from table sql", "code": "def wipe_table(self, table: str) -> int:\n        \"\"\"Delete all records from a table. Use caution!\"\"\"\n        sql = \"DELETE FROM \" + self.delimit(table)\n        return self.db_exec(sql)", "code_tokens": "def wipe_table ( self , table : str ) -> int : sql = \"DELETE FROM \" + self . delimit ( table ) return self . db_exec ( sql )", "docstring_tokens": "Delete all records from a table . Use caution!", "label": 1}, {"idx": "cosqa-train-17929", "doc": "python return year from a date string", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 0}, {"idx": "cosqa-train-17930", "doc": "python detect interface existance", "code": "def _interface_exists(self, interface):\n        \"\"\"Check whether interface exists.\"\"\"\n        ios_cfg = self._get_running_config()\n        parse = HTParser(ios_cfg)\n        itfcs_raw = parse.find_lines(\"^interface \" + interface)\n        return len(itfcs_raw) > 0", "code_tokens": "def _interface_exists ( self , interface ) : ios_cfg = self . _get_running_config ( ) parse = HTParser ( ios_cfg ) itfcs_raw = parse . find_lines ( \"^interface \" + interface ) return len ( itfcs_raw ) > 0", "docstring_tokens": "Check whether interface exists .", "label": 1}, {"idx": "cosqa-train-17931", "doc": "use template string in python to replcae later", "code": "def templategetter(tmpl):\n    \"\"\"\n    This is a dirty little template function generator that turns single-brace\n    Mustache-style template strings into functions that interpolate dict keys:\n\n    >>> get_name = templategetter(\"{first} {last}\")\n    >>> get_name({'first': 'Shawn', 'last': 'Allen'})\n    'Shawn Allen'\n    \"\"\"\n    tmpl = tmpl.replace('{', '%(')\n    tmpl = tmpl.replace('}', ')s')\n    return lambda data: tmpl % data", "code_tokens": "def templategetter ( tmpl ) : tmpl = tmpl . replace ( '{' , '%(' ) tmpl = tmpl . replace ( '}' , ')s' ) return lambda data : tmpl % data", "docstring_tokens": "This is a dirty little template function generator that turns single - brace Mustache - style template strings into functions that interpolate dict keys :", "label": 1}, {"idx": "cosqa-train-17932", "doc": "calculating the time of a function python", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 0}, {"idx": "cosqa-train-17933", "doc": "how to rotate list left in python3", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 0}, {"idx": "cosqa-train-17934", "doc": "python check is valuie is str", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 1}, {"idx": "cosqa-train-17935", "doc": "call post api from python", "code": "def post(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP POST operation to API endpoint.\"\"\"\n\n        return self._request('POST', endpoint, **kwargs)", "code_tokens": "def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "docstring_tokens": "HTTP POST operation to API endpoint .", "label": 0}, {"idx": "cosqa-train-17936", "doc": "python get chrome size", "code": "def get_window_dim():\n    \"\"\" gets the dimensions depending on python version and os\"\"\"\n    version = sys.version_info\n\n    if version >= (3, 3):\n        return _size_36()\n    if platform.system() == 'Windows':\n        return _size_windows()\n    return _size_27()", "code_tokens": "def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )", "docstring_tokens": "gets the dimensions depending on python version and os", "label": 0}, {"idx": "cosqa-train-17937", "doc": "python ctypes array of arrays", "code": "def GetAllPixelColors(self) -> ctypes.Array:\n        \"\"\"\n        Return `ctypes.Array`, an iterable array of int values in argb.\n        \"\"\"\n        return self.GetPixelColorsOfRect(0, 0, self.Width, self.Height)", "code_tokens": "def GetAllPixelColors ( self ) -> ctypes . Array : return self . GetPixelColorsOfRect ( 0 , 0 , self . Width , self . Height )", "docstring_tokens": "Return ctypes . Array an iterable array of int values in argb .", "label": 1}, {"idx": "cosqa-train-17938", "doc": "python lambda filter lowercase string", "code": "def gen_lower(x: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\"\n    Args:\n        x: iterable of strings\n\n    Yields:\n        each string in lower case\n    \"\"\"\n    for string in x:\n        yield string.lower()", "code_tokens": "def gen_lower ( x : Iterable [ str ] ) -> Generator [ str , None , None ] : for string in x : yield string . lower ( )", "docstring_tokens": "Args : x : iterable of strings", "label": 0}, {"idx": "cosqa-train-17939", "doc": "python calculate fft for wave form", "code": "def calculate_fft(data, tbin):\n    \"\"\"\n    Function to calculate the Fourier transform of data.\n    \n    \n    Parameters\n    ----------\n    data : numpy.ndarray\n        1D or 2D array containing time series.\n    tbin : float\n        Bin size of time series (in ms).\n    \n    \n    Returns\n    -------\n    freqs : numpy.ndarray\n        Frequency axis of signal in Fourier space.         \n    fft : numpy.ndarray\n        Signal in Fourier space.\n        \n    \"\"\"\n    if len(np.shape(data)) > 1:\n        n = len(data[0])\n        return np.fft.fftfreq(n, tbin * 1e-3), np.fft.fft(data, axis=1)\n    else:\n        n = len(data)\n        return np.fft.fftfreq(n, tbin * 1e-3), np.fft.fft(data)", "code_tokens": "def calculate_fft ( data , tbin ) : if len ( np . shape ( data ) ) > 1 : n = len ( data [ 0 ] ) return np . fft . fftfreq ( n , tbin * 1e-3 ) , np . fft . fft ( data , axis = 1 ) else : n = len ( data ) return np . fft . fftfreq ( n , tbin * 1e-3 ) , np . fft . fft ( data )", "docstring_tokens": "Function to calculate the Fourier transform of data . Parameters ---------- data : numpy . ndarray 1D or 2D array containing time series . tbin : float Bin size of time series ( in ms ) . Returns ------- freqs : numpy . ndarray Frequency axis of signal in Fourier space . fft : numpy . ndarray Signal in Fourier space .", "label": 1}, {"idx": "cosqa-train-17940", "doc": "finding max 3 out of a dictionary in python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 0}, {"idx": "cosqa-train-17941", "doc": "python ast visit get parent node", "code": "def assign_parent(node: astroid.node_classes.NodeNG) -> astroid.node_classes.NodeNG:\n    \"\"\"return the higher parent which is not an AssignName, Tuple or List node\n    \"\"\"\n    while node and isinstance(node, (astroid.AssignName, astroid.Tuple, astroid.List)):\n        node = node.parent\n    return node", "code_tokens": "def assign_parent ( node : astroid . node_classes . NodeNG ) -> astroid . node_classes . NodeNG : while node and isinstance ( node , ( astroid . AssignName , astroid . Tuple , astroid . List ) ) : node = node . parent return node", "docstring_tokens": "return the higher parent which is not an AssignName Tuple or List node", "label": 1}, {"idx": "cosqa-train-17942", "doc": "get files changed using commitid using gitpython", "code": "def get_commits_modified_file(self, filepath: str) -> List[str]:\n        \"\"\"\n        Given a filepath, returns all the commits that modified this file\n        (following renames).\n\n        :param str filepath: path to the file\n        :return: the list of commits' hash\n        \"\"\"\n        path = str(Path(filepath))\n\n        commits = []\n        try:\n            commits = self.git.log(\"--follow\", \"--format=%H\", path).split('\\n')\n        except GitCommandError:\n            logger.debug(\"Could not find information of file %s\", path)\n\n        return commits", "code_tokens": "def get_commits_modified_file ( self , filepath : str ) -> List [ str ] : path = str ( Path ( filepath ) ) commits = [ ] try : commits = self . git . log ( \"--follow\" , \"--format=%H\" , path ) . split ( '\\n' ) except GitCommandError : logger . debug ( \"Could not find information of file %s\" , path ) return commits", "docstring_tokens": "Given a filepath returns all the commits that modified this file ( following renames ) .", "label": 0}, {"idx": "cosqa-train-17943", "doc": "python sqlite3 executemany %", "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None:\n        \"\"\"Execute the given multiquery.\"\"\"\n        await self._execute(self._cursor.executemany, sql, parameters)", "code_tokens": "async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "docstring_tokens": "Execute the given multiquery .", "label": 0}, {"idx": "cosqa-train-17944", "doc": "remove leading zeros python", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 1}, {"idx": "cosqa-train-17945", "doc": "print the full name of the day of the week python", "code": "def get_day_name(self) -> str:\n        \"\"\" Returns the day name \"\"\"\n        weekday = self.value.isoweekday() - 1\n        return calendar.day_name[weekday]", "code_tokens": "def get_day_name ( self ) -> str : weekday = self . value . isoweekday ( ) - 1 return calendar . day_name [ weekday ]", "docstring_tokens": "Returns the day name", "label": 1}, {"idx": "cosqa-train-17946", "doc": "python fibonacci user input", "code": "def fib(n):\n    \"\"\"Fibonacci example function\n\n    Args:\n      n (int): integer\n\n    Returns:\n      int: n-th Fibonacci number\n    \"\"\"\n    assert n > 0\n    a, b = 1, 1\n    for i in range(n - 1):\n        a, b = b, a + b\n    return a", "code_tokens": "def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a", "docstring_tokens": "Fibonacci example function", "label": 1}, {"idx": "cosqa-train-17947", "doc": "how to detect language in python", "code": "def get_language():\n    \"\"\"\n    Wrapper around Django's `get_language` utility.\n    For Django >= 1.8, `get_language` returns None in case no translation is activate.\n    Here we patch this behavior e.g. for back-end functionality requiring access to translated fields\n    \"\"\"\n    from parler import appsettings\n    language = dj_get_language()\n    if language is None and appsettings.PARLER_DEFAULT_ACTIVATE:\n        return appsettings.PARLER_DEFAULT_LANGUAGE_CODE\n    else:\n        return language", "code_tokens": "def get_language ( ) : from parler import appsettings language = dj_get_language ( ) if language is None and appsettings . PARLER_DEFAULT_ACTIVATE : return appsettings . PARLER_DEFAULT_LANGUAGE_CODE else : return language", "docstring_tokens": "Wrapper around Django s get_language utility . For Django > = 1 . 8 get_language returns None in case no translation is activate . Here we patch this behavior e . g . for back - end functionality requiring access to translated fields", "label": 0}, {"idx": "cosqa-train-17948", "doc": "how to check if a key was pressed with curses python", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 0}, {"idx": "cosqa-train-17949", "doc": "python if a is greater than b", "code": "def __gt__(self, other):\n        \"\"\"Test for greater than.\"\"\"\n        if isinstance(other, Address):\n            return str(self) > str(other)\n        raise TypeError", "code_tokens": "def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError", "docstring_tokens": "Test for greater than .", "label": 0}, {"idx": "cosqa-train-17950", "doc": "python similarities between two strings word2vec", "code": "def similarity(word1: str, word2: str) -> float:\n    \"\"\"\n    Get cosine similarity between two words.\n    If a word is not in the vocabulary, KeyError will be raised.\n\n    :param string word1: first word\n    :param string word2: second word\n    :return: the cosine similarity between the two word vectors\n    \"\"\"\n    return _MODEL.similarity(word1, word2)", "code_tokens": "def similarity ( word1 : str , word2 : str ) -> float : return _MODEL . similarity ( word1 , word2 )", "docstring_tokens": "Get cosine similarity between two words . If a word is not in the vocabulary KeyError will be raised .", "label": 0}, {"idx": "cosqa-train-17951", "doc": "lower case string in python", "code": "def snake_case(a_string):\n    \"\"\"Returns a snake cased version of a string.\n\n    :param a_string: any :class:`str` object.\n\n    Usage:\n        >>> snake_case('FooBar')\n        \"foo_bar\"\n    \"\"\"\n\n    partial = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', a_string)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', partial).lower()", "code_tokens": "def snake_case ( a_string ) : partial = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , a_string ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , partial ) . lower ( )", "docstring_tokens": "Returns a snake cased version of a string .", "label": 0}, {"idx": "cosqa-train-17952", "doc": "get key with max value python", "code": "def get_default_bucket_key(buckets: List[Tuple[int, int]]) -> Tuple[int, int]:\n    \"\"\"\n    Returns the default bucket from a list of buckets, i.e. the largest bucket.\n\n    :param buckets: List of buckets.\n    :return: The largest bucket in the list.\n    \"\"\"\n    return max(buckets)", "code_tokens": "def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )", "docstring_tokens": "Returns the default bucket from a list of buckets i . e . the largest bucket .", "label": 0}, {"idx": "cosqa-train-17953", "doc": "python map remove key", "code": "def __remove_method(m: lmap.Map, key: T) -> lmap.Map:\n        \"\"\"Swap the methods atom to remove method with key.\"\"\"\n        return m.dissoc(key)", "code_tokens": "def __remove_method ( m : lmap . Map , key : T ) -> lmap . Map : return m . dissoc ( key )", "docstring_tokens": "Swap the methods atom to remove method with key .", "label": 0}, {"idx": "cosqa-train-17954", "doc": "how to implement a rate limiter in python", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 0}, {"idx": "cosqa-train-17955", "doc": "permutations in python with three arguements", "code": "def product(*args, **kwargs):\n    \"\"\" Yields all permutations with replacement:\n        list(product(\"cat\", repeat=2)) => \n        [(\"c\", \"c\"), \n         (\"c\", \"a\"), \n         (\"c\", \"t\"), \n         (\"a\", \"c\"), \n         (\"a\", \"a\"), \n         (\"a\", \"t\"), \n         (\"t\", \"c\"), \n         (\"t\", \"a\"), \n         (\"t\", \"t\")]\n    \"\"\"\n    p = [[]]\n    for iterable in map(tuple, args) * kwargs.get(\"repeat\", 1):\n        p = [x + [y] for x in p for y in iterable]\n    for p in p:\n        yield tuple(p)", "code_tokens": "def product ( * args , * * kwargs ) : p = [ [ ] ] for iterable in map ( tuple , args ) * kwargs . get ( \"repeat\" , 1 ) : p = [ x + [ y ] for x in p for y in iterable ] for p in p : yield tuple ( p )", "docstring_tokens": "Yields all permutations with replacement : list ( product ( cat repeat = 2 )) = > [ ( c c ) ( c a ) ( c t ) ( a c ) ( a a ) ( a t ) ( t c ) ( t a ) ( t t ) ]", "label": 1}, {"idx": "cosqa-train-17956", "doc": "python greater than string", "code": "def __gt__(self, other):\n        \"\"\"Test for greater than.\"\"\"\n        if isinstance(other, Address):\n            return str(self) > str(other)\n        raise TypeError", "code_tokens": "def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError", "docstring_tokens": "Test for greater than .", "label": 1}, {"idx": "cosqa-train-17957", "doc": "how to pass a file to stdin in python", "code": "def file_or_stdin() -> Callable:\n    \"\"\"\n    Returns a file descriptor from stdin or opening a file from a given path.\n    \"\"\"\n\n    def parse(path):\n        if path is None or path == \"-\":\n            return sys.stdin\n        else:\n            return data_io.smart_open(path)\n\n    return parse", "code_tokens": "def file_or_stdin ( ) -> Callable : def parse ( path ) : if path is None or path == \"-\" : return sys . stdin else : return data_io . smart_open ( path ) return parse", "docstring_tokens": "Returns a file descriptor from stdin or opening a file from a given path .", "label": 1}, {"idx": "cosqa-train-17958", "doc": "invert dictionary python 3", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 0}, {"idx": "cosqa-train-17959", "doc": "python list index by identity", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 0}, {"idx": "cosqa-train-17960", "doc": "how to get only one row in sql database python using flask", "code": "def fetchvalue(self, sql: str, *args) -> Optional[Any]:\n        \"\"\"Executes SQL; returns the first value of the first row, or None.\"\"\"\n        row = self.fetchone(sql, *args)\n        if row is None:\n            return None\n        return row[0]", "code_tokens": "def fetchvalue ( self , sql : str , * args ) -> Optional [ Any ] : row = self . fetchone ( sql , * args ) if row is None : return None return row [ 0 ]", "docstring_tokens": "Executes SQL ; returns the first value of the first row or None .", "label": 1}, {"idx": "cosqa-train-17961", "doc": "python get columns names in a list", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 0}, {"idx": "cosqa-train-17962", "doc": "calculate mid points between numbers python", "code": "def _mid(pt1, pt2):\n    \"\"\"\n    (Point, Point) -> Point\n    Return the point that lies in between the two input points.\n    \"\"\"\n    (x0, y0), (x1, y1) = pt1, pt2\n    return 0.5 * (x0 + x1), 0.5 * (y0 + y1)", "code_tokens": "def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "docstring_tokens": "( Point Point ) - > Point Return the point that lies in between the two input points .", "label": 1}, {"idx": "cosqa-train-17963", "doc": "how to get the index of elements with max value in array python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 0}, {"idx": "cosqa-train-17964", "doc": "python remove key from dictionary if exist", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-17965", "doc": "python json value as string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 1}, {"idx": "cosqa-train-17966", "doc": "return last index in python", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-17967", "doc": "python histogram get number of bins", "code": "def shape(self) -> Tuple[int, ...]:\n        \"\"\"Shape of histogram's data.\n\n        Returns\n        -------\n        One-element tuple with the number of bins along each axis.\n        \"\"\"\n        return tuple(bins.bin_count for bins in self._binnings)", "code_tokens": "def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )", "docstring_tokens": "Shape of histogram s data .", "label": 1}, {"idx": "cosqa-train-17968", "doc": "how to split sentence in python with delimiter", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 1}, {"idx": "cosqa-train-17969", "doc": "exit function in python not defined", "code": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)", "code_tokens": "def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "docstring_tokens": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting", "label": 1}, {"idx": "cosqa-train-17970", "doc": "python argparse call from code", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 1}, {"idx": "cosqa-train-17971", "doc": "get column with max value python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 1}, {"idx": "cosqa-train-17972", "doc": "docker container ls not listing python", "code": "def running_containers(name_filter: str) -> List[str]:\n    \"\"\"\n    :raises docker.exceptions.APIError\n    \"\"\"\n    return [container.short_id for container in\n            docker_client.containers.list(filters={\"name\": name_filter})]", "code_tokens": "def running_containers ( name_filter : str ) -> List [ str ] : return [ container . short_id for container in docker_client . containers . list ( filters = { \"name\" : name_filter } ) ]", "docstring_tokens": ": raises docker . exceptions . APIError", "label": 1}, {"idx": "cosqa-train-17973", "doc": "remove words of string in list of stringpython", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 1}, {"idx": "cosqa-train-17974", "doc": "how to test if a str is an int python", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-17975", "doc": "python calculating bitwise differently", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-17976", "doc": "testing if two strings are equal in python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 1}, {"idx": "cosqa-train-17977", "doc": "python3 flask jsonify unhashable type list", "code": "def __as_list(value: List[JsonObjTypes]) -> List[JsonTypes]:\n        \"\"\" Return a json array as a list\n\n        :param value: array\n        :return: array with JsonObj instances removed\n        \"\"\"\n        return [e._as_dict if isinstance(e, JsonObj) else e for e in value]", "code_tokens": "def __as_list ( value : List [ JsonObjTypes ] ) -> List [ JsonTypes ] : return [ e . _as_dict if isinstance ( e , JsonObj ) else e for e in value ]", "docstring_tokens": "Return a json array as a list", "label": 0}, {"idx": "cosqa-train-17978", "doc": "how to get all cookies from python request", "code": "def cookies(self) -> Dict[str, str]:\n        \"\"\"The parsed cookies attached to this request.\"\"\"\n        cookies = SimpleCookie()\n        cookies.load(self.headers.get('Cookie', ''))\n        return {key: cookie.value for key, cookie in cookies.items()}", "code_tokens": "def cookies ( self ) -> Dict [ str , str ] : cookies = SimpleCookie ( ) cookies . load ( self . headers . get ( 'Cookie' , '' ) ) return { key : cookie . value for key , cookie in cookies . items ( ) }", "docstring_tokens": "The parsed cookies attached to this request .", "label": 1}, {"idx": "cosqa-train-17979", "doc": "how to count in lists without the sum command python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 1}, {"idx": "cosqa-train-17980", "doc": "how to converta string into bytes in python", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 1}, {"idx": "cosqa-train-17981", "doc": "python str number zero pad left and right", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 1}, {"idx": "cosqa-train-17982", "doc": "python 3 cursor position", "code": "def position(self) -> Position:\n        \"\"\"The current position of the cursor.\"\"\"\n        return Position(self._index, self._lineno, self._col_offset)", "code_tokens": "def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "docstring_tokens": "The current position of the cursor .", "label": 1}, {"idx": "cosqa-train-17983", "doc": "how to delete duplicates in a list python panda", "code": "def de_duplicate(items):\n    \"\"\"Remove any duplicate item, preserving order\n\n    >>> de_duplicate([1, 2, 1, 2])\n    [1, 2]\n    \"\"\"\n    result = []\n    for item in items:\n        if item not in result:\n            result.append(item)\n    return result", "code_tokens": "def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "docstring_tokens": "Remove any duplicate item preserving order", "label": 0}, {"idx": "cosqa-train-17984", "doc": "how to get bottom n lowestkey value pair from the dictionary in python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 0}, {"idx": "cosqa-train-17985", "doc": "is last day of month python", "code": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day", "code_tokens": "def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "docstring_tokens": "Returns day number of the last day of the month : param t : datetime : return : int", "label": 1}, {"idx": "cosqa-train-17986", "doc": "get key of maximum value in python", "code": "def get_default_bucket_key(buckets: List[Tuple[int, int]]) -> Tuple[int, int]:\n    \"\"\"\n    Returns the default bucket from a list of buckets, i.e. the largest bucket.\n\n    :param buckets: List of buckets.\n    :return: The largest bucket in the list.\n    \"\"\"\n    return max(buckets)", "code_tokens": "def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )", "docstring_tokens": "Returns the default bucket from a list of buckets i . e . the largest bucket .", "label": 1}, {"idx": "cosqa-train-17987", "doc": "python docker configuration passing environment varialbes", "code": "def docker_environment(env):\n    \"\"\"\n    Transform dictionary of environment variables into Docker -e parameters.\n\n    >>> result = docker_environment({'param1': 'val1', 'param2': 'val2'})\n    >>> result in ['-e \"param1=val1\" -e \"param2=val2\"', '-e \"param2=val2\" -e \"param1=val1\"']\n    True\n    \"\"\"\n    return ' '.join(\n        [\"-e \\\"%s=%s\\\"\" % (key, value.replace(\"$\", \"\\\\$\").replace(\"\\\"\", \"\\\\\\\"\").replace(\"`\", \"\\\\`\"))\n         for key, value in env.items()])", "code_tokens": "def docker_environment ( env ) : return ' ' . join ( [ \"-e \\\"%s=%s\\\"\" % ( key , value . replace ( \"$\" , \"\\\\$\" ) . replace ( \"\\\"\" , \"\\\\\\\"\" ) . replace ( \"`\" , \"\\\\`\" ) ) for key , value in env . items ( ) ] )", "docstring_tokens": "Transform dictionary of environment variables into Docker - e parameters .", "label": 0}, {"idx": "cosqa-train-17988", "doc": "python http request synchronous or asynchronous", "code": "def call_api(self, resource_path, method,\n                 path_params=None, query_params=None, header_params=None,\n                 body=None, post_params=None, files=None,\n                 response_type=None, auth_settings=None, asynchronous=None,\n                 _return_http_data_only=None, collection_formats=None, _preload_content=True,\n                 _request_timeout=None):\n        \"\"\"\n        Makes the HTTP request (synchronous) and return the deserialized data.\n        To make an async request, set the asynchronous parameter.\n\n        :param resource_path: Path to method endpoint.\n        :param method: Method to call.\n        :param path_params: Path parameters in the url.\n        :param query_params: Query parameters in the url.\n        :param header_params: Header parameters to be\n            placed in the request header.\n        :param body: Request body.\n        :param post_params dict: Request post form parameters,\n            for `application/x-www-form-urlencoded`, `multipart/form-data`.\n        :param auth_settings list: Auth Settings names for the request.\n        :param response: Response data type.\n        :param files dict: key -> filename, value -> filepath,\n            for `multipart/form-data`.\n        :param asynchronous bool: execute request asynchronously\n        :param _return_http_data_only: response data without head status code and headers\n        :param collection_formats: dict of collection formats for path, query,\n            header, and post parameters.\n        :param _preload_content: if False, the urllib3.HTTPResponse object will be returned without\n                                 reading/decoding response data. Default is True.\n        :param _request_timeout: timeout setting for this request. If one number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of (connection, read) timeouts.\n        :return:\n            If asynchronous parameter is True,\n            the request will be called asynchronously.\n            The method will return the request thread.\n            If parameter asynchronous is False or missing,\n            then the method will return the response directly.\n        \"\"\"\n        if not asynchronous:\n            return self.__call_api(resource_path, method,\n                                   path_params, query_params, header_params,\n                                   body, post_params, files,\n                                   response_type, auth_settings,\n                                   _return_http_data_only, collection_formats, _preload_content, _request_timeout)\n        else:\n            thread = self.pool.apply_async(self.__call_api, (resource_path, method,\n                                           path_params, query_params,\n                                           header_params, body,\n                                           post_params, files,\n                                           response_type, auth_settings,\n                                           _return_http_data_only,\n                                           collection_formats, _preload_content, _request_timeout))\n        return thread", "code_tokens": "def call_api ( self , resource_path , method , path_params = None , query_params = None , header_params = None , body = None , post_params = None , files = None , response_type = None , auth_settings = None , asynchronous = None , _return_http_data_only = None , collection_formats = None , _preload_content = True , _request_timeout = None ) : if not asynchronous : return self . __call_api ( resource_path , method , path_params , query_params , header_params , body , post_params , files , response_type , auth_settings , _return_http_data_only , collection_formats , _preload_content , _request_timeout ) else : thread = self . pool . apply_async ( self . __call_api , ( resource_path , method , path_params , query_params , header_params , body , post_params , files , response_type , auth_settings , _return_http_data_only , collection_formats , _preload_content , _request_timeout ) ) return thread", "docstring_tokens": "Makes the HTTP request ( synchronous ) and return the deserialized data . To make an async request set the asynchronous parameter .", "label": 0}, {"idx": "cosqa-train-17989", "doc": "lowercase letter numbers in python", "code": "def snake_to_camel(value):\n    \"\"\"\n    Converts a snake_case_string to a camelCaseString.\n\n    >>> snake_to_camel(\"foo_bar_baz\")\n    'fooBarBaz'\n    \"\"\"\n    camel = \"\".join(word.title() for word in value.split(\"_\"))\n    return value[:1].lower() + camel[1:]", "code_tokens": "def snake_to_camel ( value ) : camel = \"\" . join ( word . title ( ) for word in value . split ( \"_\" ) ) return value [ : 1 ] . lower ( ) + camel [ 1 : ]", "docstring_tokens": "Converts a snake_case_string to a camelCaseString .", "label": 0}, {"idx": "cosqa-train-17990", "doc": "how to uppercase string element python", "code": "def camelize(key):\n    \"\"\"Convert a python_style_variable_name to lowerCamelCase.\n\n    Examples\n    --------\n    >>> camelize('variable_name')\n    'variableName'\n    >>> camelize('variableName')\n    'variableName'\n    \"\"\"\n    return ''.join(x.capitalize() if i > 0 else x\n                   for i, x in enumerate(key.split('_')))", "code_tokens": "def camelize ( key ) : return '' . join ( x . capitalize ( ) if i > 0 else x for i , x in enumerate ( key . split ( '_' ) ) )", "docstring_tokens": "Convert a python_style_variable_name to lowerCamelCase .", "label": 1}, {"idx": "cosqa-train-17991", "doc": "how to make check digit even or odd python", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 0}, {"idx": "cosqa-train-17992", "doc": "date time string python http", "code": "def parsehttpdate(string_):\n    \"\"\"\n    Parses an HTTP date into a datetime object.\n\n        >>> parsehttpdate('Thu, 01 Jan 1970 01:01:01 GMT')\n        datetime.datetime(1970, 1, 1, 1, 1, 1)\n    \"\"\"\n    try:\n        t = time.strptime(string_, \"%a, %d %b %Y %H:%M:%S %Z\")\n    except ValueError:\n        return None\n    return datetime.datetime(*t[:6])", "code_tokens": "def parsehttpdate ( string_ ) : try : t = time . strptime ( string_ , \"%a, %d %b %Y %H:%M:%S %Z\" ) except ValueError : return None return datetime . datetime ( * t [ : 6 ] )", "docstring_tokens": "Parses an HTTP date into a datetime object .", "label": 1}, {"idx": "cosqa-train-17993", "doc": "how to get length of deque in python", "code": "def count(self, elem):\n        \"\"\"\n        Return the number of elements equal to elem present in the queue\n\n        >>> pdeque([1, 2, 1]).count(1)\n        2\n        \"\"\"\n        return self._left_list.count(elem) + self._right_list.count(elem)", "code_tokens": "def count ( self , elem ) : return self . _left_list . count ( elem ) + self . _right_list . count ( elem )", "docstring_tokens": "Return the number of elements equal to elem present in the queue", "label": 0}, {"idx": "cosqa-train-17994", "doc": "python how to check if key exists + haskeys", "code": "def check_key(self, key: str) -> bool:\n        \"\"\"\n        Checks if key exists in datastore. True if yes, False if no.\n\n        :param: SHA512 hash key\n\n        :return: whether or key not exists in datastore\n        \"\"\"\n        keys = self.get_keys()\n        return key in keys", "code_tokens": "def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "docstring_tokens": "Checks if key exists in datastore . True if yes False if no .", "label": 1}, {"idx": "cosqa-train-17995", "doc": "python checking for duplicates in a list", "code": "def find_duplicates(l: list) -> set:\n    \"\"\"\n    Return the duplicates in a list.\n\n    The function relies on\n    https://stackoverflow.com/questions/9835762/find-and-list-duplicates-in-a-list .\n    Parameters\n    ----------\n    l : list\n        Name\n\n    Returns\n    -------\n    set\n        Duplicated values\n\n    >>> find_duplicates([1,2,3])\n    set()\n    >>> find_duplicates([1,2,1])\n    {1}\n    \"\"\"\n    return set([x for x in l if l.count(x) > 1])", "code_tokens": "def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "docstring_tokens": "Return the duplicates in a list .", "label": 1}, {"idx": "cosqa-train-17996", "doc": "check if df is not null in python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 0}, {"idx": "cosqa-train-17997", "doc": "python keep bits byte aligned", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 1}, {"idx": "cosqa-train-17998", "doc": "how to get the year of the date in python", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 1}, {"idx": "cosqa-train-17999", "doc": "pick up a row having a maximum value in a column in python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 1}, {"idx": "cosqa-train-18000", "doc": "python read keyboard input from specific", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 0}, {"idx": "cosqa-train-18001", "doc": "return key for largest list in python", "code": "def get_default_bucket_key(buckets: List[Tuple[int, int]]) -> Tuple[int, int]:\n    \"\"\"\n    Returns the default bucket from a list of buckets, i.e. the largest bucket.\n\n    :param buckets: List of buckets.\n    :return: The largest bucket in the list.\n    \"\"\"\n    return max(buckets)", "code_tokens": "def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )", "docstring_tokens": "Returns the default bucket from a list of buckets i . e . the largest bucket .", "label": 1}, {"idx": "cosqa-train-18002", "doc": "casting map to string python", "code": "def translate_dict(cls, val):\n        \"\"\"Translate dicts to scala Maps\"\"\"\n        escaped = ', '.join(\n            [\"{} -> {}\".format(cls.translate_str(k), cls.translate(v)) for k, v in val.items()]\n        )\n        return 'Map({})'.format(escaped)", "code_tokens": "def translate_dict ( cls , val ) : escaped = ', ' . join ( [ \"{} -> {}\" . format ( cls . translate_str ( k ) , cls . translate ( v ) ) for k , v in val . items ( ) ] ) return 'Map({})' . format ( escaped )", "docstring_tokens": "Translate dicts to scala Maps", "label": 1}, {"idx": "cosqa-train-18003", "doc": "python how to rotate a list", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 1}, {"idx": "cosqa-train-18004", "doc": "python list of unique values in text file", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 0}, {"idx": "cosqa-train-18005", "doc": "python getyear from the date string", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 0}, {"idx": "cosqa-train-18006", "doc": "python create hash of list elements", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 0}, {"idx": "cosqa-train-18007", "doc": "+python +datetime +format iso format", "code": "def datetime_iso_format(date):\n    \"\"\"\n    Return an ISO-8601 representation of a datetime object.\n    \"\"\"\n    return \"{0:0>4}-{1:0>2}-{2:0>2}T{3:0>2}:{4:0>2}:{5:0>2}Z\".format(\n        date.year, date.month, date.day, date.hour,\n        date.minute, date.second)", "code_tokens": "def datetime_iso_format ( date ) : return \"{0:0>4}-{1:0>2}-{2:0>2}T{3:0>2}:{4:0>2}:{5:0>2}Z\" . format ( date . year , date . month , date . day , date . hour , date . minute , date . second )", "docstring_tokens": "Return an ISO - 8601 representation of a datetime object .", "label": 0}, {"idx": "cosqa-train-18008", "doc": "how to check if key exists in python", "code": "def check_key(self, key: str) -> bool:\n        \"\"\"\n        Checks if key exists in datastore. True if yes, False if no.\n\n        :param: SHA512 hash key\n\n        :return: whether or key not exists in datastore\n        \"\"\"\n        keys = self.get_keys()\n        return key in keys", "code_tokens": "def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "docstring_tokens": "Checks if key exists in datastore . True if yes False if no .", "label": 1}, {"idx": "cosqa-train-18009", "doc": "python hist returns bin edges right", "code": "def get_bin_edges_from_axis(axis) -> np.ndarray:\n    \"\"\" Get bin edges from a ROOT hist axis.\n\n    Note:\n        Doesn't include over- or underflow bins!\n\n    Args:\n        axis (ROOT.TAxis): Axis from which the bin edges should be extracted.\n    Returns:\n        Array containing the bin edges.\n    \"\"\"\n    # Don't include over- or underflow bins\n    bins = range(1, axis.GetNbins() + 1)\n    # Bin edges\n    bin_edges = np.empty(len(bins) + 1)\n    bin_edges[:-1] = [axis.GetBinLowEdge(i) for i in bins]\n    bin_edges[-1] = axis.GetBinUpEdge(axis.GetNbins())\n\n    return bin_edges", "code_tokens": "def get_bin_edges_from_axis ( axis ) -> np . ndarray : # Don't include over- or underflow bins bins = range ( 1 , axis . GetNbins ( ) + 1 ) # Bin edges bin_edges = np . empty ( len ( bins ) + 1 ) bin_edges [ : - 1 ] = [ axis . GetBinLowEdge ( i ) for i in bins ] bin_edges [ - 1 ] = axis . GetBinUpEdge ( axis . GetNbins ( ) ) return bin_edges", "docstring_tokens": "Get bin edges from a ROOT hist axis .", "label": 1}, {"idx": "cosqa-train-18010", "doc": "python get top n values from list", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 1}, {"idx": "cosqa-train-18011", "doc": "graphviz dot to png python", "code": "def cmd_dot(conf: Config):\n    \"\"\"Print out a neat targets dependency tree based on requested targets.\n\n    Use graphviz to render the dot file, e.g.:\n\n    > ybt dot :foo :bar | dot -Tpng -o graph.png\n    \"\"\"\n    build_context = BuildContext(conf)\n    populate_targets_graph(build_context, conf)\n    if conf.output_dot_file is None:\n        write_dot(build_context, conf, sys.stdout)\n    else:\n        with open(conf.output_dot_file, 'w') as out_file:\n            write_dot(build_context, conf, out_file)", "code_tokens": "def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "docstring_tokens": "Print out a neat targets dependency tree based on requested targets .", "label": 1}, {"idx": "cosqa-train-18012", "doc": "how to transform a 2d matrix to tensor python", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 1}, {"idx": "cosqa-train-18013", "doc": "how to grep a string in a file using aspython", "code": "def grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''", "code_tokens": "def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "docstring_tokens": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .", "label": 0}, {"idx": "cosqa-train-18014", "doc": "python string \"any lowercase characters\"", "code": "def lowercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the lowercase chars in the given string.\"\"\"\n        return ''.join([c if c.islower() else '' for c in str(string)])", "code_tokens": "def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the lowercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-18015", "doc": "transfer list to string witho commas python", "code": "def list_to_str(lst):\n    \"\"\"\n    Turn a list into a comma- and/or and-separated string.\n\n    Parameters\n    ----------\n    lst : :obj:`list`\n        A list of strings to join into a single string.\n\n    Returns\n    -------\n    str_ : :obj:`str`\n        A string with commas and/or ands separating th elements from ``lst``.\n\n    \"\"\"\n    if len(lst) == 1:\n        str_ = lst[0]\n    elif len(lst) == 2:\n        str_ = ' and '.join(lst)\n    elif len(lst) > 2:\n        str_ = ', '.join(lst[:-1])\n        str_ += ', and {0}'.format(lst[-1])\n    else:\n        raise ValueError('List of length 0 provided.')\n    return str_", "code_tokens": "def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "docstring_tokens": "Turn a list into a comma - and / or and - separated string .", "label": 0}, {"idx": "cosqa-train-18016", "doc": "python delete element from set", "code": "def remove_once(gset, elem):\n    \"\"\"Remove the element from a set, lists or dict.\n    \n        >>> L = [\"Lucy\"]; S = set([\"Sky\"]); D = { \"Diamonds\": True };\n        >>> remove_once(L, \"Lucy\"); remove_once(S, \"Sky\"); remove_once(D, \"Diamonds\");\n        >>> print L, S, D\n        [] set([]) {}\n\n    Returns the element if it was removed. Raises one of the exceptions in \n    :obj:`RemoveError` otherwise.\n    \"\"\"\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "code_tokens": "def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "docstring_tokens": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}", "label": 1}, {"idx": "cosqa-train-18017", "doc": "detect language of the text python", "code": "def get_language(query: str) -> str:\n    \"\"\"Tries to work out the highlight.js language of a given file name or\n    shebang. Returns an empty string if none match.\n    \"\"\"\n    query = query.lower()\n    for language in LANGUAGES:\n        if query.endswith(language):\n            return language\n    return ''", "code_tokens": "def get_language ( query : str ) -> str : query = query . lower ( ) for language in LANGUAGES : if query . endswith ( language ) : return language return ''", "docstring_tokens": "Tries to work out the highlight . js language of a given file name or shebang . Returns an empty string if none match .", "label": 0}, {"idx": "cosqa-train-18018", "doc": "python get datatype of sql column", "code": "def get_datatype(self, table: str, column: str) -> str:\n        \"\"\"Returns database SQL datatype for a column: e.g. VARCHAR.\"\"\"\n        return self.flavour.get_datatype(self, table, column).upper()", "code_tokens": "def get_datatype ( self , table : str , column : str ) -> str : return self . flavour . get_datatype ( self , table , column ) . upper ( )", "docstring_tokens": "Returns database SQL datatype for a column : e . g . VARCHAR .", "label": 1}, {"idx": "cosqa-train-18019", "doc": "pylint for python 3", "code": "def lint(fmt='colorized'):\n    \"\"\"Run verbose PyLint on source. Optionally specify fmt=html for HTML output.\"\"\"\n    if fmt == 'html':\n        outfile = 'pylint_report.html'\n        local('pylint -f %s davies > %s || true' % (fmt, outfile))\n        local('open %s' % outfile)\n    else:\n        local('pylint -f %s davies || true' % fmt)", "code_tokens": "def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "docstring_tokens": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output .", "label": 0}, {"idx": "cosqa-train-18020", "doc": "determining alphanumeric characters in a string python", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 1}, {"idx": "cosqa-train-18021", "doc": "python see if value is finite", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 0}, {"idx": "cosqa-train-18022", "doc": "delete top comment of python file", "code": "def _strip_top_comments(lines: Sequence[str], line_separator: str) -> str:\n        \"\"\"Strips # comments that exist at the top of the given lines\"\"\"\n        lines = copy.copy(lines)\n        while lines and lines[0].startswith(\"#\"):\n            lines = lines[1:]\n        return line_separator.join(lines)", "code_tokens": "def _strip_top_comments ( lines : Sequence [ str ] , line_separator : str ) -> str : lines = copy . copy ( lines ) while lines and lines [ 0 ] . startswith ( \"#\" ) : lines = lines [ 1 : ] return line_separator . join ( lines )", "docstring_tokens": "Strips # comments that exist at the top of the given lines", "label": 0}, {"idx": "cosqa-train-18023", "doc": "function that returns first occurence of item in string in python", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 1}, {"idx": "cosqa-train-18024", "doc": "make a function that sets up a logger python", "code": "def scope_logger(cls):\n    \"\"\"\n    Class decorator for adding a class local logger\n\n    Example:\n    >>> @scope_logger\n    >>> class Test:\n    >>>     def __init__(self):\n    >>>         self.log.info(\"class instantiated\")\n    >>> t = Test()\n    \n    \"\"\"\n    cls.log = logging.getLogger('{0}.{1}'.format(cls.__module__, cls.__name__))\n    return cls", "code_tokens": "def scope_logger ( cls ) : cls . log = logging . getLogger ( '{0}.{1}' . format ( cls . __module__ , cls . __name__ ) ) return cls", "docstring_tokens": "Class decorator for adding a class local logger", "label": 0}, {"idx": "cosqa-train-18025", "doc": "check if string equals quotation marks python", "code": "def is_quoted(arg: str) -> bool:\n    \"\"\"\n    Checks if a string is quoted\n    :param arg: the string being checked for quotes\n    :return: True if a string is quoted\n    \"\"\"\n    return len(arg) > 1 and arg[0] == arg[-1] and arg[0] in constants.QUOTES", "code_tokens": "def is_quoted ( arg : str ) -> bool : return len ( arg ) > 1 and arg [ 0 ] == arg [ - 1 ] and arg [ 0 ] in constants . QUOTES", "docstring_tokens": "Checks if a string is quoted : param arg : the string being checked for quotes : return : True if a string is quoted", "label": 1}, {"idx": "cosqa-train-18026", "doc": "dot product of two lists of same length python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 0}, {"idx": "cosqa-train-18027", "doc": "python judge if file empty", "code": "def isfile_notempty(inputfile: str) -> bool:\n        \"\"\"Check if the input filename with path is a file and is not empty.\"\"\"\n        try:\n            return isfile(inputfile) and getsize(inputfile) > 0\n        except TypeError:\n            raise TypeError('inputfile is not a valid type')", "code_tokens": "def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )", "docstring_tokens": "Check if the input filename with path is a file and is not empty .", "label": 1}, {"idx": "cosqa-train-18028", "doc": "how to flatten image python", "code": "def read_flat(self):\n        \"\"\"\n        Read a PNG file and decode it into flat row flat pixel format.\n\n        Returns (*width*, *height*, *pixels*, *metadata*).\n\n        May use excessive memory.\n\n        `pixels` are returned in flat row flat pixel format.\n\n        See also the :meth:`read` method which returns pixels in the\n        more stream-friendly boxed row flat pixel format.\n        \"\"\"\n        x, y, pixel, meta = self.read()\n        arraycode = 'BH'[meta['bitdepth'] > 8]\n        pixel = array(arraycode, itertools.chain(*pixel))\n        return x, y, pixel, meta", "code_tokens": "def read_flat ( self ) : x , y , pixel , meta = self . read ( ) arraycode = 'BH' [ meta [ 'bitdepth' ] > 8 ] pixel = array ( arraycode , itertools . chain ( * pixel ) ) return x , y , pixel , meta", "docstring_tokens": "Read a PNG file and decode it into flat row flat pixel format .", "label": 0}, {"idx": "cosqa-train-18029", "doc": "python ctypes how to identify a window", "code": "def SwitchToThisWindow(handle: int) -> None:\n    \"\"\"\n    SwitchToThisWindow from Win32.\n    handle: int, the handle of a native window.\n    \"\"\"\n    ctypes.windll.user32.SwitchToThisWindow(ctypes.c_void_p(handle), 1)", "code_tokens": "def SwitchToThisWindow ( handle : int ) -> None : ctypes . windll . user32 . SwitchToThisWindow ( ctypes . c_void_p ( handle ) , 1 )", "docstring_tokens": "SwitchToThisWindow from Win32 . handle : int the handle of a native window .", "label": 0}, {"idx": "cosqa-train-18030", "doc": "html color to rgb tuple python", "code": "def hex_color_to_tuple(hex):\n    \"\"\" convent hex color to tuple\n    \"#ffffff\"   ->  (255, 255, 255)\n    \"#ffff00ff\" ->  (255, 255, 0, 255)\n    \"\"\"\n    hex = hex[1:]\n    length = len(hex) // 2\n    return tuple(int(hex[i*2:i*2+2], 16) for i in range(length))", "code_tokens": "def hex_color_to_tuple ( hex ) : hex = hex [ 1 : ] length = len ( hex ) // 2 return tuple ( int ( hex [ i * 2 : i * 2 + 2 ] , 16 ) for i in range ( length ) )", "docstring_tokens": "convent hex color to tuple #ffffff - > ( 255 255 255 ) #ffff00ff - > ( 255 255 0 255 )", "label": 0}, {"idx": "cosqa-train-18031", "doc": "how to check datatype of column in python", "code": "def is_sqlatype_numeric(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type one that inherits from :class:`Numeric`,\n    such as :class:`Float`, :class:`Decimal`?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Numeric)", "code_tokens": "def is_sqlatype_numeric ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Numeric )", "docstring_tokens": "Is the SQLAlchemy column type one that inherits from : class : Numeric such as : class : Float : class : Decimal ?", "label": 1}, {"idx": "cosqa-train-18032", "doc": "map list to every 3 elements python", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-18033", "doc": "python enum check if value in enum", "code": "def has_value(cls, value: int) -> bool:\n        \"\"\"True if specified value exists in int enum; otherwise, False.\"\"\"\n        return any(value == item.value for item in cls)", "code_tokens": "def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "docstring_tokens": "True if specified value exists in int enum ; otherwise False .", "label": 0}, {"idx": "cosqa-train-18034", "doc": "python and remove trailing zeros", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 0}, {"idx": "cosqa-train-18035", "doc": "how do you exit code python and give message to user", "code": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)", "code_tokens": "def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "docstring_tokens": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting", "label": 0}, {"idx": "cosqa-train-18036", "doc": "check if you have 32 or 64 bit python", "code": "def check64bit(current_system=\"python\"):\n    \"\"\"checks if you are on a 64 bit platform\"\"\"\n    if current_system == \"python\":\n        return sys.maxsize > 2147483647\n    elif current_system == \"os\":\n        import platform\n        pm = platform.machine()\n        if pm != \"..\" and pm.endswith('64'):  # recent Python (not Iron)\n            return True\n        else:\n            if 'PROCESSOR_ARCHITEW6432' in os.environ:\n                return True  # 32 bit program running on 64 bit Windows\n            try:\n                # 64 bit Windows 64 bit program\n                return os.environ['PROCESSOR_ARCHITECTURE'].endswith('64')\n            except IndexError:\n                pass  # not Windows\n            try:\n                # this often works in Linux\n                return '64' in platform.architecture()[0]\n            except Exception:\n                # is an older version of Python, assume also an older os@\n                # (best we can guess)\n                return False", "code_tokens": "def check64bit ( current_system = \"python\" ) : if current_system == \"python\" : return sys . maxsize > 2147483647 elif current_system == \"os\" : import platform pm = platform . machine ( ) if pm != \"..\" and pm . endswith ( '64' ) : # recent Python (not Iron) return True else : if 'PROCESSOR_ARCHITEW6432' in os . environ : return True # 32 bit program running on 64 bit Windows try : # 64 bit Windows 64 bit program return os . environ [ 'PROCESSOR_ARCHITECTURE' ] . endswith ( '64' ) except IndexError : pass # not Windows try : # this often works in Linux return '64' in platform . architecture ( ) [ 0 ] except Exception : # is an older version of Python, assume also an older os@ # (best we can guess) return False", "docstring_tokens": "checks if you are on a 64 bit platform", "label": 0}, {"idx": "cosqa-train-18037", "doc": "python removing columns from a data frame", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 0}, {"idx": "cosqa-train-18038", "doc": "python matrix multiplication *", "code": "def __rmatmul__(self, other):\n        \"\"\"\n        Matrix multiplication using binary `@` operator in Python>=3.5.\n        \"\"\"\n        return self.T.dot(np.transpose(other)).T", "code_tokens": "def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T", "docstring_tokens": "Matrix multiplication using binary", "label": 1}, {"idx": "cosqa-train-18039", "doc": "how to decode base 64 python", "code": "def decodebytes(input):\n    \"\"\"Decode base64 string to byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _decodebytes_py3(input)\n    return _decodebytes_py2(input)", "code_tokens": "def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )", "docstring_tokens": "Decode base64 string to byte array .", "label": 1}, {"idx": "cosqa-train-18040", "doc": "python json formatted string to string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 0}, {"idx": "cosqa-train-18041", "doc": "printing data type off all columns in data frame in python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-18042", "doc": "python check if float is none", "code": "def parse_reading(val: str) -> Optional[float]:\n    \"\"\" Convert reading value to float (if possible) \"\"\"\n    try:\n        return float(val)\n    except ValueError:\n        logging.warning('Reading of \"%s\" is not a number', val)\n        return None", "code_tokens": "def parse_reading ( val : str ) -> Optional [ float ] : try : return float ( val ) except ValueError : logging . warning ( 'Reading of \"%s\" is not a number' , val ) return None", "docstring_tokens": "Convert reading value to float ( if possible )", "label": 0}, {"idx": "cosqa-train-18043", "doc": "python tell a file type", "code": "def from_buffer(buffer, mime=False):\n    \"\"\"\n    Accepts a binary string and returns the detected filetype.  Return\n    value is the mimetype if mime=True, otherwise a human readable\n    name.\n\n    >>> magic.from_buffer(open(\"testdata/test.pdf\").read(1024))\n    'PDF document, version 1.2'\n    \"\"\"\n    m = _get_magic_type(mime)\n    return m.from_buffer(buffer)", "code_tokens": "def from_buffer ( buffer , mime = False ) : m = _get_magic_type ( mime ) return m . from_buffer ( buffer )", "docstring_tokens": "Accepts a binary string and returns the detected filetype . Return value is the mimetype if mime = True otherwise a human readable name .", "label": 0}, {"idx": "cosqa-train-18044", "doc": "using map on lists python", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 1}, {"idx": "cosqa-train-18045", "doc": "python check for existing hash key", "code": "def check_key(self, key: str) -> bool:\n        \"\"\"\n        Checks if key exists in datastore. True if yes, False if no.\n\n        :param: SHA512 hash key\n\n        :return: whether or key not exists in datastore\n        \"\"\"\n        keys = self.get_keys()\n        return key in keys", "code_tokens": "def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "docstring_tokens": "Checks if key exists in datastore . True if yes False if no .", "label": 0}, {"idx": "cosqa-train-18046", "doc": "how to specify capitalization in python", "code": "def capitalize(string):\n    \"\"\"Capitalize a sentence.\n\n    Parameters\n    ----------\n    string : `str`\n        String to capitalize.\n\n    Returns\n    -------\n    `str`\n        Capitalized string.\n\n    Examples\n    --------\n    >>> capitalize('worD WORD WoRd')\n    'Word word word'\n    \"\"\"\n    if not string:\n        return string\n    if len(string) == 1:\n        return string.upper()\n    return string[0].upper() + string[1:].lower()", "code_tokens": "def capitalize ( string ) : if not string : return string if len ( string ) == 1 : return string . upper ( ) return string [ 0 ] . upper ( ) + string [ 1 : ] . lower ( )", "docstring_tokens": "Capitalize a sentence .", "label": 0}, {"idx": "cosqa-train-18047", "doc": "python iter dictionary items", "code": "def iterate_items(dictish):\n    \"\"\" Return a consistent (key, value) iterable on dict-like objects,\n    including lists of tuple pairs.\n\n    Example:\n\n        >>> list(iterate_items({'a': 1}))\n        [('a', 1)]\n        >>> list(iterate_items([('a', 1), ('b', 2)]))\n        [('a', 1), ('b', 2)]\n    \"\"\"\n    if hasattr(dictish, 'iteritems'):\n        return dictish.iteritems()\n    if hasattr(dictish, 'items'):\n        return dictish.items()\n    return dictish", "code_tokens": "def iterate_items ( dictish ) : if hasattr ( dictish , 'iteritems' ) : return dictish . iteritems ( ) if hasattr ( dictish , 'items' ) : return dictish . items ( ) return dictish", "docstring_tokens": "Return a consistent ( key value ) iterable on dict - like objects including lists of tuple pairs .", "label": 1}, {"idx": "cosqa-train-18048", "doc": "test asyncio python not working", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 1}, {"idx": "cosqa-train-18049", "doc": "get datatime from string python", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 1}, {"idx": "cosqa-train-18050", "doc": "how to get data type in python matrix", "code": "def maybe_infer_dtype_type(element):\n    \"\"\"Try to infer an object's dtype, for use in arithmetic ops\n\n    Uses `element.dtype` if that's available.\n    Objects implementing the iterator protocol are cast to a NumPy array,\n    and from there the array's type is used.\n\n    Parameters\n    ----------\n    element : object\n        Possibly has a `.dtype` attribute, and possibly the iterator\n        protocol.\n\n    Returns\n    -------\n    tipo : type\n\n    Examples\n    --------\n    >>> from collections import namedtuple\n    >>> Foo = namedtuple(\"Foo\", \"dtype\")\n    >>> maybe_infer_dtype_type(Foo(np.dtype(\"i8\")))\n    numpy.int64\n    \"\"\"\n    tipo = None\n    if hasattr(element, 'dtype'):\n        tipo = element.dtype\n    elif is_list_like(element):\n        element = np.asarray(element)\n        tipo = element.dtype\n    return tipo", "code_tokens": "def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "docstring_tokens": "Try to infer an object s dtype for use in arithmetic ops", "label": 0}, {"idx": "cosqa-train-18051", "doc": "highest 5 values from dictionary python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 0}, {"idx": "cosqa-train-18052", "doc": "python current time mysql", "code": "def get_now_sql_datetime():\n    \"\"\"\n    *A datetime stamp in MySQL format: ``YYYY-MM-DDTHH:MM:SS``*\n\n    **Return:**\n        - ``now`` -- current time and date in MySQL format\n\n    **Usage:**\n        .. code-block:: python \n\n            from fundamentals import times\n            now = times.get_now_sql_datetime()\n            print now\n\n            # OUT: 2016-03-18T11:08:23 \n    \"\"\"\n    ## > IMPORTS ##\n    from datetime import datetime, date, time\n    now = datetime.now()\n    now = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    return now", "code_tokens": "def get_now_sql_datetime ( ) : ## > IMPORTS ## from datetime import datetime , date , time now = datetime . now ( ) now = now . strftime ( \"%Y-%m-%dT%H:%M:%S\" ) return now", "docstring_tokens": "* A datetime stamp in MySQL format : YYYY - MM - DDTHH : MM : SS *", "label": 1}, {"idx": "cosqa-train-18053", "doc": "python graph to file", "code": "def export_to_dot(self, filename: str = 'output') -> None:\n        \"\"\" Export the graph to the dot file \"filename.dot\". \"\"\"\n        with open(filename + '.dot', 'w') as output:\n            output.write(self.as_dot())", "code_tokens": "def export_to_dot ( self , filename : str = 'output' ) -> None : with open ( filename + '.dot' , 'w' ) as output : output . write ( self . as_dot ( ) )", "docstring_tokens": "Export the graph to the dot file filename . dot .", "label": 0}, {"idx": "cosqa-train-18054", "doc": "python how to flatten image", "code": "def read_flat(self):\n        \"\"\"\n        Read a PNG file and decode it into flat row flat pixel format.\n\n        Returns (*width*, *height*, *pixels*, *metadata*).\n\n        May use excessive memory.\n\n        `pixels` are returned in flat row flat pixel format.\n\n        See also the :meth:`read` method which returns pixels in the\n        more stream-friendly boxed row flat pixel format.\n        \"\"\"\n        x, y, pixel, meta = self.read()\n        arraycode = 'BH'[meta['bitdepth'] > 8]\n        pixel = array(arraycode, itertools.chain(*pixel))\n        return x, y, pixel, meta", "code_tokens": "def read_flat ( self ) : x , y , pixel , meta = self . read ( ) arraycode = 'BH' [ meta [ 'bitdepth' ] > 8 ] pixel = array ( arraycode , itertools . chain ( * pixel ) ) return x , y , pixel , meta", "docstring_tokens": "Read a PNG file and decode it into flat row flat pixel format .", "label": 1}, {"idx": "cosqa-train-18055", "doc": "current date in iso string format in python", "code": "def to_iso_string(self) -> str:\n        \"\"\" Returns full ISO string for the given date \"\"\"\n        assert isinstance(self.value, datetime)\n        return datetime.isoformat(self.value)", "code_tokens": "def to_iso_string ( self ) -> str : assert isinstance ( self . value , datetime ) return datetime . isoformat ( self . value )", "docstring_tokens": "Returns full ISO string for the given date", "label": 0}, {"idx": "cosqa-train-18056", "doc": "check if a string timestamp iso format python", "code": "def from_iso_time(timestring, use_dateutil=True):\n    \"\"\"Parse an ISO8601-formatted datetime string and return a datetime.time\n    object.\n    \"\"\"\n    if not _iso8601_time_re.match(timestring):\n        raise ValueError('Not a valid ISO8601-formatted time string')\n    if dateutil_available and use_dateutil:\n        return parser.parse(timestring).time()\n    else:\n        if len(timestring) > 8:  # has microseconds\n            fmt = '%H:%M:%S.%f'\n        else:\n            fmt = '%H:%M:%S'\n        return datetime.datetime.strptime(timestring, fmt).time()", "code_tokens": "def from_iso_time ( timestring , use_dateutil = True ) : if not _iso8601_time_re . match ( timestring ) : raise ValueError ( 'Not a valid ISO8601-formatted time string' ) if dateutil_available and use_dateutil : return parser . parse ( timestring ) . time ( ) else : if len ( timestring ) > 8 : # has microseconds fmt = '%H:%M:%S.%f' else : fmt = '%H:%M:%S' return datetime . datetime . strptime ( timestring , fmt ) . time ( )", "docstring_tokens": "Parse an ISO8601 - formatted datetime string and return a datetime . time object .", "label": 1}, {"idx": "cosqa-train-18057", "doc": "how to print the current timezone in python", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-18058", "doc": "python 2 to python 3 decoding", "code": "def decodebytes(input):\n    \"\"\"Decode base64 string to byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _decodebytes_py3(input)\n    return _decodebytes_py2(input)", "code_tokens": "def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )", "docstring_tokens": "Decode base64 string to byte array .", "label": 0}, {"idx": "cosqa-train-18059", "doc": "python test if first letter is capital", "code": "def fix_title_capitalization(title):\n    \"\"\"Try to capitalize properly a title string.\"\"\"\n    if re.search(\"[A-Z]\", title) and re.search(\"[a-z]\", title):\n        return title\n    word_list = re.split(' +', title)\n    final = [word_list[0].capitalize()]\n    for word in word_list[1:]:\n        if word.upper() in COMMON_ACRONYMS:\n            final.append(word.upper())\n        elif len(word) > 3:\n            final.append(word.capitalize())\n        else:\n            final.append(word.lower())\n    return \" \".join(final)", "code_tokens": "def fix_title_capitalization ( title ) : if re . search ( \"[A-Z]\" , title ) and re . search ( \"[a-z]\" , title ) : return title word_list = re . split ( ' +' , title ) final = [ word_list [ 0 ] . capitalize ( ) ] for word in word_list [ 1 : ] : if word . upper ( ) in COMMON_ACRONYMS : final . append ( word . upper ( ) ) elif len ( word ) > 3 : final . append ( word . capitalize ( ) ) else : final . append ( word . lower ( ) ) return \" \" . join ( final )", "docstring_tokens": "Try to capitalize properly a title string .", "label": 0}, {"idx": "cosqa-train-18060", "doc": "indices of k smallest elements python", "code": "def argsort_k_smallest(x, k):\n    \"\"\" Return no more than ``k`` indices of smallest values. \"\"\"\n    if k == 0:\n        return np.array([], dtype=np.intp)\n    if k is None or k >= len(x):\n        return np.argsort(x)\n    indices = np.argpartition(x, k)[:k]\n    values = x[indices]\n    return indices[np.argsort(values)]", "code_tokens": "def argsort_k_smallest ( x , k ) : if k == 0 : return np . array ( [ ] , dtype = np . intp ) if k is None or k >= len ( x ) : return np . argsort ( x ) indices = np . argpartition ( x , k ) [ : k ] values = x [ indices ] return indices [ np . argsort ( values ) ]", "docstring_tokens": "Return no more than k indices of smallest values .", "label": 1}, {"idx": "cosqa-train-18061", "doc": "python get area of polygon", "code": "def area (self):\n    \"\"\"area() -> number\n\n    Returns the area of this Polygon.\n    \"\"\"\n    area = 0.0\n    \n    for segment in self.segments():\n      area += ((segment.p.x * segment.q.y) - (segment.q.x * segment.p.y))/2\n\n    return area", "code_tokens": "def area ( self ) : area = 0.0 for segment in self . segments ( ) : area += ( ( segment . p . x * segment . q . y ) - ( segment . q . x * segment . p . y ) ) / 2 return area", "docstring_tokens": "area () - > number", "label": 1}, {"idx": "cosqa-train-18062", "doc": "vs code change indent space for python files only", "code": "def PrintIndented(self, file, ident, code):\n        \"\"\"Takes an array, add indentation to each entry and prints it.\"\"\"\n        for entry in code:\n            print >>file, '%s%s' % (ident, entry)", "code_tokens": "def PrintIndented ( self , file , ident , code ) : for entry in code : print >> file , '%s%s' % ( ident , entry )", "docstring_tokens": "Takes an array add indentation to each entry and prints it .", "label": 0}, {"idx": "cosqa-train-18063", "doc": "how to code a tree in python", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-18064", "doc": "cast python variable string to date", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 1}, {"idx": "cosqa-train-18065", "doc": "python str remove blank", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 0}, {"idx": "cosqa-train-18066", "doc": "python turn uuid into string", "code": "def uuid2buid(value):\n    \"\"\"\n    Convert a UUID object to a 22-char BUID string\n\n    >>> u = uuid.UUID('33203dd2-f2ef-422f-aeb0-058d6f5f7089')\n    >>> uuid2buid(u)\n    'MyA90vLvQi-usAWNb19wiQ'\n    \"\"\"\n    if six.PY3:  # pragma: no cover\n        return urlsafe_b64encode(value.bytes).decode('utf-8').rstrip('=')\n    else:\n        return six.text_type(urlsafe_b64encode(value.bytes).rstrip('='))", "code_tokens": "def uuid2buid ( value ) : if six . PY3 : # pragma: no cover return urlsafe_b64encode ( value . bytes ) . decode ( 'utf-8' ) . rstrip ( '=' ) else : return six . text_type ( urlsafe_b64encode ( value . bytes ) . rstrip ( '=' ) )", "docstring_tokens": "Convert a UUID object to a 22 - char BUID string", "label": 0}, {"idx": "cosqa-train-18067", "doc": "python3 encoding a bytestring", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 1}, {"idx": "cosqa-train-18068", "doc": "python make all list elements lowercase", "code": "def gen_lower(x: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\"\n    Args:\n        x: iterable of strings\n\n    Yields:\n        each string in lower case\n    \"\"\"\n    for string in x:\n        yield string.lower()", "code_tokens": "def gen_lower ( x : Iterable [ str ] ) -> Generator [ str , None , None ] : for string in x : yield string . lower ( )", "docstring_tokens": "Args : x : iterable of strings", "label": 1}, {"idx": "cosqa-train-18069", "doc": "how to remove leading zeroes in python", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 1}, {"idx": "cosqa-train-18070", "doc": "does readlines in python skip empty lines", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-18071", "doc": "finding longest path of dag python", "code": "def dag_longest_path(graph, source, target):\n    \"\"\"\n    Finds the longest path in a dag between two nodes\n    \"\"\"\n    if source == target:\n        return [source]\n    allpaths = nx.all_simple_paths(graph, source, target)\n    longest_path = []\n    for l in allpaths:\n        if len(l) > len(longest_path):\n            longest_path = l\n    return longest_path", "code_tokens": "def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "docstring_tokens": "Finds the longest path in a dag between two nodes", "label": 1}, {"idx": "cosqa-train-18072", "doc": "python check datatype of a column", "code": "def is_sqlatype_string(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type a string type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.String)", "code_tokens": "def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "docstring_tokens": "Is the SQLAlchemy column type a string type?", "label": 0}, {"idx": "cosqa-train-18073", "doc": "how to replace a substring in a python sdtring", "code": "def replace(s, old, new, maxreplace=-1):\n    \"\"\"replace (str, old, new[, maxreplace]) -> string\n\n    Return a copy of string str with all occurrences of substring\n    old replaced by new. If the optional argument maxreplace is\n    given, only the first maxreplace occurrences are replaced.\n\n    \"\"\"\n    return s.replace(old, new, maxreplace)", "code_tokens": "def replace ( s , old , new , maxreplace = - 1 ) : return s . replace ( old , new , maxreplace )", "docstring_tokens": "replace ( str old new [ maxreplace ] ) - > string", "label": 0}, {"idx": "cosqa-train-18074", "doc": "get most frequent items in list python", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 0}, {"idx": "cosqa-train-18075", "doc": "max length of list of strings python", "code": "def _prm_get_longest_stringsize(string_list):\n        \"\"\" Returns the longest string size for a string entry across data.\"\"\"\n        maxlength = 1\n\n        for stringar in string_list:\n            if isinstance(stringar, np.ndarray):\n                if stringar.ndim > 0:\n                    for string in stringar.ravel():\n                        maxlength = max(len(string), maxlength)\n                else:\n                    maxlength = max(len(stringar.tolist()), maxlength)\n            else:\n                maxlength = max(len(stringar), maxlength)\n\n        # Make the string Col longer than needed in order to allow later on slightly larger strings\n        return int(maxlength * 1.5)", "code_tokens": "def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "docstring_tokens": "Returns the longest string size for a string entry across data .", "label": 0}, {"idx": "cosqa-train-18076", "doc": "python re expression to delete all files", "code": "def rmglob(pattern: str) -> None:\n    \"\"\"\n    Deletes all files whose filename matches the glob ``pattern`` (via\n    :func:`glob.glob`).\n    \"\"\"\n    for f in glob.glob(pattern):\n        os.remove(f)", "code_tokens": "def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "docstring_tokens": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .", "label": 0}, {"idx": "cosqa-train-18077", "doc": "how to determine depth nested list python", "code": "def list_depth(list_, func=max, _depth=0):\n    \"\"\"\n    Returns the deepest level of nesting within a list of lists\n\n    Args:\n       list_  : a nested listlike object\n       func   : depth aggregation strategy (defaults to max)\n       _depth : internal var\n\n    Example:\n        >>> # ENABLE_DOCTEST\n        >>> from utool.util_list import *  # NOQA\n        >>> list_ = [[[[[1]]], [3]], [[1], [3]], [[1], [3]]]\n        >>> result = (list_depth(list_, _depth=0))\n        >>> print(result)\n\n    \"\"\"\n    depth_list = [list_depth(item, func=func, _depth=_depth + 1)\n                  for item in  list_ if util_type.is_listlike(item)]\n    if len(depth_list) > 0:\n        return func(depth_list)\n    else:\n        return _depth", "code_tokens": "def list_depth ( list_ , func = max , _depth = 0 ) : depth_list = [ list_depth ( item , func = func , _depth = _depth + 1 ) for item in list_ if util_type . is_listlike ( item ) ] if len ( depth_list ) > 0 : return func ( depth_list ) else : return _depth", "docstring_tokens": "Returns the deepest level of nesting within a list of lists", "label": 1}, {"idx": "cosqa-train-18078", "doc": "tensorflow python get shape", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 0}, {"idx": "cosqa-train-18079", "doc": "how do you get python code to print longest line of a text", "code": "def get_longest_line_length(text):\n    \"\"\"Get the length longest line in a paragraph\"\"\"\n    lines = text.split(\"\\n\")\n    length = 0\n\n    for i in range(len(lines)):\n        if len(lines[i]) > length:\n            length = len(lines[i])\n\n    return length", "code_tokens": "def get_longest_line_length ( text ) : lines = text . split ( \"\\n\" ) length = 0 for i in range ( len ( lines ) ) : if len ( lines [ i ] ) > length : length = len ( lines [ i ] ) return length", "docstring_tokens": "Get the length longest line in a paragraph", "label": 1}, {"idx": "cosqa-train-18080", "doc": "flatten arbitrary list python", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 1}, {"idx": "cosqa-train-18081", "doc": "index slicing python get last element", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-18082", "doc": "python csv read numpy array", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 1}, {"idx": "cosqa-train-18083", "doc": "python square wave with input and end", "code": "def constant(times: np.ndarray, amp: complex) -> np.ndarray:\n    \"\"\"Continuous constant pulse.\n\n    Args:\n        times: Times to output pulse for.\n        amp: Complex pulse amplitude.\n    \"\"\"\n    return np.full(len(times), amp, dtype=np.complex_)", "code_tokens": "def constant ( times : np . ndarray , amp : complex ) -> np . ndarray : return np . full ( len ( times ) , amp , dtype = np . complex_ )", "docstring_tokens": "Continuous constant pulse .", "label": 1}, {"idx": "cosqa-train-18084", "doc": "python check is a float zero", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 0}, {"idx": "cosqa-train-18085", "doc": "python requests post how to use params", "code": "def post(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP POST operation to API endpoint.\"\"\"\n\n        return self._request('POST', endpoint, **kwargs)", "code_tokens": "def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "docstring_tokens": "HTTP POST operation to API endpoint .", "label": 0}, {"idx": "cosqa-train-18086", "doc": "python get files in directory sort by modified time", "code": "def sort_by_modified(files_or_folders: list) -> list:\n    \"\"\"\n    Sort files or folders by modified time\n\n    Args:\n        files_or_folders: list of files or folders\n\n    Returns:\n        list\n    \"\"\"\n    return sorted(files_or_folders, key=os.path.getmtime, reverse=True)", "code_tokens": "def sort_by_modified ( files_or_folders : list ) -> list : return sorted ( files_or_folders , key = os . path . getmtime , reverse = True )", "docstring_tokens": "Sort files or folders by modified time", "label": 1}, {"idx": "cosqa-train-18087", "doc": "call a fucntion argparse cli python", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 0}, {"idx": "cosqa-train-18088", "doc": "flatten list in list python", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 0}, {"idx": "cosqa-train-18089", "doc": "list of indices to list of values python", "code": "def indices_to_labels(self, indices: Sequence[int]) -> List[str]:\n        \"\"\" Converts a sequence of indices into their corresponding labels.\"\"\"\n\n        return [(self.INDEX_TO_LABEL[index]) for index in indices]", "code_tokens": "def indices_to_labels ( self , indices : Sequence [ int ] ) -> List [ str ] : return [ ( self . INDEX_TO_LABEL [ index ] ) for index in indices ]", "docstring_tokens": "Converts a sequence of indices into their corresponding labels .", "label": 0}, {"idx": "cosqa-train-18090", "doc": "remove carriage return from string in python", "code": "def strip_codes(s: Any) -> str:\n    \"\"\" Strip all color codes from a string.\n        Returns empty string for \"falsey\" inputs.\n    \"\"\"\n    return codepat.sub('', str(s) if (s or (s == 0)) else '')", "code_tokens": "def strip_codes ( s : Any ) -> str : return codepat . sub ( '' , str ( s ) if ( s or ( s == 0 ) ) else '' )", "docstring_tokens": "Strip all color codes from a string . Returns empty string for falsey inputs .", "label": 0}, {"idx": "cosqa-train-18091", "doc": "python iterate and remove dict filter", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-18092", "doc": "rendering a python figure in html with javascript", "code": "def to_jupyter(graph: BELGraph, chart: Optional[str] = None) -> Javascript:\n    \"\"\"Render the graph as JavaScript in a Jupyter Notebook.\"\"\"\n    with open(os.path.join(HERE, 'render_with_javascript.js'), 'rt') as f:\n        js_template = Template(f.read())\n\n    return Javascript(js_template.render(**_get_context(graph, chart=chart)))", "code_tokens": "def to_jupyter ( graph : BELGraph , chart : Optional [ str ] = None ) -> Javascript : with open ( os . path . join ( HERE , 'render_with_javascript.js' ) , 'rt' ) as f : js_template = Template ( f . read ( ) ) return Javascript ( js_template . render ( * * _get_context ( graph , chart = chart ) ) )", "docstring_tokens": "Render the graph as JavaScript in a Jupyter Notebook .", "label": 1}, {"idx": "cosqa-train-18093", "doc": "python how to check if a string is file", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-18094", "doc": "python normalize to sum to 1", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 0}, {"idx": "cosqa-train-18095", "doc": "how to check for a line in a file using python", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 1}, {"idx": "cosqa-train-18096", "doc": "python matrix only return values above 0", "code": "def negate_mask(mask):\n    \"\"\"Returns the negated mask.\n\n    If elements of input mask have 0 and non-zero values, then the returned matrix will have all elements 0 (1) where\n    the original one has non-zero (0).\n\n    :param mask: Input mask\n    :type mask: np.array\n    :return: array of same shape and dtype=int8 as input array\n    :rtype: np.array\n    \"\"\"\n    res = np.ones(mask.shape, dtype=np.int8)\n    res[mask > 0] = 0\n\n    return res", "code_tokens": "def negate_mask ( mask ) : res = np . ones ( mask . shape , dtype = np . int8 ) res [ mask > 0 ] = 0 return res", "docstring_tokens": "Returns the negated mask . If elements of input mask have 0 and non - zero values then the returned matrix will have all elements 0 ( 1 ) where the original one has non - zero ( 0 ) . : param mask : Input mask : type mask : np . array : return : array of same shape and dtype = int8 as input array : rtype : np . array", "label": 1}, {"idx": "cosqa-train-18097", "doc": "how do i cut off leading zeroes in python", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 1}, {"idx": "cosqa-train-18098", "doc": "python asyncio socket examples", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 0}, {"idx": "cosqa-train-18099", "doc": "how to parse bits into 32 bit in python chunk", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 1}, {"idx": "cosqa-train-18100", "doc": "windows python get disk uuid", "code": "def local_machine_uuid():\n    \"\"\"Return local machine unique identifier.\n\n    >>> uuid = local_machine_uuid()\n\n    \"\"\"\n\n    result = subprocess.check_output(\n        'hal-get-property --udi '\n        '/org/freedesktop/Hal/devices/computer '\n        '--key system.hardware.uuid'.split()\n        ).strip()\n\n    return uuid.UUID(hex=result)", "code_tokens": "def local_machine_uuid ( ) : result = subprocess . check_output ( 'hal-get-property --udi ' '/org/freedesktop/Hal/devices/computer ' '--key system.hardware.uuid' . split ( ) ) . strip ( ) return uuid . UUID ( hex = result )", "docstring_tokens": "Return local machine unique identifier .", "label": 0}, {"idx": "cosqa-train-18101", "doc": "python last day of month two months ago", "code": "def get_period_last_3_months() -> str:\n    \"\"\" Returns the last week as a period string \"\"\"\n    today = Datum()\n    today.today()\n\n    # start_date = today - timedelta(weeks=13)\n    start_date = today.clone()\n    start_date.subtract_months(3)\n\n    period = get_period(start_date.date, today.date)\n    return period", "code_tokens": "def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "docstring_tokens": "Returns the last week as a period string", "label": 0}, {"idx": "cosqa-train-18102", "doc": "get datatypesof columns python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-18103", "doc": "python remove all empty items in list", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 0}, {"idx": "cosqa-train-18104", "doc": "how to make a set from an existing file python", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 1}, {"idx": "cosqa-train-18105", "doc": "python get top n element", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 0}, {"idx": "cosqa-train-18106", "doc": "how to get a timezones time in python", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 0}, {"idx": "cosqa-train-18107", "doc": "python test if strings equal", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 1}, {"idx": "cosqa-train-18108", "doc": "how do i check for args in python main", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 1}, {"idx": "cosqa-train-18109", "doc": "python sql with paramters", "code": "def execute(cur, *args):\n    \"\"\"Utility function to print sqlite queries before executing.\n\n    Use instead of cur.execute().  First argument is cursor.\n\n    cur.execute(stmt)\n    becomes\n    util.execute(cur, stmt)\n    \"\"\"\n    stmt = args[0]\n    if len(args) > 1:\n        stmt = stmt.replace('%', '%%').replace('?', '%r')\n        print(stmt % (args[1]))\n    return cur.execute(*args)", "code_tokens": "def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )", "docstring_tokens": "Utility function to print sqlite queries before executing .", "label": 0}, {"idx": "cosqa-train-18110", "doc": "python normalize to normal distribution", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 1}, {"idx": "cosqa-train-18111", "doc": "python check if all are type string in a column", "code": "def is_sqlatype_string(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type a string type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.String)", "code_tokens": "def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "docstring_tokens": "Is the SQLAlchemy column type a string type?", "label": 1}, {"idx": "cosqa-train-18112", "doc": "how to check if a line is in a file in python", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 0}, {"idx": "cosqa-train-18113", "doc": "python map for loop", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 1}, {"idx": "cosqa-train-18114", "doc": "python series get the minimum", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-18115", "doc": "python read csv as numpy array", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 1}, {"idx": "cosqa-train-18116", "doc": "vectorized normal cdf in python for speed", "code": "def normcdf(x, log=False):\n    \"\"\"Normal cumulative density function.\"\"\"\n    y = np.atleast_1d(x).copy()\n    flib.normcdf(y)\n    if log:\n        if (y>0).all():\n            return np.log(y)\n        return -np.inf\n    return y", "code_tokens": "def normcdf ( x , log = False ) : y = np . atleast_1d ( x ) . copy ( ) flib . normcdf ( y ) if log : if ( y > 0 ) . all ( ) : return np . log ( y ) return - np . inf return y", "docstring_tokens": "Normal cumulative density function .", "label": 1}, {"idx": "cosqa-train-18117", "doc": "python finding first occurance of character in string", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 1}, {"idx": "cosqa-train-18118", "doc": "python map function replace for loops", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-18119", "doc": "orthogonalize a matrix python", "code": "def is_orthogonal(\n        matrix: np.ndarray,\n        *,\n        rtol: float = 1e-5,\n        atol: float = 1e-8) -> bool:\n    \"\"\"Determines if a matrix is approximately orthogonal.\n\n    A matrix is orthogonal if it's square and real and its transpose is its\n    inverse.\n\n    Args:\n        matrix: The matrix to check.\n        rtol: The per-matrix-entry relative tolerance on equality.\n        atol: The per-matrix-entry absolute tolerance on equality.\n\n    Returns:\n        Whether the matrix is orthogonal within the given tolerance.\n    \"\"\"\n    return (matrix.shape[0] == matrix.shape[1] and\n            np.all(np.imag(matrix) == 0) and\n            np.allclose(matrix.dot(matrix.T), np.eye(matrix.shape[0]),\n                        rtol=rtol,\n                        atol=atol))", "code_tokens": "def is_orthogonal ( matrix : np . ndarray , * , rtol : float = 1e-5 , atol : float = 1e-8 ) -> bool : return ( matrix . shape [ 0 ] == matrix . shape [ 1 ] and np . all ( np . imag ( matrix ) == 0 ) and np . allclose ( matrix . dot ( matrix . T ) , np . eye ( matrix . shape [ 0 ] ) , rtol = rtol , atol = atol ) )", "docstring_tokens": "Determines if a matrix is approximately orthogonal .", "label": 1}, {"idx": "cosqa-train-18120", "doc": "python last element in a list of lists", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 0}, {"idx": "cosqa-train-18121", "doc": "how to get the year from a date in python", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 0}, {"idx": "cosqa-train-18122", "doc": "how to print half a list python", "code": "def _brief_print_list(lst, limit=7):\n    \"\"\"Print at most `limit` elements of list.\"\"\"\n    lst = list(lst)\n    if len(lst) > limit:\n        return _brief_print_list(lst[:limit//2], limit) + ', ..., ' + \\\n            _brief_print_list(lst[-limit//2:], limit)\n    return ', '.join([\"'%s'\"%str(i) for i in lst])", "code_tokens": "def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "docstring_tokens": "Print at most limit elements of list .", "label": 1}, {"idx": "cosqa-train-18123", "doc": "check whether the col has null value or not python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-18124", "doc": "check for letters without is alpha python", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-18125", "doc": "python map, delete key", "code": "def __remove_method(m: lmap.Map, key: T) -> lmap.Map:\n        \"\"\"Swap the methods atom to remove method with key.\"\"\"\n        return m.dissoc(key)", "code_tokens": "def __remove_method ( m : lmap . Map , key : T ) -> lmap . Map : return m . dissoc ( key )", "docstring_tokens": "Swap the methods atom to remove method with key .", "label": 1}, {"idx": "cosqa-train-18126", "doc": "datareader python current stock price", "code": "def get_value(self) -> Decimal:\n        \"\"\" Returns the current value of stocks \"\"\"\n        quantity = self.get_quantity()\n        price = self.get_last_available_price()\n        if not price:\n            # raise ValueError(\"no price found for\", self.full_symbol)\n            return Decimal(0)\n\n        value = quantity * price.value\n        return value", "code_tokens": "def get_value ( self ) -> Decimal : quantity = self . get_quantity ( ) price = self . get_last_available_price ( ) if not price : # raise ValueError(\"no price found for\", self.full_symbol) return Decimal ( 0 ) value = quantity * price . value return value", "docstring_tokens": "Returns the current value of stocks", "label": 0}, {"idx": "cosqa-train-18127", "doc": "python flask add cache", "code": "def setup_cache(app: Flask, cache_config) -> Optional[Cache]:\n    \"\"\"Setup the flask-cache on a flask app\"\"\"\n    if cache_config and cache_config.get('CACHE_TYPE') != 'null':\n        return Cache(app, config=cache_config)\n\n    return None", "code_tokens": "def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None", "docstring_tokens": "Setup the flask - cache on a flask app", "label": 1}, {"idx": "cosqa-train-18128", "doc": "how to identify last occurrence of character in string in python", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 0}, {"idx": "cosqa-train-18129", "doc": "get top n fields of dict in python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 0}, {"idx": "cosqa-train-18130", "doc": "get year from string date python", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 1}, {"idx": "cosqa-train-18131", "doc": "creating and finding the midpoints of two points in python", "code": "def _mid(pt1, pt2):\n    \"\"\"\n    (Point, Point) -> Point\n    Return the point that lies in between the two input points.\n    \"\"\"\n    (x0, y0), (x1, y1) = pt1, pt2\n    return 0.5 * (x0 + x1), 0.5 * (y0 + y1)", "code_tokens": "def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "docstring_tokens": "( Point Point ) - > Point Return the point that lies in between the two input points .", "label": 1}, {"idx": "cosqa-train-18132", "doc": "python how to verify file locaiton", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-18133", "doc": "how to check whether a variable is a lambda function in python", "code": "def is_inside_lambda(node: astroid.node_classes.NodeNG) -> bool:\n    \"\"\"Return true if given node is inside lambda\"\"\"\n    parent = node.parent\n    while parent is not None:\n        if isinstance(parent, astroid.Lambda):\n            return True\n        parent = parent.parent\n    return False", "code_tokens": "def is_inside_lambda ( node : astroid . node_classes . NodeNG ) -> bool : parent = node . parent while parent is not None : if isinstance ( parent , astroid . Lambda ) : return True parent = parent . parent return False", "docstring_tokens": "Return true if given node is inside lambda", "label": 1}, {"idx": "cosqa-train-18134", "doc": "how can i get text file in python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 0}, {"idx": "cosqa-train-18135", "doc": "python get domain of an http address", "code": "def get_domain(url):\n    \"\"\"\n    Get domain part of an url.\n\n    For example: https://www.python.org/doc/ -> https://www.python.org\n    \"\"\"\n    parse_result = urlparse(url)\n    domain = \"{schema}://{netloc}\".format(\n        schema=parse_result.scheme, netloc=parse_result.netloc)\n    return domain", "code_tokens": "def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "docstring_tokens": "Get domain part of an url .", "label": 0}, {"idx": "cosqa-train-18136", "doc": "longest string in a list python", "code": "def _prm_get_longest_stringsize(string_list):\n        \"\"\" Returns the longest string size for a string entry across data.\"\"\"\n        maxlength = 1\n\n        for stringar in string_list:\n            if isinstance(stringar, np.ndarray):\n                if stringar.ndim > 0:\n                    for string in stringar.ravel():\n                        maxlength = max(len(string), maxlength)\n                else:\n                    maxlength = max(len(stringar.tolist()), maxlength)\n            else:\n                maxlength = max(len(stringar), maxlength)\n\n        # Make the string Col longer than needed in order to allow later on slightly larger strings\n        return int(maxlength * 1.5)", "code_tokens": "def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "docstring_tokens": "Returns the longest string size for a string entry across data .", "label": 1}, {"idx": "cosqa-train-18137", "doc": "how to check if missing values are blanks or nan or none in python", "code": "def warn_if_nans_exist(X):\n    \"\"\"Warn if nans exist in a numpy array.\"\"\"\n    null_count = count_rows_with_nans(X)\n    total = len(X)\n    percent = 100 * null_count / total\n\n    if null_count > 0:\n        warning_message = \\\n            'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\\n            'complete rows will be plotted.'.format(null_count, total, percent)\n        warnings.warn(warning_message, DataWarning)", "code_tokens": "def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "docstring_tokens": "Warn if nans exist in a numpy array .", "label": 1}, {"idx": "cosqa-train-18138", "doc": "way to change the string \"python\" to have all uppercase letters", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-18139", "doc": "python list filters all blank string", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 0}, {"idx": "cosqa-train-18140", "doc": "python tensor to array", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 1}, {"idx": "cosqa-train-18141", "doc": "check if value is infinity or not python", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 0}, {"idx": "cosqa-train-18142", "doc": "python parse timezone abbreviation", "code": "def remove_parenthesis_around_tz(cls, timestr):\n        \"\"\"get rid of parenthesis around timezone: (GMT) => GMT\n\n        :return: the new string if parenthesis were found, `None` otherwise\n        \"\"\"\n        parenthesis = cls.TIMEZONE_PARENTHESIS.match(timestr)\n        if parenthesis is not None:\n            return parenthesis.group(1)", "code_tokens": "def remove_parenthesis_around_tz ( cls , timestr ) : parenthesis = cls . TIMEZONE_PARENTHESIS . match ( timestr ) if parenthesis is not None : return parenthesis . group ( 1 )", "docstring_tokens": "get rid of parenthesis around timezone : ( GMT ) = > GMT", "label": 1}, {"idx": "cosqa-train-18143", "doc": "compute similarity between data set python", "code": "def tanimoto_set_similarity(x: Iterable[X], y: Iterable[X]) -> float:\n    \"\"\"Calculate the tanimoto set similarity.\"\"\"\n    a, b = set(x), set(y)\n    union = a | b\n\n    if not union:\n        return 0.0\n\n    return len(a & b) / len(union)", "code_tokens": "def tanimoto_set_similarity ( x : Iterable [ X ] , y : Iterable [ X ] ) -> float : a , b = set ( x ) , set ( y ) union = a | b if not union : return 0.0 return len ( a & b ) / len ( union )", "docstring_tokens": "Calculate the tanimoto set similarity .", "label": 0}, {"idx": "cosqa-train-18144", "doc": "python 3 get timezone from pc", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-18145", "doc": "python parse string to date time", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 0}, {"idx": "cosqa-train-18146", "doc": "python how to judge all elements of an array at the same time", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 1}, {"idx": "cosqa-train-18147", "doc": "python list from delimited string", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 1}, {"idx": "cosqa-train-18148", "doc": "python json list object serializable", "code": "def __as_list(value: List[JsonObjTypes]) -> List[JsonTypes]:\n        \"\"\" Return a json array as a list\n\n        :param value: array\n        :return: array with JsonObj instances removed\n        \"\"\"\n        return [e._as_dict if isinstance(e, JsonObj) else e for e in value]", "code_tokens": "def __as_list ( value : List [ JsonObjTypes ] ) -> List [ JsonTypes ] : return [ e . _as_dict if isinstance ( e , JsonObj ) else e for e in value ]", "docstring_tokens": "Return a json array as a list", "label": 1}, {"idx": "cosqa-train-18149", "doc": "how to check whether string is whitespace in python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 1}, {"idx": "cosqa-train-18150", "doc": "how to test if atributes are equal in python", "code": "def simple_eq(one: Instance, two: Instance, attrs: List[str]) -> bool:\n    \"\"\"\n    Test if two objects are equal, based on a comparison of the specified\n    attributes ``attrs``.\n    \"\"\"\n    return all(getattr(one, a) == getattr(two, a) for a in attrs)", "code_tokens": "def simple_eq ( one : Instance , two : Instance , attrs : List [ str ] ) -> bool : return all ( getattr ( one , a ) == getattr ( two , a ) for a in attrs )", "docstring_tokens": "Test if two objects are equal based on a comparison of the specified attributes attrs .", "label": 1}, {"idx": "cosqa-train-18151", "doc": "get year from datetime date python", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 1}, {"idx": "cosqa-train-18152", "doc": "how to print a binary tree python", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-18153", "doc": "python last element of a multi diemnsional list", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 1}, {"idx": "cosqa-train-18154", "doc": "python self type str", "code": "def __repr__(self) -> str:\n        \"\"\"Return the string representation of self.\"\"\"\n        return '{0}({1})'.format(type(self).__name__, repr(self.string))", "code_tokens": "def __repr__ ( self ) -> str : return '{0}({1})' . format ( type ( self ) . __name__ , repr ( self . string ) )", "docstring_tokens": "Return the string representation of self .", "label": 0}, {"idx": "cosqa-train-18155", "doc": "rearrange matrix rows randomly python", "code": "def _reshuffle(mat, shape):\n    \"\"\"Reshuffle the indicies of a bipartite matrix A[ij,kl] -> A[lj,ki].\"\"\"\n    return np.reshape(\n        np.transpose(np.reshape(mat, shape), (3, 1, 2, 0)),\n        (shape[3] * shape[1], shape[0] * shape[2]))", "code_tokens": "def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )", "docstring_tokens": "Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] .", "label": 0}, {"idx": "cosqa-train-18156", "doc": "python change numpy ndarray to strings", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 1}, {"idx": "cosqa-train-18157", "doc": "python parsing yaml file", "code": "def load_yaml(yaml_file: str) -> Any:\n    \"\"\"\n    Load YAML from file.\n\n    :param yaml_file: path to YAML file\n    :return: content of the YAML as dict/list\n    \"\"\"\n    with open(yaml_file, 'r') as file:\n        return ruamel.yaml.load(file, ruamel.yaml.RoundTripLoader)", "code_tokens": "def load_yaml ( yaml_file : str ) -> Any : with open ( yaml_file , 'r' ) as file : return ruamel . yaml . load ( file , ruamel . yaml . RoundTripLoader )", "docstring_tokens": "Load YAML from file .", "label": 1}, {"idx": "cosqa-train-18158", "doc": "python string compare single quote", "code": "def is_quoted(arg: str) -> bool:\n    \"\"\"\n    Checks if a string is quoted\n    :param arg: the string being checked for quotes\n    :return: True if a string is quoted\n    \"\"\"\n    return len(arg) > 1 and arg[0] == arg[-1] and arg[0] in constants.QUOTES", "code_tokens": "def is_quoted ( arg : str ) -> bool : return len ( arg ) > 1 and arg [ 0 ] == arg [ - 1 ] and arg [ 0 ] in constants . QUOTES", "docstring_tokens": "Checks if a string is quoted : param arg : the string being checked for quotes : return : True if a string is quoted", "label": 0}, {"idx": "cosqa-train-18159", "doc": "how to inclrease memory allocated to python", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 1}, {"idx": "cosqa-train-18160", "doc": "\"any\" python list of strings", "code": "def quoted_or_list(items: List[str]) -> Optional[str]:\n    \"\"\"Given [A, B, C] return \"'A', 'B', or 'C'\".\n\n    Note: We use single quotes here, since these are also used by repr().\n    \"\"\"\n    return or_list([f\"'{item}'\" for item in items])", "code_tokens": "def quoted_or_list ( items : List [ str ] ) -> Optional [ str ] : return or_list ( [ f\"'{item}'\" for item in items ] )", "docstring_tokens": "Given [ A B C ] return A B or C .", "label": 0}, {"idx": "cosqa-train-18161", "doc": "how to generate hash value from list in python program", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 0}, {"idx": "cosqa-train-18162", "doc": "input string that replaces occurences python", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 1}, {"idx": "cosqa-train-18163", "doc": "get first digits of string only python", "code": "def first_digits(s, default=0):\n    \"\"\"Return the fist (left-hand) digits in a string as a single integer, ignoring sign (+/-).\n    >>> first_digits('+123.456')\n    123\n    \"\"\"\n    s = re.split(r'[^0-9]+', str(s).strip().lstrip('+-' + charlist.whitespace))\n    if len(s) and len(s[0]):\n        return int(s[0])\n    return default", "code_tokens": "def first_digits ( s , default = 0 ) : s = re . split ( r'[^0-9]+' , str ( s ) . strip ( ) . lstrip ( '+-' + charlist . whitespace ) ) if len ( s ) and len ( s [ 0 ] ) : return int ( s [ 0 ] ) return default", "docstring_tokens": "Return the fist ( left - hand ) digits in a string as a single integer ignoring sign ( + / - ) . >>> first_digits ( + 123 . 456 ) 123", "label": 0}, {"idx": "cosqa-train-18164", "doc": "python check if every array element satisfies condition", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 0}, {"idx": "cosqa-train-18165", "doc": "how to do bit masking in python3", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 1}, {"idx": "cosqa-train-18166", "doc": "how to add offset in current time python", "code": "def run_time() -> timedelta:\n    \"\"\"\n\n    :return:\n    \"\"\"\n\n    delta = start_time if start_time else datetime.utcnow()\n    return datetime.utcnow() - delta", "code_tokens": "def run_time ( ) -> timedelta : delta = start_time if start_time else datetime . utcnow ( ) return datetime . utcnow ( ) - delta", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-18167", "doc": "python char in a string to uppercase", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 0}, {"idx": "cosqa-train-18168", "doc": "python for in list except the last", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 1}, {"idx": "cosqa-train-18169", "doc": "how to graph a random walk in python", "code": "def returned(n):\n\t\"\"\"Generate a random walk and return True if the walker has returned to\n\tthe origin after taking `n` steps.\n\t\"\"\"\n\t## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk\n\tfor pos in randwalk() >> drop(1) >> takei(xrange(n-1)):\n\t\tif pos == Origin:\n\t\t\treturn True\n\treturn False", "code_tokens": "def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "docstring_tokens": "Generate a random walk and return True if the walker has returned to the origin after taking n steps .", "label": 0}, {"idx": "cosqa-train-18170", "doc": "get columns names of table in python", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 1}, {"idx": "cosqa-train-18171", "doc": "how do i create a numpy aray from a python list", "code": "def to_np(*args):\n    \"\"\" convert GPU arras to numpy and return them\"\"\"\n    if len(args) > 1:\n        return (cp.asnumpy(x) for x in args)\n    else:\n        return cp.asnumpy(args[0])", "code_tokens": "def to_np ( * args ) : if len ( args ) > 1 : return ( cp . asnumpy ( x ) for x in args ) else : return cp . asnumpy ( args [ 0 ] )", "docstring_tokens": "convert GPU arras to numpy and return them", "label": 0}, {"idx": "cosqa-train-18172", "doc": "count elements in queue of python", "code": "def count(self, elem):\n        \"\"\"\n        Return the number of elements equal to elem present in the queue\n\n        >>> pdeque([1, 2, 1]).count(1)\n        2\n        \"\"\"\n        return self._left_list.count(elem) + self._right_list.count(elem)", "code_tokens": "def count ( self , elem ) : return self . _left_list . count ( elem ) + self . _right_list . count ( elem )", "docstring_tokens": "Return the number of elements equal to elem present in the queue", "label": 0}, {"idx": "cosqa-train-18173", "doc": "how to fix the timeout error python requests", "code": "def _RetryRequest(self, timeout=None, **request_args):\n    \"\"\"Retry the request a few times before we determine it failed.\n\n    Sometimes the frontend becomes loaded and issues a 500 error to throttle the\n    clients. We wait Client.error_poll_min seconds between each attempt to back\n    off the frontend. Note that this does not affect any timing algorithm in the\n    client itself which is controlled by the Timer() class.\n\n    Args:\n      timeout: Timeout for retry.\n      **request_args: Args to the requests.request call.\n\n    Returns:\n      a tuple of duration, urllib.request.urlopen response.\n    \"\"\"\n    while True:\n      try:\n        now = time.time()\n        if not timeout:\n          timeout = config.CONFIG[\"Client.http_timeout\"]\n\n        result = requests.request(**request_args)\n        # By default requests doesn't raise on HTTP error codes.\n        result.raise_for_status()\n\n        # Requests does not always raise an exception when an incorrect response\n        # is received. This fixes that behaviour.\n        if not result.ok:\n          raise requests.RequestException(response=result)\n\n        return time.time() - now, result\n\n      # Catch any exceptions that dont have a code (e.g. socket.error).\n      except IOError as e:\n        self.consecutive_connection_errors += 1\n        # Request failed. If we connected successfully before we attempt a few\n        # connections before we determine that it really failed. This might\n        # happen if the front end is loaded and returns a few throttling 500\n        # messages.\n        if self.active_base_url is not None:\n          # Propagate 406 immediately without retrying, as 406 is a valid\n          # response that indicates a need for enrollment.\n          response = getattr(e, \"response\", None)\n          if getattr(response, \"status_code\", None) == 406:\n            raise\n\n          if self.consecutive_connection_errors >= self.retry_error_limit:\n            # We tried several times but this really did not work, just fail it.\n            logging.info(\n                \"Too many connection errors to %s, retrying another URL\",\n                self.active_base_url)\n            self.active_base_url = None\n            raise e\n\n          # Back off hard to allow the front end to recover.\n          logging.debug(\n              \"Unable to connect to frontend. Backing off %s seconds.\",\n              self.error_poll_min)\n          self.Wait(self.error_poll_min)\n\n        # We never previously connected, maybe the URL/proxy is wrong? Just fail\n        # right away to allow callers to try a different URL.\n        else:\n          raise e", "code_tokens": "def _RetryRequest ( self , timeout = None , * * request_args ) : while True : try : now = time . time ( ) if not timeout : timeout = config . CONFIG [ \"Client.http_timeout\" ] result = requests . request ( * * request_args ) # By default requests doesn't raise on HTTP error codes. result . raise_for_status ( ) # Requests does not always raise an exception when an incorrect response # is received. This fixes that behaviour. if not result . ok : raise requests . RequestException ( response = result ) return time . time ( ) - now , result # Catch any exceptions that dont have a code (e.g. socket.error). except IOError as e : self . consecutive_connection_errors += 1 # Request failed. If we connected successfully before we attempt a few # connections before we determine that it really failed. This might # happen if the front end is loaded and returns a few throttling 500 # messages. if self . active_base_url is not None : # Propagate 406 immediately without retrying, as 406 is a valid # response that indicates a need for enrollment. response = getattr ( e , \"response\" , None ) if getattr ( response , \"status_code\" , None ) == 406 : raise if self . consecutive_connection_errors >= self . retry_error_limit : # We tried several times but this really did not work, just fail it. logging . info ( \"Too many connection errors to %s, retrying another URL\" , self . active_base_url ) self . active_base_url = None raise e # Back off hard to allow the front end to recover. logging . debug ( \"Unable to connect to frontend. Backing off %s seconds.\" , self . error_poll_min ) self . Wait ( self . error_poll_min ) # We never previously connected, maybe the URL/proxy is wrong? Just fail # right away to allow callers to try a different URL. else : raise e", "docstring_tokens": "Retry the request a few times before we determine it failed .", "label": 1}, {"idx": "cosqa-train-18174", "doc": "how to rotate a list left in python 3", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 1}, {"idx": "cosqa-train-18175", "doc": "python iterator last value", "code": "def enum_mark_last(iterable, start=0):\n    \"\"\"\n    Returns a generator over iterable that tells whether the current item is the last one.\n    Usage:\n        >>> iterable = range(10)\n        >>> for index, is_last, item in enum_mark_last(iterable):\n        >>>     print(index, item, end='\\n' if is_last else ', ')\n    \"\"\"\n    it = iter(iterable)\n    count = start\n    try:\n        last = next(it)\n    except StopIteration:\n        return\n    for val in it:\n        yield count, False, last\n        last = val\n        count += 1\n    yield count, True, last", "code_tokens": "def enum_mark_last ( iterable , start = 0 ) : it = iter ( iterable ) count = start try : last = next ( it ) except StopIteration : return for val in it : yield count , False , last last = val count += 1 yield count , True , last", "docstring_tokens": "Returns a generator over iterable that tells whether the current item is the last one . Usage : >>> iterable = range ( 10 ) >>> for index is_last item in enum_mark_last ( iterable ) : >>> print ( index item end = \\ n if is_last else )", "label": 0}, {"idx": "cosqa-train-18176", "doc": "set limits on a function python 3", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 0}, {"idx": "cosqa-train-18177", "doc": "python psutil linux is consuming all the cpu", "code": "def memory_usage():\n    \"\"\"return memory usage of python process in MB\n\n    from\n    http://fa.bianp.net/blog/2013/different-ways-to-get-memory-consumption-or-lessons-learned-from-memory_profiler/\n    psutil is quicker\n\n    >>> isinstance(memory_usage(),float)\n    True\n\n    \"\"\"\n    try:\n        import psutil\n        import os\n    except ImportError:\n        return _memory_usage_ps()\n\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info()[0] / float(2 ** 20)\n    return mem", "code_tokens": "def memory_usage ( ) : try : import psutil import os except ImportError : return _memory_usage_ps ( ) process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) [ 0 ] / float ( 2 ** 20 ) return mem", "docstring_tokens": "return memory usage of python process in MB", "label": 1}, {"idx": "cosqa-train-18178", "doc": "dot product python loop", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 0}, {"idx": "cosqa-train-18179", "doc": "python delete files with wild card", "code": "def rmglob(pattern: str) -> None:\n    \"\"\"\n    Deletes all files whose filename matches the glob ``pattern`` (via\n    :func:`glob.glob`).\n    \"\"\"\n    for f in glob.glob(pattern):\n        os.remove(f)", "code_tokens": "def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "docstring_tokens": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .", "label": 1}, {"idx": "cosqa-train-18180", "doc": "how to check python timestamp older than 5 minutes", "code": "def duration_expired(start_time, duration_seconds):\n    \"\"\"\n    Return True if ``duration_seconds`` have expired since ``start_time``\n    \"\"\"\n\n    if duration_seconds is not None:\n        delta_seconds = datetime_delta_to_seconds(dt.datetime.now() - start_time)\n\n        if delta_seconds >= duration_seconds:\n            return True\n\n    return False", "code_tokens": "def duration_expired ( start_time , duration_seconds ) : if duration_seconds is not None : delta_seconds = datetime_delta_to_seconds ( dt . datetime . now ( ) - start_time ) if delta_seconds >= duration_seconds : return True return False", "docstring_tokens": "Return True if duration_seconds have expired since start_time", "label": 0}, {"idx": "cosqa-train-18181", "doc": "python fastest way to map", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-18182", "doc": "python invalid filename characters", "code": "def get_valid_filename(s):\n    \"\"\"\n    Shamelessly taken from Django.\n    https://github.com/django/django/blob/master/django/utils/text.py\n\n    Return the given string converted to a string that can be used for a clean\n    filename. Remove leading and trailing spaces; convert other spaces to\n    underscores; and remove anything that is not an alphanumeric, dash,\n    underscore, or dot.\n    >>> get_valid_filename(\"john's portrait in 2004.jpg\")\n    'johns_portrait_in_2004.jpg'\n    \"\"\"\n    s = str(s).strip().replace(' ', '_')\n    return re.sub(r'(?u)[^-\\w.]', '', s)", "code_tokens": "def get_valid_filename ( s ) : s = str ( s ) . strip ( ) . replace ( ' ' , '_' ) return re . sub ( r'(?u)[^-\\w.]' , '' , s )", "docstring_tokens": "Shamelessly taken from Django . https : // github . com / django / django / blob / master / django / utils / text . py", "label": 0}, {"idx": "cosqa-train-18183", "doc": "python submit form captcha requests", "code": "async def enter_captcha(self, url: str, sid: str) -> str:\n        \"\"\"\n        Override this method for processing captcha.\n\n        :param url: link to captcha image\n        :param sid: captcha id. I do not know why pass here but may be useful\n        :return captcha value\n        \"\"\"\n        raise VkCaptchaNeeded(url, sid)", "code_tokens": "async def enter_captcha ( self , url : str , sid : str ) -> str : raise VkCaptchaNeeded ( url , sid )", "docstring_tokens": "Override this method for processing captcha .", "label": 0}, {"idx": "cosqa-train-18184", "doc": "force string to date python", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 1}, {"idx": "cosqa-train-18185", "doc": "get first 100 rows python", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 0}, {"idx": "cosqa-train-18186", "doc": "python join list to string seperated by comma", "code": "def list_to_str(lst):\n    \"\"\"\n    Turn a list into a comma- and/or and-separated string.\n\n    Parameters\n    ----------\n    lst : :obj:`list`\n        A list of strings to join into a single string.\n\n    Returns\n    -------\n    str_ : :obj:`str`\n        A string with commas and/or ands separating th elements from ``lst``.\n\n    \"\"\"\n    if len(lst) == 1:\n        str_ = lst[0]\n    elif len(lst) == 2:\n        str_ = ' and '.join(lst)\n    elif len(lst) > 2:\n        str_ = ', '.join(lst[:-1])\n        str_ += ', and {0}'.format(lst[-1])\n    else:\n        raise ValueError('List of length 0 provided.')\n    return str_", "code_tokens": "def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "docstring_tokens": "Turn a list into a comma - and / or and - separated string .", "label": 0}, {"idx": "cosqa-train-18187", "doc": "python longest directed path", "code": "def dag_longest_path(graph, source, target):\n    \"\"\"\n    Finds the longest path in a dag between two nodes\n    \"\"\"\n    if source == target:\n        return [source]\n    allpaths = nx.all_simple_paths(graph, source, target)\n    longest_path = []\n    for l in allpaths:\n        if len(l) > len(longest_path):\n            longest_path = l\n    return longest_path", "code_tokens": "def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "docstring_tokens": "Finds the longest path in a dag between two nodes", "label": 1}, {"idx": "cosqa-train-18188", "doc": "how to remove columns from a data frame python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 1}, {"idx": "cosqa-train-18189", "doc": "python doesn't stop on keyboard interrupt", "code": "def wait_for_shutdown_signal(\n        self,\n        please_stop=False,  # ASSIGN SIGNAL TO STOP EARLY\n        allow_exit=False,  # ALLOW \"exit\" COMMAND ON CONSOLE TO ALSO STOP THE APP\n        wait_forever=True  # IGNORE CHILD THREADS, NEVER EXIT.  False => IF NO CHILD THREADS LEFT, THEN EXIT\n    ):\n        \"\"\"\n        FOR USE BY PROCESSES THAT NEVER DIE UNLESS EXTERNAL SHUTDOWN IS REQUESTED\n\n        CALLING THREAD WILL SLEEP UNTIL keyboard interrupt, OR please_stop, OR \"exit\"\n\n        :param please_stop:\n        :param allow_exit:\n        :param wait_forever:: Assume all needed threads have been launched. When done\n        :return:\n        \"\"\"\n        self_thread = Thread.current()\n        if self_thread != MAIN_THREAD or self_thread != self:\n            Log.error(\"Only the main thread can sleep forever (waiting for KeyboardInterrupt)\")\n\n        if isinstance(please_stop, Signal):\n            # MUTUAL SIGNALING MAKES THESE TWO EFFECTIVELY THE SAME SIGNAL\n            self.please_stop.on_go(please_stop.go)\n            please_stop.on_go(self.please_stop.go)\n        else:\n            please_stop = self.please_stop\n\n        if not wait_forever:\n            # TRIGGER SIGNAL WHEN ALL CHILDREN THEADS ARE DONE\n            with self_thread.child_lock:\n                pending = copy(self_thread.children)\n            children_done = AndSignals(please_stop, len(pending))\n            children_done.signal.on_go(self.please_stop.go)\n            for p in pending:\n                p.stopped.on_go(children_done.done)\n\n        try:\n            if allow_exit:\n                _wait_for_exit(please_stop)\n            else:\n                _wait_for_interrupt(please_stop)\n        except KeyboardInterrupt as _:\n            Log.alert(\"SIGINT Detected!  Stopping...\")\n        except SystemExit as _:\n            Log.alert(\"SIGTERM Detected!  Stopping...\")\n        finally:\n            self.stop()", "code_tokens": "def wait_for_shutdown_signal ( self , please_stop = False , # ASSIGN SIGNAL TO STOP EARLY allow_exit = False , # ALLOW \"exit\" COMMAND ON CONSOLE TO ALSO STOP THE APP wait_forever = True # IGNORE CHILD THREADS, NEVER EXIT.  False => IF NO CHILD THREADS LEFT, THEN EXIT ) : self_thread = Thread . current ( ) if self_thread != MAIN_THREAD or self_thread != self : Log . error ( \"Only the main thread can sleep forever (waiting for KeyboardInterrupt)\" ) if isinstance ( please_stop , Signal ) : # MUTUAL SIGNALING MAKES THESE TWO EFFECTIVELY THE SAME SIGNAL self . please_stop . on_go ( please_stop . go ) please_stop . on_go ( self . please_stop . go ) else : please_stop = self . please_stop if not wait_forever : # TRIGGER SIGNAL WHEN ALL CHILDREN THEADS ARE DONE with self_thread . child_lock : pending = copy ( self_thread . children ) children_done = AndSignals ( please_stop , len ( pending ) ) children_done . signal . on_go ( self . please_stop . go ) for p in pending : p . stopped . on_go ( children_done . done ) try : if allow_exit : _wait_for_exit ( please_stop ) else : _wait_for_interrupt ( please_stop ) except KeyboardInterrupt as _ : Log . alert ( \"SIGINT Detected!  Stopping...\" ) except SystemExit as _ : Log . alert ( \"SIGTERM Detected!  Stopping...\" ) finally : self . stop ( )", "docstring_tokens": "FOR USE BY PROCESSES THAT NEVER DIE UNLESS EXTERNAL SHUTDOWN IS REQUESTED", "label": 1}, {"idx": "cosqa-train-18190", "doc": "python2 replace text in string", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 1}, {"idx": "cosqa-train-18191", "doc": "python read protobuf from bytes", "code": "def decode(self, bytes, raw=False):\n        \"\"\"decode(bytearray, raw=False) -> value\n\n        Decodes the given bytearray according to this PrimitiveType\n        definition.\n\n        NOTE: The parameter ``raw`` is present to adhere to the\n        ``decode()`` inteface, but has no effect for PrimitiveType\n        definitions.\n        \"\"\"\n        return struct.unpack(self.format, buffer(bytes))[0]", "code_tokens": "def decode ( self , bytes , raw = False ) : return struct . unpack ( self . format , buffer ( bytes ) ) [ 0 ]", "docstring_tokens": "decode ( bytearray raw = False ) - > value", "label": 0}, {"idx": "cosqa-train-18192", "doc": "how to grab the last value of an index in python", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-18193", "doc": "checking if the row value is the same with the row value above it in python", "code": "def non_increasing(values):\n    \"\"\"True if values are not increasing.\"\"\"\n    return all(x >= y for x, y in zip(values, values[1:]))", "code_tokens": "def non_increasing ( values ) : return all ( x >= y for x , y in zip ( values , values [ 1 : ] ) )", "docstring_tokens": "True if values are not increasing .", "label": 0}, {"idx": "cosqa-train-18194", "doc": "python string value of a json object", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 1}, {"idx": "cosqa-train-18195", "doc": "python how to trim trailing zeroes", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 1}, {"idx": "cosqa-train-18196", "doc": "list python column names", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 0}, {"idx": "cosqa-train-18197", "doc": "python gensim dictionary token2id for", "code": "def strids2ids(tokens: Iterable[str]) -> List[int]:\n    \"\"\"\n    Returns sequence of integer ids given a sequence of string ids.\n\n    :param tokens: List of integer tokens.\n    :return: List of word ids.\n    \"\"\"\n    return list(map(int, tokens))", "code_tokens": "def strids2ids ( tokens : Iterable [ str ] ) -> List [ int ] : return list ( map ( int , tokens ) )", "docstring_tokens": "Returns sequence of integer ids given a sequence of string ids .", "label": 1}, {"idx": "cosqa-train-18198", "doc": "how to return the top values in dictionary python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 1}, {"idx": "cosqa-train-18199", "doc": "validating an input is an integer python", "code": "def clean_int(x) -> int:\n    \"\"\"\n    Returns its parameter as an integer, or raises\n    ``django.forms.ValidationError``.\n    \"\"\"\n    try:\n        return int(x)\n    except ValueError:\n        raise forms.ValidationError(\n            \"Cannot convert to integer: {}\".format(repr(x)))", "code_tokens": "def clean_int ( x ) -> int : try : return int ( x ) except ValueError : raise forms . ValidationError ( \"Cannot convert to integer: {}\" . format ( repr ( x ) ) )", "docstring_tokens": "Returns its parameter as an integer or raises django . forms . ValidationError .", "label": 1}, {"idx": "cosqa-train-18200", "doc": "how to get time zone python", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-18201", "doc": "python string replace all", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 1}, {"idx": "cosqa-train-18202", "doc": "how to check if a line in a file has something in it python", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 0}, {"idx": "cosqa-train-18203", "doc": "cast list of strings to int python", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-18204", "doc": "python return largest even number in the arrary", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 1}, {"idx": "cosqa-train-18205", "doc": "python tree default dict", "code": "def to_dict(self):\n        \"\"\"\n\n        Returns: the tree item as a dictionary\n\n        \"\"\"\n        if self.childCount() > 0:\n            value = {}\n            for index in range(self.childCount()):\n                value.update(self.child(index).to_dict())\n        else:\n            value = self.value\n\n        return {self.name: value}", "code_tokens": "def to_dict ( self ) : if self . childCount ( ) > 0 : value = { } for index in range ( self . childCount ( ) ) : value . update ( self . child ( index ) . to_dict ( ) ) else : value = self . value return { self . name : value }", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-18206", "doc": "found the first occurrence of target string from strings python", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 0}, {"idx": "cosqa-train-18207", "doc": "python check a binary tree", "code": "def same_network(atree, btree) -> bool:\n    \"\"\"True if given trees share the same structure of powernodes,\n    independently of (power)node names,\n    and same edge topology between (power)nodes.\n\n    \"\"\"\n    return same_hierarchy(atree, btree) and same_topology(atree, btree)", "code_tokens": "def same_network ( atree , btree ) -> bool : return same_hierarchy ( atree , btree ) and same_topology ( atree , btree )", "docstring_tokens": "True if given trees share the same structure of powernodes independently of ( power ) node names and same edge topology between ( power ) nodes .", "label": 0}, {"idx": "cosqa-train-18208", "doc": "python iterator for dict", "code": "def iterate_items(dictish):\n    \"\"\" Return a consistent (key, value) iterable on dict-like objects,\n    including lists of tuple pairs.\n\n    Example:\n\n        >>> list(iterate_items({'a': 1}))\n        [('a', 1)]\n        >>> list(iterate_items([('a', 1), ('b', 2)]))\n        [('a', 1), ('b', 2)]\n    \"\"\"\n    if hasattr(dictish, 'iteritems'):\n        return dictish.iteritems()\n    if hasattr(dictish, 'items'):\n        return dictish.items()\n    return dictish", "code_tokens": "def iterate_items ( dictish ) : if hasattr ( dictish , 'iteritems' ) : return dictish . iteritems ( ) if hasattr ( dictish , 'items' ) : return dictish . items ( ) return dictish", "docstring_tokens": "Return a consistent ( key value ) iterable on dict - like objects including lists of tuple pairs .", "label": 0}, {"idx": "cosqa-train-18209", "doc": "python most frequent in a list", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 1}, {"idx": "cosqa-train-18210", "doc": "python numpy make empty array", "code": "def _create_empty_array(self, frames, always_2d, dtype):\n        \"\"\"Create an empty array with appropriate shape.\"\"\"\n        import numpy as np\n        if always_2d or self.channels > 1:\n            shape = frames, self.channels\n        else:\n            shape = frames,\n        return np.empty(shape, dtype, order='C')", "code_tokens": "def _create_empty_array ( self , frames , always_2d , dtype ) : import numpy as np if always_2d or self . channels > 1 : shape = frames , self . channels else : shape = frames , return np . empty ( shape , dtype , order = 'C' )", "docstring_tokens": "Create an empty array with appropriate shape .", "label": 1}, {"idx": "cosqa-train-18211", "doc": "python datetime format string with millisecond", "code": "def python_utc_datetime_to_sqlite_strftime_string(\n        value: datetime.datetime) -> str:\n    \"\"\"\n    Converts a Python datetime to a string literal compatible with SQLite,\n    including the millisecond field.\n    \"\"\"\n    millisec_str = str(round(value.microsecond / 1000)).zfill(3)\n    return value.strftime(\"%Y-%m-%d %H:%M:%S\") + \".\" + millisec_str", "code_tokens": "def python_utc_datetime_to_sqlite_strftime_string ( value : datetime . datetime ) -> str : millisec_str = str ( round ( value . microsecond / 1000 ) ) . zfill ( 3 ) return value . strftime ( \"%Y-%m-%d %H:%M:%S\" ) + \".\" + millisec_str", "docstring_tokens": "Converts a Python datetime to a string literal compatible with SQLite including the millisecond field .", "label": 0}, {"idx": "cosqa-train-18212", "doc": "how to only print the leaf nodes in a tree python", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-18213", "doc": "python 3 change string to a binary string", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 1}, {"idx": "cosqa-train-18214", "doc": "return year from date python", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 1}, {"idx": "cosqa-train-18215", "doc": "python remove postfix string", "code": "def drop_post(self):\n        \"\"\"Remove .postXXXX postfix from version\"\"\"\n        post_index = self.version.find('.post')\n        if post_index >= 0:\n            self.version = self.version[:post_index]", "code_tokens": "def drop_post ( self ) : post_index = self . version . find ( '.post' ) if post_index >= 0 : self . version = self . version [ : post_index ]", "docstring_tokens": "Remove . postXXXX postfix from version", "label": 1}, {"idx": "cosqa-train-18216", "doc": "raise a umber to a power function python", "code": "def safe_pow(base, exp):\n    \"\"\"safe version of pow\"\"\"\n    if exp > MAX_EXPONENT:\n        raise RuntimeError(\"Invalid exponent, max exponent is {}\".format(MAX_EXPONENT))\n    return base ** exp", "code_tokens": "def safe_pow ( base , exp ) : if exp > MAX_EXPONENT : raise RuntimeError ( \"Invalid exponent, max exponent is {}\" . format ( MAX_EXPONENT ) ) return base ** exp", "docstring_tokens": "safe version of pow", "label": 0}, {"idx": "cosqa-train-18217", "doc": "python how to keep leading zeroes", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 0}, {"idx": "cosqa-train-18218", "doc": "python how to ensure function return type", "code": "def callable_validator(v: Any) -> AnyCallable:\n    \"\"\"\n    Perform a simple check if the value is callable.\n\n    Note: complete matching of argument type hints and return types is not performed\n    \"\"\"\n    if callable(v):\n        return v\n\n    raise errors.CallableError(value=v)", "code_tokens": "def callable_validator ( v : Any ) -> AnyCallable : if callable ( v ) : return v raise errors . CallableError ( value = v )", "docstring_tokens": "Perform a simple check if the value is callable .", "label": 1}, {"idx": "cosqa-train-18219", "doc": "python structured array to tensorflow tensor", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 0}, {"idx": "cosqa-train-18220", "doc": "python isfinite for all columns", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 1}, {"idx": "cosqa-train-18221", "doc": "python element wise product", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 0}, {"idx": "cosqa-train-18222", "doc": "check if date is valid python", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 1}, {"idx": "cosqa-train-18223", "doc": "create folder in s3 bucket python", "code": "def mkdir(self, target_folder):\n        \"\"\"\n        Create a folder on S3.\n\n        Examples\n        --------\n            >>> s3utils.mkdir(\"path/to/my_folder\")\n            Making directory: path/to/my_folder\n        \"\"\"\n        self.printv(\"Making directory: %s\" % target_folder)\n        self.k.key = re.sub(r\"^/|/$\", \"\", target_folder) + \"/\"\n        self.k.set_contents_from_string('')\n        self.k.close()", "code_tokens": "def mkdir ( self , target_folder ) : self . printv ( \"Making directory: %s\" % target_folder ) self . k . key = re . sub ( r\"^/|/$\" , \"\" , target_folder ) + \"/\" self . k . set_contents_from_string ( '' ) self . k . close ( )", "docstring_tokens": "Create a folder on S3 .", "label": 0}, {"idx": "cosqa-train-18224", "doc": "median of array in python", "code": "def fast_median(a):\n    \"\"\"Fast median operation for masked array using 50th-percentile\n    \"\"\"\n    a = checkma(a)\n    #return scoreatpercentile(a.compressed(), 50)\n    if a.count() > 0:\n        out = np.percentile(a.compressed(), 50)\n    else:\n        out = np.ma.masked\n    return out", "code_tokens": "def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out", "docstring_tokens": "Fast median operation for masked array using 50th - percentile", "label": 0}, {"idx": "cosqa-train-18225", "doc": "python how to verify if a key exist", "code": "def check_key(self, key: str) -> bool:\n        \"\"\"\n        Checks if key exists in datastore. True if yes, False if no.\n\n        :param: SHA512 hash key\n\n        :return: whether or key not exists in datastore\n        \"\"\"\n        keys = self.get_keys()\n        return key in keys", "code_tokens": "def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "docstring_tokens": "Checks if key exists in datastore . True if yes False if no .", "label": 1}, {"idx": "cosqa-train-18226", "doc": "python how to remove from a certain word onward with prefix", "code": "def remove_prefix(text, prefix):\n\t\"\"\"\n\tRemove the prefix from the text if it exists.\n\n\t>>> remove_prefix('underwhelming performance', 'underwhelming ')\n\t'performance'\n\n\t>>> remove_prefix('something special', 'sample')\n\t'something special'\n\t\"\"\"\n\tnull, prefix, rest = text.rpartition(prefix)\n\treturn rest", "code_tokens": "def remove_prefix ( text , prefix ) : null , prefix , rest = text . rpartition ( prefix ) return rest", "docstring_tokens": "Remove the prefix from the text if it exists .", "label": 0}, {"idx": "cosqa-train-18227", "doc": "python get computer uuid", "code": "def local_machine_uuid():\n    \"\"\"Return local machine unique identifier.\n\n    >>> uuid = local_machine_uuid()\n\n    \"\"\"\n\n    result = subprocess.check_output(\n        'hal-get-property --udi '\n        '/org/freedesktop/Hal/devices/computer '\n        '--key system.hardware.uuid'.split()\n        ).strip()\n\n    return uuid.UUID(hex=result)", "code_tokens": "def local_machine_uuid ( ) : result = subprocess . check_output ( 'hal-get-property --udi ' '/org/freedesktop/Hal/devices/computer ' '--key system.hardware.uuid' . split ( ) ) . strip ( ) return uuid . UUID ( hex = result )", "docstring_tokens": "Return local machine unique identifier .", "label": 0}, {"idx": "cosqa-train-18228", "doc": "in python how to check if my path given is that of a file or is a directory", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-18229", "doc": "sqlite change int to string python", "code": "def process_literal_param(self, value: Optional[List[int]],\n                              dialect: Dialect) -> str:\n        \"\"\"Convert things on the way from Python to the database.\"\"\"\n        retval = self._intlist_to_dbstr(value)\n        return retval", "code_tokens": "def process_literal_param ( self , value : Optional [ List [ int ] ] , dialect : Dialect ) -> str : retval = self . _intlist_to_dbstr ( value ) return retval", "docstring_tokens": "Convert things on the way from Python to the database .", "label": 0}, {"idx": "cosqa-train-18230", "doc": "python get the first file in a folder", "code": "def find_first(pattern: str, path: str) -> str:\n    \"\"\"\n    Finds first file in ``path`` whose filename matches ``pattern`` (via\n    :func:`fnmatch.fnmatch`), or raises :exc:`IndexError`.\n    \"\"\"\n    try:\n        return find(pattern, path)[0]\n    except IndexError:\n        log.critical('''Couldn't find \"{}\" in \"{}\"''', pattern, path)\n        raise", "code_tokens": "def find_first ( pattern : str , path : str ) -> str : try : return find ( pattern , path ) [ 0 ] except IndexError : log . critical ( '''Couldn't find \"{}\" in \"{}\"''' , pattern , path ) raise", "docstring_tokens": "Finds first file in path whose filename matches pattern ( via : func : fnmatch . fnmatch ) or raises : exc : IndexError .", "label": 0}, {"idx": "cosqa-train-18231", "doc": "python set contains multiple items", "code": "def issuperset(self, items):\n        \"\"\"Return whether this collection contains all items.\n\n        >>> Unique(['spam', 'eggs']).issuperset(['spam', 'spam', 'spam'])\n        True\n        \"\"\"\n        return all(_compat.map(self._seen.__contains__, items))", "code_tokens": "def issuperset ( self , items ) : return all ( _compat . map ( self . _seen . __contains__ , items ) )", "docstring_tokens": "Return whether this collection contains all items .", "label": 1}, {"idx": "cosqa-train-18232", "doc": "check if a set contains one value python", "code": "def is_any_type_set(sett: Set[Type]) -> bool:\n    \"\"\"\n    Helper method to check if a set of types is the {AnyObject} singleton\n\n    :param sett:\n    :return:\n    \"\"\"\n    return len(sett) == 1 and is_any_type(min(sett))", "code_tokens": "def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )", "docstring_tokens": "Helper method to check if a set of types is the { AnyObject } singleton", "label": 0}, {"idx": "cosqa-train-18233", "doc": "python pprint string according to length", "code": "def _short_repr(obj):\n  \"\"\"Helper function returns a truncated repr() of an object.\"\"\"\n  stringified = pprint.saferepr(obj)\n  if len(stringified) > 200:\n    return '%s... (%d bytes)' % (stringified[:200], len(stringified))\n  return stringified", "code_tokens": "def _short_repr ( obj ) : stringified = pprint . saferepr ( obj ) if len ( stringified ) > 200 : return '%s... (%d bytes)' % ( stringified [ : 200 ] , len ( stringified ) ) return stringified", "docstring_tokens": "Helper function returns a truncated repr () of an object .", "label": 1}, {"idx": "cosqa-train-18234", "doc": "delete files in python using glob", "code": "def rmglob(pattern: str) -> None:\n    \"\"\"\n    Deletes all files whose filename matches the glob ``pattern`` (via\n    :func:`glob.glob`).\n    \"\"\"\n    for f in glob.glob(pattern):\n        os.remove(f)", "code_tokens": "def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "docstring_tokens": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .", "label": 1}, {"idx": "cosqa-train-18235", "doc": "python array of bytes from integers", "code": "def convert_bytes_to_ints(in_bytes, num):\n    \"\"\"Convert a byte array into an integer array. The number of bytes forming an integer\n    is defined by num\n\n    :param in_bytes: the input bytes\n    :param num: the number of bytes per int\n    :return the integer array\"\"\"\n    dt = numpy.dtype('>i' + str(num))\n    return numpy.frombuffer(in_bytes, dt)", "code_tokens": "def convert_bytes_to_ints ( in_bytes , num ) : dt = numpy . dtype ( '>i' + str ( num ) ) return numpy . frombuffer ( in_bytes , dt )", "docstring_tokens": "Convert a byte array into an integer array . The number of bytes forming an integer is defined by num", "label": 0}, {"idx": "cosqa-train-18236", "doc": "python create empty array without numpy", "code": "def _create_empty_array(self, frames, always_2d, dtype):\n        \"\"\"Create an empty array with appropriate shape.\"\"\"\n        import numpy as np\n        if always_2d or self.channels > 1:\n            shape = frames, self.channels\n        else:\n            shape = frames,\n        return np.empty(shape, dtype, order='C')", "code_tokens": "def _create_empty_array ( self , frames , always_2d , dtype ) : import numpy as np if always_2d or self . channels > 1 : shape = frames , self . channels else : shape = frames , return np . empty ( shape , dtype , order = 'C' )", "docstring_tokens": "Create an empty array with appropriate shape .", "label": 1}, {"idx": "cosqa-train-18237", "doc": "how to combine sets in python", "code": "def union(cls, *sets):\n        \"\"\"\n        >>> from utool.util_set import *  # NOQA\n        \"\"\"\n        import utool as ut\n        lists_ = ut.flatten([list(s) for s in sets])\n        return cls(lists_)", "code_tokens": "def union ( cls , * sets ) : import utool as ut lists_ = ut . flatten ( [ list ( s ) for s in sets ] ) return cls ( lists_ )", "docstring_tokens": ">>> from utool . util_set import * # NOQA", "label": 0}, {"idx": "cosqa-train-18238", "doc": "python clean up temporary files", "code": "def _cleanup(path: str) -> None:\n    \"\"\"Cleanup temporary directory.\"\"\"\n    if os.path.isdir(path):\n        shutil.rmtree(path)", "code_tokens": "def _cleanup ( path : str ) -> None : if os . path . isdir ( path ) : shutil . rmtree ( path )", "docstring_tokens": "Cleanup temporary directory .", "label": 0}, {"idx": "cosqa-train-18239", "doc": "check if column has null value python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 0}, {"idx": "cosqa-train-18240", "doc": "python matrix dot multiplication", "code": "def __rmatmul__(self, other):\n        \"\"\"\n        Matrix multiplication using binary `@` operator in Python>=3.5.\n        \"\"\"\n        return self.T.dot(np.transpose(other)).T", "code_tokens": "def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T", "docstring_tokens": "Matrix multiplication using binary", "label": 1}, {"idx": "cosqa-train-18241", "doc": "python get docker container name", "code": "def running_containers(name_filter: str) -> List[str]:\n    \"\"\"\n    :raises docker.exceptions.APIError\n    \"\"\"\n    return [container.short_id for container in\n            docker_client.containers.list(filters={\"name\": name_filter})]", "code_tokens": "def running_containers ( name_filter : str ) -> List [ str ] : return [ container . short_id for container in docker_client . containers . list ( filters = { \"name\" : name_filter } ) ]", "docstring_tokens": ": raises docker . exceptions . APIError", "label": 0}, {"idx": "cosqa-train-18242", "doc": "python iterator file lines", "code": "def file_lines(bblfile:str) -> iter:\n    \"\"\"Yield lines found in given file\"\"\"\n    with open(bblfile) as fd:\n        yield from (line.rstrip() for line in fd if line.rstrip())", "code_tokens": "def file_lines ( bblfile : str ) -> iter : with open ( bblfile ) as fd : yield from ( line . rstrip ( ) for line in fd if line . rstrip ( ) )", "docstring_tokens": "Yield lines found in given file", "label": 0}, {"idx": "cosqa-train-18243", "doc": "how to check column value is null python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-18244", "doc": "python finding uppercase strings", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 0}, {"idx": "cosqa-train-18245", "doc": "pad zeros python string", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 1}, {"idx": "cosqa-train-18246", "doc": "python argparse example call function", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 1}, {"idx": "cosqa-train-18247", "doc": "how to capitalize the all letter in python", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 1}, {"idx": "cosqa-train-18248", "doc": "check exact substring python", "code": "def valid_substitution(strlen, index):\n    \"\"\"\n    skip performing substitutions that are outside the bounds of the string\n    \"\"\"\n    values = index[0]\n    return all([strlen > i for i in values])", "code_tokens": "def valid_substitution ( strlen , index ) : values = index [ 0 ] return all ( [ strlen > i for i in values ] )", "docstring_tokens": "skip performing substitutions that are outside the bounds of the string", "label": 0}, {"idx": "cosqa-train-18249", "doc": "python accuracy recall f1", "code": "def recall_score(y_true, y_pred, average='micro', suffix=False):\n    \"\"\"Compute the recall.\n\n    The recall is the ratio ``tp / (tp + fn)`` where ``tp`` is the number of\n    true positives and ``fn`` the number of false negatives. The recall is\n    intuitively the ability of the classifier to find all the positive samples.\n\n    The best value is 1 and the worst value is 0.\n\n    Args:\n        y_true : 2d array. Ground truth (correct) target values.\n        y_pred : 2d array. Estimated targets as returned by a tagger.\n\n    Returns:\n        score : float.\n\n    Example:\n        >>> from seqeval.metrics import recall_score\n        >>> y_true = [['O', 'O', 'O', 'B-MISC', 'I-MISC', 'I-MISC', 'O'], ['B-PER', 'I-PER', 'O']]\n        >>> y_pred = [['O', 'O', 'B-MISC', 'I-MISC', 'I-MISC', 'I-MISC', 'O'], ['B-PER', 'I-PER', 'O']]\n        >>> recall_score(y_true, y_pred)\n        0.50\n    \"\"\"\n    true_entities = set(get_entities(y_true, suffix))\n    pred_entities = set(get_entities(y_pred, suffix))\n\n    nb_correct = len(true_entities & pred_entities)\n    nb_true = len(true_entities)\n\n    score = nb_correct / nb_true if nb_true > 0 else 0\n\n    return score", "code_tokens": "def recall_score ( y_true , y_pred , average = 'micro' , suffix = False ) : true_entities = set ( get_entities ( y_true , suffix ) ) pred_entities = set ( get_entities ( y_pred , suffix ) ) nb_correct = len ( true_entities & pred_entities ) nb_true = len ( true_entities ) score = nb_correct / nb_true if nb_true > 0 else 0 return score", "docstring_tokens": "Compute the recall .", "label": 0}, {"idx": "cosqa-train-18250", "doc": "argparse python namespace object has no attribute 'help'", "code": "def default_parser() -> argparse.ArgumentParser:\n    \"\"\"Create a parser for CLI arguments and options.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog=CONSOLE_SCRIPT,\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n    )\n    build_parser(parser)\n    return parser", "code_tokens": "def default_parser ( ) -> argparse . ArgumentParser : parser = argparse . ArgumentParser ( prog = CONSOLE_SCRIPT , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) build_parser ( parser ) return parser", "docstring_tokens": "Create a parser for CLI arguments and options .", "label": 1}, {"idx": "cosqa-train-18251", "doc": "extract bits of large numbers python", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 1}, {"idx": "cosqa-train-18252", "doc": "cast str to integer python", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 0}, {"idx": "cosqa-train-18253", "doc": "bit wise & in python", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-18254", "doc": "python callable arg must be a list", "code": "def callable_validator(v: Any) -> AnyCallable:\n    \"\"\"\n    Perform a simple check if the value is callable.\n\n    Note: complete matching of argument type hints and return types is not performed\n    \"\"\"\n    if callable(v):\n        return v\n\n    raise errors.CallableError(value=v)", "code_tokens": "def callable_validator ( v : Any ) -> AnyCallable : if callable ( v ) : return v raise errors . CallableError ( value = v )", "docstring_tokens": "Perform a simple check if the value is callable .", "label": 1}, {"idx": "cosqa-train-18255", "doc": "vs code python conda not found", "code": "def _find_conda():\n    \"\"\"Find the conda executable robustly across conda versions.\n\n    Returns\n    -------\n    conda : str\n        Path to the conda executable.\n\n    Raises\n    ------\n    IOError\n        If the executable cannot be found in either the CONDA_EXE environment\n        variable or in the PATH.\n\n    Notes\n    -----\n    In POSIX platforms in conda >= 4.4, conda can be set up as a bash function\n    rather than an executable. (This is to enable the syntax\n    ``conda activate env-name``.) In this case, the environment variable\n    ``CONDA_EXE`` contains the path to the conda executable. In other cases,\n    we use standard search for the appropriate name in the PATH.\n\n    See https://github.com/airspeed-velocity/asv/issues/645 for more details.\n    \"\"\"\n    if 'CONDA_EXE' in os.environ:\n        conda = os.environ['CONDA_EXE']\n    else:\n        conda = util.which('conda')\n    return conda", "code_tokens": "def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda", "docstring_tokens": "Find the conda executable robustly across conda versions .", "label": 1}, {"idx": "cosqa-train-18256", "doc": "inverse key and value in dictionary in python", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 1}, {"idx": "cosqa-train-18257", "doc": "identify type of python column", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 0}, {"idx": "cosqa-train-18258", "doc": "to flatten a list consisting of individual values as well as list of lists in python", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 0}, {"idx": "cosqa-train-18259", "doc": "how to truncate decimals python's", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 0}, {"idx": "cosqa-train-18260", "doc": "call function with exit in python", "code": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)", "code_tokens": "def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "docstring_tokens": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting", "label": 1}, {"idx": "cosqa-train-18261", "doc": "python get cpu cores in a cluster", "code": "def cpu_count() -> int:\n    \"\"\"Returns the number of processors on this machine.\"\"\"\n    if multiprocessing is None:\n        return 1\n    try:\n        return multiprocessing.cpu_count()\n    except NotImplementedError:\n        pass\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_CONF\")\n    except (AttributeError, ValueError):\n        pass\n    gen_log.error(\"Could not detect number of processors; assuming 1\")\n    return 1", "code_tokens": "def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( \"SC_NPROCESSORS_CONF\" ) except ( AttributeError , ValueError ) : pass gen_log . error ( \"Could not detect number of processors; assuming 1\" ) return 1", "docstring_tokens": "Returns the number of processors on this machine .", "label": 1}, {"idx": "cosqa-train-18262", "doc": "flatten list of lists python into list", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 0}, {"idx": "cosqa-train-18263", "doc": "function in python to generate random numbers for a given average", "code": "def _gauss(mean: int, sigma: int) -> int:\n        \"\"\"\n        Creates a variation from a base value\n\n        Args:\n            mean: base value\n            sigma: gaussian sigma\n\n        Returns: random value\n\n        \"\"\"\n        return int(random.gauss(mean, sigma))", "code_tokens": "def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "docstring_tokens": "Creates a variation from a base value", "label": 0}, {"idx": "cosqa-train-18264", "doc": "add marks to string in python", "code": "def add_mark_at(string, index, mark):\n    \"\"\"\n    Add mark to the index-th character of the given string. Return the new string after applying change.\n    Notice: index > 0\n    \"\"\"\n    if index == -1:\n        return string\n    # Python can handle the case which index is out of range of given string\n    return string[:index] + add_mark_char(string[index], mark) + string[index+1:]", "code_tokens": "def add_mark_at ( string , index , mark ) : if index == - 1 : return string # Python can handle the case which index is out of range of given string return string [ : index ] + add_mark_char ( string [ index ] , mark ) + string [ index + 1 : ]", "docstring_tokens": "Add mark to the index - th character of the given string . Return the new string after applying change . Notice : index > 0", "label": 0}, {"idx": "cosqa-train-18265", "doc": "python take n elements from iterator", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 1}, {"idx": "cosqa-train-18266", "doc": "python how to check if file older than", "code": "def is_up_to_date(outfile, basedatetime):\n        # type: (AnyStr, datetime) -> bool\n        \"\"\"Return true if outfile exists and is no older than base datetime.\"\"\"\n        if os.path.exists(outfile):\n            if os.path.getmtime(outfile) >= basedatetime:\n                return True\n        return False", "code_tokens": "def is_up_to_date ( outfile , basedatetime ) : # type: (AnyStr, datetime) -> bool if os . path . exists ( outfile ) : if os . path . getmtime ( outfile ) >= basedatetime : return True return False", "docstring_tokens": "Return true if outfile exists and is no older than base datetime .", "label": 1}, {"idx": "cosqa-train-18267", "doc": "python check if whitespace", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 0}, {"idx": "cosqa-train-18268", "doc": "python data frame show index number of the max value of the vector", "code": "def first_location_of_maximum(x):\n    \"\"\"\n    Returns the first location of the maximum value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    if not isinstance(x, (np.ndarray, pd.Series)):\n        x = np.asarray(x)\n    return np.argmax(x) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def first_location_of_maximum ( x ) : if not isinstance ( x , ( np . ndarray , pd . Series ) ) : x = np . asarray ( x ) return np . argmax ( x ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the first location of the maximum value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-18269", "doc": "python detect key press do not block", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 1}, {"idx": "cosqa-train-18270", "doc": "python get month last day", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 1}, {"idx": "cosqa-train-18271", "doc": "how to permanently change a string from upper to lower case in python", "code": "def camel_to_snake_case(string):\n    \"\"\"Converts 'string' presented in camel case to snake case.\n\n    e.g.: CamelCase => snake_case\n    \"\"\"\n    s = _1.sub(r'\\1_\\2', string)\n    return _2.sub(r'\\1_\\2', s).lower()", "code_tokens": "def camel_to_snake_case ( string ) : s = _1 . sub ( r'\\1_\\2' , string ) return _2 . sub ( r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Converts string presented in camel case to snake case .", "label": 1}, {"idx": "cosqa-train-18272", "doc": "how to get from datetime object about current time zone in python", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-18273", "doc": "elasticsearch bulk python faster", "code": "def bulk_load_docs(es, docs):\n    \"\"\"Bulk load docs\n\n    Args:\n        es: elasticsearch handle\n        docs: Iterator of doc objects - includes index_name\n    \"\"\"\n\n    chunk_size = 200\n\n    try:\n        results = elasticsearch.helpers.bulk(es, docs, chunk_size=chunk_size)\n        log.debug(f\"Elasticsearch documents loaded: {results[0]}\")\n\n        # elasticsearch.helpers.parallel_bulk(es, terms, chunk_size=chunk_size, thread_count=4)\n        if len(results[1]) > 0:\n            log.error(\"Bulk load errors {}\".format(results))\n    except elasticsearch.ElasticsearchException as e:\n        log.error(\"Indexing error: {}\\n\".format(e))", "code_tokens": "def bulk_load_docs ( es , docs ) : chunk_size = 200 try : results = elasticsearch . helpers . bulk ( es , docs , chunk_size = chunk_size ) log . debug ( f\"Elasticsearch documents loaded: {results[0]}\" ) # elasticsearch.helpers.parallel_bulk(es, terms, chunk_size=chunk_size, thread_count=4) if len ( results [ 1 ] ) > 0 : log . error ( \"Bulk load errors {}\" . format ( results ) ) except elasticsearch . ElasticsearchException as e : log . error ( \"Indexing error: {}\\n\" . format ( e ) )", "docstring_tokens": "Bulk load docs", "label": 0}, {"idx": "cosqa-train-18274", "doc": "replace none with blank python dict", "code": "def inject_nulls(data: Mapping, field_names) -> dict:\n    \"\"\"Insert None as value for missing fields.\"\"\"\n\n    record = dict()\n\n    for field in field_names:\n        record[field] = data.get(field, None)\n\n    return record", "code_tokens": "def inject_nulls ( data : Mapping , field_names ) -> dict : record = dict ( ) for field in field_names : record [ field ] = data . get ( field , None ) return record", "docstring_tokens": "Insert None as value for missing fields .", "label": 1}, {"idx": "cosqa-train-18275", "doc": "python checking string for whitespace", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 1}, {"idx": "cosqa-train-18276", "doc": "python string to javascript string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 0}, {"idx": "cosqa-train-18277", "doc": "python dont imeditalte terminate", "code": "def do_quit(self, _: argparse.Namespace) -> bool:\n        \"\"\"Exit this application\"\"\"\n        self._should_quit = True\n        return self._STOP_AND_EXIT", "code_tokens": "def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "docstring_tokens": "Exit this application", "label": 0}, {"idx": "cosqa-train-18278", "doc": "how to get all columns names in python", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 1}, {"idx": "cosqa-train-18279", "doc": "greater than or equal sign python", "code": "def SGT(self, a, b):\n        \"\"\"Signed greater-than comparison\"\"\"\n        # http://gavwood.com/paper.pdf\n        s0, s1 = to_signed(a), to_signed(b)\n        return Operators.ITEBV(256, s0 > s1, 1, 0)", "code_tokens": "def SGT ( self , a , b ) : # http://gavwood.com/paper.pdf s0 , s1 = to_signed ( a ) , to_signed ( b ) return Operators . ITEBV ( 256 , s0 > s1 , 1 , 0 )", "docstring_tokens": "Signed greater - than comparison", "label": 0}, {"idx": "cosqa-train-18280", "doc": "how to get top 5 values from dictionaty in python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 1}, {"idx": "cosqa-train-18281", "doc": "python get size of the matrix", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 1}, {"idx": "cosqa-train-18282", "doc": "determine if a number is a prime factor python", "code": "def is_prime(n):\n    \"\"\"\n    Check if n is a prime number\n    \"\"\"\n    if n % 2 == 0 and n > 2:\n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))", "code_tokens": "def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "docstring_tokens": "Check if n is a prime number", "label": 1}, {"idx": "cosqa-train-18283", "doc": "python check not existing key", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 0}, {"idx": "cosqa-train-18284", "doc": "how to test if a set is a subset of another set python", "code": "def issubset(self, other):\n        \"\"\"\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        \"\"\"\n        if len(self) > len(other):  # Fast check for obvious cases\n            return False\n        return all(item in other for item in self)", "code_tokens": "def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "docstring_tokens": "Report whether another set contains this set .", "label": 0}, {"idx": "cosqa-train-18285", "doc": "python third friday date", "code": "def after_third_friday(day=None):\n    \"\"\" check if day is after month's 3rd friday \"\"\"\n    day = day if day is not None else datetime.datetime.now()\n    now = day.replace(day=1, hour=16, minute=0, second=0, microsecond=0)\n    now += relativedelta.relativedelta(weeks=2, weekday=relativedelta.FR)\n    return day > now", "code_tokens": "def after_third_friday ( day = None ) : day = day if day is not None else datetime . datetime . now ( ) now = day . replace ( day = 1 , hour = 16 , minute = 0 , second = 0 , microsecond = 0 ) now += relativedelta . relativedelta ( weeks = 2 , weekday = relativedelta . FR ) return day > now", "docstring_tokens": "check if day is after month s 3rd friday", "label": 1}, {"idx": "cosqa-train-18286", "doc": "python api call header and body", "code": "def _request(self, method: str, endpoint: str, params: dict = None, data: dict = None, headers: dict = None) -> dict:\n        \"\"\"HTTP request method of interface implementation.\"\"\"", "code_tokens": "def _request ( self , method : str , endpoint : str , params : dict = None , data : dict = None , headers : dict = None ) -> dict :", "docstring_tokens": "HTTP request method of interface implementation .", "label": 0}, {"idx": "cosqa-train-18287", "doc": "save an object to file python", "code": "def _write_json(obj, path):  # type: (object, str) -> None\n    \"\"\"Writes a serializeable object as a JSON file\"\"\"\n    with open(path, 'w') as f:\n        json.dump(obj, f)", "code_tokens": "def _write_json ( obj , path ) : # type: (object, str) -> None with open ( path , 'w' ) as f : json . dump ( obj , f )", "docstring_tokens": "Writes a serializeable object as a JSON file", "label": 0}, {"idx": "cosqa-train-18288", "doc": "flatten python list of lists", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 0}, {"idx": "cosqa-train-18289", "doc": "python calendar month how to get last day of month", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 0}, {"idx": "cosqa-train-18290", "doc": "python max argmax key lambda", "code": "def argmax(iterable, key=None, both=False):\n    \"\"\"\n    >>> argmax([4,2,-5])\n    0\n    >>> argmax([4,2,-5], key=abs)\n    2\n    >>> argmax([4,2,-5], key=abs, both=True)\n    (2, 5)\n    \"\"\"\n    if key is not None:\n        it = imap(key, iterable)\n    else:\n        it = iter(iterable)\n    score, argmax = reduce(max, izip(it, count()))\n    if both:\n        return argmax, score\n    return argmax", "code_tokens": "def argmax ( iterable , key = None , both = False ) : if key is not None : it = imap ( key , iterable ) else : it = iter ( iterable ) score , argmax = reduce ( max , izip ( it , count ( ) ) ) if both : return argmax , score return argmax", "docstring_tokens": ">>> argmax ( [ 4 2 - 5 ] ) 0 >>> argmax ( [ 4 2 - 5 ] key = abs ) 2 >>> argmax ( [ 4 2 - 5 ] key = abs both = True ) ( 2 5 )", "label": 1}, {"idx": "cosqa-train-18291", "doc": "python return a set", "code": "def get_system_flags() -> FrozenSet[Flag]:\n    \"\"\"Return the set of implemented system flags.\"\"\"\n    return frozenset({Seen, Recent, Deleted, Flagged, Answered, Draft})", "code_tokens": "def get_system_flags ( ) -> FrozenSet [ Flag ] : return frozenset ( { Seen , Recent , Deleted , Flagged , Answered , Draft } )", "docstring_tokens": "Return the set of implemented system flags .", "label": 0}, {"idx": "cosqa-train-18292", "doc": "how go from list to string python", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 1}, {"idx": "cosqa-train-18293", "doc": "string to bytes ascii python", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 1}, {"idx": "cosqa-train-18294", "doc": "python get index for element in list with condition", "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:\n    \"\"\"\n    Finds the index of an item in list, which satisfies predicate\n    :param predicateFn: predicate function to run on items of list\n    :param items: list of tuples\n    :return: first index for which predicate function returns True\n    \"\"\"\n    try:\n        return next(i for i, v in enumerate(items) if predicateFn(v))\n    except StopIteration:\n        return -1", "code_tokens": "def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "docstring_tokens": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True", "label": 1}, {"idx": "cosqa-train-18295", "doc": "python map instead of for loop", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-18296", "doc": "python how to exit a code", "code": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)", "code_tokens": "def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "docstring_tokens": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting", "label": 0}, {"idx": "cosqa-train-18297", "doc": "python 4 bytes to int32", "code": "def hex_to_int(value):\n    \"\"\"\n    Convert hex string like \"\\x0A\\xE3\" to 2787.\n    \"\"\"\n    if version_info.major >= 3:\n        return int.from_bytes(value, \"big\")\n    return int(value.encode(\"hex\"), 16)", "code_tokens": "def hex_to_int ( value ) : if version_info . major >= 3 : return int . from_bytes ( value , \"big\" ) return int ( value . encode ( \"hex\" ) , 16 )", "docstring_tokens": "Convert hex string like \\ x0A \\ xE3 to 2787 .", "label": 1}, {"idx": "cosqa-train-18298", "doc": "isoformat python datetitme timezone", "code": "def timestamp_with_tzinfo(dt):\n    \"\"\"\n    Serialize a date/time value into an ISO8601 text representation\n    adjusted (if needed) to UTC timezone.\n\n    For instance:\n    >>> serialize_date(datetime(2012, 4, 10, 22, 38, 20, 604391))\n    '2012-04-10T22:38:20.604391Z'\n    \"\"\"\n    utc = tzutc()\n\n    if dt.tzinfo:\n        dt = dt.astimezone(utc).replace(tzinfo=None)\n    return dt.isoformat() + 'Z'", "code_tokens": "def timestamp_with_tzinfo ( dt ) : utc = tzutc ( ) if dt . tzinfo : dt = dt . astimezone ( utc ) . replace ( tzinfo = None ) return dt . isoformat ( ) + 'Z'", "docstring_tokens": "Serialize a date / time value into an ISO8601 text representation adjusted ( if needed ) to UTC timezone .", "label": 1}, {"idx": "cosqa-train-18299", "doc": "python check char type", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 0}, {"idx": "cosqa-train-18300", "doc": "python cursor iterate fetchall", "code": "async def fetchall(self) -> Iterable[sqlite3.Row]:\n        \"\"\"Fetch all remaining rows.\"\"\"\n        return await self._execute(self._cursor.fetchall)", "code_tokens": "async def fetchall ( self ) -> Iterable [ sqlite3 . Row ] : return await self . _execute ( self . _cursor . fetchall )", "docstring_tokens": "Fetch all remaining rows .", "label": 0}, {"idx": "cosqa-train-18301", "doc": "get duplicate index python", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 1}, {"idx": "cosqa-train-18302", "doc": "turn string to a list in python", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 1}, {"idx": "cosqa-train-18303", "doc": "elements of list to string python", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 1}, {"idx": "cosqa-train-18304", "doc": "delete an entry out of a dictionary python", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-18305", "doc": "python subsitute a variable with the variable text", "code": "def replace_variables(self, source: str, variables: dict) -> str:\n        \"\"\"Replace {{variable-name}} with stored value.\"\"\"\n        try:\n            replaced = re.sub(\n                \"{{(.*?)}}\", lambda m: variables.get(m.group(1), \"\"), source\n            )\n        except TypeError:\n            replaced = source\n        return replaced", "code_tokens": "def replace_variables ( self , source : str , variables : dict ) -> str : try : replaced = re . sub ( \"{{(.*?)}}\" , lambda m : variables . get ( m . group ( 1 ) , \"\" ) , source ) except TypeError : replaced = source return replaced", "docstring_tokens": "Replace {{ variable - name }} with stored value .", "label": 0}, {"idx": "cosqa-train-18306", "doc": "check if object is not empty python", "code": "def is_empty_shape(sh: ShExJ.Shape) -> bool:\n        \"\"\" Determine whether sh has any value \"\"\"\n        return sh.closed is None and sh.expression is None and sh.extra is None and \\\n            sh.semActs is None", "code_tokens": "def is_empty_shape ( sh : ShExJ . Shape ) -> bool : return sh . closed is None and sh . expression is None and sh . extra is None and sh . semActs is None", "docstring_tokens": "Determine whether sh has any value", "label": 0}, {"idx": "cosqa-train-18307", "doc": "python for n in arange loop numper of times", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 1}, {"idx": "cosqa-train-18308", "doc": "python verify if type is string", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 1}, {"idx": "cosqa-train-18309", "doc": "python if key doesn't exist create", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 1}, {"idx": "cosqa-train-18310", "doc": "python remove duplicate in collection", "code": "def duplicates(coll):\n    \"\"\"Return the duplicated items in the given collection\n\n    :param coll: a collection\n    :returns: a list of the duplicated items in the collection\n\n    >>> duplicates([1, 1, 2, 3, 3, 4, 1, 1])\n    [1, 3]\n\n    \"\"\"\n    return list(set(x for x in coll if coll.count(x) > 1))", "code_tokens": "def duplicates ( coll ) : return list ( set ( x for x in coll if coll . count ( x ) > 1 ) )", "docstring_tokens": "Return the duplicated items in the given collection", "label": 0}, {"idx": "cosqa-train-18311", "doc": "round to closest defined value python", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 1}, {"idx": "cosqa-train-18312", "doc": "python cycle detection dfs stack", "code": "def _dfs_cycle_detect(graph, node, path, visited_nodes):\n    \"\"\"\n    search graph for cycle using DFS continuing from node\n    path contains the list of visited nodes currently on the stack\n    visited_nodes is the set of already visited nodes\n    :param graph:\n    :param node:\n    :param path:\n    :param visited_nodes:\n    :return:\n    \"\"\"\n    visited_nodes.add(node)\n    for target in graph[node]:\n        if target in path:\n            # cycle found => return current path\n            return path + [target]\n        else:\n            return _dfs_cycle_detect(graph, target, path + [target], visited_nodes)\n    return None", "code_tokens": "def _dfs_cycle_detect ( graph , node , path , visited_nodes ) : visited_nodes . add ( node ) for target in graph [ node ] : if target in path : # cycle found => return current path return path + [ target ] else : return _dfs_cycle_detect ( graph , target , path + [ target ] , visited_nodes ) return None", "docstring_tokens": "search graph for cycle using DFS continuing from node path contains the list of visited nodes currently on the stack visited_nodes is the set of already visited nodes : param graph : : param node : : param path : : param visited_nodes : : return :", "label": 1}, {"idx": "cosqa-train-18313", "doc": "how to create a set within a file in python", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 0}, {"idx": "cosqa-train-18314", "doc": "replace a substring of characters in python", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 0}, {"idx": "cosqa-train-18315", "doc": "how to read a text file in python to a set", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 0}, {"idx": "cosqa-train-18316", "doc": "how to tell if a directory is empty in python", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 0}, {"idx": "cosqa-train-18317", "doc": "tell python to quit else rerun main function", "code": "def do_quit(self, _: argparse.Namespace) -> bool:\n        \"\"\"Exit this application\"\"\"\n        self._should_quit = True\n        return self._STOP_AND_EXIT", "code_tokens": "def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "docstring_tokens": "Exit this application", "label": 0}, {"idx": "cosqa-train-18318", "doc": "python django name 'static' is not defined", "code": "def collect_static() -> bool:\n    \"\"\"\n    Runs Django ``collectstatic`` command in silent mode.\n\n    :return: always ``True``\n    \"\"\"\n    from django.core.management import execute_from_command_line\n    # from django.conf import settings\n    # if not os.listdir(settings.STATIC_ROOT):\n    wf('Collecting static files... ', False)\n    execute_from_command_line(['./manage.py', 'collectstatic', '-c', '--noinput', '-v0'])\n    wf('[+]\\n')\n    return True", "code_tokens": "def collect_static ( ) -> bool : from django . core . management import execute_from_command_line # from django.conf import settings # if not os.listdir(settings.STATIC_ROOT): wf ( 'Collecting static files... ' , False ) execute_from_command_line ( [ './manage.py' , 'collectstatic' , '-c' , '--noinput' , '-v0' ] ) wf ( '[+]\\n' ) return True", "docstring_tokens": "Runs Django collectstatic command in silent mode .", "label": 0}, {"idx": "cosqa-train-18319", "doc": "python checking if key exists in shelve", "code": "def check_key(self, key: str) -> bool:\n        \"\"\"\n        Checks if key exists in datastore. True if yes, False if no.\n\n        :param: SHA512 hash key\n\n        :return: whether or key not exists in datastore\n        \"\"\"\n        keys = self.get_keys()\n        return key in keys", "code_tokens": "def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "docstring_tokens": "Checks if key exists in datastore . True if yes False if no .", "label": 0}, {"idx": "cosqa-train-18320", "doc": "python 2^3 exponents using pow", "code": "def safe_pow(base, exp):\n    \"\"\"safe version of pow\"\"\"\n    if exp > MAX_EXPONENT:\n        raise RuntimeError(\"Invalid exponent, max exponent is {}\".format(MAX_EXPONENT))\n    return base ** exp", "code_tokens": "def safe_pow ( base , exp ) : if exp > MAX_EXPONENT : raise RuntimeError ( \"Invalid exponent, max exponent is {}\" . format ( MAX_EXPONENT ) ) return base ** exp", "docstring_tokens": "safe version of pow", "label": 1}, {"idx": "cosqa-train-18321", "doc": "python generate permutions of sequence", "code": "def product(*args, **kwargs):\n    \"\"\" Yields all permutations with replacement:\n        list(product(\"cat\", repeat=2)) => \n        [(\"c\", \"c\"), \n         (\"c\", \"a\"), \n         (\"c\", \"t\"), \n         (\"a\", \"c\"), \n         (\"a\", \"a\"), \n         (\"a\", \"t\"), \n         (\"t\", \"c\"), \n         (\"t\", \"a\"), \n         (\"t\", \"t\")]\n    \"\"\"\n    p = [[]]\n    for iterable in map(tuple, args) * kwargs.get(\"repeat\", 1):\n        p = [x + [y] for x in p for y in iterable]\n    for p in p:\n        yield tuple(p)", "code_tokens": "def product ( * args , * * kwargs ) : p = [ [ ] ] for iterable in map ( tuple , args ) * kwargs . get ( \"repeat\" , 1 ) : p = [ x + [ y ] for x in p for y in iterable ] for p in p : yield tuple ( p )", "docstring_tokens": "Yields all permutations with replacement : list ( product ( cat repeat = 2 )) = > [ ( c c ) ( c a ) ( c t ) ( a c ) ( a a ) ( a t ) ( t c ) ( t a ) ( t t ) ]", "label": 0}, {"idx": "cosqa-train-18322", "doc": "how do i skip a line without entering it in python", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 1}, {"idx": "cosqa-train-18323", "doc": "python for longest substring in list", "code": "def long_substr(data):\n    \"\"\"Return the longest common substring in a list of strings.\n    \n    Credit: http://stackoverflow.com/questions/2892931/longest-common-substring-from-more-than-two-strings-python\n    \"\"\"\n    substr = ''\n    if len(data) > 1 and len(data[0]) > 0:\n        for i in range(len(data[0])):\n            for j in range(len(data[0])-i+1):\n                if j > len(substr) and all(data[0][i:i+j] in x for x in data):\n                    substr = data[0][i:i+j]\n    elif len(data) == 1:\n        substr = data[0]\n    return substr", "code_tokens": "def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "docstring_tokens": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python", "label": 1}, {"idx": "cosqa-train-18324", "doc": "python 3 parse iso date", "code": "def _parse_date(string: str) -> datetime.date:\n    \"\"\"Parse an ISO format date (YYYY-mm-dd).\n\n    >>> _parse_date('1990-01-02')\n    datetime.date(1990, 1, 2)\n    \"\"\"\n    return datetime.datetime.strptime(string, '%Y-%m-%d').date()", "code_tokens": "def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )", "docstring_tokens": "Parse an ISO format date ( YYYY - mm - dd ) .", "label": 1}, {"idx": "cosqa-train-18325", "doc": "how to flatten image in python", "code": "def read_flat(self):\n        \"\"\"\n        Read a PNG file and decode it into flat row flat pixel format.\n\n        Returns (*width*, *height*, *pixels*, *metadata*).\n\n        May use excessive memory.\n\n        `pixels` are returned in flat row flat pixel format.\n\n        See also the :meth:`read` method which returns pixels in the\n        more stream-friendly boxed row flat pixel format.\n        \"\"\"\n        x, y, pixel, meta = self.read()\n        arraycode = 'BH'[meta['bitdepth'] > 8]\n        pixel = array(arraycode, itertools.chain(*pixel))\n        return x, y, pixel, meta", "code_tokens": "def read_flat ( self ) : x , y , pixel , meta = self . read ( ) arraycode = 'BH' [ meta [ 'bitdepth' ] > 8 ] pixel = array ( arraycode , itertools . chain ( * pixel ) ) return x , y , pixel , meta", "docstring_tokens": "Read a PNG file and decode it into flat row flat pixel format .", "label": 0}, {"idx": "cosqa-train-18326", "doc": "readlines function in python deleting spaces", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-18327", "doc": "how to check a column type in python", "code": "def is_sqlatype_string(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type a string type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.String)", "code_tokens": "def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "docstring_tokens": "Is the SQLAlchemy column type a string type?", "label": 0}, {"idx": "cosqa-train-18328", "doc": "python get function by full path", "code": "def import_by_path(path: str) -> Callable:\n    \"\"\"Import a class or function given it's absolute path.\n\n    Parameters\n    ----------\n    path:\n      Path to object to import\n    \"\"\"\n\n    module_path, _, class_name = path.rpartition('.')\n    return getattr(import_module(module_path), class_name)", "code_tokens": "def import_by_path ( path : str ) -> Callable : module_path , _ , class_name = path . rpartition ( '.' ) return getattr ( import_module ( module_path ) , class_name )", "docstring_tokens": "Import a class or function given it s absolute path .", "label": 1}, {"idx": "cosqa-train-18329", "doc": "finding the last occurence of a character in a string in python", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 0}, {"idx": "cosqa-train-18330", "doc": "python trim white space on column names", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 0}, {"idx": "cosqa-train-18331", "doc": "how to random sample part of normal distribution in python", "code": "def sample_normal(mean, var, rng):\n    \"\"\"Sample from independent normal distributions\n\n    Each element is an independent normal distribution.\n\n    Parameters\n    ----------\n    mean : numpy.ndarray\n      Means of the normal distribution. Shape --> (batch_num, sample_dim)\n    var : numpy.ndarray\n      Variance of the normal distribution. Shape --> (batch_num, sample_dim)\n    rng : numpy.random.RandomState\n\n    Returns\n    -------\n    ret : numpy.ndarray\n       The sampling result. Shape --> (batch_num, sample_dim)\n    \"\"\"\n    ret = numpy.sqrt(var) * rng.randn(*mean.shape) + mean\n    return ret", "code_tokens": "def sample_normal ( mean , var , rng ) : ret = numpy . sqrt ( var ) * rng . randn ( * mean . shape ) + mean return ret", "docstring_tokens": "Sample from independent normal distributions", "label": 0}, {"idx": "cosqa-train-18332", "doc": "python sqlite3 cursor context", "code": "async def cursor(self) -> Cursor:\n        \"\"\"Create an aiosqlite cursor wrapping a sqlite3 cursor object.\"\"\"\n        return Cursor(self, await self._execute(self._conn.cursor))", "code_tokens": "async def cursor ( self ) -> Cursor : return Cursor ( self , await self . _execute ( self . _conn . cursor ) )", "docstring_tokens": "Create an aiosqlite cursor wrapping a sqlite3 cursor object .", "label": 1}, {"idx": "cosqa-train-18333", "doc": "python test if line in file", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 1}, {"idx": "cosqa-train-18334", "doc": "python3 decode b string", "code": "def decodebytes(input):\n    \"\"\"Decode base64 string to byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _decodebytes_py3(input)\n    return _decodebytes_py2(input)", "code_tokens": "def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )", "docstring_tokens": "Decode base64 string to byte array .", "label": 0}, {"idx": "cosqa-train-18335", "doc": "python index of the second largest value in a 2d array", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 0}, {"idx": "cosqa-train-18336", "doc": "turn list of str into int python", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-18337", "doc": "python expected type 'list', got 'iterator' instead", "code": "def ensure_list(iterable: Iterable[A]) -> List[A]:\n    \"\"\"\n    An Iterable may be a list or a generator.\n    This ensures we get a list without making an unnecessary copy.\n    \"\"\"\n    if isinstance(iterable, list):\n        return iterable\n    else:\n        return list(iterable)", "code_tokens": "def ensure_list ( iterable : Iterable [ A ] ) -> List [ A ] : if isinstance ( iterable , list ) : return iterable else : return list ( iterable )", "docstring_tokens": "An Iterable may be a list or a generator . This ensures we get a list without making an unnecessary copy .", "label": 0}, {"idx": "cosqa-train-18338", "doc": "python numpy read array from csv", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 0}, {"idx": "cosqa-train-18339", "doc": "how to use pylint for python 3", "code": "def lint(fmt='colorized'):\n    \"\"\"Run verbose PyLint on source. Optionally specify fmt=html for HTML output.\"\"\"\n    if fmt == 'html':\n        outfile = 'pylint_report.html'\n        local('pylint -f %s davies > %s || true' % (fmt, outfile))\n        local('open %s' % outfile)\n    else:\n        local('pylint -f %s davies || true' % fmt)", "code_tokens": "def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "docstring_tokens": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output .", "label": 0}, {"idx": "cosqa-train-18340", "doc": "log distribution in python with a zero value", "code": "def _protected_log(x1):\n    \"\"\"Closure of log for zero arguments.\"\"\"\n    with np.errstate(divide='ignore', invalid='ignore'):\n        return np.where(np.abs(x1) > 0.001, np.log(np.abs(x1)), 0.)", "code_tokens": "def _protected_log ( x1 ) : with np . errstate ( divide = 'ignore' , invalid = 'ignore' ) : return np . where ( np . abs ( x1 ) > 0.001 , np . log ( np . abs ( x1 ) ) , 0. )", "docstring_tokens": "Closure of log for zero arguments .", "label": 0}, {"idx": "cosqa-train-18341", "doc": "python right bitwise overload", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 1}, {"idx": "cosqa-train-18342", "doc": "python map with conditional function", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-18343", "doc": "python check if path is file or folder", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 0}, {"idx": "cosqa-train-18344", "doc": "python filter a dictionary by value", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 1}, {"idx": "cosqa-train-18345", "doc": "python if column is not null", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-18346", "doc": "determine the mth to last element of a sequence python", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-18347", "doc": "how to read file from s3 bucket in python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 1}, {"idx": "cosqa-train-18348", "doc": "how to get the first file of the path python glob", "code": "def find_first(pattern: str, path: str) -> str:\n    \"\"\"\n    Finds first file in ``path`` whose filename matches ``pattern`` (via\n    :func:`fnmatch.fnmatch`), or raises :exc:`IndexError`.\n    \"\"\"\n    try:\n        return find(pattern, path)[0]\n    except IndexError:\n        log.critical('''Couldn't find \"{}\" in \"{}\"''', pattern, path)\n        raise", "code_tokens": "def find_first ( pattern : str , path : str ) -> str : try : return find ( pattern , path ) [ 0 ] except IndexError : log . critical ( '''Couldn't find \"{}\" in \"{}\"''' , pattern , path ) raise", "docstring_tokens": "Finds first file in path whose filename matches pattern ( via : func : fnmatch . fnmatch ) or raises : exc : IndexError .", "label": 1}, {"idx": "cosqa-train-18349", "doc": "storing elements of a list to string python", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 1}, {"idx": "cosqa-train-18350", "doc": "python, get timezone info in python", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-18351", "doc": "diffrence bytes bwtween python2 and python3", "code": "def bytes_hack(buf):\n    \"\"\"\n    Hacky workaround for old installs of the library on systems without python-future that were\n    keeping the 2to3 update from working after auto-update.\n    \"\"\"\n    ub = None\n    if sys.version_info > (3,):\n        ub = buf\n    else:\n        ub = bytes(buf)\n\n    return ub", "code_tokens": "def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "docstring_tokens": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update .", "label": 1}, {"idx": "cosqa-train-18352", "doc": "check if line in file python", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 1}, {"idx": "cosqa-train-18353", "doc": "python see if 2 paths equal", "code": "def samefile(a: str, b: str) -> bool:\n    \"\"\"Check if two pathes represent the same file.\"\"\"\n    try:\n        return os.path.samefile(a, b)\n    except OSError:\n        return os.path.normpath(a) == os.path.normpath(b)", "code_tokens": "def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )", "docstring_tokens": "Check if two pathes represent the same file .", "label": 1}, {"idx": "cosqa-train-18354", "doc": "splitting a tuple into variables python", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 1}, {"idx": "cosqa-train-18355", "doc": "python get the last index of a slice", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-18356", "doc": "check if a list is sequential python", "code": "def are_token_parallel(sequences: Sequence[Sized]) -> bool:\n    \"\"\"\n    Returns True if all sequences in the list have the same length.\n    \"\"\"\n    if not sequences or len(sequences) == 1:\n        return True\n    return all(len(s) == len(sequences[0]) for s in sequences)", "code_tokens": "def are_token_parallel ( sequences : Sequence [ Sized ] ) -> bool : if not sequences or len ( sequences ) == 1 : return True return all ( len ( s ) == len ( sequences [ 0 ] ) for s in sequences )", "docstring_tokens": "Returns True if all sequences in the list have the same length .", "label": 0}, {"idx": "cosqa-train-18357", "doc": "python to get the uid of a process", "code": "def local_machine_uuid():\n    \"\"\"Return local machine unique identifier.\n\n    >>> uuid = local_machine_uuid()\n\n    \"\"\"\n\n    result = subprocess.check_output(\n        'hal-get-property --udi '\n        '/org/freedesktop/Hal/devices/computer '\n        '--key system.hardware.uuid'.split()\n        ).strip()\n\n    return uuid.UUID(hex=result)", "code_tokens": "def local_machine_uuid ( ) : result = subprocess . check_output ( 'hal-get-property --udi ' '/org/freedesktop/Hal/devices/computer ' '--key system.hardware.uuid' . split ( ) ) . strip ( ) return uuid . UUID ( hex = result )", "docstring_tokens": "Return local machine unique identifier .", "label": 0}, {"idx": "cosqa-train-18358", "doc": "parse a url in python and get the hostname", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 1}, {"idx": "cosqa-train-18359", "doc": "jira python issue fixversion", "code": "def _check_update_(self):\n        \"\"\"Check if the current version of the library is outdated.\"\"\"\n        try:\n            data = requests.get(\"https://pypi.python.org/pypi/jira/json\", timeout=2.001).json()\n\n            released_version = data['info']['version']\n            if parse_version(released_version) > parse_version(__version__):\n                warnings.warn(\n                    \"You are running an outdated version of JIRA Python %s. Current version is %s. Do not file any bugs against older versions.\" % (\n                        __version__, released_version))\n        except requests.RequestException:\n            pass\n        except Exception as e:\n            logging.warning(e)", "code_tokens": "def _check_update_ ( self ) : try : data = requests . get ( \"https://pypi.python.org/pypi/jira/json\" , timeout = 2.001 ) . json ( ) released_version = data [ 'info' ] [ 'version' ] if parse_version ( released_version ) > parse_version ( __version__ ) : warnings . warn ( \"You are running an outdated version of JIRA Python %s. Current version is %s. Do not file any bugs against older versions.\" % ( __version__ , released_version ) ) except requests . RequestException : pass except Exception as e : logging . warning ( e )", "docstring_tokens": "Check if the current version of the library is outdated .", "label": 0}, {"idx": "cosqa-train-18360", "doc": "finding the minimum in a vector in python", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-18361", "doc": "greater than comparison python3", "code": "def __gt__(self, other):\n        \"\"\"Test for greater than.\"\"\"\n        if isinstance(other, Address):\n            return str(self) > str(other)\n        raise TypeError", "code_tokens": "def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError", "docstring_tokens": "Test for greater than .", "label": 0}, {"idx": "cosqa-train-18362", "doc": "last item of series in python", "code": "def last(self):\n        \"\"\"Last time step available.\n\n        Example:\n            >>> sdat = StagyyData('path/to/run')\n            >>> assert(sdat.steps.last is sdat.steps[-1])\n        \"\"\"\n        if self._last is UNDETERMINED:\n            # not necessarily the last one...\n            self._last = self.sdat.tseries.index[-1]\n        return self[self._last]", "code_tokens": "def last ( self ) : if self . _last is UNDETERMINED : # not necessarily the last one... self . _last = self . sdat . tseries . index [ - 1 ] return self [ self . _last ]", "docstring_tokens": "Last time step available .", "label": 1}, {"idx": "cosqa-train-18363", "doc": "python parser call from script", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 0}, {"idx": "cosqa-train-18364", "doc": "get with default value python", "code": "def _get_or_default(mylist, i, default=None):\n    \"\"\"return list item number, or default if don't exist\"\"\"\n    if i >= len(mylist):\n        return default\n    else :\n        return mylist[i]", "code_tokens": "def _get_or_default ( mylist , i , default = None ) : if i >= len ( mylist ) : return default else : return mylist [ i ]", "docstring_tokens": "return list item number or default if don t exist", "label": 0}, {"idx": "cosqa-train-18365", "doc": "how to use mulde argparse to input parmeters into python program", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 0}, {"idx": "cosqa-train-18366", "doc": "python replace string until no further replaces made", "code": "def right_replace(string, old, new, count=1):\n    \"\"\"\n    Right replaces ``count`` occurrences of ``old`` with ``new`` in ``string``.\n    For example::\n\n        right_replace('one_two_two', 'two', 'three') -> 'one_two_three'\n    \"\"\"\n    if not string:\n        return string\n    return new.join(string.rsplit(old, count))", "code_tokens": "def right_replace ( string , old , new , count = 1 ) : if not string : return string return new . join ( string . rsplit ( old , count ) )", "docstring_tokens": "Right replaces count occurrences of old with new in string . For example ::", "label": 0}, {"idx": "cosqa-train-18367", "doc": "greatest common divisor of 3 numbers python", "code": "def gcd_float(numbers, tol=1e-8):\n    \"\"\"\n    Returns the greatest common divisor for a sequence of numbers.\n    Uses a numerical tolerance, so can be used on floats\n\n    Args:\n        numbers: Sequence of numbers.\n        tol: Numerical tolerance\n\n    Returns:\n        (int) Greatest common divisor of numbers.\n    \"\"\"\n\n    def pair_gcd_tol(a, b):\n        \"\"\"Calculate the Greatest Common Divisor of a and b.\n\n        Unless b==0, the result will have the same sign as b (so that when\n        b is divided by it, the result comes out positive).\n        \"\"\"\n        while b > tol:\n            a, b = b, a % b\n        return a\n\n    n = numbers[0]\n    for i in numbers:\n        n = pair_gcd_tol(n, i)\n    return n", "code_tokens": "def gcd_float ( numbers , tol = 1e-8 ) : def pair_gcd_tol ( a , b ) : \"\"\"Calculate the Greatest Common Divisor of a and b.\n\n        Unless b==0, the result will have the same sign as b (so that when\n        b is divided by it, the result comes out positive).\n        \"\"\" while b > tol : a , b = b , a % b return a n = numbers [ 0 ] for i in numbers : n = pair_gcd_tol ( n , i ) return n", "docstring_tokens": "Returns the greatest common divisor for a sequence of numbers . Uses a numerical tolerance so can be used on floats", "label": 1}, {"idx": "cosqa-train-18368", "doc": "replace duplicare in python list", "code": "def de_duplicate(items):\n    \"\"\"Remove any duplicate item, preserving order\n\n    >>> de_duplicate([1, 2, 1, 2])\n    [1, 2]\n    \"\"\"\n    result = []\n    for item in items:\n        if item not in result:\n            result.append(item)\n    return result", "code_tokens": "def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "docstring_tokens": "Remove any duplicate item preserving order", "label": 0}, {"idx": "cosqa-train-18369", "doc": "python method to replace multiple characters", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 0}, {"idx": "cosqa-train-18370", "doc": "make jpeg default in python", "code": "def version():\n    \"\"\"Wrapper for opj_version library routine.\"\"\"\n    OPENJPEG.opj_version.restype = ctypes.c_char_p\n    library_version = OPENJPEG.opj_version()\n    if sys.hexversion >= 0x03000000:\n        return library_version.decode('utf-8')\n    else:\n        return library_version", "code_tokens": "def version ( ) : OPENJPEG . opj_version . restype = ctypes . c_char_p library_version = OPENJPEG . opj_version ( ) if sys . hexversion >= 0x03000000 : return library_version . decode ( 'utf-8' ) else : return library_version", "docstring_tokens": "Wrapper for opj_version library routine .", "label": 0}, {"idx": "cosqa-train-18371", "doc": "making a string all uppercase python", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-18372", "doc": "how to pass the current time as variable in python to sql", "code": "def get_now_sql_datetime():\n    \"\"\"\n    *A datetime stamp in MySQL format: ``YYYY-MM-DDTHH:MM:SS``*\n\n    **Return:**\n        - ``now`` -- current time and date in MySQL format\n\n    **Usage:**\n        .. code-block:: python \n\n            from fundamentals import times\n            now = times.get_now_sql_datetime()\n            print now\n\n            # OUT: 2016-03-18T11:08:23 \n    \"\"\"\n    ## > IMPORTS ##\n    from datetime import datetime, date, time\n    now = datetime.now()\n    now = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    return now", "code_tokens": "def get_now_sql_datetime ( ) : ## > IMPORTS ## from datetime import datetime , date , time now = datetime . now ( ) now = now . strftime ( \"%Y-%m-%dT%H:%M:%S\" ) return now", "docstring_tokens": "* A datetime stamp in MySQL format : YYYY - MM - DDTHH : MM : SS *", "label": 1}, {"idx": "cosqa-train-18373", "doc": "python test assert not equal", "code": "def assert_equal(first, second, msg_fmt=\"{msg}\"):\n    \"\"\"Fail unless first equals second, as determined by the '==' operator.\n\n    >>> assert_equal(5, 5.0)\n    >>> assert_equal(\"Hello World!\", \"Goodbye!\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'Hello World!' != 'Goodbye!'\n\n    The following msg_fmt arguments are supported:\n    * msg - the default error message\n    * first - the first argument\n    * second - the second argument\n    \"\"\"\n\n    if isinstance(first, dict) and isinstance(second, dict):\n        assert_dict_equal(first, second, msg_fmt)\n    elif not first == second:\n        msg = \"{!r} != {!r}\".format(first, second)\n        fail(msg_fmt.format(msg=msg, first=first, second=second))", "code_tokens": "def assert_equal ( first , second , msg_fmt = \"{msg}\" ) : if isinstance ( first , dict ) and isinstance ( second , dict ) : assert_dict_equal ( first , second , msg_fmt ) elif not first == second : msg = \"{!r} != {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "docstring_tokens": "Fail unless first equals second as determined by the == operator .", "label": 0}, {"idx": "cosqa-train-18374", "doc": "replace is not working in python", "code": "def right_replace(string, old, new, count=1):\n    \"\"\"\n    Right replaces ``count`` occurrences of ``old`` with ``new`` in ``string``.\n    For example::\n\n        right_replace('one_two_two', 'two', 'three') -> 'one_two_three'\n    \"\"\"\n    if not string:\n        return string\n    return new.join(string.rsplit(old, count))", "code_tokens": "def right_replace ( string , old , new , count = 1 ) : if not string : return string return new . join ( string . rsplit ( old , count ) )", "docstring_tokens": "Right replaces count occurrences of old with new in string . For example ::", "label": 0}, {"idx": "cosqa-train-18375", "doc": "how to check if a node is a leaf in python", "code": "def is_builtin_object(node: astroid.node_classes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == BUILTINS_NAME", "code_tokens": "def is_builtin_object ( node : astroid . node_classes . NodeNG ) -> bool : return node and node . root ( ) . name == BUILTINS_NAME", "docstring_tokens": "Returns True if the given node is an object from the __builtin__ module .", "label": 0}, {"idx": "cosqa-train-18376", "doc": "how to rotate a list of numbers in python", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 1}, {"idx": "cosqa-train-18377", "doc": "python bitwise first bit on", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 1}, {"idx": "cosqa-train-18378", "doc": "string remove the last blank python", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 1}, {"idx": "cosqa-train-18379", "doc": "what code in python capitalizes the first letter of the word", "code": "def capitalize(string):\n    \"\"\"Capitalize a sentence.\n\n    Parameters\n    ----------\n    string : `str`\n        String to capitalize.\n\n    Returns\n    -------\n    `str`\n        Capitalized string.\n\n    Examples\n    --------\n    >>> capitalize('worD WORD WoRd')\n    'Word word word'\n    \"\"\"\n    if not string:\n        return string\n    if len(string) == 1:\n        return string.upper()\n    return string[0].upper() + string[1:].lower()", "code_tokens": "def capitalize ( string ) : if not string : return string if len ( string ) == 1 : return string . upper ( ) return string [ 0 ] . upper ( ) + string [ 1 : ] . lower ( )", "docstring_tokens": "Capitalize a sentence .", "label": 0}, {"idx": "cosqa-train-18380", "doc": "python get min value from column", "code": "def min(self):\n        \"\"\"\n        :returns the minimum of the column\n        \"\"\"\n        res = self._qexec(\"min(%s)\" % self._name)\n        if len(res) > 0:\n            self._min = res[0][0]\n        return self._min", "code_tokens": "def min ( self ) : res = self . _qexec ( \"min(%s)\" % self . _name ) if len ( res ) > 0 : self . _min = res [ 0 ] [ 0 ] return self . _min", "docstring_tokens": ": returns the minimum of the column", "label": 1}, {"idx": "cosqa-train-18381", "doc": "python last day in month", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 0}, {"idx": "cosqa-train-18382", "doc": "generating a checksum of a file python", "code": "def checksum(path):\n    \"\"\"Calculcate checksum for a file.\"\"\"\n    hasher = hashlib.sha1()\n    with open(path, 'rb') as stream:\n        buf = stream.read(BLOCKSIZE)\n        while len(buf) > 0:\n            hasher.update(buf)\n            buf = stream.read(BLOCKSIZE)\n    return hasher.hexdigest()", "code_tokens": "def checksum ( path ) : hasher = hashlib . sha1 ( ) with open ( path , 'rb' ) as stream : buf = stream . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = stream . read ( BLOCKSIZE ) return hasher . hexdigest ( )", "docstring_tokens": "Calculcate checksum for a file .", "label": 1}, {"idx": "cosqa-train-18383", "doc": "fibonacci sequence python lambda", "code": "def fib(n):\n    \"\"\"Fibonacci example function\n\n    Args:\n      n (int): integer\n\n    Returns:\n      int: n-th Fibonacci number\n    \"\"\"\n    assert n > 0\n    a, b = 1, 1\n    for i in range(n - 1):\n        a, b = b, a + b\n    return a", "code_tokens": "def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a", "docstring_tokens": "Fibonacci example function", "label": 0}, {"idx": "cosqa-train-18384", "doc": "python program to determine days number in a month in a year", "code": "def get_days_in_month(year: int, month: int) -> int:\n    \"\"\" Returns number of days in the given month.\n    1-based numbers as arguments. i.e. November = 11 \"\"\"\n    month_range = calendar.monthrange(year, month)\n    return month_range[1]", "code_tokens": "def get_days_in_month ( year : int , month : int ) -> int : month_range = calendar . monthrange ( year , month ) return month_range [ 1 ]", "docstring_tokens": "Returns number of days in the given month . 1 - based numbers as arguments . i . e . November = 11", "label": 1}, {"idx": "cosqa-train-18385", "doc": "python get key if it exists", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 0}, {"idx": "cosqa-train-18386", "doc": "python dateutil get last day of this month", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 1}, {"idx": "cosqa-train-18387", "doc": "change json text to string python", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 0}, {"idx": "cosqa-train-18388", "doc": "python itertools tuple for every two elements", "code": "def pairwise(iterable):\n    \"\"\"From itertools cookbook. [a, b, c, ...] -> (a, b), (b, c), ...\"\"\"\n    first, second = tee(iterable)\n    next(second, None)\n    return zip(first, second)", "code_tokens": "def pairwise ( iterable ) : first , second = tee ( iterable ) next ( second , None ) return zip ( first , second )", "docstring_tokens": "From itertools cookbook . [ a b c ... ] - > ( a b ) ( b c ) ...", "label": 0}, {"idx": "cosqa-train-18389", "doc": "python3 dict to graphviz nodes", "code": "def to_graphviz(graph):\n    \"\"\"\n\n    :param graph:\n    :return:\n    \"\"\"\n    ret = ['digraph g {']\n    vertices = []\n\n    node_ids = dict([(name, 'node' + idx) for (idx, name) in enumerate(list(graph))])\n\n    for node in list(graph):\n        ret.append('  \"%s\" [label=\"%s\"];' % (node_ids[node], node))\n        for target in graph[node]:\n            vertices.append('  \"%s\" -> \"%s\";' % (node_ids[node], node_ids[target]))\n\n    ret += vertices\n    ret.append('}')\n    return '\\n'.join(ret)", "code_tokens": "def to_graphviz ( graph ) : ret = [ 'digraph g {' ] vertices = [ ] node_ids = dict ( [ ( name , 'node' + idx ) for ( idx , name ) in enumerate ( list ( graph ) ) ] ) for node in list ( graph ) : ret . append ( '  \"%s\" [label=\"%s\"];' % ( node_ids [ node ] , node ) ) for target in graph [ node ] : vertices . append ( '  \"%s\" -> \"%s\";' % ( node_ids [ node ] , node_ids [ target ] ) ) ret += vertices ret . append ( '}' ) return '\\n' . join ( ret )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-18390", "doc": "python open file or stdin", "code": "def file_or_stdin() -> Callable:\n    \"\"\"\n    Returns a file descriptor from stdin or opening a file from a given path.\n    \"\"\"\n\n    def parse(path):\n        if path is None or path == \"-\":\n            return sys.stdin\n        else:\n            return data_io.smart_open(path)\n\n    return parse", "code_tokens": "def file_or_stdin ( ) -> Callable : def parse ( path ) : if path is None or path == \"-\" : return sys . stdin else : return data_io . smart_open ( path ) return parse", "docstring_tokens": "Returns a file descriptor from stdin or opening a file from a given path .", "label": 1}, {"idx": "cosqa-train-18391", "doc": "python how to get the file extension", "code": "def get_file_extension(filename):\n    \"\"\" Return the extension if the filename has it. None if not.\n\n    :param filename: The filename.\n    :return: Extension or None.\n    \"\"\"\n    filename_x = filename.split('.')\n    if len(filename_x) > 1:\n        if filename_x[-1].strip() is not '':\n            return filename_x[-1]\n    return None", "code_tokens": "def get_file_extension ( filename ) : filename_x = filename . split ( '.' ) if len ( filename_x ) > 1 : if filename_x [ - 1 ] . strip ( ) is not '' : return filename_x [ - 1 ] return None", "docstring_tokens": "Return the extension if the filename has it . None if not .", "label": 1}, {"idx": "cosqa-train-18392", "doc": "how to cut decimals in python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 0}, {"idx": "cosqa-train-18393", "doc": "python how to combine a list to make a string", "code": "def list_to_str(lst):\n    \"\"\"\n    Turn a list into a comma- and/or and-separated string.\n\n    Parameters\n    ----------\n    lst : :obj:`list`\n        A list of strings to join into a single string.\n\n    Returns\n    -------\n    str_ : :obj:`str`\n        A string with commas and/or ands separating th elements from ``lst``.\n\n    \"\"\"\n    if len(lst) == 1:\n        str_ = lst[0]\n    elif len(lst) == 2:\n        str_ = ' and '.join(lst)\n    elif len(lst) > 2:\n        str_ = ', '.join(lst[:-1])\n        str_ += ', and {0}'.format(lst[-1])\n    else:\n        raise ValueError('List of length 0 provided.')\n    return str_", "code_tokens": "def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "docstring_tokens": "Turn a list into a comma - and / or and - separated string .", "label": 1}, {"idx": "cosqa-train-18394", "doc": "python, remove special characters [spaces,'(', and ')'] from column names", "code": "def normalize_column_names(df):\n    r\"\"\" Clean up whitespace in column names. See better version at `pugnlp.clean_columns`\n\n    >>> df = pd.DataFrame([[1, 2], [3, 4]], columns=['Hello World', 'not here'])\n    >>> normalize_column_names(df)\n    ['hello_world', 'not_here']\n    \"\"\"\n    columns = df.columns if hasattr(df, 'columns') else df\n    columns = [c.lower().replace(' ', '_') for c in columns]\n    return columns", "code_tokens": "def normalize_column_names ( df ) : columns = df . columns if hasattr ( df , 'columns' ) else df columns = [ c . lower ( ) . replace ( ' ' , '_' ) for c in columns ] return columns", "docstring_tokens": "r Clean up whitespace in column names . See better version at pugnlp . clean_columns", "label": 1}, {"idx": "cosqa-train-18395", "doc": "how to check image pixel size python", "code": "def _width_is_big_enough(image, width):\n    \"\"\"Check that the image width is superior to `width`\"\"\"\n    if width > image.size[0]:\n        raise ImageSizeError(image.size[0], width)", "code_tokens": "def _width_is_big_enough ( image , width ) : if width > image . size [ 0 ] : raise ImageSizeError ( image . size [ 0 ] , width )", "docstring_tokens": "Check that the image width is superior to width", "label": 0}, {"idx": "cosqa-train-18396", "doc": "elasticsearch python bulk stackoverflow", "code": "def bulk_load_docs(es, docs):\n    \"\"\"Bulk load docs\n\n    Args:\n        es: elasticsearch handle\n        docs: Iterator of doc objects - includes index_name\n    \"\"\"\n\n    chunk_size = 200\n\n    try:\n        results = elasticsearch.helpers.bulk(es, docs, chunk_size=chunk_size)\n        log.debug(f\"Elasticsearch documents loaded: {results[0]}\")\n\n        # elasticsearch.helpers.parallel_bulk(es, terms, chunk_size=chunk_size, thread_count=4)\n        if len(results[1]) > 0:\n            log.error(\"Bulk load errors {}\".format(results))\n    except elasticsearch.ElasticsearchException as e:\n        log.error(\"Indexing error: {}\\n\".format(e))", "code_tokens": "def bulk_load_docs ( es , docs ) : chunk_size = 200 try : results = elasticsearch . helpers . bulk ( es , docs , chunk_size = chunk_size ) log . debug ( f\"Elasticsearch documents loaded: {results[0]}\" ) # elasticsearch.helpers.parallel_bulk(es, terms, chunk_size=chunk_size, thread_count=4) if len ( results [ 1 ] ) > 0 : log . error ( \"Bulk load errors {}\" . format ( results ) ) except elasticsearch . ElasticsearchException as e : log . error ( \"Indexing error: {}\\n\" . format ( e ) )", "docstring_tokens": "Bulk load docs", "label": 0}, {"idx": "cosqa-train-18397", "doc": "how to display contents a text file in python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 0}, {"idx": "cosqa-train-18398", "doc": "python get the model number", "code": "def detect_model_num(string):\n    \"\"\"Takes a string related to a model name and extract its model number.\n\n    For example:\n        '000000-bootstrap.index' => 0\n    \"\"\"\n    match = re.match(MODEL_NUM_REGEX, string)\n    if match:\n        return int(match.group())\n    return None", "code_tokens": "def detect_model_num ( string ) : match = re . match ( MODEL_NUM_REGEX , string ) if match : return int ( match . group ( ) ) return None", "docstring_tokens": "Takes a string related to a model name and extract its model number .", "label": 0}, {"idx": "cosqa-train-18399", "doc": "how to do normalcdf in python", "code": "def normcdf(x, log=False):\n    \"\"\"Normal cumulative density function.\"\"\"\n    y = np.atleast_1d(x).copy()\n    flib.normcdf(y)\n    if log:\n        if (y>0).all():\n            return np.log(y)\n        return -np.inf\n    return y", "code_tokens": "def normcdf ( x , log = False ) : y = np . atleast_1d ( x ) . copy ( ) flib . normcdf ( y ) if log : if ( y > 0 ) . all ( ) : return np . log ( y ) return - np . inf return y", "docstring_tokens": "Normal cumulative density function .", "label": 1}, {"idx": "cosqa-train-18400", "doc": "python how to skip subsequent lines", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 1}, {"idx": "cosqa-train-18401", "doc": "get first file in a folder python", "code": "def find_first(pattern: str, path: str) -> str:\n    \"\"\"\n    Finds first file in ``path`` whose filename matches ``pattern`` (via\n    :func:`fnmatch.fnmatch`), or raises :exc:`IndexError`.\n    \"\"\"\n    try:\n        return find(pattern, path)[0]\n    except IndexError:\n        log.critical('''Couldn't find \"{}\" in \"{}\"''', pattern, path)\n        raise", "code_tokens": "def find_first ( pattern : str , path : str ) -> str : try : return find ( pattern , path ) [ 0 ] except IndexError : log . critical ( '''Couldn't find \"{}\" in \"{}\"''' , pattern , path ) raise", "docstring_tokens": "Finds first file in path whose filename matches pattern ( via : func : fnmatch . fnmatch ) or raises : exc : IndexError .", "label": 1}, {"idx": "cosqa-train-18402", "doc": "how to count a list of tokens in python", "code": "def _sum_cycles_from_tokens(self, tokens: List[str]) -> int:\n        \"\"\"Sum the total number of cycles over a list of tokens.\"\"\"\n        return sum((int(self._nonnumber_pattern.sub('', t)) for t in tokens))", "code_tokens": "def _sum_cycles_from_tokens ( self , tokens : List [ str ] ) -> int : return sum ( ( int ( self . _nonnumber_pattern . sub ( '' , t ) ) for t in tokens ) )", "docstring_tokens": "Sum the total number of cycles over a list of tokens .", "label": 1}, {"idx": "cosqa-train-18403", "doc": "python graphviz create dot file", "code": "def cmd_dot(conf: Config):\n    \"\"\"Print out a neat targets dependency tree based on requested targets.\n\n    Use graphviz to render the dot file, e.g.:\n\n    > ybt dot :foo :bar | dot -Tpng -o graph.png\n    \"\"\"\n    build_context = BuildContext(conf)\n    populate_targets_graph(build_context, conf)\n    if conf.output_dot_file is None:\n        write_dot(build_context, conf, sys.stdout)\n    else:\n        with open(conf.output_dot_file, 'w') as out_file:\n            write_dot(build_context, conf, out_file)", "code_tokens": "def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "docstring_tokens": "Print out a neat targets dependency tree based on requested targets .", "label": 1}, {"idx": "cosqa-train-18404", "doc": "python midpoint of two numbers", "code": "def _mid(pt1, pt2):\n    \"\"\"\n    (Point, Point) -> Point\n    Return the point that lies in between the two input points.\n    \"\"\"\n    (x0, y0), (x1, y1) = pt1, pt2\n    return 0.5 * (x0 + x1), 0.5 * (y0 + y1)", "code_tokens": "def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "docstring_tokens": "( Point Point ) - > Point Return the point that lies in between the two input points .", "label": 0}, {"idx": "cosqa-train-18405", "doc": "how to get longest string in an array of string python", "code": "def _prm_get_longest_stringsize(string_list):\n        \"\"\" Returns the longest string size for a string entry across data.\"\"\"\n        maxlength = 1\n\n        for stringar in string_list:\n            if isinstance(stringar, np.ndarray):\n                if stringar.ndim > 0:\n                    for string in stringar.ravel():\n                        maxlength = max(len(string), maxlength)\n                else:\n                    maxlength = max(len(stringar.tolist()), maxlength)\n            else:\n                maxlength = max(len(stringar), maxlength)\n\n        # Make the string Col longer than needed in order to allow later on slightly larger strings\n        return int(maxlength * 1.5)", "code_tokens": "def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "docstring_tokens": "Returns the longest string size for a string entry across data .", "label": 1}, {"idx": "cosqa-train-18406", "doc": "python read datetime from text string", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 0}, {"idx": "cosqa-train-18407", "doc": "python deleat duplicates in list", "code": "def de_duplicate(items):\n    \"\"\"Remove any duplicate item, preserving order\n\n    >>> de_duplicate([1, 2, 1, 2])\n    [1, 2]\n    \"\"\"\n    result = []\n    for item in items:\n        if item not in result:\n            result.append(item)\n    return result", "code_tokens": "def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "docstring_tokens": "Remove any duplicate item preserving order", "label": 0}, {"idx": "cosqa-train-18408", "doc": "return longest strings substring using python", "code": "def long_substr(data):\n    \"\"\"Return the longest common substring in a list of strings.\n    \n    Credit: http://stackoverflow.com/questions/2892931/longest-common-substring-from-more-than-two-strings-python\n    \"\"\"\n    substr = ''\n    if len(data) > 1 and len(data[0]) > 0:\n        for i in range(len(data[0])):\n            for j in range(len(data[0])-i+1):\n                if j > len(substr) and all(data[0][i:i+j] in x for x in data):\n                    substr = data[0][i:i+j]\n    elif len(data) == 1:\n        substr = data[0]\n    return substr", "code_tokens": "def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "docstring_tokens": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python", "label": 1}, {"idx": "cosqa-train-18409", "doc": "get key with largest value in python", "code": "def get_default_bucket_key(buckets: List[Tuple[int, int]]) -> Tuple[int, int]:\n    \"\"\"\n    Returns the default bucket from a list of buckets, i.e. the largest bucket.\n\n    :param buckets: List of buckets.\n    :return: The largest bucket in the list.\n    \"\"\"\n    return max(buckets)", "code_tokens": "def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )", "docstring_tokens": "Returns the default bucket from a list of buckets i . e . the largest bucket .", "label": 1}, {"idx": "cosqa-train-18410", "doc": "python genrator take next", "code": "def __next__(self):\n        \"\"\"\n        :return: int\n        \"\"\"\n        self.current += 1\n        if self.current > self.total:\n            raise StopIteration\n        else:\n            return self.iterable[self.current - 1]", "code_tokens": "def __next__ ( self ) : self . current += 1 if self . current > self . total : raise StopIteration else : return self . iterable [ self . current - 1 ]", "docstring_tokens": ": return : int", "label": 0}, {"idx": "cosqa-train-18411", "doc": "python xml delete element elementtree", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 0}, {"idx": "cosqa-train-18412", "doc": "python drop a key in dictionary", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-18413", "doc": "python remove leading zeroes", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 1}, {"idx": "cosqa-train-18414", "doc": "how to check type of column in python", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 0}, {"idx": "cosqa-train-18415", "doc": "python 3 create date from string", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 1}, {"idx": "cosqa-train-18416", "doc": "python cast as an enum type", "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum:\n    \"\"\"\n    Converts an ``dict`` to a ``Enum``.\n    \"\"\"\n    return enum_class[d['name']]", "code_tokens": "def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "docstring_tokens": "Converts an dict to a Enum .", "label": 0}, {"idx": "cosqa-train-18417", "doc": "how to check column type in python", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 0}, {"idx": "cosqa-train-18418", "doc": "remove all values in dictionary python", "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": "def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "docstring_tokens": "Return a new copied dictionary without the keys with None values from the given Mapping object .", "label": 1}, {"idx": "cosqa-train-18419", "doc": "python check if valid date", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 0}, {"idx": "cosqa-train-18420", "doc": "python list local branches git", "code": "def branches():\n    # type: () -> List[str]\n    \"\"\" Return a list of branches in the current repo.\n\n    Returns:\n        list[str]: A list of branches in the current repo.\n    \"\"\"\n    out = shell.run(\n        'git branch',\n        capture=True,\n        never_pretend=True\n    ).stdout.strip()\n    return [x.strip('* \\t\\n') for x in out.splitlines()]", "code_tokens": "def branches ( ) : # type: () -> List[str] out = shell . run ( 'git branch' , capture = True , never_pretend = True ) . stdout . strip ( ) return [ x . strip ( '* \\t\\n' ) for x in out . splitlines ( ) ]", "docstring_tokens": "Return a list of branches in the current repo .", "label": 1}, {"idx": "cosqa-train-18421", "doc": "implementation of cache memory performance in python", "code": "def cache_page(page_cache, page_hash, cache_size):\n    \"\"\"Add a page to the page cache.\"\"\"\n    page_cache.append(page_hash)\n    if len(page_cache) > cache_size:\n        page_cache.pop(0)", "code_tokens": "def cache_page ( page_cache , page_hash , cache_size ) : page_cache . append ( page_hash ) if len ( page_cache ) > cache_size : page_cache . pop ( 0 )", "docstring_tokens": "Add a page to the page cache .", "label": 1}, {"idx": "cosqa-train-18422", "doc": "iterate till second last element in a list python", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 0}, {"idx": "cosqa-train-18423", "doc": "python requests detailed log", "code": "def _log_response(response):\n    \"\"\"Log out information about a ``Request`` object.\n\n    After calling ``requests.request`` or one of its convenience methods, the\n    object returned can be passed to this method. If done, information about\n    the object returned is logged.\n\n    :return: Nothing is returned.\n\n    \"\"\"\n    message = u'Received HTTP {0} response: {1}'.format(\n        response.status_code,\n        response.text\n    )\n    if response.status_code >= 400:  # pragma: no cover\n        logger.warning(message)\n    else:\n        logger.debug(message)", "code_tokens": "def _log_response ( response ) : message = u'Received HTTP {0} response: {1}' . format ( response . status_code , response . text ) if response . status_code >= 400 : # pragma: no cover logger . warning ( message ) else : logger . debug ( message )", "docstring_tokens": "Log out information about a Request object .", "label": 0}, {"idx": "cosqa-train-18424", "doc": "how to test if a wav file says something python", "code": "def empty_wav(wav_path: Union[Path, str]) -> bool:\n    \"\"\"Check if a wav contains data\"\"\"\n    with wave.open(str(wav_path), 'rb') as wav_f:\n        return wav_f.getnframes() == 0", "code_tokens": "def empty_wav ( wav_path : Union [ Path , str ] ) -> bool : with wave . open ( str ( wav_path ) , 'rb' ) as wav_f : return wav_f . getnframes ( ) == 0", "docstring_tokens": "Check if a wav contains data", "label": 1}, {"idx": "cosqa-train-18425", "doc": "python decide if a qapplication instance is active", "code": "def _in_qtconsole() -> bool:\n    \"\"\"\n    A small utility function which determines if we're running in QTConsole's context.\n    \"\"\"\n    try:\n        from IPython import get_ipython\n        try:\n            from ipykernel.zmqshell import ZMQInteractiveShell\n            shell_object = ZMQInteractiveShell\n        except ImportError:\n            from IPython.kernel.zmq import zmqshell\n            shell_object = zmqshell.ZMQInteractiveShell\n        return isinstance(get_ipython(), shell_object)\n    except Exception:\n        return False", "code_tokens": "def _in_qtconsole ( ) -> bool : try : from IPython import get_ipython try : from ipykernel . zmqshell import ZMQInteractiveShell shell_object = ZMQInteractiveShell except ImportError : from IPython . kernel . zmq import zmqshell shell_object = zmqshell . ZMQInteractiveShell return isinstance ( get_ipython ( ) , shell_object ) except Exception : return False", "docstring_tokens": "A small utility function which determines if we re running in QTConsole s context .", "label": 0}, {"idx": "cosqa-train-18426", "doc": "get the last day of the month in a list python", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 0}, {"idx": "cosqa-train-18427", "doc": "python memview using size", "code": "def read(self, start_position: int, size: int) -> memoryview:\n        \"\"\"\n        Return a view into the memory\n        \"\"\"\n        return memoryview(self._bytes)[start_position:start_position + size]", "code_tokens": "def read ( self , start_position : int , size : int ) -> memoryview : return memoryview ( self . _bytes ) [ start_position : start_position + size ]", "docstring_tokens": "Return a view into the memory", "label": 0}, {"idx": "cosqa-train-18428", "doc": "how to go to a next line from a current line in line python", "code": "def auto_up(self, count=1, go_to_start_of_line_if_history_changes=False):\n        \"\"\"\n        If we're not on the first line (of a multiline input) go a line up,\n        otherwise go back in history. (If nothing is selected.)\n        \"\"\"\n        if self.complete_state:\n            self.complete_previous(count=count)\n        elif self.document.cursor_position_row > 0:\n            self.cursor_up(count=count)\n        elif not self.selection_state:\n            self.history_backward(count=count)\n\n            # Go to the start of the line?\n            if go_to_start_of_line_if_history_changes:\n                self.cursor_position += self.document.get_start_of_line_position()", "code_tokens": "def auto_up ( self , count = 1 , go_to_start_of_line_if_history_changes = False ) : if self . complete_state : self . complete_previous ( count = count ) elif self . document . cursor_position_row > 0 : self . cursor_up ( count = count ) elif not self . selection_state : self . history_backward ( count = count ) # Go to the start of the line? if go_to_start_of_line_if_history_changes : self . cursor_position += self . document . get_start_of_line_position ( )", "docstring_tokens": "If we re not on the first line ( of a multiline input ) go a line up otherwise go back in history . ( If nothing is selected . )", "label": 0}, {"idx": "cosqa-train-18429", "doc": "python openpyxl set cell color", "code": "def set_cell_value(cell, value):\n    \"\"\"\n    Convenience method for setting the value of an openpyxl cell\n\n    This is necessary since the value property changed from internal_value\n    to value between version 1.* and 2.*.\n    \"\"\"\n    if OPENPYXL_MAJOR_VERSION > 1:\n        cell.value = value\n    else:\n        cell.internal_value = value", "code_tokens": "def set_cell_value ( cell , value ) : if OPENPYXL_MAJOR_VERSION > 1 : cell . value = value else : cell . internal_value = value", "docstring_tokens": "Convenience method for setting the value of an openpyxl cell", "label": 0}, {"idx": "cosqa-train-18430", "doc": "python check if file is writeable", "code": "def writable_stream(handle):\n    \"\"\"Test whether a stream can be written to.\n    \"\"\"\n    if isinstance(handle, io.IOBase) and sys.version_info >= (3, 5):\n        return handle.writable()\n    try:\n        handle.write(b'')\n    except (io.UnsupportedOperation, IOError):\n        return False\n    else:\n        return True", "code_tokens": "def writable_stream ( handle ) : if isinstance ( handle , io . IOBase ) and sys . version_info >= ( 3 , 5 ) : return handle . writable ( ) try : handle . write ( b'' ) except ( io . UnsupportedOperation , IOError ) : return False else : return True", "docstring_tokens": "Test whether a stream can be written to .", "label": 0}, {"idx": "cosqa-train-18431", "doc": "how do i minimize tabs in python", "code": "def sorted(self):\n        \"\"\"Utility function for sort_file_tabs_alphabetically().\"\"\"\n        for i in range(0, self.tabs.tabBar().count() - 1):\n            if (self.tabs.tabBar().tabText(i) >\n                    self.tabs.tabBar().tabText(i + 1)):\n                return False\n        return True", "code_tokens": "def sorted ( self ) : for i in range ( 0 , self . tabs . tabBar ( ) . count ( ) - 1 ) : if ( self . tabs . tabBar ( ) . tabText ( i ) > self . tabs . tabBar ( ) . tabText ( i + 1 ) ) : return False return True", "docstring_tokens": "Utility function for sort_file_tabs_alphabetically () .", "label": 1}, {"idx": "cosqa-train-18432", "doc": "how to choose between yes or no in python", "code": "def ask_bool(question: str, default: bool = True) -> bool:\n    \"\"\"Asks a question yes no style\"\"\"\n    default_q = \"Y/n\" if default else \"y/N\"\n    answer = input(\"{0} [{1}]: \".format(question, default_q))\n    lower = answer.lower()\n    if not lower:\n        return default\n    return lower == \"y\"", "code_tokens": "def ask_bool ( question : str , default : bool = True ) -> bool : default_q = \"Y/n\" if default else \"y/N\" answer = input ( \"{0} [{1}]: \" . format ( question , default_q ) ) lower = answer . lower ( ) if not lower : return default return lower == \"y\"", "docstring_tokens": "Asks a question yes no style", "label": 0}, {"idx": "cosqa-train-18433", "doc": "python expected type 'list', got 'iterator] instead", "code": "def ensure_list(iterable: Iterable[A]) -> List[A]:\n    \"\"\"\n    An Iterable may be a list or a generator.\n    This ensures we get a list without making an unnecessary copy.\n    \"\"\"\n    if isinstance(iterable, list):\n        return iterable\n    else:\n        return list(iterable)", "code_tokens": "def ensure_list ( iterable : Iterable [ A ] ) -> List [ A ] : if isinstance ( iterable , list ) : return iterable else : return list ( iterable )", "docstring_tokens": "An Iterable may be a list or a generator . This ensures we get a list without making an unnecessary copy .", "label": 0}, {"idx": "cosqa-train-18434", "doc": "python how to check if file is empty", "code": "def isfile_notempty(inputfile: str) -> bool:\n        \"\"\"Check if the input filename with path is a file and is not empty.\"\"\"\n        try:\n            return isfile(inputfile) and getsize(inputfile) > 0\n        except TypeError:\n            raise TypeError('inputfile is not a valid type')", "code_tokens": "def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )", "docstring_tokens": "Check if the input filename with path is a file and is not empty .", "label": 1}, {"idx": "cosqa-train-18435", "doc": "python generate a random number from a normal distribution", "code": "def _gauss(mean: int, sigma: int) -> int:\n        \"\"\"\n        Creates a variation from a base value\n\n        Args:\n            mean: base value\n            sigma: gaussian sigma\n\n        Returns: random value\n\n        \"\"\"\n        return int(random.gauss(mean, sigma))", "code_tokens": "def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "docstring_tokens": "Creates a variation from a base value", "label": 0}, {"idx": "cosqa-train-18436", "doc": "python repeat elements in a list different amount of times", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 0}, {"idx": "cosqa-train-18437", "doc": "python checking if a value is in an enumeration", "code": "def has_value(cls, value: int) -> bool:\n        \"\"\"True if specified value exists in int enum; otherwise, False.\"\"\"\n        return any(value == item.value for item in cls)", "code_tokens": "def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "docstring_tokens": "True if specified value exists in int enum ; otherwise False .", "label": 0}, {"idx": "cosqa-train-18438", "doc": "check if set is subset of another set python", "code": "def issubset(self, other):\n        \"\"\"\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        \"\"\"\n        if len(self) > len(other):  # Fast check for obvious cases\n            return False\n        return all(item in other for item in self)", "code_tokens": "def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "docstring_tokens": "Report whether another set contains this set .", "label": 1}, {"idx": "cosqa-train-18439", "doc": "python code to check numbers of rows and columns in a dataset", "code": "def parse_dim(features, check=True):\n    \"\"\"Return the features dimension, raise if error\n\n    Raise IOError if features have not all the same positive\n    dimension.  Return dim (int), the features dimension.\n\n    \"\"\"\n    # try:\n    dim = features[0].shape[1]\n    # except IndexError:\n    #     dim = 1\n\n    if check and not dim > 0:\n        raise IOError('features dimension must be strictly positive')\n    if check and not all([d == dim for d in [x.shape[1] for x in features]]):\n        raise IOError('all files must have the same feature dimension')\n    return dim", "code_tokens": "def parse_dim ( features , check = True ) : # try: dim = features [ 0 ] . shape [ 1 ] # except IndexError: #     dim = 1 if check and not dim > 0 : raise IOError ( 'features dimension must be strictly positive' ) if check and not all ( [ d == dim for d in [ x . shape [ 1 ] for x in features ] ] ) : raise IOError ( 'all files must have the same feature dimension' ) return dim", "docstring_tokens": "Return the features dimension raise if error", "label": 1}, {"idx": "cosqa-train-18440", "doc": "python howe to tell if path passed in is absolute or relative", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 1}, {"idx": "cosqa-train-18441", "doc": "how to check keyboard input with python", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 0}, {"idx": "cosqa-train-18442", "doc": "python everything got changed to lowercase", "code": "def camel_to_snake_case(string):\n    \"\"\"Converts 'string' presented in camel case to snake case.\n\n    e.g.: CamelCase => snake_case\n    \"\"\"\n    s = _1.sub(r'\\1_\\2', string)\n    return _2.sub(r'\\1_\\2', s).lower()", "code_tokens": "def camel_to_snake_case ( string ) : s = _1 . sub ( r'\\1_\\2' , string ) return _2 . sub ( r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Converts string presented in camel case to snake case .", "label": 0}, {"idx": "cosqa-train-18443", "doc": "writing text and a variable to a file in python", "code": "def write_text(filename: str, text: str) -> None:\n    \"\"\"\n    Writes text to a file.\n    \"\"\"\n    with open(filename, 'w') as f:  # type: TextIO\n        print(text, file=f)", "code_tokens": "def write_text ( filename : str , text : str ) -> None : with open ( filename , 'w' ) as f : # type: TextIO print ( text , file = f )", "docstring_tokens": "Writes text to a file .", "label": 1}, {"idx": "cosqa-train-18444", "doc": "capitalize first element of the list python", "code": "def fmt_camel(name):\n    \"\"\"\n    Converts name to lower camel case. Words are identified by capitalization,\n    dashes, and underscores.\n    \"\"\"\n    words = split_words(name)\n    assert len(words) > 0\n    first = words.pop(0).lower()\n    return first + ''.join([word.capitalize() for word in words])", "code_tokens": "def fmt_camel ( name ) : words = split_words ( name ) assert len ( words ) > 0 first = words . pop ( 0 ) . lower ( ) return first + '' . join ( [ word . capitalize ( ) for word in words ] )", "docstring_tokens": "Converts name to lower camel case . Words are identified by capitalization dashes and underscores .", "label": 0}, {"idx": "cosqa-train-18445", "doc": "print only limited element of a list python", "code": "def _brief_print_list(lst, limit=7):\n    \"\"\"Print at most `limit` elements of list.\"\"\"\n    lst = list(lst)\n    if len(lst) > limit:\n        return _brief_print_list(lst[:limit//2], limit) + ', ..., ' + \\\n            _brief_print_list(lst[-limit//2:], limit)\n    return ', '.join([\"'%s'\"%str(i) for i in lst])", "code_tokens": "def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "docstring_tokens": "Print at most limit elements of list .", "label": 1}, {"idx": "cosqa-train-18446", "doc": "how to test if str is int python", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-18447", "doc": "python get cursor position", "code": "def position(self) -> Position:\n        \"\"\"The current position of the cursor.\"\"\"\n        return Position(self._index, self._lineno, self._col_offset)", "code_tokens": "def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "docstring_tokens": "The current position of the cursor .", "label": 0}, {"idx": "cosqa-train-18448", "doc": "python graph dict of set", "code": "def get_edge_relations(graph: BELGraph) -> Mapping[Tuple[BaseEntity, BaseEntity], Set[str]]:\n    \"\"\"Build a dictionary of {node pair: set of edge types}.\"\"\"\n    return group_dict_set(\n        ((u, v), d[RELATION])\n        for u, v, d in graph.edges(data=True)\n    )", "code_tokens": "def get_edge_relations ( graph : BELGraph ) -> Mapping [ Tuple [ BaseEntity , BaseEntity ] , Set [ str ] ] : return group_dict_set ( ( ( u , v ) , d [ RELATION ] ) for u , v , d in graph . edges ( data = True ) )", "docstring_tokens": "Build a dictionary of { node pair : set of edge types } .", "label": 0}, {"idx": "cosqa-train-18449", "doc": "condense multiple lists to single list python", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 0}, {"idx": "cosqa-train-18450", "doc": "python calculate bounding sphere from points", "code": "def arcball_map_to_sphere(point, center, radius):\n    \"\"\"Return unit sphere coordinates from window coordinates.\"\"\"\n    v0 = (point[0] - center[0]) / radius\n    v1 = (center[1] - point[1]) / radius\n    n = v0*v0 + v1*v1\n    if n > 1.0:\n        # position outside of sphere\n        n = math.sqrt(n)\n        return numpy.array([v0/n, v1/n, 0.0])\n    else:\n        return numpy.array([v0, v1, math.sqrt(1.0 - n)])", "code_tokens": "def arcball_map_to_sphere ( point , center , radius ) : v0 = ( point [ 0 ] - center [ 0 ] ) / radius v1 = ( center [ 1 ] - point [ 1 ] ) / radius n = v0 * v0 + v1 * v1 if n > 1.0 : # position outside of sphere n = math . sqrt ( n ) return numpy . array ( [ v0 / n , v1 / n , 0.0 ] ) else : return numpy . array ( [ v0 , v1 , math . sqrt ( 1.0 - n ) ] )", "docstring_tokens": "Return unit sphere coordinates from window coordinates .", "label": 1}, {"idx": "cosqa-train-18451", "doc": "python configuration file check if it exsists", "code": "def file_exists(self) -> bool:\n        \"\"\" Check if the settings file exists or not \"\"\"\n        cfg_path = self.file_path\n        assert cfg_path\n\n        return path.isfile(cfg_path)", "code_tokens": "def file_exists ( self ) -> bool : cfg_path = self . file_path assert cfg_path return path . isfile ( cfg_path )", "docstring_tokens": "Check if the settings file exists or not", "label": 0}, {"idx": "cosqa-train-18452", "doc": "python3 os' has no attribute 'getuid'", "code": "def local_machine_uuid():\n    \"\"\"Return local machine unique identifier.\n\n    >>> uuid = local_machine_uuid()\n\n    \"\"\"\n\n    result = subprocess.check_output(\n        'hal-get-property --udi '\n        '/org/freedesktop/Hal/devices/computer '\n        '--key system.hardware.uuid'.split()\n        ).strip()\n\n    return uuid.UUID(hex=result)", "code_tokens": "def local_machine_uuid ( ) : result = subprocess . check_output ( 'hal-get-property --udi ' '/org/freedesktop/Hal/devices/computer ' '--key system.hardware.uuid' . split ( ) ) . strip ( ) return uuid . UUID ( hex = result )", "docstring_tokens": "Return local machine unique identifier .", "label": 0}, {"idx": "cosqa-train-18453", "doc": "write a function checking whether a number is prime or not python using def", "code": "def is_prime(n):\n    \"\"\"\n    Check if n is a prime number\n    \"\"\"\n    if n % 2 == 0 and n > 2:\n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))", "code_tokens": "def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "docstring_tokens": "Check if n is a prime number", "label": 0}, {"idx": "cosqa-train-18454", "doc": "pop will remove popped up items in python", "code": "def __setitem__(self, *args, **kwargs):\n        \"\"\" Cut if needed. \"\"\"\n        super(History, self).__setitem__(*args, **kwargs)\n        if len(self) > self.size:\n            self.popitem(False)", "code_tokens": "def __setitem__ ( self , * args , * * kwargs ) : super ( History , self ) . __setitem__ ( * args , * * kwargs ) if len ( self ) > self . size : self . popitem ( False )", "docstring_tokens": "Cut if needed .", "label": 0}, {"idx": "cosqa-train-18455", "doc": "how to split a word with no whitespaceinto a list in python", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 0}, {"idx": "cosqa-train-18456", "doc": "if any true in array return true python", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 1}, {"idx": "cosqa-train-18457", "doc": "printing out the leaves of a tree in python", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-18458", "doc": "python get adb devices id", "code": "def list_adb_devices_by_usb_id():\n    \"\"\"List the usb id of all android devices connected to the computer that\n    are detected by adb.\n\n    Returns:\n        A list of strings that are android device usb ids. Empty if there's\n        none.\n    \"\"\"\n    out = adb.AdbProxy().devices(['-l'])\n    clean_lines = new_str(out, 'utf-8').strip().split('\\n')\n    results = []\n    for line in clean_lines:\n        tokens = line.strip().split()\n        if len(tokens) > 2 and tokens[1] == 'device':\n            results.append(tokens[2])\n    return results", "code_tokens": "def list_adb_devices_by_usb_id ( ) : out = adb . AdbProxy ( ) . devices ( [ '-l' ] ) clean_lines = new_str ( out , 'utf-8' ) . strip ( ) . split ( '\\n' ) results = [ ] for line in clean_lines : tokens = line . strip ( ) . split ( ) if len ( tokens ) > 2 and tokens [ 1 ] == 'device' : results . append ( tokens [ 2 ] ) return results", "docstring_tokens": "List the usb id of all android devices connected to the computer that are detected by adb .", "label": 0}, {"idx": "cosqa-train-18459", "doc": "lowercase + string object + python", "code": "def snake_case(a_string):\n    \"\"\"Returns a snake cased version of a string.\n\n    :param a_string: any :class:`str` object.\n\n    Usage:\n        >>> snake_case('FooBar')\n        \"foo_bar\"\n    \"\"\"\n\n    partial = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', a_string)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', partial).lower()", "code_tokens": "def snake_case ( a_string ) : partial = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , a_string ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , partial ) . lower ( )", "docstring_tokens": "Returns a snake cased version of a string .", "label": 1}, {"idx": "cosqa-train-18460", "doc": "check if file exist in key python", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 1}, {"idx": "cosqa-train-18461", "doc": "python decode protobuf without proto", "code": "def decode(self, bytes, raw=False):\n        \"\"\"decode(bytearray, raw=False) -> value\n\n        Decodes the given bytearray according to this PrimitiveType\n        definition.\n\n        NOTE: The parameter ``raw`` is present to adhere to the\n        ``decode()`` inteface, but has no effect for PrimitiveType\n        definitions.\n        \"\"\"\n        return struct.unpack(self.format, buffer(bytes))[0]", "code_tokens": "def decode ( self , bytes , raw = False ) : return struct . unpack ( self . format , buffer ( bytes ) ) [ 0 ]", "docstring_tokens": "decode ( bytearray raw = False ) - > value", "label": 1}, {"idx": "cosqa-train-18462", "doc": "python docstring specify yield type", "code": "def returns(self) -> T.Optional[DocstringReturns]:\n        \"\"\"Return return information indicated in docstring.\"\"\"\n        try:\n            return next(\n                DocstringReturns.from_meta(meta)\n                for meta in self.meta\n                if meta.args[0] in {\"return\", \"returns\", \"yield\", \"yields\"}\n            )\n        except StopIteration:\n            return None", "code_tokens": "def returns ( self ) -> T . Optional [ DocstringReturns ] : try : return next ( DocstringReturns . from_meta ( meta ) for meta in self . meta if meta . args [ 0 ] in { \"return\" , \"returns\" , \"yield\" , \"yields\" } ) except StopIteration : return None", "docstring_tokens": "Return return information indicated in docstring .", "label": 1}, {"idx": "cosqa-train-18463", "doc": "python add element for a set", "code": "def dict_of_sets_add(dictionary, key, value):\n    # type: (DictUpperBound, Any, Any) -> None\n    \"\"\"Add value to a set in a dictionary by key\n\n    Args:\n        dictionary (DictUpperBound): Dictionary to which to add values\n        key (Any): Key within dictionary\n        value (Any): Value to add to set in dictionary\n\n    Returns:\n        None\n\n    \"\"\"\n    set_objs = dictionary.get(key, set())\n    set_objs.add(value)\n    dictionary[key] = set_objs", "code_tokens": "def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "docstring_tokens": "Add value to a set in a dictionary by key", "label": 1}, {"idx": "cosqa-train-18464", "doc": "python first index of a list that validates a condition", "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:\n    \"\"\"\n    Finds the index of an item in list, which satisfies predicate\n    :param predicateFn: predicate function to run on items of list\n    :param items: list of tuples\n    :return: first index for which predicate function returns True\n    \"\"\"\n    try:\n        return next(i for i, v in enumerate(items) if predicateFn(v))\n    except StopIteration:\n        return -1", "code_tokens": "def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "docstring_tokens": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True", "label": 1}, {"idx": "cosqa-train-18465", "doc": "list azure containers with specific name type using python", "code": "def running_containers(name_filter: str) -> List[str]:\n    \"\"\"\n    :raises docker.exceptions.APIError\n    \"\"\"\n    return [container.short_id for container in\n            docker_client.containers.list(filters={\"name\": name_filter})]", "code_tokens": "def running_containers ( name_filter : str ) -> List [ str ] : return [ container . short_id for container in docker_client . containers . list ( filters = { \"name\" : name_filter } ) ]", "docstring_tokens": ": raises docker . exceptions . APIError", "label": 1}, {"idx": "cosqa-train-18466", "doc": "python return index of item in list satisfying a condition", "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:\n    \"\"\"\n    Finds the index of an item in list, which satisfies predicate\n    :param predicateFn: predicate function to run on items of list\n    :param items: list of tuples\n    :return: first index for which predicate function returns True\n    \"\"\"\n    try:\n        return next(i for i, v in enumerate(items) if predicateFn(v))\n    except StopIteration:\n        return -1", "code_tokens": "def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "docstring_tokens": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True", "label": 1}, {"idx": "cosqa-train-18467", "doc": "how to print size of tensor in python in tensorflow", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 1}, {"idx": "cosqa-train-18468", "doc": "how to get the top values in a dictionary for python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 1}, {"idx": "cosqa-train-18469", "doc": "check if float has some value python", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 0}, {"idx": "cosqa-train-18470", "doc": "last elemnts of a list in python", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 1}, {"idx": "cosqa-train-18471", "doc": "python numpy fill arraw with sine wave", "code": "def constant(times: np.ndarray, amp: complex) -> np.ndarray:\n    \"\"\"Continuous constant pulse.\n\n    Args:\n        times: Times to output pulse for.\n        amp: Complex pulse amplitude.\n    \"\"\"\n    return np.full(len(times), amp, dtype=np.complex_)", "code_tokens": "def constant ( times : np . ndarray , amp : complex ) -> np . ndarray : return np . full ( len ( times ) , amp , dtype = np . complex_ )", "docstring_tokens": "Continuous constant pulse .", "label": 1}, {"idx": "cosqa-train-18472", "doc": "how to do normalcdf on python", "code": "def normcdf(x, log=False):\n    \"\"\"Normal cumulative density function.\"\"\"\n    y = np.atleast_1d(x).copy()\n    flib.normcdf(y)\n    if log:\n        if (y>0).all():\n            return np.log(y)\n        return -np.inf\n    return y", "code_tokens": "def normcdf ( x , log = False ) : y = np . atleast_1d ( x ) . copy ( ) flib . normcdf ( y ) if log : if ( y > 0 ) . all ( ) : return np . log ( y ) return - np . inf return y", "docstring_tokens": "Normal cumulative density function .", "label": 0}, {"idx": "cosqa-train-18473", "doc": "python multiple string substitutions", "code": "def replaceStrs(s, *args):\n    r\"\"\"Replace all ``(frm, to)`` tuples in `args` in string `s`.\n\n    >>> replaceStrs(\"nothing is better than warm beer\",\n    ...             ('nothing','warm beer'), ('warm beer','nothing'))\n    'warm beer is better than nothing'\n\n    \"\"\"\n    if args == (): return s\n    mapping = dict((frm, to) for frm, to in args)\n    return re.sub(\"|\".join(map(re.escape, mapping.keys())),\n                  lambda match:mapping[match.group(0)], s)", "code_tokens": "def replaceStrs ( s , * args ) : if args == ( ) : return s mapping = dict ( ( frm , to ) for frm , to in args ) return re . sub ( \"|\" . join ( map ( re . escape , mapping . keys ( ) ) ) , lambda match : mapping [ match . group ( 0 ) ] , s )", "docstring_tokens": "r Replace all ( frm to ) tuples in args in string s .", "label": 1}, {"idx": "cosqa-train-18474", "doc": "python if variable type is not str", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 1}, {"idx": "cosqa-train-18475", "doc": "how to bitmask python", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-18476", "doc": "python filter a dictionary key,valyue", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 1}, {"idx": "cosqa-train-18477", "doc": "python if type is a string", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 1}, {"idx": "cosqa-train-18478", "doc": "how to determine the index interval for given range of array python", "code": "def _infer_interval_breaks(coord):\n    \"\"\"\n    >>> _infer_interval_breaks(np.arange(5))\n    array([-0.5,  0.5,  1.5,  2.5,  3.5,  4.5])\n\n    Taken from xarray.plotting.plot module\n    \"\"\"\n    coord = np.asarray(coord)\n    deltas = 0.5 * (coord[1:] - coord[:-1])\n    first = coord[0] - deltas[0]\n    last = coord[-1] + deltas[-1]\n    return np.r_[[first], coord[:-1] + deltas, [last]]", "code_tokens": "def _infer_interval_breaks ( coord ) : coord = np . asarray ( coord ) deltas = 0.5 * ( coord [ 1 : ] - coord [ : - 1 ] ) first = coord [ 0 ] - deltas [ 0 ] last = coord [ - 1 ] + deltas [ - 1 ] return np . r_ [ [ first ] , coord [ : - 1 ] + deltas , [ last ] ]", "docstring_tokens": ">>> _infer_interval_breaks ( np . arange ( 5 )) array ( [ - 0 . 5 0 . 5 1 . 5 2 . 5 3 . 5 4 . 5 ] )", "label": 1}, {"idx": "cosqa-train-18479", "doc": "log of zero define in python", "code": "def _protected_log(x1):\n    \"\"\"Closure of log for zero arguments.\"\"\"\n    with np.errstate(divide='ignore', invalid='ignore'):\n        return np.where(np.abs(x1) > 0.001, np.log(np.abs(x1)), 0.)", "code_tokens": "def _protected_log ( x1 ) : with np . errstate ( divide = 'ignore' , invalid = 'ignore' ) : return np . where ( np . abs ( x1 ) > 0.001 , np . log ( np . abs ( x1 ) ) , 0. )", "docstring_tokens": "Closure of log for zero arguments .", "label": 0}, {"idx": "cosqa-train-18480", "doc": "check to see if a value in directory is empty in python", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 0}, {"idx": "cosqa-train-18481", "doc": "python if file larger than", "code": "def check_max_filesize(chosen_file, max_size):\n    \"\"\"\n    Checks file sizes for host\n    \"\"\"\n    if os.path.getsize(chosen_file) > max_size:\n        return False\n    else:\n        return True", "code_tokens": "def check_max_filesize ( chosen_file , max_size ) : if os . path . getsize ( chosen_file ) > max_size : return False else : return True", "docstring_tokens": "Checks file sizes for host", "label": 0}, {"idx": "cosqa-train-18482", "doc": "how to display a dictionary with extra indentation python", "code": "def pretty_describe(object, nestedness=0, indent=2):\n    \"\"\"Maintain dict ordering - but make string version prettier\"\"\"\n    if not isinstance(object, dict):\n        return str(object)\n    sep = f'\\n{\" \" * nestedness * indent}'\n    out = sep.join((f'{k}: {pretty_describe(v, nestedness + 1)}' for k, v in object.items()))\n    if nestedness > 0 and out:\n        return f'{sep}{out}'\n    return out", "code_tokens": "def pretty_describe ( object , nestedness = 0 , indent = 2 ) : if not isinstance ( object , dict ) : return str ( object ) sep = f'\\n{\" \" * nestedness * indent}' out = sep . join ( ( f'{k}: {pretty_describe(v, nestedness + 1)}' for k , v in object . items ( ) ) ) if nestedness > 0 and out : return f'{sep}{out}' return out", "docstring_tokens": "Maintain dict ordering - but make string version prettier", "label": 0}, {"idx": "cosqa-train-18483", "doc": "how to indent a line of text in python", "code": "def indent(text: str, num: int = 2) -> str:\n    \"\"\"Indent a piece of text.\"\"\"\n    lines = text.splitlines()\n    return \"\\n\".join(indent_iterable(lines, num=num))", "code_tokens": "def indent ( text : str , num : int = 2 ) -> str : lines = text . splitlines ( ) return \"\\n\" . join ( indent_iterable ( lines , num = num ) )", "docstring_tokens": "Indent a piece of text .", "label": 1}, {"idx": "cosqa-train-18484", "doc": "to check if a set is empty in python", "code": "def is_any_type_set(sett: Set[Type]) -> bool:\n    \"\"\"\n    Helper method to check if a set of types is the {AnyObject} singleton\n\n    :param sett:\n    :return:\n    \"\"\"\n    return len(sett) == 1 and is_any_type(min(sett))", "code_tokens": "def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )", "docstring_tokens": "Helper method to check if a set of types is the { AnyObject } singleton", "label": 1}, {"idx": "cosqa-train-18485", "doc": "python dict from another dict", "code": "def extend(a: dict, b: dict) -> dict:\n    \"\"\"Merge two dicts and return a new dict. Much like subclassing works.\"\"\"\n    res = a.copy()\n    res.update(b)\n    return res", "code_tokens": "def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res", "docstring_tokens": "Merge two dicts and return a new dict . Much like subclassing works .", "label": 0}, {"idx": "cosqa-train-18486", "doc": "date time from string python", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 0}, {"idx": "cosqa-train-18487", "doc": "how to check in python if token is person or not", "code": "def contains(self, token: str) -> bool:\n        \"\"\"Return if the token is in the list or not.\"\"\"\n        self._validate_token(token)\n        return token in self", "code_tokens": "def contains ( self , token : str ) -> bool : self . _validate_token ( token ) return token in self", "docstring_tokens": "Return if the token is in the list or not .", "label": 1}, {"idx": "cosqa-train-18488", "doc": "read the last line/raw of file in python", "code": "def _read_section(self):\n        \"\"\"Read and return an entire section\"\"\"\n        lines = [self._last[self._last.find(\":\")+1:]]\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            lines.append(self._last)\n            self._last = self._f.readline()\n        return lines", "code_tokens": "def _read_section ( self ) : lines = [ self . _last [ self . _last . find ( \":\" ) + 1 : ] ] self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : lines . append ( self . _last ) self . _last = self . _f . readline ( ) return lines", "docstring_tokens": "Read and return an entire section", "label": 0}, {"idx": "cosqa-train-18489", "doc": "time a function using timeit python", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 0}, {"idx": "cosqa-train-18490", "doc": "python if any element in array meets conditions", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 0}, {"idx": "cosqa-train-18491", "doc": "how to name enum python", "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum:\n    \"\"\"\n    Converts an ``dict`` to a ``Enum``.\n    \"\"\"\n    return enum_class[d['name']]", "code_tokens": "def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "docstring_tokens": "Converts an dict to a Enum .", "label": 0}, {"idx": "cosqa-train-18492", "doc": "python protobuf from byte array", "code": "def decode(self, bytes, raw=False):\n        \"\"\"decode(bytearray, raw=False) -> value\n\n        Decodes the given bytearray according to this PrimitiveType\n        definition.\n\n        NOTE: The parameter ``raw`` is present to adhere to the\n        ``decode()`` inteface, but has no effect for PrimitiveType\n        definitions.\n        \"\"\"\n        return struct.unpack(self.format, buffer(bytes))[0]", "code_tokens": "def decode ( self , bytes , raw = False ) : return struct . unpack ( self . format , buffer ( bytes ) ) [ 0 ]", "docstring_tokens": "decode ( bytearray raw = False ) - > value", "label": 1}, {"idx": "cosqa-train-18493", "doc": "python detect if path is valid", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-18494", "doc": "python generate hash of list", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 1}, {"idx": "cosqa-train-18495", "doc": "python base64 encoded missing padding", "code": "def decode_base64(data: str) -> bytes:\n    \"\"\"Decode base64, padding being optional.\n\n    :param data: Base64 data as an ASCII byte string\n    :returns: The decoded byte string.\n    \"\"\"\n    missing_padding = len(data) % 4\n    if missing_padding != 0:\n        data += \"=\" * (4 - missing_padding)\n    return base64.decodebytes(data.encode(\"utf-8\"))", "code_tokens": "def decode_base64 ( data : str ) -> bytes : missing_padding = len ( data ) % 4 if missing_padding != 0 : data += \"=\" * ( 4 - missing_padding ) return base64 . decodebytes ( data . encode ( \"utf-8\" ) )", "docstring_tokens": "Decode base64 padding being optional .", "label": 0}, {"idx": "cosqa-train-18496", "doc": "is python string comparison case sensitive", "code": "def lowercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the lowercase chars in the given string.\"\"\"\n        return ''.join([c if c.islower() else '' for c in str(string)])", "code_tokens": "def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the lowercase chars in the given string .", "label": 0}, {"idx": "cosqa-train-18497", "doc": "determine a file exist or not python", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 1}, {"idx": "cosqa-train-18498", "doc": "treeview row selection python", "code": "def get_view_selection(self):\n        \"\"\"Get actual tree selection object and all respective models of selected rows\"\"\"\n        if not self.MODEL_STORAGE_ID:\n            return None, None\n\n        # avoid selection requests on empty tree views -> case warnings in gtk3\n        if len(self.store) == 0:\n            paths = []\n        else:\n            model, paths = self._tree_selection.get_selected_rows()\n\n        # get all related models for selection from respective tree store field\n        selected_model_list = []\n        for path in paths:\n            model = self.store[path][self.MODEL_STORAGE_ID]\n            selected_model_list.append(model)\n        return self._tree_selection, selected_model_list", "code_tokens": "def get_view_selection ( self ) : if not self . MODEL_STORAGE_ID : return None , None # avoid selection requests on empty tree views -> case warnings in gtk3 if len ( self . store ) == 0 : paths = [ ] else : model , paths = self . _tree_selection . get_selected_rows ( ) # get all related models for selection from respective tree store field selected_model_list = [ ] for path in paths : model = self . store [ path ] [ self . MODEL_STORAGE_ID ] selected_model_list . append ( model ) return self . _tree_selection , selected_model_list", "docstring_tokens": "Get actual tree selection object and all respective models of selected rows", "label": 1}, {"idx": "cosqa-train-18499", "doc": "python dir to show public attributes", "code": "def public(self) -> 'PrettyDir':\n        \"\"\"Returns public attributes of the inspected object.\"\"\"\n        return PrettyDir(\n            self.obj, [pattr for pattr in self.pattrs if not pattr.name.startswith('_')]\n        )", "code_tokens": "def public ( self ) -> 'PrettyDir' : return PrettyDir ( self . obj , [ pattr for pattr in self . pattrs if not pattr . name . startswith ( '_' ) ] )", "docstring_tokens": "Returns public attributes of the inspected object .", "label": 1}, {"idx": "cosqa-train-18500", "doc": "delete a column in python db", "code": "def drop_column(self, tablename: str, fieldname: str) -> int:\n        \"\"\"Drops (deletes) a column from an existing table.\"\"\"\n        sql = \"ALTER TABLE {} DROP COLUMN {}\".format(tablename, fieldname)\n        log.info(sql)\n        return self.db_exec_literal(sql)", "code_tokens": "def drop_column ( self , tablename : str , fieldname : str ) -> int : sql = \"ALTER TABLE {} DROP COLUMN {}\" . format ( tablename , fieldname ) log . info ( sql ) return self . db_exec_literal ( sql )", "docstring_tokens": "Drops ( deletes ) a column from an existing table .", "label": 1}, {"idx": "cosqa-train-18501", "doc": "python mssql send query that uses in tuple", "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None:\n        \"\"\"Execute the given multiquery.\"\"\"\n        await self._execute(self._cursor.executemany, sql, parameters)", "code_tokens": "async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "docstring_tokens": "Execute the given multiquery .", "label": 1}, {"idx": "cosqa-train-18502", "doc": "how to have python skip empty lines", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 1}, {"idx": "cosqa-train-18503", "doc": "how to define output path in python", "code": "def output_dir(self, *args) -> str:\n        \"\"\" Directory where to store output \"\"\"\n        return os.path.join(self.project_dir, 'output', *args)", "code_tokens": "def output_dir ( self , * args ) -> str : return os . path . join ( self . project_dir , 'output' , * args )", "docstring_tokens": "Directory where to store output", "label": 1}, {"idx": "cosqa-train-18504", "doc": "python array to tensor", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 0}, {"idx": "cosqa-train-18505", "doc": "set python path for pylint", "code": "def get_pylint_options(config_dir='.'):\n    # type: (str) -> List[str]\n    \"\"\"Checks for local config overrides for `pylint`\n    and add them in the correct `pylint` `options` format.\n\n    :param config_dir:\n    :return: List [str]\n    \"\"\"\n    if PYLINT_CONFIG_NAME in os.listdir(config_dir):\n        pylint_config_path = PYLINT_CONFIG_NAME\n    else:\n        pylint_config_path = DEFAULT_PYLINT_CONFIG_PATH\n\n    return ['--rcfile={}'.format(pylint_config_path)]", "code_tokens": "def get_pylint_options ( config_dir = '.' ) : # type: (str) -> List[str] if PYLINT_CONFIG_NAME in os . listdir ( config_dir ) : pylint_config_path = PYLINT_CONFIG_NAME else : pylint_config_path = DEFAULT_PYLINT_CONFIG_PATH return [ '--rcfile={}' . format ( pylint_config_path ) ]", "docstring_tokens": "Checks for local config overrides for pylint and add them in the correct pylint options format .", "label": 1}, {"idx": "cosqa-train-18506", "doc": "passing python object as a string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 0}, {"idx": "cosqa-train-18507", "doc": "python spider memery usage not stop growing", "code": "def _check_limit(self):\n        \"\"\"Intenal method: check if current cache size exceeds maximum cache\n           size and pop the oldest item in this case\"\"\"\n\n        # First compress\n        self._compress()\n\n        # Then check the max size\n        if len(self._store) >= self._max_size:\n            self._store.popitem(last=False)", "code_tokens": "def _check_limit ( self ) : # First compress self . _compress ( ) # Then check the max size if len ( self . _store ) >= self . _max_size : self . _store . popitem ( last = False )", "docstring_tokens": "Intenal method : check if current cache size exceeds maximum cache size and pop the oldest item in this case", "label": 0}, {"idx": "cosqa-train-18508", "doc": "how to reurn the key for a largest value in python", "code": "def get_default_bucket_key(buckets: List[Tuple[int, int]]) -> Tuple[int, int]:\n    \"\"\"\n    Returns the default bucket from a list of buckets, i.e. the largest bucket.\n\n    :param buckets: List of buckets.\n    :return: The largest bucket in the list.\n    \"\"\"\n    return max(buckets)", "code_tokens": "def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )", "docstring_tokens": "Returns the default bucket from a list of buckets i . e . the largest bucket .", "label": 1}, {"idx": "cosqa-train-18509", "doc": "max size of a key in python", "code": "def codes_get_size(handle, key):\n    # type: (cffi.FFI.CData, str) -> int\n    \"\"\"\n    Get the number of coded value from a key.\n    If several keys of the same name are present, the total sum is returned.\n\n    :param bytes key: the keyword to get the size of\n\n    :rtype: int\n    \"\"\"\n    size = ffi.new('size_t *')\n    _codes_get_size(handle, key.encode(ENC), size)\n    return size[0]", "code_tokens": "def codes_get_size ( handle , key ) : # type: (cffi.FFI.CData, str) -> int size = ffi . new ( 'size_t *' ) _codes_get_size ( handle , key . encode ( ENC ) , size ) return size [ 0 ]", "docstring_tokens": "Get the number of coded value from a key . If several keys of the same name are present the total sum is returned .", "label": 1}, {"idx": "cosqa-train-18510", "doc": "pythong 3 covert str to int", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 0}, {"idx": "cosqa-train-18511", "doc": "python remove all xml namespaces", "code": "def remove_namespaces(root):\n    \"\"\"Call this on an lxml.etree document to remove all namespaces\"\"\"\n    for elem in root.getiterator():\n        if not hasattr(elem.tag, 'find'):\n            continue\n\n        i = elem.tag.find('}')\n        if i >= 0:\n            elem.tag = elem.tag[i + 1:]\n\n    objectify.deannotate(root, cleanup_namespaces=True)", "code_tokens": "def remove_namespaces ( root ) : for elem in root . getiterator ( ) : if not hasattr ( elem . tag , 'find' ) : continue i = elem . tag . find ( '}' ) if i >= 0 : elem . tag = elem . tag [ i + 1 : ] objectify . deannotate ( root , cleanup_namespaces = True )", "docstring_tokens": "Call this on an lxml . etree document to remove all namespaces", "label": 1}, {"idx": "cosqa-train-18512", "doc": "clear whitespace python string", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 0}, {"idx": "cosqa-train-18513", "doc": "how to print few element of a list in python", "code": "def _brief_print_list(lst, limit=7):\n    \"\"\"Print at most `limit` elements of list.\"\"\"\n    lst = list(lst)\n    if len(lst) > limit:\n        return _brief_print_list(lst[:limit//2], limit) + ', ..., ' + \\\n            _brief_print_list(lst[-limit//2:], limit)\n    return ', '.join([\"'%s'\"%str(i) for i in lst])", "code_tokens": "def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "docstring_tokens": "Print at most limit elements of list .", "label": 0}, {"idx": "cosqa-train-18514", "doc": "python check if file has a specific line", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 0}, {"idx": "cosqa-train-18515", "doc": "values in bytearray should be integers between python", "code": "def convert_bytes_to_ints(in_bytes, num):\n    \"\"\"Convert a byte array into an integer array. The number of bytes forming an integer\n    is defined by num\n\n    :param in_bytes: the input bytes\n    :param num: the number of bytes per int\n    :return the integer array\"\"\"\n    dt = numpy.dtype('>i' + str(num))\n    return numpy.frombuffer(in_bytes, dt)", "code_tokens": "def convert_bytes_to_ints ( in_bytes , num ) : dt = numpy . dtype ( '>i' + str ( num ) ) return numpy . frombuffer ( in_bytes , dt )", "docstring_tokens": "Convert a byte array into an integer array . The number of bytes forming an integer is defined by num", "label": 1}, {"idx": "cosqa-train-18516", "doc": "python string zero fill", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 0}, {"idx": "cosqa-train-18517", "doc": "how to return a string formed by concatenating all the elements in a list in python", "code": "def list_to_str(lst):\n    \"\"\"\n    Turn a list into a comma- and/or and-separated string.\n\n    Parameters\n    ----------\n    lst : :obj:`list`\n        A list of strings to join into a single string.\n\n    Returns\n    -------\n    str_ : :obj:`str`\n        A string with commas and/or ands separating th elements from ``lst``.\n\n    \"\"\"\n    if len(lst) == 1:\n        str_ = lst[0]\n    elif len(lst) == 2:\n        str_ = ' and '.join(lst)\n    elif len(lst) > 2:\n        str_ = ', '.join(lst[:-1])\n        str_ += ', and {0}'.format(lst[-1])\n    else:\n        raise ValueError('List of length 0 provided.')\n    return str_", "code_tokens": "def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "docstring_tokens": "Turn a list into a comma - and / or and - separated string .", "label": 0}, {"idx": "cosqa-train-18518", "doc": "reading csv as numpy array in python", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 1}, {"idx": "cosqa-train-18519", "doc": "how to get first few rows in python", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 1}, {"idx": "cosqa-train-18520", "doc": "python return based on first digit of string", "code": "def first_digits(s, default=0):\n    \"\"\"Return the fist (left-hand) digits in a string as a single integer, ignoring sign (+/-).\n    >>> first_digits('+123.456')\n    123\n    \"\"\"\n    s = re.split(r'[^0-9]+', str(s).strip().lstrip('+-' + charlist.whitespace))\n    if len(s) and len(s[0]):\n        return int(s[0])\n    return default", "code_tokens": "def first_digits ( s , default = 0 ) : s = re . split ( r'[^0-9]+' , str ( s ) . strip ( ) . lstrip ( '+-' + charlist . whitespace ) ) if len ( s ) and len ( s [ 0 ] ) : return int ( s [ 0 ] ) return default", "docstring_tokens": "Return the fist ( left - hand ) digits in a string as a single integer ignoring sign ( + / - ) . >>> first_digits ( + 123 . 456 ) 123", "label": 1}, {"idx": "cosqa-train-18521", "doc": "turn string into uppercase python", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 0}, {"idx": "cosqa-train-18522", "doc": "python exit thread in advance", "code": "def _exit(self, status_code):\n        \"\"\"Properly kill Python process including zombie threads.\"\"\"\n        # If there are active threads still running infinite loops, sys.exit\n        # won't kill them but os._exit will. os._exit skips calling cleanup\n        # handlers, flushing stdio buffers, etc.\n        exit_func = os._exit if threading.active_count() > 1 else sys.exit\n        exit_func(status_code)", "code_tokens": "def _exit ( self , status_code ) : # If there are active threads still running infinite loops, sys.exit # won't kill them but os._exit will. os._exit skips calling cleanup # handlers, flushing stdio buffers, etc. exit_func = os . _exit if threading . active_count ( ) > 1 else sys . exit exit_func ( status_code )", "docstring_tokens": "Properly kill Python process including zombie threads .", "label": 0}, {"idx": "cosqa-train-18523", "doc": "how to check character type in python", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 0}, {"idx": "cosqa-train-18524", "doc": "python from string to enum", "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum:\n    \"\"\"\n    Converts an ``dict`` to a ``Enum``.\n    \"\"\"\n    return enum_class[d['name']]", "code_tokens": "def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "docstring_tokens": "Converts an dict to a Enum .", "label": 0}, {"idx": "cosqa-train-18525", "doc": "how to get % frequencies python", "code": "def _relative_frequency(self, word):\n\t\t\"\"\"Computes the log relative frequency for a word form\"\"\"\n\n\t\tcount = self.type_counts.get(word, 0)\n\t\treturn math.log(count/len(self.type_counts)) if count > 0 else 0", "code_tokens": "def _relative_frequency ( self , word ) : count = self . type_counts . get ( word , 0 ) return math . log ( count / len ( self . type_counts ) ) if count > 0 else 0", "docstring_tokens": "Computes the log relative frequency for a word form", "label": 1}, {"idx": "cosqa-train-18526", "doc": "python variable replacement in string", "code": "def replace_variables(self, source: str, variables: dict) -> str:\n        \"\"\"Replace {{variable-name}} with stored value.\"\"\"\n        try:\n            replaced = re.sub(\n                \"{{(.*?)}}\", lambda m: variables.get(m.group(1), \"\"), source\n            )\n        except TypeError:\n            replaced = source\n        return replaced", "code_tokens": "def replace_variables ( self , source : str , variables : dict ) -> str : try : replaced = re . sub ( \"{{(.*?)}}\" , lambda m : variables . get ( m . group ( 1 ) , \"\" ) , source ) except TypeError : replaced = source return replaced", "docstring_tokens": "Replace {{ variable - name }} with stored value .", "label": 1}, {"idx": "cosqa-train-18527", "doc": "python create dict of index and item of list", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 0}, {"idx": "cosqa-train-18528", "doc": "python how to add to kwargs if not present", "code": "def update_kwargs(kwargs, **keyvalues):\n    \"\"\"Update dict with keys and values if keys do not already exist.\n\n    >>> kwargs = {'one': 1, }\n    >>> update_kwargs(kwargs, one=None, two=2)\n    >>> kwargs == {'one': 1, 'two': 2}\n    True\n\n    \"\"\"\n    for key, value in keyvalues.items():\n        if key not in kwargs:\n            kwargs[key] = value", "code_tokens": "def update_kwargs ( kwargs , * * keyvalues ) : for key , value in keyvalues . items ( ) : if key not in kwargs : kwargs [ key ] = value", "docstring_tokens": "Update dict with keys and values if keys do not already exist .", "label": 0}, {"idx": "cosqa-train-18529", "doc": "python mysqldb executemany thread", "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None:\n        \"\"\"Execute the given multiquery.\"\"\"\n        await self._execute(self._cursor.executemany, sql, parameters)", "code_tokens": "async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "docstring_tokens": "Execute the given multiquery .", "label": 0}, {"idx": "cosqa-train-18530", "doc": "python reader skip header line", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 0}, {"idx": "cosqa-train-18531", "doc": "python flatten a nested dictionaary", "code": "def flatten_multidict(multidict):\n    \"\"\"Return flattened dictionary from ``MultiDict``.\"\"\"\n    return dict([(key, value if len(value) > 1 else value[0])\n                 for (key, value) in multidict.iterlists()])", "code_tokens": "def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "docstring_tokens": "Return flattened dictionary from MultiDict .", "label": 1}, {"idx": "cosqa-train-18532", "doc": "python check if 2 paths are the same", "code": "def samefile(a: str, b: str) -> bool:\n    \"\"\"Check if two pathes represent the same file.\"\"\"\n    try:\n        return os.path.samefile(a, b)\n    except OSError:\n        return os.path.normpath(a) == os.path.normpath(b)", "code_tokens": "def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )", "docstring_tokens": "Check if two pathes represent the same file .", "label": 0}, {"idx": "cosqa-train-18533", "doc": "python check if doesn't exist", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 0}, {"idx": "cosqa-train-18534", "doc": "crawl async data with python asyncio", "code": "async def parallel_results(future_map: Sequence[Tuple]) -> Dict:\n    \"\"\"\n    Run parallel execution of futures and return mapping of their results to the provided keys.\n    Just a neat shortcut around ``asyncio.gather()``\n\n    :param future_map: Keys to futures mapping, e.g.: ( ('nav', get_nav()), ('content, get_content()) )\n    :return: Dict with futures results mapped to keys {'nav': {1:2}, 'content': 'xyz'}\n    \"\"\"\n    ctx_methods = OrderedDict(future_map)\n    fs = list(ctx_methods.values())\n    results = await asyncio.gather(*fs)\n    results = {\n        key: results[idx] for idx, key in enumerate(ctx_methods.keys())\n    }\n    return results", "code_tokens": "async def parallel_results ( future_map : Sequence [ Tuple ] ) -> Dict : ctx_methods = OrderedDict ( future_map ) fs = list ( ctx_methods . values ( ) ) results = await asyncio . gather ( * fs ) results = { key : results [ idx ] for idx , key in enumerate ( ctx_methods . keys ( ) ) } return results", "docstring_tokens": "Run parallel execution of futures and return mapping of their results to the provided keys . Just a neat shortcut around asyncio . gather ()", "label": 0}, {"idx": "cosqa-train-18535", "doc": "python text to list tokenizer split", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 1}, {"idx": "cosqa-train-18536", "doc": "python 3 string to bytecode", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 0}, {"idx": "cosqa-train-18537", "doc": "python get set word synonyms", "code": "def has_synset(word: str) -> list:\n    \"\"\"\" Returns a list of synsets of a word after lemmatization. \"\"\"\n\n    return wn.synsets(lemmatize(word, neverstem=True))", "code_tokens": "def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "docstring_tokens": "Returns a list of synsets of a word after lemmatization .", "label": 1}, {"idx": "cosqa-train-18538", "doc": "read and display a text file in python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-18539", "doc": "how to time a python function", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 0}, {"idx": "cosqa-train-18540", "doc": "python lambda get self", "code": "def head(self) -> Any:\n        \"\"\"Retrive first element in List.\"\"\"\n\n        lambda_list = self._get_value()\n        return lambda_list(lambda head, _: head)", "code_tokens": "def head ( self ) -> Any : lambda_list = self . _get_value ( ) return lambda_list ( lambda head , _ : head )", "docstring_tokens": "Retrive first element in List .", "label": 0}, {"idx": "cosqa-train-18541", "doc": "python change a str to a date", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-18542", "doc": "compare against enum values in python", "code": "def has_value(cls, value: int) -> bool:\n        \"\"\"True if specified value exists in int enum; otherwise, False.\"\"\"\n        return any(value == item.value for item in cls)", "code_tokens": "def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "docstring_tokens": "True if specified value exists in int enum ; otherwise False .", "label": 0}, {"idx": "cosqa-train-18543", "doc": "turning a string into a list in python", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 1}, {"idx": "cosqa-train-18544", "doc": "truncate floats to 4 decimals in python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 1}, {"idx": "cosqa-train-18545", "doc": "stop a function from continuing python", "code": "def stop(self) -> None:\n        \"\"\"Stops the analysis as soon as possible.\"\"\"\n        if self._stop and not self._posted_kork:\n            self._stop()\n            self._stop = None", "code_tokens": "def stop ( self ) -> None : if self . _stop and not self . _posted_kork : self . _stop ( ) self . _stop = None", "docstring_tokens": "Stops the analysis as soon as possible .", "label": 1}, {"idx": "cosqa-train-18546", "doc": "how to get back to previous line in python while printing", "code": "def auto_up(self, count=1, go_to_start_of_line_if_history_changes=False):\n        \"\"\"\n        If we're not on the first line (of a multiline input) go a line up,\n        otherwise go back in history. (If nothing is selected.)\n        \"\"\"\n        if self.complete_state:\n            self.complete_previous(count=count)\n        elif self.document.cursor_position_row > 0:\n            self.cursor_up(count=count)\n        elif not self.selection_state:\n            self.history_backward(count=count)\n\n            # Go to the start of the line?\n            if go_to_start_of_line_if_history_changes:\n                self.cursor_position += self.document.get_start_of_line_position()", "code_tokens": "def auto_up ( self , count = 1 , go_to_start_of_line_if_history_changes = False ) : if self . complete_state : self . complete_previous ( count = count ) elif self . document . cursor_position_row > 0 : self . cursor_up ( count = count ) elif not self . selection_state : self . history_backward ( count = count ) # Go to the start of the line? if go_to_start_of_line_if_history_changes : self . cursor_position += self . document . get_start_of_line_position ( )", "docstring_tokens": "If we re not on the first line ( of a multiline input ) go a line up otherwise go back in history . ( If nothing is selected . )", "label": 1}, {"idx": "cosqa-train-18547", "doc": "how to shuffe columns python", "code": "def _reshuffle(mat, shape):\n    \"\"\"Reshuffle the indicies of a bipartite matrix A[ij,kl] -> A[lj,ki].\"\"\"\n    return np.reshape(\n        np.transpose(np.reshape(mat, shape), (3, 1, 2, 0)),\n        (shape[3] * shape[1], shape[0] * shape[2]))", "code_tokens": "def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )", "docstring_tokens": "Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] .", "label": 0}, {"idx": "cosqa-train-18548", "doc": "count partitions python permute", "code": "def integer_partition(size: int, nparts: int) -> Iterator[List[List[int]]]:\n    \"\"\" Partition a list of integers into a list of partitions \"\"\"\n    for part in algorithm_u(range(size), nparts):\n        yield part", "code_tokens": "def integer_partition ( size : int , nparts : int ) -> Iterator [ List [ List [ int ] ] ] : for part in algorithm_u ( range ( size ) , nparts ) : yield part", "docstring_tokens": "Partition a list of integers into a list of partitions", "label": 0}, {"idx": "cosqa-train-18549", "doc": "how do you input the exit function in python", "code": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)", "code_tokens": "def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "docstring_tokens": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting", "label": 0}, {"idx": "cosqa-train-18550", "doc": "wrapper for int or float python", "code": "def filter_float(n: Node, query: str) -> float:\n    \"\"\"\n    Filter and ensure that the returned value is of type int.\n    \"\"\"\n    return _scalariter2item(n, query, float)", "code_tokens": "def filter_float ( n : Node , query : str ) -> float : return _scalariter2item ( n , query , float )", "docstring_tokens": "Filter and ensure that the returned value is of type int .", "label": 0}, {"idx": "cosqa-train-18551", "doc": "python code for least common multiple of a list of numbers", "code": "def lcm(num1, num2):\n    \"\"\"\n    Find the lowest common multiple of 2 numbers\n\n    :type num1: number\n    :param num1: The first number to find the lcm for\n\n    :type num2: number\n    :param num2: The second number to find the lcm for\n    \"\"\"\n\n    if num1 > num2:\n        bigger = num1\n    else:\n        bigger = num2\n    while True:\n        if bigger % num1 == 0 and bigger % num2 == 0:\n            return bigger\n        bigger += 1", "code_tokens": "def lcm ( num1 , num2 ) : if num1 > num2 : bigger = num1 else : bigger = num2 while True : if bigger % num1 == 0 and bigger % num2 == 0 : return bigger bigger += 1", "docstring_tokens": "Find the lowest common multiple of 2 numbers", "label": 1}, {"idx": "cosqa-train-18552", "doc": "index of last occurence of an element in a list in python", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 1}, {"idx": "cosqa-train-18553", "doc": "python how to check if file older then", "code": "def is_up_to_date(outfile, basedatetime):\n        # type: (AnyStr, datetime) -> bool\n        \"\"\"Return true if outfile exists and is no older than base datetime.\"\"\"\n        if os.path.exists(outfile):\n            if os.path.getmtime(outfile) >= basedatetime:\n                return True\n        return False", "code_tokens": "def is_up_to_date ( outfile , basedatetime ) : # type: (AnyStr, datetime) -> bool if os . path . exists ( outfile ) : if os . path . getmtime ( outfile ) >= basedatetime : return True return False", "docstring_tokens": "Return true if outfile exists and is no older than base datetime .", "label": 1}, {"idx": "cosqa-train-18554", "doc": "python reading text file as json", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 1}, {"idx": "cosqa-train-18555", "doc": "starttime minus current time delta in python", "code": "def run_time() -> timedelta:\n    \"\"\"\n\n    :return:\n    \"\"\"\n\n    delta = start_time if start_time else datetime.utcnow()\n    return datetime.utcnow() - delta", "code_tokens": "def run_time ( ) -> timedelta : delta = start_time if start_time else datetime . utcnow ( ) return datetime . utcnow ( ) - delta", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-18556", "doc": "how to create a datetime object with a string date in python", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 1}, {"idx": "cosqa-train-18557", "doc": "python bitwise mask not turning white pixels", "code": "def negate_mask(mask):\n    \"\"\"Returns the negated mask.\n\n    If elements of input mask have 0 and non-zero values, then the returned matrix will have all elements 0 (1) where\n    the original one has non-zero (0).\n\n    :param mask: Input mask\n    :type mask: np.array\n    :return: array of same shape and dtype=int8 as input array\n    :rtype: np.array\n    \"\"\"\n    res = np.ones(mask.shape, dtype=np.int8)\n    res[mask > 0] = 0\n\n    return res", "code_tokens": "def negate_mask ( mask ) : res = np . ones ( mask . shape , dtype = np . int8 ) res [ mask > 0 ] = 0 return res", "docstring_tokens": "Returns the negated mask . If elements of input mask have 0 and non - zero values then the returned matrix will have all elements 0 ( 1 ) where the original one has non - zero ( 0 ) . : param mask : Input mask : type mask : np . array : return : array of same shape and dtype = int8 as input array : rtype : np . array", "label": 0}, {"idx": "cosqa-train-18558", "doc": "filter dictionary values in python", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-18559", "doc": "python load csv to numpy array", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 1}, {"idx": "cosqa-train-18560", "doc": "testing for empty file in python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 1}, {"idx": "cosqa-train-18561", "doc": "python 3 domain url parse", "code": "def get_domain(url):\n    \"\"\"\n    Get domain part of an url.\n\n    For example: https://www.python.org/doc/ -> https://www.python.org\n    \"\"\"\n    parse_result = urlparse(url)\n    domain = \"{schema}://{netloc}\".format(\n        schema=parse_result.scheme, netloc=parse_result.netloc)\n    return domain", "code_tokens": "def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "docstring_tokens": "Get domain part of an url .", "label": 1}, {"idx": "cosqa-train-18562", "doc": "how to determine data type of variable in python", "code": "def maybe_infer_dtype_type(element):\n    \"\"\"Try to infer an object's dtype, for use in arithmetic ops\n\n    Uses `element.dtype` if that's available.\n    Objects implementing the iterator protocol are cast to a NumPy array,\n    and from there the array's type is used.\n\n    Parameters\n    ----------\n    element : object\n        Possibly has a `.dtype` attribute, and possibly the iterator\n        protocol.\n\n    Returns\n    -------\n    tipo : type\n\n    Examples\n    --------\n    >>> from collections import namedtuple\n    >>> Foo = namedtuple(\"Foo\", \"dtype\")\n    >>> maybe_infer_dtype_type(Foo(np.dtype(\"i8\")))\n    numpy.int64\n    \"\"\"\n    tipo = None\n    if hasattr(element, 'dtype'):\n        tipo = element.dtype\n    elif is_list_like(element):\n        element = np.asarray(element)\n        tipo = element.dtype\n    return tipo", "code_tokens": "def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "docstring_tokens": "Try to infer an object s dtype for use in arithmetic ops", "label": 1}, {"idx": "cosqa-train-18563", "doc": "python measuring memory usage dynamically", "code": "def memory_usage():\n    \"\"\"return memory usage of python process in MB\n\n    from\n    http://fa.bianp.net/blog/2013/different-ways-to-get-memory-consumption-or-lessons-learned-from-memory_profiler/\n    psutil is quicker\n\n    >>> isinstance(memory_usage(),float)\n    True\n\n    \"\"\"\n    try:\n        import psutil\n        import os\n    except ImportError:\n        return _memory_usage_ps()\n\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info()[0] / float(2 ** 20)\n    return mem", "code_tokens": "def memory_usage ( ) : try : import psutil import os except ImportError : return _memory_usage_ps ( ) process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) [ 0 ] / float ( 2 ** 20 ) return mem", "docstring_tokens": "return memory usage of python process in MB", "label": 0}, {"idx": "cosqa-train-18564", "doc": "python comvert string to title case", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-18565", "doc": "a check funtion in python for turned based game", "code": "def was_into_check(self) -> bool:\n        \"\"\"\n        Checks if the king of the other side is attacked. Such a position is not\n        valid and could only be reached by an illegal move.\n        \"\"\"\n        king = self.king(not self.turn)\n        return king is not None and self.is_attacked_by(self.turn, king)", "code_tokens": "def was_into_check ( self ) -> bool : king = self . king ( not self . turn ) return king is not None and self . is_attacked_by ( self . turn , king )", "docstring_tokens": "Checks if the king of the other side is attacked . Such a position is not valid and could only be reached by an illegal move .", "label": 1}, {"idx": "cosqa-train-18566", "doc": "check if column values are blank in python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-18567", "doc": "python extract hostname from url", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 0}, {"idx": "cosqa-train-18568", "doc": "how to prepreocess multiple images in python", "code": "def load_preprocess_images(image_paths: List[str], image_size: tuple) -> List[np.ndarray]:\n    \"\"\"\n    Load and pre-process the images specified with absolute paths.\n\n    :param image_paths: List of images specified with paths.\n    :param image_size: Tuple to resize the image to (Channels, Height, Width)\n    :return: A list of loaded images (numpy arrays).\n    \"\"\"\n    image_size = image_size[1:]  # we do not need the number of channels\n    images = []\n    for image_path in image_paths:\n        images.append(load_preprocess_image(image_path, image_size))\n    return images", "code_tokens": "def load_preprocess_images ( image_paths : List [ str ] , image_size : tuple ) -> List [ np . ndarray ] : image_size = image_size [ 1 : ] # we do not need the number of channels images = [ ] for image_path in image_paths : images . append ( load_preprocess_image ( image_path , image_size ) ) return images", "docstring_tokens": "Load and pre - process the images specified with absolute paths .", "label": 1}, {"idx": "cosqa-train-18569", "doc": "check is a link is relative python", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 0}, {"idx": "cosqa-train-18570", "doc": "python pprint a long string", "code": "def _short_repr(obj):\n  \"\"\"Helper function returns a truncated repr() of an object.\"\"\"\n  stringified = pprint.saferepr(obj)\n  if len(stringified) > 200:\n    return '%s... (%d bytes)' % (stringified[:200], len(stringified))\n  return stringified", "code_tokens": "def _short_repr ( obj ) : stringified = pprint . saferepr ( obj ) if len ( stringified ) > 200 : return '%s... (%d bytes)' % ( stringified [ : 200 ] , len ( stringified ) ) return stringified", "docstring_tokens": "Helper function returns a truncated repr () of an object .", "label": 1}, {"idx": "cosqa-train-18571", "doc": "selecting a range of 2d elements from a numpy array gives empty array in python 3", "code": "def to_0d_array(value: Any) -> np.ndarray:\n    \"\"\"Given a value, wrap it in a 0-D numpy.ndarray.\n    \"\"\"\n    if np.isscalar(value) or (isinstance(value, np.ndarray) and\n                              value.ndim == 0):\n        return np.array(value)\n    else:\n        return to_0d_object_array(value)", "code_tokens": "def to_0d_array ( value : Any ) -> np . ndarray : if np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and value . ndim == 0 ) : return np . array ( value ) else : return to_0d_object_array ( value )", "docstring_tokens": "Given a value wrap it in a 0 - D numpy . ndarray .", "label": 1}, {"idx": "cosqa-train-18572", "doc": "python check for real number", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 0}, {"idx": "cosqa-train-18573", "doc": "if clause checking tow statemetents in python", "code": "def find_unit_clause(clauses, model):\n    \"\"\"Find a forced assignment if possible from a clause with only 1\n    variable not bound in the model.\n    >>> find_unit_clause([A|B|C, B|~C, ~A|~B], {A:True})\n    (B, False)\n    \"\"\"\n    for clause in clauses:\n        P, value = unit_clause_assign(clause, model)\n        if P: return P, value\n    return None, None", "code_tokens": "def find_unit_clause ( clauses , model ) : for clause in clauses : P , value = unit_clause_assign ( clause , model ) if P : return P , value return None , None", "docstring_tokens": "Find a forced assignment if possible from a clause with only 1 variable not bound in the model . >>> find_unit_clause ( [ A|B|C B|~C ~A|~B ] { A : True } ) ( B False )", "label": 0}, {"idx": "cosqa-train-18574", "doc": "check if a string match date type format python", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 0}, {"idx": "cosqa-train-18575", "doc": "python check if it is not a string", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 0}, {"idx": "cosqa-train-18576", "doc": "product of all elements python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 1}, {"idx": "cosqa-train-18577", "doc": "how to check if any char in a string is alpha python", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 1}, {"idx": "cosqa-train-18578", "doc": "covert an array to a list in python", "code": "def listify(a):\n    \"\"\"\n    Convert a scalar ``a`` to a list and all iterables to list as well.\n\n    Examples\n    --------\n    >>> listify(0)\n    [0]\n\n    >>> listify([1,2,3])\n    [1, 2, 3]\n\n    >>> listify('a')\n    ['a']\n\n    >>> listify(np.array([1,2,3]))\n    [1, 2, 3]\n\n    >>> listify('string')\n    ['string']\n    \"\"\"\n    if a is None:\n        return []\n    elif not isinstance(a, (tuple, list, np.ndarray)):\n        return [a]\n    return list(a)", "code_tokens": "def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "docstring_tokens": "Convert a scalar a to a list and all iterables to list as well .", "label": 0}, {"idx": "cosqa-train-18579", "doc": "python how to get the year from a timestamp", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 0}, {"idx": "cosqa-train-18580", "doc": "remove columns a data frame python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 0}, {"idx": "cosqa-train-18581", "doc": "python check if date is valid", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 1}, {"idx": "cosqa-train-18582", "doc": "trimming off leading zeros python", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 1}, {"idx": "cosqa-train-18583", "doc": "finding the last occurance of a character in a string in python", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 0}, {"idx": "cosqa-train-18584", "doc": "python datetime today astimezone", "code": "def get_now_utc_notz_datetime() -> datetime.datetime:\n    \"\"\"\n    Get the UTC time now, but with no timezone information,\n    in :class:`datetime.datetime` format.\n    \"\"\"\n    now = datetime.datetime.utcnow()\n    return now.replace(tzinfo=None)", "code_tokens": "def get_now_utc_notz_datetime ( ) -> datetime . datetime : now = datetime . datetime . utcnow ( ) return now . replace ( tzinfo = None )", "docstring_tokens": "Get the UTC time now but with no timezone information in : class : datetime . datetime format .", "label": 0}, {"idx": "cosqa-train-18585", "doc": "is there a way to replace multiple characters in python", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 0}, {"idx": "cosqa-train-18586", "doc": "how to check 2 strings are the same in python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 1}, {"idx": "cosqa-train-18587", "doc": "python draw dependency graph", "code": "def make_dep_graph(depender):\n\t\"\"\"Returns a digraph string fragment based on the passed-in module\n\t\"\"\"\n\tshutit_global.shutit_global_object.yield_to_draw()\n\tdigraph = ''\n\tfor dependee_id in depender.depends_on:\n\t\tdigraph = (digraph + '\"' + depender.module_id + '\"->\"' + dependee_id + '\";\\n')\n\treturn digraph", "code_tokens": "def make_dep_graph ( depender ) : shutit_global . shutit_global_object . yield_to_draw ( ) digraph = '' for dependee_id in depender . depends_on : digraph = ( digraph + '\"' + depender . module_id + '\"->\"' + dependee_id + '\";\\n' ) return digraph", "docstring_tokens": "Returns a digraph string fragment based on the passed - in module", "label": 0}, {"idx": "cosqa-train-18588", "doc": "python test elements of an array", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 1}, {"idx": "cosqa-train-18589", "doc": "python remove non english charachters from a text", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 1}, {"idx": "cosqa-train-18590", "doc": "python get a numerical date from a string date", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-18591", "doc": "vs code python read text file", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-18592", "doc": "how to open a python conda environment", "code": "def _find_conda():\n    \"\"\"Find the conda executable robustly across conda versions.\n\n    Returns\n    -------\n    conda : str\n        Path to the conda executable.\n\n    Raises\n    ------\n    IOError\n        If the executable cannot be found in either the CONDA_EXE environment\n        variable or in the PATH.\n\n    Notes\n    -----\n    In POSIX platforms in conda >= 4.4, conda can be set up as a bash function\n    rather than an executable. (This is to enable the syntax\n    ``conda activate env-name``.) In this case, the environment variable\n    ``CONDA_EXE`` contains the path to the conda executable. In other cases,\n    we use standard search for the appropriate name in the PATH.\n\n    See https://github.com/airspeed-velocity/asv/issues/645 for more details.\n    \"\"\"\n    if 'CONDA_EXE' in os.environ:\n        conda = os.environ['CONDA_EXE']\n    else:\n        conda = util.which('conda')\n    return conda", "code_tokens": "def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda", "docstring_tokens": "Find the conda executable robustly across conda versions .", "label": 0}, {"idx": "cosqa-train-18593", "doc": "pyodbc python oracle connect", "code": "def connect_to_database_odbc_access(self,\n                                        dsn: str,\n                                        autocommit: bool = True) -> None:\n        \"\"\"Connects to an Access database via ODBC, with the DSN\n        prespecified.\"\"\"\n        self.connect(engine=ENGINE_ACCESS, interface=INTERFACE_ODBC,\n                     dsn=dsn, autocommit=autocommit)", "code_tokens": "def connect_to_database_odbc_access ( self , dsn : str , autocommit : bool = True ) -> None : self . connect ( engine = ENGINE_ACCESS , interface = INTERFACE_ODBC , dsn = dsn , autocommit = autocommit )", "docstring_tokens": "Connects to an Access database via ODBC with the DSN prespecified .", "label": 0}, {"idx": "cosqa-train-18594", "doc": "conda python env not activated windows", "code": "def _find_conda():\n    \"\"\"Find the conda executable robustly across conda versions.\n\n    Returns\n    -------\n    conda : str\n        Path to the conda executable.\n\n    Raises\n    ------\n    IOError\n        If the executable cannot be found in either the CONDA_EXE environment\n        variable or in the PATH.\n\n    Notes\n    -----\n    In POSIX platforms in conda >= 4.4, conda can be set up as a bash function\n    rather than an executable. (This is to enable the syntax\n    ``conda activate env-name``.) In this case, the environment variable\n    ``CONDA_EXE`` contains the path to the conda executable. In other cases,\n    we use standard search for the appropriate name in the PATH.\n\n    See https://github.com/airspeed-velocity/asv/issues/645 for more details.\n    \"\"\"\n    if 'CONDA_EXE' in os.environ:\n        conda = os.environ['CONDA_EXE']\n    else:\n        conda = util.which('conda')\n    return conda", "code_tokens": "def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda", "docstring_tokens": "Find the conda executable robustly across conda versions .", "label": 1}, {"idx": "cosqa-train-18595", "doc": "python delete all characters from text", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 1}, {"idx": "cosqa-train-18596", "doc": "python how to return separate tuples", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 0}, {"idx": "cosqa-train-18597", "doc": "how to remove a empty string in python", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 1}, {"idx": "cosqa-train-18598", "doc": "how to get randomwalk to work python", "code": "def returned(n):\n\t\"\"\"Generate a random walk and return True if the walker has returned to\n\tthe origin after taking `n` steps.\n\t\"\"\"\n\t## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk\n\tfor pos in randwalk() >> drop(1) >> takei(xrange(n-1)):\n\t\tif pos == Origin:\n\t\t\treturn True\n\treturn False", "code_tokens": "def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "docstring_tokens": "Generate a random walk and return True if the walker has returned to the origin after taking n steps .", "label": 0}, {"idx": "cosqa-train-18599", "doc": "python datetime utcnow no tzinfo", "code": "def get_now_utc_notz_datetime() -> datetime.datetime:\n    \"\"\"\n    Get the UTC time now, but with no timezone information,\n    in :class:`datetime.datetime` format.\n    \"\"\"\n    now = datetime.datetime.utcnow()\n    return now.replace(tzinfo=None)", "code_tokens": "def get_now_utc_notz_datetime ( ) -> datetime . datetime : now = datetime . datetime . utcnow ( ) return now . replace ( tzinfo = None )", "docstring_tokens": "Get the UTC time now but with no timezone information in : class : datetime . datetime format .", "label": 0}, {"idx": "cosqa-train-18600", "doc": "python modify list of strings while iterating", "code": "def replace_in_list(stringlist: Iterable[str],\n                    replacedict: Dict[str, str]) -> List[str]:\n    \"\"\"\n    Returns a list produced by applying :func:`multiple_replace` to every\n    string in ``stringlist``.\n\n    Args:\n        stringlist: list of source strings\n        replacedict: dictionary mapping \"original\" to \"replacement\" strings\n\n    Returns:\n        list of final strings\n\n    \"\"\"\n    newlist = []\n    for fromstring in stringlist:\n        newlist.append(multiple_replace(fromstring, replacedict))\n    return newlist", "code_tokens": "def replace_in_list ( stringlist : Iterable [ str ] , replacedict : Dict [ str , str ] ) -> List [ str ] : newlist = [ ] for fromstring in stringlist : newlist . append ( multiple_replace ( fromstring , replacedict ) ) return newlist", "docstring_tokens": "Returns a list produced by applying : func : multiple_replace to every string in stringlist .", "label": 1}, {"idx": "cosqa-train-18601", "doc": "how to replace a certain word for another word in a string in python", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 1}, {"idx": "cosqa-train-18602", "doc": "numpy to tensor python", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 1}, {"idx": "cosqa-train-18603", "doc": "finding last index in python", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 1}, {"idx": "cosqa-train-18604", "doc": "how to custom set range on color bar python", "code": "def set_range(self, min_val, max_val):\n        \"\"\"Set the range of the colormap to [*min_val*, *max_val*]\n        \"\"\"\n        if min_val > max_val:\n            max_val, min_val = min_val, max_val\n        self.values = (((self.values * 1.0 - self.values.min()) /\n                        (self.values.max() - self.values.min()))\n                       * (max_val - min_val) + min_val)", "code_tokens": "def set_range ( self , min_val , max_val ) : if min_val > max_val : max_val , min_val = min_val , max_val self . values = ( ( ( self . values * 1.0 - self . values . min ( ) ) / ( self . values . max ( ) - self . values . min ( ) ) ) * ( max_val - min_val ) + min_val )", "docstring_tokens": "Set the range of the colormap to [ * min_val * * max_val * ]", "label": 0}, {"idx": "cosqa-train-18605", "doc": "how to read lines into a set python", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 1}, {"idx": "cosqa-train-18606", "doc": "how to write an exit function python", "code": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)", "code_tokens": "def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "docstring_tokens": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting", "label": 0}, {"idx": "cosqa-train-18607", "doc": "array condition && python", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 0}, {"idx": "cosqa-train-18608", "doc": "python how to detect string with all white spaces", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 1}, {"idx": "cosqa-train-18609", "doc": "how to get first 5 records of array python", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 0}, {"idx": "cosqa-train-18610", "doc": "python passing a tuple in function that takes a string", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 0}, {"idx": "cosqa-train-18611", "doc": "how to get the first 5 elements of a sorted dictionary in python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 1}, {"idx": "cosqa-train-18612", "doc": "how to make a python program draw a tree using recursion", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-18613", "doc": "make a 2d empty array python", "code": "def _create_empty_array(self, frames, always_2d, dtype):\n        \"\"\"Create an empty array with appropriate shape.\"\"\"\n        import numpy as np\n        if always_2d or self.channels > 1:\n            shape = frames, self.channels\n        else:\n            shape = frames,\n        return np.empty(shape, dtype, order='C')", "code_tokens": "def _create_empty_array ( self , frames , always_2d , dtype ) : import numpy as np if always_2d or self . channels > 1 : shape = frames , self . channels else : shape = frames , return np . empty ( shape , dtype , order = 'C' )", "docstring_tokens": "Create an empty array with appropriate shape .", "label": 1}, {"idx": "cosqa-train-18614", "doc": "python detect key exist or not", "code": "def check_key(self, key: str) -> bool:\n        \"\"\"\n        Checks if key exists in datastore. True if yes, False if no.\n\n        :param: SHA512 hash key\n\n        :return: whether or key not exists in datastore\n        \"\"\"\n        keys = self.get_keys()\n        return key in keys", "code_tokens": "def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "docstring_tokens": "Checks if key exists in datastore . True if yes False if no .", "label": 1}, {"idx": "cosqa-train-18615", "doc": "how do you add values to a set in python", "code": "def dict_of_sets_add(dictionary, key, value):\n    # type: (DictUpperBound, Any, Any) -> None\n    \"\"\"Add value to a set in a dictionary by key\n\n    Args:\n        dictionary (DictUpperBound): Dictionary to which to add values\n        key (Any): Key within dictionary\n        value (Any): Value to add to set in dictionary\n\n    Returns:\n        None\n\n    \"\"\"\n    set_objs = dictionary.get(key, set())\n    set_objs.add(value)\n    dictionary[key] = set_objs", "code_tokens": "def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "docstring_tokens": "Add value to a set in a dictionary by key", "label": 0}, {"idx": "cosqa-train-18616", "doc": "python check if value in enum", "code": "def has_value(cls, value: int) -> bool:\n        \"\"\"True if specified value exists in int enum; otherwise, False.\"\"\"\n        return any(value == item.value for item in cls)", "code_tokens": "def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "docstring_tokens": "True if specified value exists in int enum ; otherwise False .", "label": 1}, {"idx": "cosqa-train-18617", "doc": "turn a string into a bytearray python", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 1}, {"idx": "cosqa-train-18618", "doc": "get content of textfile as string python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 0}, {"idx": "cosqa-train-18619", "doc": "python uuid to integer", "code": "def from_uuid(value: uuid.UUID) -> ulid.ULID:\n    \"\"\"\n    Create a new :class:`~ulid.ulid.ULID` instance from the given :class:`~uuid.UUID` value.\n\n    :param value: UUIDv4 value\n    :type value: :class:`~uuid.UUID`\n    :return: ULID from UUID value\n    :rtype: :class:`~ulid.ulid.ULID`\n    \"\"\"\n    return ulid.ULID(value.bytes)", "code_tokens": "def from_uuid ( value : uuid . UUID ) -> ulid . ULID : return ulid . ULID ( value . bytes )", "docstring_tokens": "Create a new : class : ~ulid . ulid . ULID instance from the given : class : ~uuid . UUID value .", "label": 1}, {"idx": "cosqa-train-18620", "doc": "how to turn a string into bytes python", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 0}, {"idx": "cosqa-train-18621", "doc": "python test if path is absolute or relative", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 0}, {"idx": "cosqa-train-18622", "doc": "how to get max value of columns python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 1}, {"idx": "cosqa-train-18623", "doc": "random walk python making sure walker is in bounds", "code": "def returned(n):\n\t\"\"\"Generate a random walk and return True if the walker has returned to\n\tthe origin after taking `n` steps.\n\t\"\"\"\n\t## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk\n\tfor pos in randwalk() >> drop(1) >> takei(xrange(n-1)):\n\t\tif pos == Origin:\n\t\t\treturn True\n\treturn False", "code_tokens": "def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "docstring_tokens": "Generate a random walk and return True if the walker has returned to the origin after taking n steps .", "label": 0}, {"idx": "cosqa-train-18624", "doc": "delete from a python dict", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 0}, {"idx": "cosqa-train-18625", "doc": "split on multiple tokens python split", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 1}, {"idx": "cosqa-train-18626", "doc": "creating dictionary using indices as map values python", "code": "def make_indices_to_labels(labels: Set[str]) -> Dict[int, str]:\n    \"\"\" Creates a mapping from indices to labels. \"\"\"\n\n    return {index: label for index, label in\n            enumerate([\"pad\"] + sorted(list(labels)))}", "code_tokens": "def make_indices_to_labels ( labels : Set [ str ] ) -> Dict [ int , str ] : return { index : label for index , label in enumerate ( [ \"pad\" ] + sorted ( list ( labels ) ) ) }", "docstring_tokens": "Creates a mapping from indices to labels .", "label": 0}, {"idx": "cosqa-train-18627", "doc": "determine powershell width using python", "code": "def get_terminal_width():\n    \"\"\" -> #int width of the terminal window \"\"\"\n    # http://www.brandonrubin.me/2014/03/18/python-snippet-get-terminal-width/\n    command = ['tput', 'cols']\n    try:\n        width = int(subprocess.check_output(command))\n    except OSError as e:\n        print(\n            \"Invalid Command '{0}': exit status ({1})\".format(\n                command[0], e.errno))\n    except subprocess.CalledProcessError as e:\n        print(\n            \"'{0}' returned non-zero exit status: ({1})\".format(\n                command, e.returncode))\n    else:\n        return width", "code_tokens": "def get_terminal_width ( ) : # http://www.brandonrubin.me/2014/03/18/python-snippet-get-terminal-width/ command = [ 'tput' , 'cols' ] try : width = int ( subprocess . check_output ( command ) ) except OSError as e : print ( \"Invalid Command '{0}': exit status ({1})\" . format ( command [ 0 ] , e . errno ) ) except subprocess . CalledProcessError as e : print ( \"'{0}' returned non-zero exit status: ({1})\" . format ( command , e . returncode ) ) else : return width", "docstring_tokens": "- > #int width of the terminal window", "label": 0}, {"idx": "cosqa-train-18628", "doc": "python flatten dict items", "code": "def flatten_multidict(multidict):\n    \"\"\"Return flattened dictionary from ``MultiDict``.\"\"\"\n    return dict([(key, value if len(value) > 1 else value[0])\n                 for (key, value) in multidict.iterlists()])", "code_tokens": "def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "docstring_tokens": "Return flattened dictionary from MultiDict .", "label": 1}, {"idx": "cosqa-train-18629", "doc": "how to check if file is empty python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 1}, {"idx": "cosqa-train-18630", "doc": "python logging auto flush", "code": "def flush(self):\n        \"\"\"\n        Ensure all logging output has been flushed\n        \"\"\"\n        if len(self._buffer) > 0:\n            self.logger.log(self.level, self._buffer)\n            self._buffer = str()", "code_tokens": "def flush ( self ) : if len ( self . _buffer ) > 0 : self . logger . log ( self . level , self . _buffer ) self . _buffer = str ( )", "docstring_tokens": "Ensure all logging output has been flushed", "label": 1}, {"idx": "cosqa-train-18631", "doc": "how to print half a list in python", "code": "def _brief_print_list(lst, limit=7):\n    \"\"\"Print at most `limit` elements of list.\"\"\"\n    lst = list(lst)\n    if len(lst) > limit:\n        return _brief_print_list(lst[:limit//2], limit) + ', ..., ' + \\\n            _brief_print_list(lst[-limit//2:], limit)\n    return ', '.join([\"'%s'\"%str(i) for i in lst])", "code_tokens": "def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "docstring_tokens": "Print at most limit elements of list .", "label": 0}, {"idx": "cosqa-train-18632", "doc": "python raise with or without brackets", "code": "def assert_or_raise(stmt: bool, exception: Exception,\n                    *exception_args, **exception_kwargs) -> None:\n  \"\"\"\n  If the statement is false, raise the given exception.\n  \"\"\"\n  if not stmt:\n    raise exception(*exception_args, **exception_kwargs)", "code_tokens": "def assert_or_raise ( stmt : bool , exception : Exception , * exception_args , * * exception_kwargs ) -> None : if not stmt : raise exception ( * exception_args , * * exception_kwargs )", "docstring_tokens": "If the statement is false raise the given exception .", "label": 0}, {"idx": "cosqa-train-18633", "doc": "remove logic symbol from python string", "code": "def strip_codes(s: Any) -> str:\n    \"\"\" Strip all color codes from a string.\n        Returns empty string for \"falsey\" inputs.\n    \"\"\"\n    return codepat.sub('', str(s) if (s or (s == 0)) else '')", "code_tokens": "def strip_codes ( s : Any ) -> str : return codepat . sub ( '' , str ( s ) if ( s or ( s == 0 ) ) else '' )", "docstring_tokens": "Strip all color codes from a string . Returns empty string for falsey inputs .", "label": 1}, {"idx": "cosqa-train-18634", "doc": "check if line is in file python", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 0}, {"idx": "cosqa-train-18635", "doc": "get parent node of a node using python", "code": "def assign_parent(node: astroid.node_classes.NodeNG) -> astroid.node_classes.NodeNG:\n    \"\"\"return the higher parent which is not an AssignName, Tuple or List node\n    \"\"\"\n    while node and isinstance(node, (astroid.AssignName, astroid.Tuple, astroid.List)):\n        node = node.parent\n    return node", "code_tokens": "def assign_parent ( node : astroid . node_classes . NodeNG ) -> astroid . node_classes . NodeNG : while node and isinstance ( node , ( astroid . AssignName , astroid . Tuple , astroid . List ) ) : node = node . parent return node", "docstring_tokens": "return the higher parent which is not an AssignName Tuple or List node", "label": 0}, {"idx": "cosqa-train-18636", "doc": "check whether two column names are identical in python", "code": "def columns_equal(a: Column, b: Column) -> bool:\n    \"\"\"\n    Are two SQLAlchemy columns are equal? Checks based on:\n\n    - column ``name``\n    - column ``type`` (see :func:`column_types_equal`)\n    - ``nullable``\n    \"\"\"\n    return (\n        a.name == b.name and\n        column_types_equal(a.type, b.type) and\n        a.nullable == b.nullable\n    )", "code_tokens": "def columns_equal ( a : Column , b : Column ) -> bool : return ( a . name == b . name and column_types_equal ( a . type , b . type ) and a . nullable == b . nullable )", "docstring_tokens": "Are two SQLAlchemy columns are equal? Checks based on :", "label": 1}, {"idx": "cosqa-train-18637", "doc": "how to indent a whole grouping of code in opython at once", "code": "def PrintIndented(self, file, ident, code):\n        \"\"\"Takes an array, add indentation to each entry and prints it.\"\"\"\n        for entry in code:\n            print >>file, '%s%s' % (ident, entry)", "code_tokens": "def PrintIndented ( self , file , ident , code ) : for entry in code : print >> file , '%s%s' % ( ident , entry )", "docstring_tokens": "Takes an array add indentation to each entry and prints it .", "label": 1}, {"idx": "cosqa-train-18638", "doc": "how to get maximum of a specific column in python list", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 0}, {"idx": "cosqa-train-18639", "doc": "how to remove all element from a python dictionary", "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": "def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "docstring_tokens": "Return a new copied dictionary without the keys with None values from the given Mapping object .", "label": 1}, {"idx": "cosqa-train-18640", "doc": "how to sample a multivariate normal distribution python", "code": "def sample_normal(mean, var, rng):\n    \"\"\"Sample from independent normal distributions\n\n    Each element is an independent normal distribution.\n\n    Parameters\n    ----------\n    mean : numpy.ndarray\n      Means of the normal distribution. Shape --> (batch_num, sample_dim)\n    var : numpy.ndarray\n      Variance of the normal distribution. Shape --> (batch_num, sample_dim)\n    rng : numpy.random.RandomState\n\n    Returns\n    -------\n    ret : numpy.ndarray\n       The sampling result. Shape --> (batch_num, sample_dim)\n    \"\"\"\n    ret = numpy.sqrt(var) * rng.randn(*mean.shape) + mean\n    return ret", "code_tokens": "def sample_normal ( mean , var , rng ) : ret = numpy . sqrt ( var ) * rng . randn ( * mean . shape ) + mean return ret", "docstring_tokens": "Sample from independent normal distributions", "label": 1}, {"idx": "cosqa-train-18641", "doc": "finding factors in python and return list", "code": "def factors(n):\n    \"\"\"\n    Computes all the integer factors of the number `n`\n\n    Example:\n        >>> # ENABLE_DOCTEST\n        >>> from utool.util_alg import *  # NOQA\n        >>> import utool as ut\n        >>> result = sorted(ut.factors(10))\n        >>> print(result)\n        [1, 2, 5, 10]\n\n    References:\n        http://stackoverflow.com/questions/6800193/finding-all-the-factors\n    \"\"\"\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))", "code_tokens": "def factors ( n ) : return set ( reduce ( list . __add__ , ( [ i , n // i ] for i in range ( 1 , int ( n ** 0.5 ) + 1 ) if n % i == 0 ) ) )", "docstring_tokens": "Computes all the integer factors of the number n", "label": 1}, {"idx": "cosqa-train-18642", "doc": "python index if there are duplicates", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 1}, {"idx": "cosqa-train-18643", "doc": "python how to check for double quotes", "code": "def is_quoted(arg: str) -> bool:\n    \"\"\"\n    Checks if a string is quoted\n    :param arg: the string being checked for quotes\n    :return: True if a string is quoted\n    \"\"\"\n    return len(arg) > 1 and arg[0] == arg[-1] and arg[0] in constants.QUOTES", "code_tokens": "def is_quoted ( arg : str ) -> bool : return len ( arg ) > 1 and arg [ 0 ] == arg [ - 1 ] and arg [ 0 ] in constants . QUOTES", "docstring_tokens": "Checks if a string is quoted : param arg : the string being checked for quotes : return : True if a string is quoted", "label": 0}, {"idx": "cosqa-train-18644", "doc": "return a set in python", "code": "def get_system_flags() -> FrozenSet[Flag]:\n    \"\"\"Return the set of implemented system flags.\"\"\"\n    return frozenset({Seen, Recent, Deleted, Flagged, Answered, Draft})", "code_tokens": "def get_system_flags ( ) -> FrozenSet [ Flag ] : return frozenset ( { Seen , Recent , Deleted , Flagged , Answered , Draft } )", "docstring_tokens": "Return the set of implemented system flags .", "label": 0}, {"idx": "cosqa-train-18645", "doc": "longest path in tree python", "code": "def dag_longest_path(graph, source, target):\n    \"\"\"\n    Finds the longest path in a dag between two nodes\n    \"\"\"\n    if source == target:\n        return [source]\n    allpaths = nx.all_simple_paths(graph, source, target)\n    longest_path = []\n    for l in allpaths:\n        if len(l) > len(longest_path):\n            longest_path = l\n    return longest_path", "code_tokens": "def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "docstring_tokens": "Finds the longest path in a dag between two nodes", "label": 0}, {"idx": "cosqa-train-18646", "doc": "how to define a floating value in python", "code": "def get_property_as_float(self, name: str) -> float:\n        \"\"\"Return the value of a float property.\n\n        :return: The property value (float).\n\n        Raises exception if property with name doesn't exist.\n\n        .. versionadded:: 1.0\n\n        Scriptable: Yes\n        \"\"\"\n        return float(self.__instrument.get_property(name))", "code_tokens": "def get_property_as_float ( self , name : str ) -> float : return float ( self . __instrument . get_property ( name ) )", "docstring_tokens": "Return the value of a float property .", "label": 1}, {"idx": "cosqa-train-18647", "doc": "sliding windows and rolling window in timeseries python", "code": "def rollapply(data, window, fn):\n    \"\"\"\n    Apply a function fn over a rolling window of size window.\n\n    Args:\n        * data (Series or DataFrame): Series or DataFrame\n        * window (int): Window size\n        * fn (function): Function to apply over the rolling window.\n            For a series, the return value is expected to be a single\n            number. For a DataFrame, it shuold return a new row.\n\n    Returns:\n        * Object of same dimensions as data\n    \"\"\"\n    res = data.copy()\n    res[:] = np.nan\n    n = len(data)\n\n    if window > n:\n        return res\n\n    for i in range(window - 1, n):\n        res.iloc[i] = fn(data.iloc[i - window + 1:i + 1])\n\n    return res", "code_tokens": "def rollapply ( data , window , fn ) : res = data . copy ( ) res [ : ] = np . nan n = len ( data ) if window > n : return res for i in range ( window - 1 , n ) : res . iloc [ i ] = fn ( data . iloc [ i - window + 1 : i + 1 ] ) return res", "docstring_tokens": "Apply a function fn over a rolling window of size window .", "label": 0}, {"idx": "cosqa-train-18648", "doc": "python check that matrix is invertable", "code": "def is_unitary(matrix: np.ndarray) -> bool:\n    \"\"\"\n    A helper function that checks if a matrix is unitary.\n\n    :param matrix: a matrix to test unitarity of\n    :return: true if and only if matrix is unitary\n    \"\"\"\n    rows, cols = matrix.shape\n    if rows != cols:\n        return False\n    return np.allclose(np.eye(rows), matrix.dot(matrix.T.conj()))", "code_tokens": "def is_unitary ( matrix : np . ndarray ) -> bool : rows , cols = matrix . shape if rows != cols : return False return np . allclose ( np . eye ( rows ) , matrix . dot ( matrix . T . conj ( ) ) )", "docstring_tokens": "A helper function that checks if a matrix is unitary .", "label": 0}, {"idx": "cosqa-train-18649", "doc": "python flatten list in list", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 0}, {"idx": "cosqa-train-18650", "doc": "python sqlalchemy how to read the table names from a sqllite database", "code": "def get_table_names_from_metadata(metadata: MetaData) -> List[str]:\n    \"\"\"\n    Returns all database table names found in an SQLAlchemy :class:`MetaData`\n    object.\n    \"\"\"\n    return [table.name for table in metadata.tables.values()]", "code_tokens": "def get_table_names_from_metadata ( metadata : MetaData ) -> List [ str ] : return [ table . name for table in metadata . tables . values ( ) ]", "docstring_tokens": "Returns all database table names found in an SQLAlchemy : class : MetaData object .", "label": 1}, {"idx": "cosqa-train-18651", "doc": "python calculate the midpoint of two points", "code": "def _mid(pt1, pt2):\n    \"\"\"\n    (Point, Point) -> Point\n    Return the point that lies in between the two input points.\n    \"\"\"\n    (x0, y0), (x1, y1) = pt1, pt2\n    return 0.5 * (x0 + x1), 0.5 * (y0 + y1)", "code_tokens": "def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "docstring_tokens": "( Point Point ) - > Point Return the point that lies in between the two input points .", "label": 0}, {"idx": "cosqa-train-18652", "doc": "python checking if two strings are equal", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 0}, {"idx": "cosqa-train-18653", "doc": "python finding longest common string in text", "code": "def long_substr(data):\n    \"\"\"Return the longest common substring in a list of strings.\n    \n    Credit: http://stackoverflow.com/questions/2892931/longest-common-substring-from-more-than-two-strings-python\n    \"\"\"\n    substr = ''\n    if len(data) > 1 and len(data[0]) > 0:\n        for i in range(len(data[0])):\n            for j in range(len(data[0])-i+1):\n                if j > len(substr) and all(data[0][i:i+j] in x for x in data):\n                    substr = data[0][i:i+j]\n    elif len(data) == 1:\n        substr = data[0]\n    return substr", "code_tokens": "def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "docstring_tokens": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python", "label": 0}, {"idx": "cosqa-train-18654", "doc": "how to limit a number to two decimals python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 0}, {"idx": "cosqa-train-18655", "doc": "python generating random numbers of given bit length", "code": "def binary(length):\n    \"\"\"\n        returns a a random string that represent a binary representation\n\n    :param length: number of bits\n    \"\"\"\n    num = randint(1, 999999)\n    mask = '0' * length\n    return (mask + ''.join([str(num >> i & 1) for i in range(7, -1, -1)]))[-length:]", "code_tokens": "def binary ( length ) : num = randint ( 1 , 999999 ) mask = '0' * length return ( mask + '' . join ( [ str ( num >> i & 1 ) for i in range ( 7 , - 1 , - 1 ) ] ) ) [ - length : ]", "docstring_tokens": "returns a a random string that represent a binary representation", "label": 0}, {"idx": "cosqa-train-18656", "doc": "python check if number isinfinite", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 1}, {"idx": "cosqa-train-18657", "doc": "python tornado set default header", "code": "def clear(self) -> None:\n        \"\"\"Resets all headers and content for this response.\"\"\"\n        self._headers = httputil.HTTPHeaders(\n            {\n                \"Server\": \"TornadoServer/%s\" % tornado.version,\n                \"Content-Type\": \"text/html; charset=UTF-8\",\n                \"Date\": httputil.format_timestamp(time.time()),\n            }\n        )\n        self.set_default_headers()\n        self._write_buffer = []  # type: List[bytes]\n        self._status_code = 200\n        self._reason = httputil.responses[200]", "code_tokens": "def clear ( self ) -> None : self . _headers = httputil . HTTPHeaders ( { \"Server\" : \"TornadoServer/%s\" % tornado . version , \"Content-Type\" : \"text/html; charset=UTF-8\" , \"Date\" : httputil . format_timestamp ( time . time ( ) ) , } ) self . set_default_headers ( ) self . _write_buffer = [ ] # type: List[bytes] self . _status_code = 200 self . _reason = httputil . responses [ 200 ]", "docstring_tokens": "Resets all headers and content for this response .", "label": 0}, {"idx": "cosqa-train-18658", "doc": "python how to tell if a socket is closed", "code": "def is_closing(self) -> bool:\n        \"\"\"Return ``True`` if this connection is closing.\n\n        The connection is considered closing if either side has\n        initiated its closing handshake or if the stream has been\n        shut down uncleanly.\n        \"\"\"\n        return self.stream.closed() or self.client_terminated or self.server_terminated", "code_tokens": "def is_closing ( self ) -> bool : return self . stream . closed ( ) or self . client_terminated or self . server_terminated", "docstring_tokens": "Return True if this connection is closing .", "label": 0}, {"idx": "cosqa-train-18659", "doc": "python delete logfile still in use", "code": "def DeleteLog() -> None:\n        \"\"\"Delete log file.\"\"\"\n        if os.path.exists(Logger.FileName):\n            os.remove(Logger.FileName)", "code_tokens": "def DeleteLog ( ) -> None : if os . path . exists ( Logger . FileName ) : os . remove ( Logger . FileName )", "docstring_tokens": "Delete log file .", "label": 1}, {"idx": "cosqa-train-18660", "doc": "python copy cookies to a new request", "code": "def copy_session(session: requests.Session) -> requests.Session:\n    \"\"\"Duplicates a requests.Session.\"\"\"\n    new = requests.Session()\n    new.cookies = requests.utils.cookiejar_from_dict(requests.utils.dict_from_cookiejar(session.cookies))\n    new.headers = session.headers.copy()\n    return new", "code_tokens": "def copy_session ( session : requests . Session ) -> requests . Session : new = requests . Session ( ) new . cookies = requests . utils . cookiejar_from_dict ( requests . utils . dict_from_cookiejar ( session . cookies ) ) new . headers = session . headers . copy ( ) return new", "docstring_tokens": "Duplicates a requests . Session .", "label": 0}, {"idx": "cosqa-train-18661", "doc": "turn a list into an array python", "code": "def listify(a):\n    \"\"\"\n    Convert a scalar ``a`` to a list and all iterables to list as well.\n\n    Examples\n    --------\n    >>> listify(0)\n    [0]\n\n    >>> listify([1,2,3])\n    [1, 2, 3]\n\n    >>> listify('a')\n    ['a']\n\n    >>> listify(np.array([1,2,3]))\n    [1, 2, 3]\n\n    >>> listify('string')\n    ['string']\n    \"\"\"\n    if a is None:\n        return []\n    elif not isinstance(a, (tuple, list, np.ndarray)):\n        return [a]\n    return list(a)", "code_tokens": "def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "docstring_tokens": "Convert a scalar a to a list and all iterables to list as well .", "label": 0}, {"idx": "cosqa-train-18662", "doc": "turn a string into a list and remove parentheses python", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 1}, {"idx": "cosqa-train-18663", "doc": "are python threads asyncronous", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 1}, {"idx": "cosqa-train-18664", "doc": "check if string in a file line python", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 1}, {"idx": "cosqa-train-18665", "doc": "remove leading zeroes in python", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 0}, {"idx": "cosqa-train-18666", "doc": "python cpu usage monitor not full", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 0}, {"idx": "cosqa-train-18667", "doc": "python check each element in list is same size", "code": "def check_consistent_length(*arrays):\n    \"\"\"Check that all arrays have consistent first dimensions.\n\n    Checks whether all objects in arrays have the same shape or length.\n\n    Parameters\n    ----------\n    arrays : list or tuple of input objects.\n        Objects that will be checked for consistent length.\n    \"\"\"\n\n    uniques = np.unique([_num_samples(X) for X in arrays if X is not None])\n    if len(uniques) > 1:\n        raise ValueError(\"Found arrays with inconsistent numbers of samples: %s\"\n                         % str(uniques))", "code_tokens": "def check_consistent_length ( * arrays ) : uniques = np . unique ( [ _num_samples ( X ) for X in arrays if X is not None ] ) if len ( uniques ) > 1 : raise ValueError ( \"Found arrays with inconsistent numbers of samples: %s\" % str ( uniques ) )", "docstring_tokens": "Check that all arrays have consistent first dimensions .", "label": 1}, {"idx": "cosqa-train-18668", "doc": "python 3 interger to byte", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 0}, {"idx": "cosqa-train-18669", "doc": "how to clean a directory in python", "code": "def _cleanup(path: str) -> None:\n    \"\"\"Cleanup temporary directory.\"\"\"\n    if os.path.isdir(path):\n        shutil.rmtree(path)", "code_tokens": "def _cleanup ( path : str ) -> None : if os . path . isdir ( path ) : shutil . rmtree ( path )", "docstring_tokens": "Cleanup temporary directory .", "label": 1}, {"idx": "cosqa-train-18670", "doc": "how do you check if two strings are the same in python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 1}, {"idx": "cosqa-train-18671", "doc": "how to call on method python", "code": "def __getattr__(self, item: str) -> Callable:\n        \"\"\"Get a callable that sends the actual API request internally.\"\"\"\n        return functools.partial(self.call_action, item)", "code_tokens": "def __getattr__ ( self , item : str ) -> Callable : return functools . partial ( self . call_action , item )", "docstring_tokens": "Get a callable that sends the actual API request internally .", "label": 1}, {"idx": "cosqa-train-18672", "doc": "python calculate similarity for two dictionaries", "code": "def calculate_single_tanimoto_set_distances(target: Iterable[X], dict_of_sets: Mapping[Y, Set[X]]) -> Mapping[Y, float]:\n    \"\"\"Return a dictionary of distances keyed by the keys in the given dict.\n\n    Distances are calculated based on pairwise tanimoto similarity of the sets contained\n\n    :param set target: A set\n    :param dict_of_sets: A dict of {x: set of y}\n    :type dict_of_sets: dict\n    :return: A similarity dicationary based on the set overlap (tanimoto) score between the target set and the sets in\n            dos\n    :rtype: dict\n    \"\"\"\n    target_set = set(target)\n\n    return {\n        k: tanimoto_set_similarity(target_set, s)\n        for k, s in dict_of_sets.items()\n    }", "code_tokens": "def calculate_single_tanimoto_set_distances ( target : Iterable [ X ] , dict_of_sets : Mapping [ Y , Set [ X ] ] ) -> Mapping [ Y , float ] : target_set = set ( target ) return { k : tanimoto_set_similarity ( target_set , s ) for k , s in dict_of_sets . items ( ) }", "docstring_tokens": "Return a dictionary of distances keyed by the keys in the given dict .", "label": 1}, {"idx": "cosqa-train-18673", "doc": "how to get top10 in python", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 0}, {"idx": "cosqa-train-18674", "doc": "python any alphabet in string", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 1}, {"idx": "cosqa-train-18675", "doc": "python array with real and imag", "code": "def quaternion_imag(quaternion):\n    \"\"\"Return imaginary part of quaternion.\n\n    >>> quaternion_imag([3, 0, 1, 2])\n    array([ 0.,  1.,  2.])\n\n    \"\"\"\n    return numpy.array(quaternion[1:4], dtype=numpy.float64, copy=True)", "code_tokens": "def quaternion_imag ( quaternion ) : return numpy . array ( quaternion [ 1 : 4 ] , dtype = numpy . float64 , copy = True )", "docstring_tokens": "Return imaginary part of quaternion .", "label": 1}, {"idx": "cosqa-train-18676", "doc": "is dict key case sensitive in python", "code": "def get_case_insensitive_dict_key(d: Dict, k: str) -> Optional[str]:\n    \"\"\"\n    Within the dictionary ``d``, find a key that matches (in case-insensitive\n    fashion) the key ``k``, and return it (or ``None`` if there isn't one).\n    \"\"\"\n    for key in d.keys():\n        if k.lower() == key.lower():\n            return key\n    return None", "code_tokens": "def get_case_insensitive_dict_key ( d : Dict , k : str ) -> Optional [ str ] : for key in d . keys ( ) : if k . lower ( ) == key . lower ( ) : return key return None", "docstring_tokens": "Within the dictionary d find a key that matches ( in case - insensitive fashion ) the key k and return it ( or None if there isn t one ) .", "label": 0}, {"idx": "cosqa-train-18677", "doc": "invert key and values dictionary python", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 1}, {"idx": "cosqa-train-18678", "doc": "python change string to bytearray", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 1}, {"idx": "cosqa-train-18679", "doc": "how to remove none in python string", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 0}, {"idx": "cosqa-train-18680", "doc": "lower case a string in python", "code": "def snake_case(a_string):\n    \"\"\"Returns a snake cased version of a string.\n\n    :param a_string: any :class:`str` object.\n\n    Usage:\n        >>> snake_case('FooBar')\n        \"foo_bar\"\n    \"\"\"\n\n    partial = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', a_string)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', partial).lower()", "code_tokens": "def snake_case ( a_string ) : partial = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , a_string ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , partial ) . lower ( )", "docstring_tokens": "Returns a snake cased version of a string .", "label": 0}, {"idx": "cosqa-train-18681", "doc": "python sqlite executemany dict", "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None:\n        \"\"\"Execute the given multiquery.\"\"\"\n        await self._execute(self._cursor.executemany, sql, parameters)", "code_tokens": "async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "docstring_tokens": "Execute the given multiquery .", "label": 1}, {"idx": "cosqa-train-18682", "doc": "python csv to two dimentional array numpy", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 0}, {"idx": "cosqa-train-18683", "doc": "python select the second element of a string within a list", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 1}, {"idx": "cosqa-train-18684", "doc": "flatten dict of dict python", "code": "def flatten_multidict(multidict):\n    \"\"\"Return flattened dictionary from ``MultiDict``.\"\"\"\n    return dict([(key, value if len(value) > 1 else value[0])\n                 for (key, value) in multidict.iterlists()])", "code_tokens": "def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "docstring_tokens": "Return flattened dictionary from MultiDict .", "label": 1}, {"idx": "cosqa-train-18685", "doc": "get wechat access token python", "code": "def access_token(self):\n        \"\"\" WeChat access token \"\"\"\n        access_token = self.session.get(self.access_token_key)\n        if access_token:\n            if not self.expires_at:\n                # user provided access_token, just return it\n                return access_token\n\n            timestamp = time.time()\n            if self.expires_at - timestamp > 60:\n                return access_token\n\n        self.fetch_access_token()\n        return self.session.get(self.access_token_key)", "code_tokens": "def access_token ( self ) : access_token = self . session . get ( self . access_token_key ) if access_token : if not self . expires_at : # user provided access_token, just return it return access_token timestamp = time . time ( ) if self . expires_at - timestamp > 60 : return access_token self . fetch_access_token ( ) return self . session . get ( self . access_token_key )", "docstring_tokens": "WeChat access token", "label": 1}, {"idx": "cosqa-train-18686", "doc": "how to test for nan in python", "code": "def warn_if_nans_exist(X):\n    \"\"\"Warn if nans exist in a numpy array.\"\"\"\n    null_count = count_rows_with_nans(X)\n    total = len(X)\n    percent = 100 * null_count / total\n\n    if null_count > 0:\n        warning_message = \\\n            'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\\n            'complete rows will be plotted.'.format(null_count, total, percent)\n        warnings.warn(warning_message, DataWarning)", "code_tokens": "def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "docstring_tokens": "Warn if nans exist in a numpy array .", "label": 0}, {"idx": "cosqa-train-18687", "doc": "python how to change all int64 columns to int16", "code": "def to_int64(a):\n    \"\"\"Return view of the recarray with all int32 cast to int64.\"\"\"\n    # build new dtype and replace i4 --> i8\n    def promote_i4(typestr):\n        if typestr[1:] == 'i4':\n            typestr = typestr[0]+'i8'\n        return typestr\n\n    dtype = [(name, promote_i4(typestr)) for name,typestr in a.dtype.descr]\n    return a.astype(dtype)", "code_tokens": "def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )", "docstring_tokens": "Return view of the recarray with all int32 cast to int64 .", "label": 0}, {"idx": "cosqa-train-18688", "doc": "python how to get next element of iterator", "code": "def __next__(self):\n        \"\"\"\n        :return: int\n        \"\"\"\n        self.current += 1\n        if self.current > self.total:\n            raise StopIteration\n        else:\n            return self.iterable[self.current - 1]", "code_tokens": "def __next__ ( self ) : self . current += 1 if self . current > self . total : raise StopIteration else : return self . iterable [ self . current - 1 ]", "docstring_tokens": ": return : int", "label": 1}, {"idx": "cosqa-train-18689", "doc": "checking for empty file python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 0}, {"idx": "cosqa-train-18690", "doc": "python qutip compute inner product between two state vectors", "code": "def join_states(*states: State) -> State:\n    \"\"\"Join two state vectors into a larger qubit state\"\"\"\n    vectors = [ket.vec for ket in states]\n    vec = reduce(outer_product, vectors)\n    return State(vec.tensor, vec.qubits)", "code_tokens": "def join_states ( * states : State ) -> State : vectors = [ ket . vec for ket in states ] vec = reduce ( outer_product , vectors ) return State ( vec . tensor , vec . qubits )", "docstring_tokens": "Join two state vectors into a larger qubit state", "label": 1}, {"idx": "cosqa-train-18691", "doc": "blockout region in image python opencv code", "code": "def blk_coverage_1d(blk, size):\n    \"\"\"Return the part of a 1d array covered by a block.\n\n    :param blk: size of the 1d block\n    :param size: size of the 1d a image\n    :return: a tuple of size covered and remaining size\n\n    Example:\n\n        >>> blk_coverage_1d(7, 100)\n        (98, 2)\n\n    \"\"\"\n    rem = size % blk\n    maxpix = size - rem\n    return maxpix, rem", "code_tokens": "def blk_coverage_1d ( blk , size ) : rem = size % blk maxpix = size - rem return maxpix , rem", "docstring_tokens": "Return the part of a 1d array covered by a block .", "label": 0}, {"idx": "cosqa-train-18692", "doc": "python get number of gpu", "code": "def cpu_count() -> int:\n    \"\"\"Returns the number of processors on this machine.\"\"\"\n    if multiprocessing is None:\n        return 1\n    try:\n        return multiprocessing.cpu_count()\n    except NotImplementedError:\n        pass\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_CONF\")\n    except (AttributeError, ValueError):\n        pass\n    gen_log.error(\"Could not detect number of processors; assuming 1\")\n    return 1", "code_tokens": "def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( \"SC_NPROCESSORS_CONF\" ) except ( AttributeError , ValueError ) : pass gen_log . error ( \"Could not detect number of processors; assuming 1\" ) return 1", "docstring_tokens": "Returns the number of processors on this machine .", "label": 1}, {"idx": "cosqa-train-18693", "doc": "how to recursively print a tree python", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-18694", "doc": "delete files using wildcards python", "code": "def rmglob(pattern: str) -> None:\n    \"\"\"\n    Deletes all files whose filename matches the glob ``pattern`` (via\n    :func:`glob.glob`).\n    \"\"\"\n    for f in glob.glob(pattern):\n        os.remove(f)", "code_tokens": "def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "docstring_tokens": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .", "label": 1}, {"idx": "cosqa-train-18695", "doc": "python load json to dict", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 1}, {"idx": "cosqa-train-18696", "doc": "python get most frequent item in list", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 1}, {"idx": "cosqa-train-18697", "doc": "python ndarray string cut out", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 0}, {"idx": "cosqa-train-18698", "doc": "dot product simple multiplication python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 0}, {"idx": "cosqa-train-18699", "doc": "how to compare similarity of two numbers on python", "code": "def tanimoto_set_similarity(x: Iterable[X], y: Iterable[X]) -> float:\n    \"\"\"Calculate the tanimoto set similarity.\"\"\"\n    a, b = set(x), set(y)\n    union = a | b\n\n    if not union:\n        return 0.0\n\n    return len(a & b) / len(union)", "code_tokens": "def tanimoto_set_similarity ( x : Iterable [ X ] , y : Iterable [ X ] ) -> float : a , b = set ( x ) , set ( y ) union = a | b if not union : return 0.0 return len ( a & b ) / len ( union )", "docstring_tokens": "Calculate the tanimoto set similarity .", "label": 0}, {"idx": "cosqa-train-18700", "doc": "index of nonzero value array python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 1}, {"idx": "cosqa-train-18701", "doc": "python json quotes in string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 1}, {"idx": "cosqa-train-18702", "doc": "how to check datatime now older than fixed date python", "code": "def is_up_to_date(outfile, basedatetime):\n        # type: (AnyStr, datetime) -> bool\n        \"\"\"Return true if outfile exists and is no older than base datetime.\"\"\"\n        if os.path.exists(outfile):\n            if os.path.getmtime(outfile) >= basedatetime:\n                return True\n        return False", "code_tokens": "def is_up_to_date ( outfile , basedatetime ) : # type: (AnyStr, datetime) -> bool if os . path . exists ( outfile ) : if os . path . getmtime ( outfile ) >= basedatetime : return True return False", "docstring_tokens": "Return true if outfile exists and is no older than base datetime .", "label": 1}, {"idx": "cosqa-train-18703", "doc": "get a date from a string pythong", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-18704", "doc": "python recognize date string as date", "code": "def _parse_date(string: str) -> datetime.date:\n    \"\"\"Parse an ISO format date (YYYY-mm-dd).\n\n    >>> _parse_date('1990-01-02')\n    datetime.date(1990, 1, 2)\n    \"\"\"\n    return datetime.datetime.strptime(string, '%Y-%m-%d').date()", "code_tokens": "def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )", "docstring_tokens": "Parse an ISO format date ( YYYY - mm - dd ) .", "label": 1}, {"idx": "cosqa-train-18705", "doc": "how to download file from s3 using python code", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 1}, {"idx": "cosqa-train-18706", "doc": "python rate limit requests", "code": "def is_rate_limited(response):\n        \"\"\"\n        Checks if the response has been rate limited by CARTO APIs\n\n        :param response: The response rate limited by CARTO APIs\n        :type response: requests.models.Response class\n\n        :return: Boolean\n        \"\"\"\n        if (response.status_code == codes.too_many_requests and 'Retry-After' in response.headers and\n                int(response.headers['Retry-After']) >= 0):\n            return True\n\n        return False", "code_tokens": "def is_rate_limited ( response ) : if ( response . status_code == codes . too_many_requests and 'Retry-After' in response . headers and int ( response . headers [ 'Retry-After' ] ) >= 0 ) : return True return False", "docstring_tokens": "Checks if the response has been rate limited by CARTO APIs", "label": 0}, {"idx": "cosqa-train-18707", "doc": "get rid of leading zeroes python", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 0}, {"idx": "cosqa-train-18708", "doc": "how to check if a file has been changed in python 3", "code": "def has_changed (filename):\n    \"\"\"Check if filename has changed since the last check. If this\n    is the first check, assume the file is changed.\"\"\"\n    key = os.path.abspath(filename)\n    mtime = get_mtime(key)\n    if key not in _mtime_cache:\n        _mtime_cache[key] = mtime\n        return True\n    return mtime > _mtime_cache[key]", "code_tokens": "def has_changed ( filename ) : key = os . path . abspath ( filename ) mtime = get_mtime ( key ) if key not in _mtime_cache : _mtime_cache [ key ] = mtime return True return mtime > _mtime_cache [ key ]", "docstring_tokens": "Check if filename has changed since the last check . If this is the first check assume the file is changed .", "label": 1}, {"idx": "cosqa-train-18709", "doc": "return the number of items in histogram plot in python", "code": "def shape(self) -> Tuple[int, ...]:\n        \"\"\"Shape of histogram's data.\n\n        Returns\n        -------\n        One-element tuple with the number of bins along each axis.\n        \"\"\"\n        return tuple(bins.bin_count for bins in self._binnings)", "code_tokens": "def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )", "docstring_tokens": "Shape of histogram s data .", "label": 1}, {"idx": "cosqa-train-18710", "doc": "python good bit equivalent", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 0}, {"idx": "cosqa-train-18711", "doc": "python read http status from raw", "code": "def header_status(header):\n    \"\"\"Parse HTTP status line, return status (int) and reason.\"\"\"\n    status_line = header[:header.find('\\r')]\n    # 'HTTP/1.1 200 OK' -> (200, 'OK')\n    fields = status_line.split(None, 2)\n    return int(fields[1]), fields[2]", "code_tokens": "def header_status ( header ) : status_line = header [ : header . find ( '\\r' ) ] # 'HTTP/1.1 200 OK' -> (200, 'OK') fields = status_line . split ( None , 2 ) return int ( fields [ 1 ] ) , fields [ 2 ]", "docstring_tokens": "Parse HTTP status line return status ( int ) and reason .", "label": 1}, {"idx": "cosqa-train-18712", "doc": "how to capitalize everything in a string python", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-18713", "doc": "python create key if don't exist", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 0}, {"idx": "cosqa-train-18714", "doc": "python function to detect first element of list", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 1}, {"idx": "cosqa-train-18715", "doc": "change numyp array to just values python", "code": "def array_to_npy(array_like):  # type: (np.array or Iterable or int or float) -> object\n    \"\"\"Convert an array like object to the NPY format.\n\n    To understand better what an array like object is see:\n    https://docs.scipy.org/doc/numpy/user/basics.creation.html#converting-python-array-like-objects-to-numpy-arrays\n\n    Args:\n        array_like (np.array or Iterable or int or float): array like object to be converted to NPY.\n\n    Returns:\n        (obj): NPY array.\n    \"\"\"\n    buffer = BytesIO()\n    np.save(buffer, array_like)\n    return buffer.getvalue()", "code_tokens": "def array_to_npy ( array_like ) : # type: (np.array or Iterable or int or float) -> object buffer = BytesIO ( ) np . save ( buffer , array_like ) return buffer . getvalue ( )", "docstring_tokens": "Convert an array like object to the NPY format .", "label": 0}, {"idx": "cosqa-train-18716", "doc": "in python how to output the last item in a list", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 0}, {"idx": "cosqa-train-18717", "doc": "minmum number of spaces indented space python", "code": "def indent(text: str, num: int = 2) -> str:\n    \"\"\"Indent a piece of text.\"\"\"\n    lines = text.splitlines()\n    return \"\\n\".join(indent_iterable(lines, num=num))", "code_tokens": "def indent ( text : str , num : int = 2 ) -> str : lines = text . splitlines ( ) return \"\\n\" . join ( indent_iterable ( lines , num = num ) )", "docstring_tokens": "Indent a piece of text .", "label": 0}, {"idx": "cosqa-train-18718", "doc": "how to make a number a percent python", "code": "def percent_of(percent, whole):\n    \"\"\"Calculates the value of a percent of a number\n    ie: 5% of 20 is what --> 1\n    \n    Args:\n        percent (float): The percent of a number\n        whole (float): The whole of the number\n        \n    Returns:\n        float: The value of a percent\n        \n    Example:\n    >>> percent_of(25, 100)\n    25.0\n    >>> percent_of(5, 20)\n    1.0\n    \n    \"\"\"\n    percent = float(percent)\n    whole = float(whole)\n    return (percent * whole) / 100", "code_tokens": "def percent_of ( percent , whole ) : percent = float ( percent ) whole = float ( whole ) return ( percent * whole ) / 100", "docstring_tokens": "Calculates the value of a percent of a number ie : 5% of 20 is what -- > 1 Args : percent ( float ) : The percent of a number whole ( float ) : The whole of the number Returns : float : The value of a percent Example : >>> percent_of ( 25 100 ) 25 . 0 >>> percent_of ( 5 20 ) 1 . 0", "label": 0}, {"idx": "cosqa-train-18719", "doc": "python determine mime type of a file", "code": "def guess_mimetype(filename):\n    \"\"\"Guesses the mimetype of a file based on the given ``filename``.\n\n    .. code-block:: python\n\n        >>> guess_mimetype('example.txt')\n        'text/plain'\n        >>> guess_mimetype('/foo/bar/example')\n        'application/octet-stream'\n\n    Parameters\n    ----------\n    filename : str\n        The file name or path for which the mimetype is to be guessed\n    \"\"\"\n    fn = os.path.basename(filename)\n    return mimetypes.guess_type(fn)[0] or 'application/octet-stream'", "code_tokens": "def guess_mimetype ( filename ) : fn = os . path . basename ( filename ) return mimetypes . guess_type ( fn ) [ 0 ] or 'application/octet-stream'", "docstring_tokens": "Guesses the mimetype of a file based on the given filename .", "label": 0}, {"idx": "cosqa-train-18720", "doc": "enumerate python last item", "code": "def enum_mark_last(iterable, start=0):\n    \"\"\"\n    Returns a generator over iterable that tells whether the current item is the last one.\n    Usage:\n        >>> iterable = range(10)\n        >>> for index, is_last, item in enum_mark_last(iterable):\n        >>>     print(index, item, end='\\n' if is_last else ', ')\n    \"\"\"\n    it = iter(iterable)\n    count = start\n    try:\n        last = next(it)\n    except StopIteration:\n        return\n    for val in it:\n        yield count, False, last\n        last = val\n        count += 1\n    yield count, True, last", "code_tokens": "def enum_mark_last ( iterable , start = 0 ) : it = iter ( iterable ) count = start try : last = next ( it ) except StopIteration : return for val in it : yield count , False , last last = val count += 1 yield count , True , last", "docstring_tokens": "Returns a generator over iterable that tells whether the current item is the last one . Usage : >>> iterable = range ( 10 ) >>> for index is_last item in enum_mark_last ( iterable ) : >>> print ( index item end = \\ n if is_last else )", "label": 0}, {"idx": "cosqa-train-18721", "doc": "opencv rgb to hsi in python", "code": "def hsv2rgb_spectrum(hsv):\n    \"\"\"Generates RGB values from HSV values in line with a typical light\n    spectrum.\"\"\"\n    h, s, v = hsv\n    return hsv2rgb_raw(((h * 192) >> 8, s, v))", "code_tokens": "def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "docstring_tokens": "Generates RGB values from HSV values in line with a typical light spectrum .", "label": 0}, {"idx": "cosqa-train-18722", "doc": "python fastest way to reverse dict", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 0}, {"idx": "cosqa-train-18723", "doc": "how to parse a line into tokens in python", "code": "def get_tokens(line: str) -> Iterator[str]:\n    \"\"\"\n    Yields tokens from input string.\n\n    :param line: Input string.\n    :return: Iterator over tokens.\n    \"\"\"\n    for token in line.rstrip().split():\n        if len(token) > 0:\n            yield token", "code_tokens": "def get_tokens ( line : str ) -> Iterator [ str ] : for token in line . rstrip ( ) . split ( ) : if len ( token ) > 0 : yield token", "docstring_tokens": "Yields tokens from input string .", "label": 1}, {"idx": "cosqa-train-18724", "doc": "wxpython get widget by id", "code": "def getElementByWdomId(id: str) -> Optional[WebEventTarget]:\n    \"\"\"Get element with ``wdom_id``.\"\"\"\n    if not id:\n        return None\n    elif id == 'document':\n        return get_document()\n    elif id == 'window':\n        return get_document().defaultView\n    elm = WdomElement._elements_with_wdom_id.get(id)\n    return elm", "code_tokens": "def getElementByWdomId ( id : str ) -> Optional [ WebEventTarget ] : if not id : return None elif id == 'document' : return get_document ( ) elif id == 'window' : return get_document ( ) . defaultView elm = WdomElement . _elements_with_wdom_id . get ( id ) return elm", "docstring_tokens": "Get element with wdom_id .", "label": 0}, {"idx": "cosqa-train-18725", "doc": "biased random walk with bound in python", "code": "def returned(n):\n\t\"\"\"Generate a random walk and return True if the walker has returned to\n\tthe origin after taking `n` steps.\n\t\"\"\"\n\t## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk\n\tfor pos in randwalk() >> drop(1) >> takei(xrange(n-1)):\n\t\tif pos == Origin:\n\t\t\treturn True\n\treturn False", "code_tokens": "def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "docstring_tokens": "Generate a random walk and return True if the walker has returned to the origin after taking n steps .", "label": 0}, {"idx": "cosqa-train-18726", "doc": "python using lambda on dictionary", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-18727", "doc": "python plot the median of a column in an array", "code": "def fast_median(a):\n    \"\"\"Fast median operation for masked array using 50th-percentile\n    \"\"\"\n    a = checkma(a)\n    #return scoreatpercentile(a.compressed(), 50)\n    if a.count() > 0:\n        out = np.percentile(a.compressed(), 50)\n    else:\n        out = np.ma.masked\n    return out", "code_tokens": "def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out", "docstring_tokens": "Fast median operation for masked array using 50th - percentile", "label": 0}, {"idx": "cosqa-train-18728", "doc": "python half of screen pixels", "code": "def viewport_to_screen_space(framebuffer_size: vec2, point: vec4) -> vec2:\n    \"\"\"Transform point in viewport space to screen space.\"\"\"\n    return (framebuffer_size * point.xy) / point.w", "code_tokens": "def viewport_to_screen_space ( framebuffer_size : vec2 , point : vec4 ) -> vec2 : return ( framebuffer_size * point . xy ) / point . w", "docstring_tokens": "Transform point in viewport space to screen space .", "label": 0}, {"idx": "cosqa-train-18729", "doc": "how to check if two strings are the same in python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 0}, {"idx": "cosqa-train-18730", "doc": "how to check for empty file in python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 0}, {"idx": "cosqa-train-18731", "doc": "python check for a specific process", "code": "def is_running(process_id: int) -> bool:\n    \"\"\"\n    Uses the Unix ``ps`` program to see if a process is running.\n    \"\"\"\n    pstr = str(process_id)\n    encoding = sys.getdefaultencoding()\n    s = subprocess.Popen([\"ps\", \"-p\", pstr], stdout=subprocess.PIPE)\n    for line in s.stdout:\n        strline = line.decode(encoding)\n        if pstr in strline:\n            return True\n    return False", "code_tokens": "def is_running ( process_id : int ) -> bool : pstr = str ( process_id ) encoding = sys . getdefaultencoding ( ) s = subprocess . Popen ( [ \"ps\" , \"-p\" , pstr ] , stdout = subprocess . PIPE ) for line in s . stdout : strline = line . decode ( encoding ) if pstr in strline : return True return False", "docstring_tokens": "Uses the Unix ps program to see if a process is running .", "label": 0}, {"idx": "cosqa-train-18732", "doc": "python check date format in iso", "code": "def datetime_is_iso(date_str):\n    \"\"\"Attempts to parse a date formatted in ISO 8601 format\"\"\"\n    try:\n        if len(date_str) > 10:\n            dt = isodate.parse_datetime(date_str)\n        else:\n            dt = isodate.parse_date(date_str)\n        return True, []\n    except:  # Any error qualifies as not ISO format\n        return False, ['Datetime provided is not in a valid ISO 8601 format']", "code_tokens": "def datetime_is_iso ( date_str ) : try : if len ( date_str ) > 10 : dt = isodate . parse_datetime ( date_str ) else : dt = isodate . parse_date ( date_str ) return True , [ ] except : # Any error qualifies as not ISO format return False , [ 'Datetime provided is not in a valid ISO 8601 format' ]", "docstring_tokens": "Attempts to parse a date formatted in ISO 8601 format", "label": 1}, {"idx": "cosqa-train-18733", "doc": "check if column exists by index python", "code": "def index_exists(self, table: str, indexname: str) -> bool:\n        \"\"\"Does an index exist? (Specific to MySQL.)\"\"\"\n        # MySQL:\n        sql = (\"SELECT COUNT(*) FROM information_schema.statistics\"\n               \" WHERE table_name=? AND index_name=?\")\n        row = self.fetchone(sql, table, indexname)\n        return True if row[0] >= 1 else False", "code_tokens": "def index_exists ( self , table : str , indexname : str ) -> bool : # MySQL: sql = ( \"SELECT COUNT(*) FROM information_schema.statistics\" \" WHERE table_name=? AND index_name=?\" ) row = self . fetchone ( sql , table , indexname ) return True if row [ 0 ] >= 1 else False", "docstring_tokens": "Does an index exist? ( Specific to MySQL . )", "label": 0}, {"idx": "cosqa-train-18734", "doc": "python how to calculate moving average in a window", "code": "def moving_average(arr: np.ndarray, n: int = 3) -> np.ndarray:\n    \"\"\" Calculate the moving overage over an array.\n\n    Algorithm from: https://stackoverflow.com/a/14314054\n\n    Args:\n        arr (np.ndarray): Array over which to calculate the moving average.\n        n (int): Number of elements over which to calculate the moving average. Default: 3\n    Returns:\n        np.ndarray: Moving average calculated over n.\n    \"\"\"\n    ret = np.cumsum(arr, dtype=float)\n    ret[n:] = ret[n:] - ret[:-n]\n    return ret[n - 1:] / n", "code_tokens": "def moving_average ( arr : np . ndarray , n : int = 3 ) -> np . ndarray : ret = np . cumsum ( arr , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n", "docstring_tokens": "Calculate the moving overage over an array .", "label": 0}, {"idx": "cosqa-train-18735", "doc": "python get row with max value", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 1}, {"idx": "cosqa-train-18736", "doc": "truncate a number after certain amount of decimals in python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 1}, {"idx": "cosqa-train-18737", "doc": "python map to json str", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 0}, {"idx": "cosqa-train-18738", "doc": "computing the product in python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 0}, {"idx": "cosqa-train-18739", "doc": "function to remove trailing zeros in python", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 0}, {"idx": "cosqa-train-18740", "doc": "return first 100 rows python", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 0}, {"idx": "cosqa-train-18741", "doc": "load a json python", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 0}, {"idx": "cosqa-train-18742", "doc": "python string replace last occureance", "code": "def right_replace(string, old, new, count=1):\n    \"\"\"\n    Right replaces ``count`` occurrences of ``old`` with ``new`` in ``string``.\n    For example::\n\n        right_replace('one_two_two', 'two', 'three') -> 'one_two_three'\n    \"\"\"\n    if not string:\n        return string\n    return new.join(string.rsplit(old, count))", "code_tokens": "def right_replace ( string , old , new , count = 1 ) : if not string : return string return new . join ( string . rsplit ( old , count ) )", "docstring_tokens": "Right replaces count occurrences of old with new in string . For example ::", "label": 0}, {"idx": "cosqa-train-18743", "doc": "count occurnaces in a list python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 1}, {"idx": "cosqa-train-18744", "doc": "rounding to the nearest preset number python", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 0}, {"idx": "cosqa-train-18745", "doc": "how to check the len of every element if it is equal to each other at the same time in python", "code": "def are_token_parallel(sequences: Sequence[Sized]) -> bool:\n    \"\"\"\n    Returns True if all sequences in the list have the same length.\n    \"\"\"\n    if not sequences or len(sequences) == 1:\n        return True\n    return all(len(s) == len(sequences[0]) for s in sequences)", "code_tokens": "def are_token_parallel ( sequences : Sequence [ Sized ] ) -> bool : if not sequences or len ( sequences ) == 1 : return True return all ( len ( s ) == len ( sequences [ 0 ] ) for s in sequences )", "docstring_tokens": "Returns True if all sequences in the list have the same length .", "label": 1}, {"idx": "cosqa-train-18746", "doc": "how to exclude certain text as condition for list comprehension in python", "code": "def exclude_from(l, containing = [], equal_to = []):\n    \"\"\"Exclude elements in list l containing any elements from list ex.\n    Example:\n        >>> l = ['bob', 'r', 'rob\\r', '\\r\\nrobert']\n        >>> containing = ['\\n', '\\r']\n        >>> equal_to = ['r']\n        >>> exclude_from(l, containing, equal_to)\n        ['bob']\n    \"\"\"\n      \n    cont = lambda li: any(c in li for c in containing)\n    eq = lambda li: any(e == li for e in equal_to)\n    return [li for li in l if not (cont(li) or eq(li))]", "code_tokens": "def exclude_from ( l , containing = [ ] , equal_to = [ ] ) : cont = lambda li : any ( c in li for c in containing ) eq = lambda li : any ( e == li for e in equal_to ) return [ li for li in l if not ( cont ( li ) or eq ( li ) ) ]", "docstring_tokens": "Exclude elements in list l containing any elements from list ex . Example : >>> l = [ bob r rob \\ r \\ r \\ nrobert ] >>> containing = [ \\ n \\ r ] >>> equal_to = [ r ] >>> exclude_from ( l containing equal_to ) [ bob ]", "label": 0}, {"idx": "cosqa-train-18747", "doc": "python check whether a date is valid", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 0}, {"idx": "cosqa-train-18748", "doc": "python flatten list comprehension", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 0}, {"idx": "cosqa-train-18749", "doc": "python boto3 dynamodb delete all items", "code": "def clean_all_buckets(self):\n        \"\"\"\n        Removes all buckets from all hashes and their content.\n        \"\"\"\n        bucket_keys = self.redis_object.keys(pattern='nearpy_*')\n        if len(bucket_keys) > 0:\n            self.redis_object.delete(*bucket_keys)", "code_tokens": "def clean_all_buckets ( self ) : bucket_keys = self . redis_object . keys ( pattern = 'nearpy_*' ) if len ( bucket_keys ) > 0 : self . redis_object . delete ( * bucket_keys )", "docstring_tokens": "Removes all buckets from all hashes and their content .", "label": 0}, {"idx": "cosqa-train-18750", "doc": "python return mongodb 'cursor' object is not callable", "code": "async def cursor(self) -> Cursor:\n        \"\"\"Create an aiosqlite cursor wrapping a sqlite3 cursor object.\"\"\"\n        return Cursor(self, await self._execute(self._conn.cursor))", "code_tokens": "async def cursor ( self ) -> Cursor : return Cursor ( self , await self . _execute ( self . _conn . cursor ) )", "docstring_tokens": "Create an aiosqlite cursor wrapping a sqlite3 cursor object .", "label": 0}, {"idx": "cosqa-train-18751", "doc": "python ctypes get cursor position", "code": "def rl_get_point() -> int:  # pragma: no cover\n    \"\"\"\n    Returns the offset of the current cursor position in rl_line_buffer\n    \"\"\"\n    if rl_type == RlType.GNU:\n        return ctypes.c_int.in_dll(readline_lib, \"rl_point\").value\n\n    elif rl_type == RlType.PYREADLINE:\n        return readline.rl.mode.l_buffer.point\n\n    else:\n        return 0", "code_tokens": "def rl_get_point ( ) -> int : # pragma: no cover if rl_type == RlType . GNU : return ctypes . c_int . in_dll ( readline_lib , \"rl_point\" ) . value elif rl_type == RlType . PYREADLINE : return readline . rl . mode . l_buffer . point else : return 0", "docstring_tokens": "Returns the offset of the current cursor position in rl_line_buffer", "label": 1}, {"idx": "cosqa-train-18752", "doc": "enumerate python all instances", "code": "def to_dict(cls):\n        \"\"\"Make dictionary version of enumerated class.\n\n        Dictionary created this way can be used with def_num.\n\n        Returns:\n          A dict (name) -> number\n        \"\"\"\n        return dict((item.name, item.number) for item in iter(cls))", "code_tokens": "def to_dict ( cls ) : return dict ( ( item . name , item . number ) for item in iter ( cls ) )", "docstring_tokens": "Make dictionary version of enumerated class .", "label": 1}, {"idx": "cosqa-train-18753", "doc": "how to check a string for any non integer characters python", "code": "def is_valid(cls, arg):\n        \"\"\"Return True if arg is valid value for the class.  If the string\n        value is wrong for the enumeration, the encoding will fail.\n        \"\"\"\n        return (isinstance(arg, (int, long)) and (arg >= 0)) or \\\n            isinstance(arg, basestring)", "code_tokens": "def is_valid ( cls , arg ) : return ( isinstance ( arg , ( int , long ) ) and ( arg >= 0 ) ) or isinstance ( arg , basestring )", "docstring_tokens": "Return True if arg is valid value for the class . If the string value is wrong for the enumeration the encoding will fail .", "label": 0}, {"idx": "cosqa-train-18754", "doc": "python ndarray to string variable with no delimiter", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 1}, {"idx": "cosqa-train-18755", "doc": "how to split python string to a list", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 1}, {"idx": "cosqa-train-18756", "doc": "python graphviz windows dot", "code": "def cmd_dot(conf: Config):\n    \"\"\"Print out a neat targets dependency tree based on requested targets.\n\n    Use graphviz to render the dot file, e.g.:\n\n    > ybt dot :foo :bar | dot -Tpng -o graph.png\n    \"\"\"\n    build_context = BuildContext(conf)\n    populate_targets_graph(build_context, conf)\n    if conf.output_dot_file is None:\n        write_dot(build_context, conf, sys.stdout)\n    else:\n        with open(conf.output_dot_file, 'w') as out_file:\n            write_dot(build_context, conf, out_file)", "code_tokens": "def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "docstring_tokens": "Print out a neat targets dependency tree based on requested targets .", "label": 1}, {"idx": "cosqa-train-18757", "doc": "python read json file into dictionary", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 0}, {"idx": "cosqa-train-18758", "doc": "get text of file python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 0}, {"idx": "cosqa-train-18759", "doc": "replace values in python string", "code": "def replaceStrs(s, *args):\n    r\"\"\"Replace all ``(frm, to)`` tuples in `args` in string `s`.\n\n    >>> replaceStrs(\"nothing is better than warm beer\",\n    ...             ('nothing','warm beer'), ('warm beer','nothing'))\n    'warm beer is better than nothing'\n\n    \"\"\"\n    if args == (): return s\n    mapping = dict((frm, to) for frm, to in args)\n    return re.sub(\"|\".join(map(re.escape, mapping.keys())),\n                  lambda match:mapping[match.group(0)], s)", "code_tokens": "def replaceStrs ( s , * args ) : if args == ( ) : return s mapping = dict ( ( frm , to ) for frm , to in args ) return re . sub ( \"|\" . join ( map ( re . escape , mapping . keys ( ) ) ) , lambda match : mapping [ match . group ( 0 ) ] , s )", "docstring_tokens": "r Replace all ( frm to ) tuples in args in string s .", "label": 0}, {"idx": "cosqa-train-18760", "doc": "python compare if int or not", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 1}, {"idx": "cosqa-train-18761", "doc": "python replace several characters in string", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 0}, {"idx": "cosqa-train-18762", "doc": "how to get the names of the columns in python", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 0}, {"idx": "cosqa-train-18763", "doc": "how to change character in a string python using replace function", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 1}, {"idx": "cosqa-train-18764", "doc": "python split string to tokens", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 0}, {"idx": "cosqa-train-18765", "doc": "removing all words of a list from a text python", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 1}, {"idx": "cosqa-train-18766", "doc": "how to read csv file into a numpy array python", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 1}, {"idx": "cosqa-train-18767", "doc": "python remove hyperlinks from text", "code": "def remove_links(text):\n    \"\"\"\n    Helper function to remove the links from the input text\n\n    Args:\n        text (str): A string\n\n    Returns:\n        str: the same text, but with any substring that matches the regex\n        for a link removed and replaced with a space\n\n    Example:\n        >>> from tweet_parser.getter_methods.tweet_text import remove_links\n        >>> text = \"lorem ipsum dolor https://twitter.com/RobotPrincessFi\"\n        >>> remove_links(text)\n        'lorem ipsum dolor  '\n    \"\"\"\n    tco_link_regex = re.compile(\"https?://t.co/[A-z0-9].*\")\n    generic_link_regex = re.compile(\"(https?://)?(\\w*[.]\\w+)+([/?=&]+\\w+)*\")\n    remove_tco = re.sub(tco_link_regex, \" \", text)\n    remove_generic = re.sub(generic_link_regex, \" \", remove_tco)\n    return remove_generic", "code_tokens": "def remove_links ( text ) : tco_link_regex = re . compile ( \"https?://t.co/[A-z0-9].*\" ) generic_link_regex = re . compile ( \"(https?://)?(\\w*[.]\\w+)+([/?=&]+\\w+)*\" ) remove_tco = re . sub ( tco_link_regex , \" \" , text ) remove_generic = re . sub ( generic_link_regex , \" \" , remove_tco ) return remove_generic", "docstring_tokens": "Helper function to remove the links from the input text", "label": 0}, {"idx": "cosqa-train-18768", "doc": "how to tell if string is absolute path in python", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 0}, {"idx": "cosqa-train-18769", "doc": "python print string numpy array", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 1}, {"idx": "cosqa-train-18770", "doc": "iterate a python map fast way", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-18771", "doc": "how to detect a legit url with python", "code": "def looks_like_url(url):\n    \"\"\" Simplified check to see if the text appears to be a URL.\n\n    Similar to `urlparse` but much more basic.\n\n    Returns:\n      True if the url str appears to be valid.\n      False otherwise.\n\n    >>> url = looks_like_url(\"totalgood.org\")\n    >>> bool(url)\n    True\n    \"\"\"\n    if not isinstance(url, basestring):\n        return False\n    if not isinstance(url, basestring) or len(url) >= 1024 or not cre_url.match(url):\n        return False\n    return True", "code_tokens": "def looks_like_url ( url ) : if not isinstance ( url , basestring ) : return False if not isinstance ( url , basestring ) or len ( url ) >= 1024 or not cre_url . match ( url ) : return False return True", "docstring_tokens": "Simplified check to see if the text appears to be a URL .", "label": 1}, {"idx": "cosqa-train-18772", "doc": "python check if set is a subset", "code": "def issubset(self, other):\n        \"\"\"\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        \"\"\"\n        if len(self) > len(other):  # Fast check for obvious cases\n            return False\n        return all(item in other for item in self)", "code_tokens": "def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "docstring_tokens": "Report whether another set contains this set .", "label": 1}, {"idx": "cosqa-train-18773", "doc": "python remove phrase from list of strings", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 1}, {"idx": "cosqa-train-18774", "doc": "python clearing a dict of any records with no values", "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": "def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "docstring_tokens": "Return a new copied dictionary without the keys with None values from the given Mapping object .", "label": 1}, {"idx": "cosqa-train-18775", "doc": "python list to sql db field", "code": "def process_literal_param(self, value: Optional[List[int]],\n                              dialect: Dialect) -> str:\n        \"\"\"Convert things on the way from Python to the database.\"\"\"\n        retval = self._intlist_to_dbstr(value)\n        return retval", "code_tokens": "def process_literal_param ( self , value : Optional [ List [ int ] ] , dialect : Dialect ) -> str : retval = self . _intlist_to_dbstr ( value ) return retval", "docstring_tokens": "Convert things on the way from Python to the database .", "label": 1}, {"idx": "cosqa-train-18776", "doc": "delete an item from a set python", "code": "def remove_once(gset, elem):\n    \"\"\"Remove the element from a set, lists or dict.\n    \n        >>> L = [\"Lucy\"]; S = set([\"Sky\"]); D = { \"Diamonds\": True };\n        >>> remove_once(L, \"Lucy\"); remove_once(S, \"Sky\"); remove_once(D, \"Diamonds\");\n        >>> print L, S, D\n        [] set([]) {}\n\n    Returns the element if it was removed. Raises one of the exceptions in \n    :obj:`RemoveError` otherwise.\n    \"\"\"\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "code_tokens": "def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "docstring_tokens": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}", "label": 0}, {"idx": "cosqa-train-18777", "doc": "python tensorflow shape to array", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 1}, {"idx": "cosqa-train-18778", "doc": "how to set python3 django apache", "code": "def validate_django_compatible_with_python():\n    \"\"\"\n    Verify Django 1.11 is present if Python 2.7 is active\n\n    Installation of pinax-cli requires the correct version of Django for\n    the active Python version. If the developer subsequently changes\n    the Python version the installed Django may no longer be compatible.\n    \"\"\"\n    python_version = sys.version[:5]\n    django_version = django.get_version()\n    if sys.version_info == (2, 7) and django_version >= \"2\":\n        click.BadArgumentUsage(\"Please install Django v1.11 for Python {}, or switch to Python >= v3.4\".format(python_version))", "code_tokens": "def validate_django_compatible_with_python ( ) : python_version = sys . version [ : 5 ] django_version = django . get_version ( ) if sys . version_info == ( 2 , 7 ) and django_version >= \"2\" : click . BadArgumentUsage ( \"Please install Django v1.11 for Python {}, or switch to Python >= v3.4\" . format ( python_version ) )", "docstring_tokens": "Verify Django 1 . 11 is present if Python 2 . 7 is active", "label": 1}, {"idx": "cosqa-train-18779", "doc": "python create a tuple from input split", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 1}, {"idx": "cosqa-train-18780", "doc": "how to swithc to an open window in windows 10 using python", "code": "def SwitchToThisWindow(handle: int) -> None:\n    \"\"\"\n    SwitchToThisWindow from Win32.\n    handle: int, the handle of a native window.\n    \"\"\"\n    ctypes.windll.user32.SwitchToThisWindow(ctypes.c_void_p(handle), 1)", "code_tokens": "def SwitchToThisWindow ( handle : int ) -> None : ctypes . windll . user32 . SwitchToThisWindow ( ctypes . c_void_p ( handle ) , 1 )", "docstring_tokens": "SwitchToThisWindow from Win32 . handle : int the handle of a native window .", "label": 1}, {"idx": "cosqa-train-18781", "doc": "python index of first match in string", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 0}, {"idx": "cosqa-train-18782", "doc": "python type is not str", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 0}, {"idx": "cosqa-train-18783", "doc": "file of words into set python", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 0}, {"idx": "cosqa-train-18784", "doc": "python set add dictionnary", "code": "def dict_of_sets_add(dictionary, key, value):\n    # type: (DictUpperBound, Any, Any) -> None\n    \"\"\"Add value to a set in a dictionary by key\n\n    Args:\n        dictionary (DictUpperBound): Dictionary to which to add values\n        key (Any): Key within dictionary\n        value (Any): Value to add to set in dictionary\n\n    Returns:\n        None\n\n    \"\"\"\n    set_objs = dictionary.get(key, set())\n    set_objs.add(value)\n    dictionary[key] = set_objs", "code_tokens": "def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "docstring_tokens": "Add value to a set in a dictionary by key", "label": 0}, {"idx": "cosqa-train-18785", "doc": "python sqlalchemy modle attributes", "code": "def attrname_to_colname_dict(cls) -> Dict[str, str]:\n    \"\"\"\n    Asks an SQLAlchemy class how its attribute names correspond to database\n    column names.\n\n    Args:\n        cls: SQLAlchemy ORM class\n\n    Returns:\n        a dictionary mapping attribute names to database column names\n    \"\"\"\n    attr_col = {}  # type: Dict[str, str]\n    for attrname, column in gen_columns(cls):\n        attr_col[attrname] = column.name\n    return attr_col", "code_tokens": "def attrname_to_colname_dict ( cls ) -> Dict [ str , str ] : attr_col = { } # type: Dict[str, str] for attrname , column in gen_columns ( cls ) : attr_col [ attrname ] = column . name return attr_col", "docstring_tokens": "Asks an SQLAlchemy class how its attribute names correspond to database column names .", "label": 0}, {"idx": "cosqa-train-18786", "doc": "python list all column names", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 1}, {"idx": "cosqa-train-18787", "doc": "how to exit a code in python", "code": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)", "code_tokens": "def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "docstring_tokens": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting", "label": 1}, {"idx": "cosqa-train-18788", "doc": "longest path in a tree python", "code": "def dag_longest_path(graph, source, target):\n    \"\"\"\n    Finds the longest path in a dag between two nodes\n    \"\"\"\n    if source == target:\n        return [source]\n    allpaths = nx.all_simple_paths(graph, source, target)\n    longest_path = []\n    for l in allpaths:\n        if len(l) > len(longest_path):\n            longest_path = l\n    return longest_path", "code_tokens": "def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "docstring_tokens": "Finds the longest path in a dag between two nodes", "label": 0}, {"idx": "cosqa-train-18789", "doc": "python hsv to rgb code", "code": "def hsv2rgb_spectrum(hsv):\n    \"\"\"Generates RGB values from HSV values in line with a typical light\n    spectrum.\"\"\"\n    h, s, v = hsv\n    return hsv2rgb_raw(((h * 192) >> 8, s, v))", "code_tokens": "def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "docstring_tokens": "Generates RGB values from HSV values in line with a typical light spectrum .", "label": 1}, {"idx": "cosqa-train-18790", "doc": "python create dictionray from a list of keys", "code": "def encode_list(key, list_):\n    # type: (str, Iterable) -> Dict[str, str]\n    \"\"\"\n    Converts a list into a space-separated string and puts it in a dictionary\n\n    :param key: Dictionary key to store the list\n    :param list_: A list of objects\n    :return: A dictionary key->string or an empty dictionary\n    \"\"\"\n    if not list_:\n        return {}\n    return {key: \" \".join(str(i) for i in list_)}", "code_tokens": "def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "docstring_tokens": "Converts a list into a space - separated string and puts it in a dictionary", "label": 1}, {"idx": "cosqa-train-18791", "doc": "python json dump to list", "code": "def __as_list(value: List[JsonObjTypes]) -> List[JsonTypes]:\n        \"\"\" Return a json array as a list\n\n        :param value: array\n        :return: array with JsonObj instances removed\n        \"\"\"\n        return [e._as_dict if isinstance(e, JsonObj) else e for e in value]", "code_tokens": "def __as_list ( value : List [ JsonObjTypes ] ) -> List [ JsonTypes ] : return [ e . _as_dict if isinstance ( e , JsonObj ) else e for e in value ]", "docstring_tokens": "Return a json array as a list", "label": 1}, {"idx": "cosqa-train-18792", "doc": "list of arbitrary objects to counts in python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 1}, {"idx": "cosqa-train-18793", "doc": "remove characters string python", "code": "def strip_codes(s: Any) -> str:\n    \"\"\" Strip all color codes from a string.\n        Returns empty string for \"falsey\" inputs.\n    \"\"\"\n    return codepat.sub('', str(s) if (s or (s == 0)) else '')", "code_tokens": "def strip_codes ( s : Any ) -> str : return codepat . sub ( '' , str ( s ) if ( s or ( s == 0 ) ) else '' )", "docstring_tokens": "Strip all color codes from a string . Returns empty string for falsey inputs .", "label": 1}, {"idx": "cosqa-train-18794", "doc": "get last day of month python", "code": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day", "code_tokens": "def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "docstring_tokens": "Returns day number of the last day of the month : param t : datetime : return : int", "label": 1}, {"idx": "cosqa-train-18795", "doc": "how to remove columns from data frame python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 0}, {"idx": "cosqa-train-18796", "doc": "how to get last trading daya as string in python", "code": "def trade_day(dt, cal='US'):\n    \"\"\"\n    Latest trading day w.r.t given dt\n\n    Args:\n        dt: date of reference\n        cal: trading calendar\n\n    Returns:\n        pd.Timestamp: last trading day\n\n    Examples:\n        >>> trade_day('2018-12-25').strftime('%Y-%m-%d')\n        '2018-12-24'\n    \"\"\"\n    from xone import calendar\n\n    dt = pd.Timestamp(dt).date()\n    return calendar.trading_dates(start=dt - pd.Timedelta('10D'), end=dt, calendar=cal)[-1]", "code_tokens": "def trade_day ( dt , cal = 'US' ) : from xone import calendar dt = pd . Timestamp ( dt ) . date ( ) return calendar . trading_dates ( start = dt - pd . Timedelta ( '10D' ) , end = dt , calendar = cal ) [ - 1 ]", "docstring_tokens": "Latest trading day w . r . t given dt", "label": 0}, {"idx": "cosqa-train-18797", "doc": "python create dictionary with keys and no values", "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": "def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "docstring_tokens": "Return a new copied dictionary without the keys with None values from the given Mapping object .", "label": 1}, {"idx": "cosqa-train-18798", "doc": "python utcnow timezone aware", "code": "def get_now_utc_notz_datetime() -> datetime.datetime:\n    \"\"\"\n    Get the UTC time now, but with no timezone information,\n    in :class:`datetime.datetime` format.\n    \"\"\"\n    now = datetime.datetime.utcnow()\n    return now.replace(tzinfo=None)", "code_tokens": "def get_now_utc_notz_datetime ( ) -> datetime . datetime : now = datetime . datetime . utcnow ( ) return now . replace ( tzinfo = None )", "docstring_tokens": "Get the UTC time now but with no timezone information in : class : datetime . datetime format .", "label": 1}, {"idx": "cosqa-train-18799", "doc": "how to check if a file is not empty in python", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 1}, {"idx": "cosqa-train-18800", "doc": "python numpy ndarray yaml", "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]:\n    \"\"\" Write a numpy array to YAML.\n\n    It registers the array under the tag ``!numpy_array``.\n\n    Use with:\n\n    .. code-block:: python\n\n        >>> yaml = ruamel.yaml.YAML()\n        >>> yaml.representer.add_representer(np.ndarray, yaml.numpy_to_yaml)\n\n    Note:\n        We cannot use ``yaml.register_class`` because it won't register the proper type.\n        (It would register the type of the class, rather than of `numpy.ndarray`). Instead,\n        we use the above approach to register this method explicitly with the representer.\n    \"\"\"\n    return representer.represent_sequence(\n        \"!numpy_array\",\n        data.tolist()\n    )", "code_tokens": "def numpy_to_yaml ( representer : Representer , data : np . ndarray ) -> Sequence [ Any ] : return representer . represent_sequence ( \"!numpy_array\" , data . tolist ( ) )", "docstring_tokens": "Write a numpy array to YAML .", "label": 1}, {"idx": "cosqa-train-18801", "doc": "create set from file in python", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 1}, {"idx": "cosqa-train-18802", "doc": "how to check if a string is a link python", "code": "def looks_like_url(url):\n    \"\"\" Simplified check to see if the text appears to be a URL.\n\n    Similar to `urlparse` but much more basic.\n\n    Returns:\n      True if the url str appears to be valid.\n      False otherwise.\n\n    >>> url = looks_like_url(\"totalgood.org\")\n    >>> bool(url)\n    True\n    \"\"\"\n    if not isinstance(url, basestring):\n        return False\n    if not isinstance(url, basestring) or len(url) >= 1024 or not cre_url.match(url):\n        return False\n    return True", "code_tokens": "def looks_like_url ( url ) : if not isinstance ( url , basestring ) : return False if not isinstance ( url , basestring ) or len ( url ) >= 1024 or not cre_url . match ( url ) : return False return True", "docstring_tokens": "Simplified check to see if the text appears to be a URL .", "label": 0}, {"idx": "cosqa-train-18803", "doc": "redis cluster delete all keys python", "code": "def clean_all_buckets(self):\n        \"\"\"\n        Removes all buckets from all hashes and their content.\n        \"\"\"\n        bucket_keys = self.redis_object.keys(pattern='nearpy_*')\n        if len(bucket_keys) > 0:\n            self.redis_object.delete(*bucket_keys)", "code_tokens": "def clean_all_buckets ( self ) : bucket_keys = self . redis_object . keys ( pattern = 'nearpy_*' ) if len ( bucket_keys ) > 0 : self . redis_object . delete ( * bucket_keys )", "docstring_tokens": "Removes all buckets from all hashes and their content .", "label": 0}, {"idx": "cosqa-train-18804", "doc": "sum to 1 normalize python", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 0}, {"idx": "cosqa-train-18805", "doc": "python3 orm mysql datetime now", "code": "def get_now_sql_datetime():\n    \"\"\"\n    *A datetime stamp in MySQL format: ``YYYY-MM-DDTHH:MM:SS``*\n\n    **Return:**\n        - ``now`` -- current time and date in MySQL format\n\n    **Usage:**\n        .. code-block:: python \n\n            from fundamentals import times\n            now = times.get_now_sql_datetime()\n            print now\n\n            # OUT: 2016-03-18T11:08:23 \n    \"\"\"\n    ## > IMPORTS ##\n    from datetime import datetime, date, time\n    now = datetime.now()\n    now = now.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    return now", "code_tokens": "def get_now_sql_datetime ( ) : ## > IMPORTS ## from datetime import datetime , date , time now = datetime . now ( ) now = now . strftime ( \"%Y-%m-%dT%H:%M:%S\" ) return now", "docstring_tokens": "* A datetime stamp in MySQL format : YYYY - MM - DDTHH : MM : SS *", "label": 0}, {"idx": "cosqa-train-18806", "doc": "python check if date is end of month", "code": "def is_end_of_month(self) -> bool:\n        \"\"\" Checks if the date is at the end of the month \"\"\"\n        end_of_month = Datum()\n        # get_end_of_month(value)\n        end_of_month.end_of_month()\n        return self.value == end_of_month.value", "code_tokens": "def is_end_of_month ( self ) -> bool : end_of_month = Datum ( ) # get_end_of_month(value) end_of_month . end_of_month ( ) return self . value == end_of_month . value", "docstring_tokens": "Checks if the date is at the end of the month", "label": 1}, {"idx": "cosqa-train-18807", "doc": "string to uuid python", "code": "def uuid2buid(value):\n    \"\"\"\n    Convert a UUID object to a 22-char BUID string\n\n    >>> u = uuid.UUID('33203dd2-f2ef-422f-aeb0-058d6f5f7089')\n    >>> uuid2buid(u)\n    'MyA90vLvQi-usAWNb19wiQ'\n    \"\"\"\n    if six.PY3:  # pragma: no cover\n        return urlsafe_b64encode(value.bytes).decode('utf-8').rstrip('=')\n    else:\n        return six.text_type(urlsafe_b64encode(value.bytes).rstrip('='))", "code_tokens": "def uuid2buid ( value ) : if six . PY3 : # pragma: no cover return urlsafe_b64encode ( value . bytes ) . decode ( 'utf-8' ) . rstrip ( '=' ) else : return six . text_type ( urlsafe_b64encode ( value . bytes ) . rstrip ( '=' ) )", "docstring_tokens": "Convert a UUID object to a 22 - char BUID string", "label": 1}, {"idx": "cosqa-train-18808", "doc": "how to check is a column is null in python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-18809", "doc": "supress python output shell", "code": "def suppress_stdout():\n    \"\"\"\n    Context manager that suppresses stdout.\n\n    Examples:\n        >>> with suppress_stdout():\n        ...     print('Test print')\n\n        >>> print('test')\n        test\n\n    \"\"\"\n    save_stdout = sys.stdout\n    sys.stdout = DevNull()\n    yield\n    sys.stdout = save_stdout", "code_tokens": "def suppress_stdout ( ) : save_stdout = sys . stdout sys . stdout = DevNull ( ) yield sys . stdout = save_stdout", "docstring_tokens": "Context manager that suppresses stdout .", "label": 1}, {"idx": "cosqa-train-18810", "doc": "python creating dictionary from list of lists", "code": "def encode_list(key, list_):\n    # type: (str, Iterable) -> Dict[str, str]\n    \"\"\"\n    Converts a list into a space-separated string and puts it in a dictionary\n\n    :param key: Dictionary key to store the list\n    :param list_: A list of objects\n    :return: A dictionary key->string or an empty dictionary\n    \"\"\"\n    if not list_:\n        return {}\n    return {key: \" \".join(str(i) for i in list_)}", "code_tokens": "def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "docstring_tokens": "Converts a list into a space - separated string and puts it in a dictionary", "label": 1}, {"idx": "cosqa-train-18811", "doc": "python lower each element of list", "code": "def gen_lower(x: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\"\n    Args:\n        x: iterable of strings\n\n    Yields:\n        each string in lower case\n    \"\"\"\n    for string in x:\n        yield string.lower()", "code_tokens": "def gen_lower ( x : Iterable [ str ] ) -> Generator [ str , None , None ] : for string in x : yield string . lower ( )", "docstring_tokens": "Args : x : iterable of strings", "label": 1}, {"idx": "cosqa-train-18812", "doc": "python invert a dict", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 1}, {"idx": "cosqa-train-18813", "doc": "remove hyper links from sentence in python", "code": "def remove_links(text):\n    \"\"\"\n    Helper function to remove the links from the input text\n\n    Args:\n        text (str): A string\n\n    Returns:\n        str: the same text, but with any substring that matches the regex\n        for a link removed and replaced with a space\n\n    Example:\n        >>> from tweet_parser.getter_methods.tweet_text import remove_links\n        >>> text = \"lorem ipsum dolor https://twitter.com/RobotPrincessFi\"\n        >>> remove_links(text)\n        'lorem ipsum dolor  '\n    \"\"\"\n    tco_link_regex = re.compile(\"https?://t.co/[A-z0-9].*\")\n    generic_link_regex = re.compile(\"(https?://)?(\\w*[.]\\w+)+([/?=&]+\\w+)*\")\n    remove_tco = re.sub(tco_link_regex, \" \", text)\n    remove_generic = re.sub(generic_link_regex, \" \", remove_tco)\n    return remove_generic", "code_tokens": "def remove_links ( text ) : tco_link_regex = re . compile ( \"https?://t.co/[A-z0-9].*\" ) generic_link_regex = re . compile ( \"(https?://)?(\\w*[.]\\w+)+([/?=&]+\\w+)*\" ) remove_tco = re . sub ( tco_link_regex , \" \" , text ) remove_generic = re . sub ( generic_link_regex , \" \" , remove_tco ) return remove_generic", "docstring_tokens": "Helper function to remove the links from the input text", "label": 1}, {"idx": "cosqa-train-18814", "doc": "python parsing bits of stream", "code": "def decode_value(stream):\n    \"\"\"Decode the contents of a value from a serialized stream.\n\n    :param stream: Source data stream\n    :type stream: io.BytesIO\n    :returns: Decoded value\n    :rtype: bytes\n    \"\"\"\n    length = decode_length(stream)\n    (value,) = unpack_value(\">{:d}s\".format(length), stream)\n    return value", "code_tokens": "def decode_value ( stream ) : length = decode_length ( stream ) ( value , ) = unpack_value ( \">{:d}s\" . format ( length ) , stream ) return value", "docstring_tokens": "Decode the contents of a value from a serialized stream .", "label": 1}, {"idx": "cosqa-train-18815", "doc": "identify the most common number in an array python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 1}, {"idx": "cosqa-train-18816", "doc": "python get value from tensor as float", "code": "def fcast(value: float) -> TensorLike:\n    \"\"\"Cast to float tensor\"\"\"\n    newvalue = tf.cast(value, FTYPE)\n    if DEVICE == 'gpu':\n        newvalue = newvalue.gpu()  # Why is this needed?  # pragma: no cover\n    return newvalue", "code_tokens": "def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "docstring_tokens": "Cast to float tensor", "label": 0}, {"idx": "cosqa-train-18817", "doc": "how to product of a list in python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 1}, {"idx": "cosqa-train-18818", "doc": "how to capitalize a letter in a string python", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 1}, {"idx": "cosqa-train-18819", "doc": "how to tell if a value is valid based of its base python", "code": "def check_valid(number, input_base=10):\n    \"\"\"\n    Checks if there is an invalid digit in the input number.\n\n    Args:\n        number: An number in the following form:\n            (int, int, int, ... , '.' , int, int, int)\n            (iterable container) containing positive integers of the input base\n        input_base(int): The base of the input number.\n\n    Returns:\n        bool, True if all digits valid, else False.\n\n    Examples:\n        >>> check_valid((1,9,6,'.',5,1,6), 12)\n        True\n        >>> check_valid((8,1,15,9), 15)\n        False\n    \"\"\"\n    for n in number:\n        if n in (\".\", \"[\", \"]\"):\n            continue\n        elif n >= input_base:\n            if n == 1 and input_base == 1:\n                continue\n            else:\n                return False\n    return True", "code_tokens": "def check_valid ( number , input_base = 10 ) : for n in number : if n in ( \".\" , \"[\" , \"]\" ) : continue elif n >= input_base : if n == 1 and input_base == 1 : continue else : return False return True", "docstring_tokens": "Checks if there is an invalid digit in the input number . Args : number : An number in the following form : ( int int int ... . int int int ) ( iterable container ) containing positive integers of the input base input_base ( int ) : The base of the input number . Returns : bool True if all digits valid else False . Examples : >>> check_valid (( 1 9 6 . 5 1 6 ) 12 ) True >>> check_valid (( 8 1 15 9 ) 15 ) False", "label": 1}, {"idx": "cosqa-train-18820", "doc": "python curses set text colour", "code": "def ResetConsoleColor() -> bool:\n    \"\"\"\n    Reset to the default text color on console window.\n    Return bool, True if succeed otherwise False.\n    \"\"\"\n    if sys.stdout:\n        sys.stdout.flush()\n    bool(ctypes.windll.kernel32.SetConsoleTextAttribute(_ConsoleOutputHandle, _DefaultConsoleColor))", "code_tokens": "def ResetConsoleColor ( ) -> bool : if sys . stdout : sys . stdout . flush ( ) bool ( ctypes . windll . kernel32 . SetConsoleTextAttribute ( _ConsoleOutputHandle , _DefaultConsoleColor ) )", "docstring_tokens": "Reset to the default text color on console window . Return bool True if succeed otherwise False .", "label": 1}, {"idx": "cosqa-train-18821", "doc": "python, get time zone info", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-18822", "doc": "bulk insert into mongodb collection in python", "code": "def upsert_multi(db, collection, object, match_params=None):\n        \"\"\"\n        Wrapper for pymongo.insert_many() and update_many()\n        :param db: db connection\n        :param collection: collection to update\n        :param object: the modifications to apply\n        :param match_params: a query that matches the documents to update\n        :return: ids of inserted/updated document\n        \"\"\"\n        if isinstance(object, list) and len(object) > 0:\n            return str(db[collection].insert_many(object).inserted_ids)\n        elif isinstance(object, dict):\n            return str(db[collection].update_many(match_params, {\"$set\": object}, upsert=False).upserted_id)", "code_tokens": "def upsert_multi ( db , collection , object , match_params = None ) : if isinstance ( object , list ) and len ( object ) > 0 : return str ( db [ collection ] . insert_many ( object ) . inserted_ids ) elif isinstance ( object , dict ) : return str ( db [ collection ] . update_many ( match_params , { \"$set\" : object } , upsert = False ) . upserted_id )", "docstring_tokens": "Wrapper for pymongo . insert_many () and update_many () : param db : db connection : param collection : collection to update : param object : the modifications to apply : param match_params : a query that matches the documents to update : return : ids of inserted / updated document", "label": 0}, {"idx": "cosqa-train-18823", "doc": "how to get visitor's language in python django", "code": "def get_language():\n    \"\"\"\n    Wrapper around Django's `get_language` utility.\n    For Django >= 1.8, `get_language` returns None in case no translation is activate.\n    Here we patch this behavior e.g. for back-end functionality requiring access to translated fields\n    \"\"\"\n    from parler import appsettings\n    language = dj_get_language()\n    if language is None and appsettings.PARLER_DEFAULT_ACTIVATE:\n        return appsettings.PARLER_DEFAULT_LANGUAGE_CODE\n    else:\n        return language", "code_tokens": "def get_language ( ) : from parler import appsettings language = dj_get_language ( ) if language is None and appsettings . PARLER_DEFAULT_ACTIVATE : return appsettings . PARLER_DEFAULT_LANGUAGE_CODE else : return language", "docstring_tokens": "Wrapper around Django s get_language utility . For Django > = 1 . 8 get_language returns None in case no translation is activate . Here we patch this behavior e . g . for back - end functionality requiring access to translated fields", "label": 1}, {"idx": "cosqa-train-18824", "doc": "python join query string to url", "code": "def url_concat(url, args):\n    \"\"\"Concatenate url and argument dictionary regardless of whether\n    url has existing query parameters.\n\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    \"\"\"\n    if not args: return url\n    if url[-1] not in ('?', '&'):\n        url += '&' if ('?' in url) else '?'\n    return url + urllib.urlencode(args)", "code_tokens": "def url_concat ( url , args ) : if not args : return url if url [ - 1 ] not in ( '?' , '&' ) : url += '&' if ( '?' in url ) else '?' return url + urllib . urlencode ( args )", "docstring_tokens": "Concatenate url and argument dictionary regardless of whether url has existing query parameters .", "label": 1}, {"idx": "cosqa-train-18825", "doc": "get all the flags in python", "code": "def get_system_flags() -> FrozenSet[Flag]:\n    \"\"\"Return the set of implemented system flags.\"\"\"\n    return frozenset({Seen, Recent, Deleted, Flagged, Answered, Draft})", "code_tokens": "def get_system_flags ( ) -> FrozenSet [ Flag ] : return frozenset ( { Seen , Recent , Deleted , Flagged , Answered , Draft } )", "docstring_tokens": "Return the set of implemented system flags .", "label": 1}, {"idx": "cosqa-train-18826", "doc": "how to check if a string is all letters python", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-18827", "doc": "count the frequency of an integer in a list python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 1}, {"idx": "cosqa-train-18828", "doc": "isalpha of a character in a string python3", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-18829", "doc": "how to get random walk onto python", "code": "def returned(n):\n\t\"\"\"Generate a random walk and return True if the walker has returned to\n\tthe origin after taking `n` steps.\n\t\"\"\"\n\t## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk\n\tfor pos in randwalk() >> drop(1) >> takei(xrange(n-1)):\n\t\tif pos == Origin:\n\t\t\treturn True\n\treturn False", "code_tokens": "def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "docstring_tokens": "Generate a random walk and return True if the walker has returned to the origin after taking n steps .", "label": 0}, {"idx": "cosqa-train-18830", "doc": "python get cache usage for a process", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 0}, {"idx": "cosqa-train-18831", "doc": "remove from python dict by key", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 0}, {"idx": "cosqa-train-18832", "doc": "python3 flatten a list", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 1}, {"idx": "cosqa-train-18833", "doc": "python pyodbc int to string", "code": "def process_literal_param(self, value: Optional[List[int]],\n                              dialect: Dialect) -> str:\n        \"\"\"Convert things on the way from Python to the database.\"\"\"\n        retval = self._intlist_to_dbstr(value)\n        return retval", "code_tokens": "def process_literal_param ( self , value : Optional [ List [ int ] ] , dialect : Dialect ) -> str : retval = self . _intlist_to_dbstr ( value ) return retval", "docstring_tokens": "Convert things on the way from Python to the database .", "label": 1}, {"idx": "cosqa-train-18834", "doc": "how does python multiply m,atrices", "code": "def __rmatmul__(self, other):\n        \"\"\"\n        Matrix multiplication using binary `@` operator in Python>=3.5.\n        \"\"\"\n        return self.T.dot(np.transpose(other)).T", "code_tokens": "def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T", "docstring_tokens": "Matrix multiplication using binary", "label": 0}, {"idx": "cosqa-train-18835", "doc": "determine if three consectuitve day are above a number python", "code": "def non_increasing(values):\n    \"\"\"True if values are not increasing.\"\"\"\n    return all(x >= y for x, y in zip(values, values[1:]))", "code_tokens": "def non_increasing ( values ) : return all ( x >= y for x , y in zip ( values , values [ 1 : ] ) )", "docstring_tokens": "True if values are not increasing .", "label": 0}, {"idx": "cosqa-train-18836", "doc": "python list index for duplicated data", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 1}, {"idx": "cosqa-train-18837", "doc": "replace every instance of word in python string", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 1}, {"idx": "cosqa-train-18838", "doc": "create a limit of a function in python", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 0}, {"idx": "cosqa-train-18839", "doc": "how to get the length of a key python", "code": "def codes_get_size(handle, key):\n    # type: (cffi.FFI.CData, str) -> int\n    \"\"\"\n    Get the number of coded value from a key.\n    If several keys of the same name are present, the total sum is returned.\n\n    :param bytes key: the keyword to get the size of\n\n    :rtype: int\n    \"\"\"\n    size = ffi.new('size_t *')\n    _codes_get_size(handle, key.encode(ENC), size)\n    return size[0]", "code_tokens": "def codes_get_size ( handle , key ) : # type: (cffi.FFI.CData, str) -> int size = ffi . new ( 'size_t *' ) _codes_get_size ( handle , key . encode ( ENC ) , size ) return size [ 0 ]", "docstring_tokens": "Get the number of coded value from a key . If several keys of the same name are present the total sum is returned .", "label": 1}, {"idx": "cosqa-train-18840", "doc": "python flask disable cache", "code": "def setup_cache(app: Flask, cache_config) -> Optional[Cache]:\n    \"\"\"Setup the flask-cache on a flask app\"\"\"\n    if cache_config and cache_config.get('CACHE_TYPE') != 'null':\n        return Cache(app, config=cache_config)\n\n    return None", "code_tokens": "def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None", "docstring_tokens": "Setup the flask - cache on a flask app", "label": 0}, {"idx": "cosqa-train-18841", "doc": "python how to shorten the decimals in a float", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 1}, {"idx": "cosqa-train-18842", "doc": "how to check whether a string is int in python", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-18843", "doc": "add a local variable python setattr", "code": "def call_fset(self, obj, value) -> None:\n        \"\"\"Store the given custom value and call the setter function.\"\"\"\n        vars(obj)[self.name] = self.fset(obj, value)", "code_tokens": "def call_fset ( self , obj , value ) -> None : vars ( obj ) [ self . name ] = self . fset ( obj , value )", "docstring_tokens": "Store the given custom value and call the setter function .", "label": 1}, {"idx": "cosqa-train-18844", "doc": "count occurences in a list python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 1}, {"idx": "cosqa-train-18845", "doc": "how to add ast in python", "code": "def src2ast(src: str) -> Expression:\n    \"\"\"Return ast.Expression created from source code given in `src`.\"\"\"\n    try:\n        return ast.parse(src, mode='eval')\n    except SyntaxError:\n        raise ValueError(\"Not a valid expression.\") from None", "code_tokens": "def src2ast ( src : str ) -> Expression : try : return ast . parse ( src , mode = 'eval' ) except SyntaxError : raise ValueError ( \"Not a valid expression.\" ) from None", "docstring_tokens": "Return ast . Expression created from source code given in src .", "label": 0}, {"idx": "cosqa-train-18846", "doc": "python make a put request to restful endpoint", "code": "def put(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP PUT operation to API endpoint.\"\"\"\n\n        return self._request('PUT', endpoint, **kwargs)", "code_tokens": "def put ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'PUT' , endpoint , * * kwargs )", "docstring_tokens": "HTTP PUT operation to API endpoint .", "label": 1}, {"idx": "cosqa-train-18847", "doc": "if two strungs are equal python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 0}, {"idx": "cosqa-train-18848", "doc": "cast list as array in python", "code": "def listify(a):\n    \"\"\"\n    Convert a scalar ``a`` to a list and all iterables to list as well.\n\n    Examples\n    --------\n    >>> listify(0)\n    [0]\n\n    >>> listify([1,2,3])\n    [1, 2, 3]\n\n    >>> listify('a')\n    ['a']\n\n    >>> listify(np.array([1,2,3]))\n    [1, 2, 3]\n\n    >>> listify('string')\n    ['string']\n    \"\"\"\n    if a is None:\n        return []\n    elif not isinstance(a, (tuple, list, np.ndarray)):\n        return [a]\n    return list(a)", "code_tokens": "def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "docstring_tokens": "Convert a scalar a to a list and all iterables to list as well .", "label": 0}, {"idx": "cosqa-train-18849", "doc": "how do you invert a dictionary python", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 0}, {"idx": "cosqa-train-18850", "doc": "python turn json into string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 0}, {"idx": "cosqa-train-18851", "doc": "python elementtree clear children", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 0}, {"idx": "cosqa-train-18852", "doc": "list of ms access table names python", "code": "def get_table_names_from_metadata(metadata: MetaData) -> List[str]:\n    \"\"\"\n    Returns all database table names found in an SQLAlchemy :class:`MetaData`\n    object.\n    \"\"\"\n    return [table.name for table in metadata.tables.values()]", "code_tokens": "def get_table_names_from_metadata ( metadata : MetaData ) -> List [ str ] : return [ table . name for table in metadata . tables . values ( ) ]", "docstring_tokens": "Returns all database table names found in an SQLAlchemy : class : MetaData object .", "label": 1}, {"idx": "cosqa-train-18853", "doc": "remove extra whitespace from all kind of data frame column values in python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 1}, {"idx": "cosqa-train-18854", "doc": "python shortest distance on triangulated mesh", "code": "def signed_distance(mesh, points):\n    \"\"\"\n    Find the signed distance from a mesh to a list of points.\n\n    * Points OUTSIDE the mesh will have NEGATIVE distance\n    * Points within tol.merge of the surface will have POSITIVE distance\n    * Points INSIDE the mesh will have POSITIVE distance\n\n    Parameters\n    -----------\n    mesh   : Trimesh object\n    points : (n,3) float, list of points in space\n\n    Returns\n    ----------\n    signed_distance : (n,3) float, signed distance from point to mesh\n    \"\"\"\n    # make sure we have a numpy array\n    points = np.asanyarray(points, dtype=np.float64)\n\n    # find the closest point on the mesh to the queried points\n    closest, distance, triangle_id = closest_point(mesh, points)\n\n    # we only care about nonzero distances\n    nonzero = distance > tol.merge\n\n    if not nonzero.any():\n        return distance\n\n    inside = mesh.ray.contains_points(points[nonzero])\n    sign = (inside.astype(int) * 2) - 1\n\n    # apply sign to previously computed distance\n    distance[nonzero] *= sign\n\n    return distance", "code_tokens": "def signed_distance ( mesh , points ) : # make sure we have a numpy array points = np . asanyarray ( points , dtype = np . float64 ) # find the closest point on the mesh to the queried points closest , distance , triangle_id = closest_point ( mesh , points ) # we only care about nonzero distances nonzero = distance > tol . merge if not nonzero . any ( ) : return distance inside = mesh . ray . contains_points ( points [ nonzero ] ) sign = ( inside . astype ( int ) * 2 ) - 1 # apply sign to previously computed distance distance [ nonzero ] *= sign return distance", "docstring_tokens": "Find the signed distance from a mesh to a list of points .", "label": 1}, {"idx": "cosqa-train-18855", "doc": "python last item inl list", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 1}, {"idx": "cosqa-train-18856", "doc": "easy way to check is a boolean has changed in python", "code": "def needs_check(self):\n        \"\"\"\n        Check if enough time has elapsed to perform a check().\n\n        If this time has elapsed, a state change check through\n        has_state_changed() should be performed and eventually a sync().\n\n        :rtype: boolean\n        \"\"\"\n        if self.lastcheck is None:\n            return True\n        return time.time() - self.lastcheck >= self.ipchangedetection_sleep", "code_tokens": "def needs_check ( self ) : if self . lastcheck is None : return True return time . time ( ) - self . lastcheck >= self . ipchangedetection_sleep", "docstring_tokens": "Check if enough time has elapsed to perform a check () .", "label": 1}, {"idx": "cosqa-train-18857", "doc": "python script to check for keyboard input", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 0}, {"idx": "cosqa-train-18858", "doc": "python how to create date from string", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 1}, {"idx": "cosqa-train-18859", "doc": "python replacing strings in a list using a dictionary", "code": "def replace_in_list(stringlist: Iterable[str],\n                    replacedict: Dict[str, str]) -> List[str]:\n    \"\"\"\n    Returns a list produced by applying :func:`multiple_replace` to every\n    string in ``stringlist``.\n\n    Args:\n        stringlist: list of source strings\n        replacedict: dictionary mapping \"original\" to \"replacement\" strings\n\n    Returns:\n        list of final strings\n\n    \"\"\"\n    newlist = []\n    for fromstring in stringlist:\n        newlist.append(multiple_replace(fromstring, replacedict))\n    return newlist", "code_tokens": "def replace_in_list ( stringlist : Iterable [ str ] , replacedict : Dict [ str , str ] ) -> List [ str ] : newlist = [ ] for fromstring in stringlist : newlist . append ( multiple_replace ( fromstring , replacedict ) ) return newlist", "docstring_tokens": "Returns a list produced by applying : func : multiple_replace to every string in stringlist .", "label": 0}, {"idx": "cosqa-train-18860", "doc": "python boto3 s3 get latest object date", "code": "def get_creation_date(\n            self,\n            bucket: str,\n            key: str,\n    ) -> datetime.datetime:\n        \"\"\"\n        Retrieves the creation date for a given key in a given bucket.\n        :param bucket: the bucket the object resides in.\n        :param key: the key of the object for which the creation date is being retrieved.\n        :return: the creation date\n        \"\"\"\n        blob_obj = self._get_blob_obj(bucket, key)\n        return blob_obj.time_created", "code_tokens": "def get_creation_date ( self , bucket : str , key : str , ) -> datetime . datetime : blob_obj = self . _get_blob_obj ( bucket , key ) return blob_obj . time_created", "docstring_tokens": "Retrieves the creation date for a given key in a given bucket . : param bucket : the bucket the object resides in . : param key : the key of the object for which the creation date is being retrieved . : return : the creation date", "label": 0}, {"idx": "cosqa-train-18861", "doc": "python replace multiple characters from string", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 0}, {"idx": "cosqa-train-18862", "doc": "python numpy read in a csv file into a numpy array", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 0}, {"idx": "cosqa-train-18863", "doc": "how to check if memory leak in python program", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 1}, {"idx": "cosqa-train-18864", "doc": "python test if path is full", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 0}, {"idx": "cosqa-train-18865", "doc": "python dateutil last day of month", "code": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day", "code_tokens": "def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "docstring_tokens": "Returns day number of the last day of the month : param t : datetime : return : int", "label": 0}, {"idx": "cosqa-train-18866", "doc": "python how to ise math pow(x n)", "code": "def safe_pow(base, exp):\n    \"\"\"safe version of pow\"\"\"\n    if exp > MAX_EXPONENT:\n        raise RuntimeError(\"Invalid exponent, max exponent is {}\".format(MAX_EXPONENT))\n    return base ** exp", "code_tokens": "def safe_pow ( base , exp ) : if exp > MAX_EXPONENT : raise RuntimeError ( \"Invalid exponent, max exponent is {}\" . format ( MAX_EXPONENT ) ) return base ** exp", "docstring_tokens": "safe version of pow", "label": 1}, {"idx": "cosqa-train-18867", "doc": "check if value is infinity in python", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 1}, {"idx": "cosqa-train-18868", "doc": "cython string to char python3", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 0}, {"idx": "cosqa-train-18869", "doc": "how to check if shape file is empty or not python", "code": "def is_empty_shape(sh: ShExJ.Shape) -> bool:\n        \"\"\" Determine whether sh has any value \"\"\"\n        return sh.closed is None and sh.expression is None and sh.extra is None and \\\n            sh.semActs is None", "code_tokens": "def is_empty_shape ( sh : ShExJ . Shape ) -> bool : return sh . closed is None and sh . expression is None and sh . extra is None and sh . semActs is None", "docstring_tokens": "Determine whether sh has any value", "label": 0}, {"idx": "cosqa-train-18870", "doc": "check each character in a string python alphanumeric", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-18871", "doc": "get name of week day in python", "code": "def get_day_name(self) -> str:\n        \"\"\" Returns the day name \"\"\"\n        weekday = self.value.isoweekday() - 1\n        return calendar.day_name[weekday]", "code_tokens": "def get_day_name ( self ) -> str : weekday = self . value . isoweekday ( ) - 1 return calendar . day_name [ weekday ]", "docstring_tokens": "Returns the day name", "label": 0}, {"idx": "cosqa-train-18872", "doc": "how to meausre distributed of hash function in python", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 0}, {"idx": "cosqa-train-18873", "doc": "python round or cast to int", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 1}, {"idx": "cosqa-train-18874", "doc": "just get an year from a date in python", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 0}, {"idx": "cosqa-train-18875", "doc": "from 1d tensor to a 3d tensor python", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 0}, {"idx": "cosqa-train-18876", "doc": "win32 move window python", "code": "def MoveWindow(handle: int, x: int, y: int, width: int, height: int, repaint: int = 1) -> bool:\n    \"\"\"\n    MoveWindow from Win32.\n    handle: int, the handle of a native window.\n    x: int.\n    y: int.\n    width: int.\n    height: int.\n    repaint: int, use 1 or 0.\n    Return bool, True if succeed otherwise False.\n    \"\"\"\n    return bool(ctypes.windll.user32.MoveWindow(ctypes.c_void_p(handle), x, y, width, height, repaint))", "code_tokens": "def MoveWindow ( handle : int , x : int , y : int , width : int , height : int , repaint : int = 1 ) -> bool : return bool ( ctypes . windll . user32 . MoveWindow ( ctypes . c_void_p ( handle ) , x , y , width , height , repaint ) )", "docstring_tokens": "MoveWindow from Win32 . handle : int the handle of a native window . x : int . y : int . width : int . height : int . repaint : int use 1 or 0 . Return bool True if succeed otherwise False .", "label": 1}, {"idx": "cosqa-train-18877", "doc": "python isprime function print integers for a range", "code": "def is_prime(n):\n    \"\"\"\n    Check if n is a prime number\n    \"\"\"\n    if n % 2 == 0 and n > 2:\n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))", "code_tokens": "def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "docstring_tokens": "Check if n is a prime number", "label": 0}, {"idx": "cosqa-train-18878", "doc": "python strip to turn string into number", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-18879", "doc": "read line in python skip certain newline", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-18880", "doc": "initialize an array in python without numpy", "code": "def to_0d_array(value: Any) -> np.ndarray:\n    \"\"\"Given a value, wrap it in a 0-D numpy.ndarray.\n    \"\"\"\n    if np.isscalar(value) or (isinstance(value, np.ndarray) and\n                              value.ndim == 0):\n        return np.array(value)\n    else:\n        return to_0d_object_array(value)", "code_tokens": "def to_0d_array ( value : Any ) -> np . ndarray : if np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and value . ndim == 0 ) : return np . array ( value ) else : return to_0d_object_array ( value )", "docstring_tokens": "Given a value wrap it in a 0 - D numpy . ndarray .", "label": 0}, {"idx": "cosqa-train-18881", "doc": "check whether date is valid python", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 0}, {"idx": "cosqa-train-18882", "doc": "difining np array in python string", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 0}, {"idx": "cosqa-train-18883", "doc": "python get last month days", "code": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day", "code_tokens": "def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "docstring_tokens": "Returns day number of the last day of the month : param t : datetime : return : int", "label": 1}, {"idx": "cosqa-train-18884", "doc": "python series datetime to seconds", "code": "def clip_to_seconds(m: Union[int, pd.Series]) -> Union[int, pd.Series]:\n        \"\"\"Clips UTC datetime in nanoseconds to seconds.\"\"\"\n        return m // pd.Timedelta(1, unit='s').value", "code_tokens": "def clip_to_seconds ( m : Union [ int , pd . Series ] ) -> Union [ int , pd . Series ] : return m // pd . Timedelta ( 1 , unit = 's' ) . value", "docstring_tokens": "Clips UTC datetime in nanoseconds to seconds .", "label": 0}, {"idx": "cosqa-train-18885", "doc": "boost python expose a struct with enum type member", "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum:\n    \"\"\"\n    Converts an ``dict`` to a ``Enum``.\n    \"\"\"\n    return enum_class[d['name']]", "code_tokens": "def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "docstring_tokens": "Converts an dict to a Enum .", "label": 0}, {"idx": "cosqa-train-18886", "doc": "python set locale threadsafe", "code": "def setlocale(name):\n    \"\"\"\n    Context manager with threading lock for set locale on enter, and set it\n    back to original state on exit.\n\n    ::\n\n        >>> with setlocale(\"C\"):\n        ...     ...\n    \"\"\"\n    with LOCALE_LOCK:\n        old_locale = locale.setlocale(locale.LC_ALL)\n        try:\n            yield locale.setlocale(locale.LC_ALL, name)\n        finally:\n            locale.setlocale(locale.LC_ALL, old_locale)", "code_tokens": "def setlocale ( name ) : with LOCALE_LOCK : old_locale = locale . setlocale ( locale . LC_ALL ) try : yield locale . setlocale ( locale . LC_ALL , name ) finally : locale . setlocale ( locale . LC_ALL , old_locale )", "docstring_tokens": "Context manager with threading lock for set locale on enter and set it back to original state on exit .", "label": 0}, {"idx": "cosqa-train-18887", "doc": "python to javascript table", "code": "def to_javascript_(self, table_name: str=\"data\") -> str:\n        \"\"\"Convert the main dataframe to javascript code\n\n        :param table_name: javascript variable name, defaults to \"data\"\n        :param table_name: str, optional\n        :return: a javascript constant with the data\n        :rtype: str\n\n        :example: ``ds.to_javastript_(\"myconst\")``\n        \"\"\"\n        try:\n            renderer = pytablewriter.JavaScriptTableWriter\n            data = self._build_export(renderer, table_name)\n            return data\n        except Exception as e:\n            self.err(e, \"Can not convert data to javascript code\")", "code_tokens": "def to_javascript_ ( self , table_name : str = \"data\" ) -> str : try : renderer = pytablewriter . JavaScriptTableWriter data = self . _build_export ( renderer , table_name ) return data except Exception as e : self . err ( e , \"Can not convert data to javascript code\" )", "docstring_tokens": "Convert the main dataframe to javascript code", "label": 0}, {"idx": "cosqa-train-18888", "doc": "condition for checking file/folder is empty or not inpython", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 0}, {"idx": "cosqa-train-18889", "doc": "how to write text to a file in python", "code": "def write_text(filename: str, text: str) -> None:\n    \"\"\"\n    Writes text to a file.\n    \"\"\"\n    with open(filename, 'w') as f:  # type: TextIO\n        print(text, file=f)", "code_tokens": "def write_text ( filename : str , text : str ) -> None : with open ( filename , 'w' ) as f : # type: TextIO print ( text , file = f )", "docstring_tokens": "Writes text to a file .", "label": 0}, {"idx": "cosqa-train-18890", "doc": "python check to see if file is empty", "code": "def isfile_notempty(inputfile: str) -> bool:\n        \"\"\"Check if the input filename with path is a file and is not empty.\"\"\"\n        try:\n            return isfile(inputfile) and getsize(inputfile) > 0\n        except TypeError:\n            raise TypeError('inputfile is not a valid type')", "code_tokens": "def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )", "docstring_tokens": "Check if the input filename with path is a file and is not empty .", "label": 0}, {"idx": "cosqa-train-18891", "doc": "tiff to searchable pdf python", "code": "def availability_pdf() -> bool:\n    \"\"\"\n    Is a PDF-to-text tool available?\n    \"\"\"\n    pdftotext = tools['pdftotext']\n    if pdftotext:\n        return True\n    elif pdfminer:\n        log.warning(\"PDF conversion: pdftotext missing; \"\n                    \"using pdfminer (less efficient)\")\n        return True\n    else:\n        return False", "code_tokens": "def availability_pdf ( ) -> bool : pdftotext = tools [ 'pdftotext' ] if pdftotext : return True elif pdfminer : log . warning ( \"PDF conversion: pdftotext missing; \" \"using pdfminer (less efficient)\" ) return True else : return False", "docstring_tokens": "Is a PDF - to - text tool available?", "label": 0}, {"idx": "cosqa-train-18892", "doc": "python create mapping from value to index of a list", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 0}, {"idx": "cosqa-train-18893", "doc": "how to get first 5 rows from sql in python", "code": "def fetchallfirstvalues(self, sql: str, *args) -> List[Any]:\n        \"\"\"Executes SQL; returns list of first values of each row.\"\"\"\n        rows = self.fetchall(sql, *args)\n        return [row[0] for row in rows]", "code_tokens": "def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "docstring_tokens": "Executes SQL ; returns list of first values of each row .", "label": 0}, {"idx": "cosqa-train-18894", "doc": "how to not except empty string python", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 1}, {"idx": "cosqa-train-18895", "doc": "how to see if a line matches in a file python", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 1}, {"idx": "cosqa-train-18896", "doc": "how to check if a variable name is valid in python", "code": "def name_is_valid(name):\n    \"\"\"Return True if the dataset name is valid.\n\n    The name can only be 80 characters long.\n    Valid characters: Alpha numeric characters [0-9a-zA-Z]\n    Valid special characters: - _ .\n    \"\"\"\n    # The name can only be 80 characters long.\n    if len(name) > MAX_NAME_LENGTH:\n        return False\n    return bool(NAME_VALID_CHARS_REGEX.match(name))", "code_tokens": "def name_is_valid ( name ) : # The name can only be 80 characters long. if len ( name ) > MAX_NAME_LENGTH : return False return bool ( NAME_VALID_CHARS_REGEX . match ( name ) )", "docstring_tokens": "Return True if the dataset name is valid .", "label": 1}, {"idx": "cosqa-train-18897", "doc": "access database python retreive column names", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 1}, {"idx": "cosqa-train-18898", "doc": "add exponents by the power of 2 in python", "code": "def safe_pow(base, exp):\n    \"\"\"safe version of pow\"\"\"\n    if exp > MAX_EXPONENT:\n        raise RuntimeError(\"Invalid exponent, max exponent is {}\".format(MAX_EXPONENT))\n    return base ** exp", "code_tokens": "def safe_pow ( base , exp ) : if exp > MAX_EXPONENT : raise RuntimeError ( \"Invalid exponent, max exponent is {}\" . format ( MAX_EXPONENT ) ) return base ** exp", "docstring_tokens": "safe version of pow", "label": 0}, {"idx": "cosqa-train-18899", "doc": "python how to multiply matrix", "code": "def __rmatmul__(self, other):\n        \"\"\"\n        Matrix multiplication using binary `@` operator in Python>=3.5.\n        \"\"\"\n        return self.T.dot(np.transpose(other)).T", "code_tokens": "def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T", "docstring_tokens": "Matrix multiplication using binary", "label": 1}, {"idx": "cosqa-train-18900", "doc": "how to index through a string to get certain positions python", "code": "def text_coords(string, position):\n    r\"\"\"\n    Transform a simple index into a human-readable position in a string.\n\n    This function accepts a string and an index, and will return a triple of\n    `(lineno, columnno, line)` representing the position through the text. It's\n    useful for displaying a string index in a human-readable way::\n\n        >>> s = \"abcdef\\nghijkl\\nmnopqr\\nstuvwx\\nyz\"\n        >>> text_coords(s, 0)\n        (0, 0, 'abcdef')\n        >>> text_coords(s, 4)\n        (0, 4, 'abcdef')\n        >>> text_coords(s, 6)\n        (0, 6, 'abcdef')\n        >>> text_coords(s, 7)\n        (1, 0, 'ghijkl')\n        >>> text_coords(s, 11)\n        (1, 4, 'ghijkl')\n        >>> text_coords(s, 15)\n        (2, 1, 'mnopqr')\n    \"\"\"\n    line_start = string.rfind('\\n', 0, position) + 1\n    line_end = string.find('\\n', position)\n    lineno = string.count('\\n', 0, position)\n    columnno = position - line_start\n    line = string[line_start:line_end]\n    return (lineno, columnno, line)", "code_tokens": "def text_coords ( string , position ) : line_start = string . rfind ( '\\n' , 0 , position ) + 1 line_end = string . find ( '\\n' , position ) lineno = string . count ( '\\n' , 0 , position ) columnno = position - line_start line = string [ line_start : line_end ] return ( lineno , columnno , line )", "docstring_tokens": "r Transform a simple index into a human - readable position in a string .", "label": 0}, {"idx": "cosqa-train-18901", "doc": "python read csv data to numpy array", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 1}, {"idx": "cosqa-train-18902", "doc": "python check existance of key", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 0}, {"idx": "cosqa-train-18903", "doc": "python test if string an int", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-18904", "doc": "sphinx how to show python code", "code": "def build(ctx):\n    \"\"\"Build documentation as HTML.\n\n    The build HTML site is located in the ``doc/_build/html`` directory\n    of the package.\n    \"\"\"\n    return_code = run_sphinx(ctx.obj['root_dir'])\n    if return_code > 0:\n        sys.exit(return_code)", "code_tokens": "def build ( ctx ) : return_code = run_sphinx ( ctx . obj [ 'root_dir' ] ) if return_code > 0 : sys . exit ( return_code )", "docstring_tokens": "Build documentation as HTML .", "label": 1}, {"idx": "cosqa-train-18905", "doc": "bits of a value python", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 0}, {"idx": "cosqa-train-18906", "doc": "how to limit the function's executing time python", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 0}, {"idx": "cosqa-train-18907", "doc": "how to make sure python stay in memory limit", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 1}, {"idx": "cosqa-train-18908", "doc": "is asyncio thread safe python", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 1}, {"idx": "cosqa-train-18909", "doc": "finding duplicate words in a list python", "code": "def find_duplicates(l: list) -> set:\n    \"\"\"\n    Return the duplicates in a list.\n\n    The function relies on\n    https://stackoverflow.com/questions/9835762/find-and-list-duplicates-in-a-list .\n    Parameters\n    ----------\n    l : list\n        Name\n\n    Returns\n    -------\n    set\n        Duplicated values\n\n    >>> find_duplicates([1,2,3])\n    set()\n    >>> find_duplicates([1,2,1])\n    {1}\n    \"\"\"\n    return set([x for x in l if l.count(x) > 1])", "code_tokens": "def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "docstring_tokens": "Return the duplicates in a list .", "label": 0}, {"idx": "cosqa-train-18910", "doc": "how to delete quotes in python so taht the string will turn into a tuple", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 1}, {"idx": "cosqa-train-18911", "doc": "python how to call methods dynamically", "code": "def __getattr__(self, item: str) -> Callable:\n        \"\"\"Get a callable that sends the actual API request internally.\"\"\"\n        return functools.partial(self.call_action, item)", "code_tokens": "def __getattr__ ( self , item : str ) -> Callable : return functools . partial ( self . call_action , item )", "docstring_tokens": "Get a callable that sends the actual API request internally .", "label": 1}, {"idx": "cosqa-train-18912", "doc": "python select first columns", "code": "def fetchallfirstvalues(self, sql: str, *args) -> List[Any]:\n        \"\"\"Executes SQL; returns list of first values of each row.\"\"\"\n        rows = self.fetchall(sql, *args)\n        return [row[0] for row in rows]", "code_tokens": "def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "docstring_tokens": "Executes SQL ; returns list of first values of each row .", "label": 1}, {"idx": "cosqa-train-18913", "doc": "python process memory leak", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 0}, {"idx": "cosqa-train-18914", "doc": "how to format a string into a date with python", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-18915", "doc": "python strip a list of string", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 0}, {"idx": "cosqa-train-18916", "doc": "python how to get index of smallest value in a series", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-18917", "doc": "python numpy get dtype of array", "code": "def maybe_infer_dtype_type(element):\n    \"\"\"Try to infer an object's dtype, for use in arithmetic ops\n\n    Uses `element.dtype` if that's available.\n    Objects implementing the iterator protocol are cast to a NumPy array,\n    and from there the array's type is used.\n\n    Parameters\n    ----------\n    element : object\n        Possibly has a `.dtype` attribute, and possibly the iterator\n        protocol.\n\n    Returns\n    -------\n    tipo : type\n\n    Examples\n    --------\n    >>> from collections import namedtuple\n    >>> Foo = namedtuple(\"Foo\", \"dtype\")\n    >>> maybe_infer_dtype_type(Foo(np.dtype(\"i8\")))\n    numpy.int64\n    \"\"\"\n    tipo = None\n    if hasattr(element, 'dtype'):\n        tipo = element.dtype\n    elif is_list_like(element):\n        element = np.asarray(element)\n        tipo = element.dtype\n    return tipo", "code_tokens": "def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "docstring_tokens": "Try to infer an object s dtype for use in arithmetic ops", "label": 1}, {"idx": "cosqa-train-18918", "doc": "python to limit memory usage", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 1}, {"idx": "cosqa-train-18919", "doc": "python how to time a function run", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 0}, {"idx": "cosqa-train-18920", "doc": "python keyword for same method name", "code": "def method_caller(method_name, *args, **kwargs):\n\t\"\"\"\n\tReturn a function that will call a named method on the\n\ttarget object with optional positional and keyword\n\targuments.\n\n\t>>> lower = method_caller('lower')\n\t>>> lower('MyString')\n\t'mystring'\n\t\"\"\"\n\tdef call_method(target):\n\t\tfunc = getattr(target, method_name)\n\t\treturn func(*args, **kwargs)\n\treturn call_method", "code_tokens": "def method_caller ( method_name , * args , * * kwargs ) : def call_method ( target ) : func = getattr ( target , method_name ) return func ( * args , * * kwargs ) return call_method", "docstring_tokens": "Return a function that will call a named method on the target object with optional positional and keyword arguments .", "label": 0}, {"idx": "cosqa-train-18921", "doc": "python check memory usage in a process", "code": "def psutil_phymem_usage():\n    \"\"\"\n    Return physical memory usage (float)\n    Requires the cross-platform psutil (>=v0.3) library\n    (https://github.com/giampaolo/psutil)\n    \"\"\"\n    import psutil\n    # This is needed to avoid a deprecation warning error with\n    # newer psutil versions\n    try:\n        percent = psutil.virtual_memory().percent\n    except:\n        percent = psutil.phymem_usage().percent\n    return percent", "code_tokens": "def psutil_phymem_usage ( ) : import psutil # This is needed to avoid a deprecation warning error with\n # newer psutil versions\n try : percent = psutil . virtual_memory ( ) . percent except : percent = psutil . phymem_usage ( ) . percent return percent", "docstring_tokens": "Return physical memory usage ( float ) Requires the cross - platform psutil ( > = v0 . 3 ) library ( https : // github . com / giampaolo / psutil )", "label": 1}, {"idx": "cosqa-train-18922", "doc": "python pad string with zeros to a certain length", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 1}, {"idx": "cosqa-train-18923", "doc": "python get last weeks time", "code": "def get_period_last_3_months() -> str:\n    \"\"\" Returns the last week as a period string \"\"\"\n    today = Datum()\n    today.today()\n\n    # start_date = today - timedelta(weeks=13)\n    start_date = today.clone()\n    start_date.subtract_months(3)\n\n    period = get_period(start_date.date, today.date)\n    return period", "code_tokens": "def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "docstring_tokens": "Returns the last week as a period string", "label": 0}, {"idx": "cosqa-train-18924", "doc": "python create diagnol block matrix", "code": "def block_diag(*blocks: np.ndarray) -> np.ndarray:\n    \"\"\"Concatenates blocks into a block diagonal matrix.\n\n    Args:\n        *blocks: Square matrices to place along the diagonal of the result.\n\n    Returns:\n        A block diagonal matrix with the given blocks along its diagonal.\n\n    Raises:\n        ValueError: A block isn't square.\n    \"\"\"\n    for b in blocks:\n        if b.shape[0] != b.shape[1]:\n            raise ValueError('Blocks must be square.')\n\n    if not blocks:\n        return np.zeros((0, 0), dtype=np.complex128)\n\n    n = sum(b.shape[0] for b in blocks)\n    dtype = functools.reduce(_merge_dtypes, (b.dtype for b in blocks))\n\n    result = np.zeros(shape=(n, n), dtype=dtype)\n    i = 0\n    for b in blocks:\n        j = i + b.shape[0]\n        result[i:j, i:j] = b\n        i = j\n\n    return result", "code_tokens": "def block_diag ( * blocks : np . ndarray ) -> np . ndarray : for b in blocks : if b . shape [ 0 ] != b . shape [ 1 ] : raise ValueError ( 'Blocks must be square.' ) if not blocks : return np . zeros ( ( 0 , 0 ) , dtype = np . complex128 ) n = sum ( b . shape [ 0 ] for b in blocks ) dtype = functools . reduce ( _merge_dtypes , ( b . dtype for b in blocks ) ) result = np . zeros ( shape = ( n , n ) , dtype = dtype ) i = 0 for b in blocks : j = i + b . shape [ 0 ] result [ i : j , i : j ] = b i = j return result", "docstring_tokens": "Concatenates blocks into a block diagonal matrix .", "label": 1}, {"idx": "cosqa-train-18925", "doc": "python list out all column names", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 1}, {"idx": "cosqa-train-18926", "doc": "python json file into dict", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 1}, {"idx": "cosqa-train-18927", "doc": "check if float has no decimal python", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 0}, {"idx": "cosqa-train-18928", "doc": "python delete false keys from dict", "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": "def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "docstring_tokens": "Return a new copied dictionary without the keys with None values from the given Mapping object .", "label": 0}, {"idx": "cosqa-train-18929", "doc": "python change dictioinary values in place", "code": "def dictlist_replace(dict_list: Iterable[Dict], key: str, value: Any) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, change\n    (in place) ``d[key]`` to ``value``.\n    \"\"\"\n    for d in dict_list:\n        d[key] = value", "code_tokens": "def dictlist_replace ( dict_list : Iterable [ Dict ] , key : str , value : Any ) -> None : for d in dict_list : d [ key ] = value", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d change ( in place ) d [ key ] to value .", "label": 1}, {"idx": "cosqa-train-18930", "doc": "average of 2d array python", "code": "def average_arrays(arrays: List[mx.nd.NDArray]) -> mx.nd.NDArray:\n    \"\"\"\n    Take a list of arrays of the same shape and take the element wise average.\n\n    :param arrays: A list of NDArrays with the same shape that will be averaged.\n    :return: The average of the NDArrays in the same context as arrays[0].\n    \"\"\"\n    if not arrays:\n        raise ValueError(\"arrays is empty.\")\n    if len(arrays) == 1:\n        return arrays[0]\n    check_condition(all(arrays[0].shape == a.shape for a in arrays), \"nd array shapes do not match\")\n    return mx.nd.add_n(*arrays) / len(arrays)", "code_tokens": "def average_arrays ( arrays : List [ mx . nd . NDArray ] ) -> mx . nd . NDArray : if not arrays : raise ValueError ( \"arrays is empty.\" ) if len ( arrays ) == 1 : return arrays [ 0 ] check_condition ( all ( arrays [ 0 ] . shape == a . shape for a in arrays ) , \"nd array shapes do not match\" ) return mx . nd . add_n ( * arrays ) / len ( arrays )", "docstring_tokens": "Take a list of arrays of the same shape and take the element wise average .", "label": 0}, {"idx": "cosqa-train-18931", "doc": "how to read contents in a text file python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-18932", "doc": "check whether a column has null values or not in python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 0}, {"idx": "cosqa-train-18933", "doc": "python urlparse strip to domain", "code": "def get_domain(url):\n    \"\"\"\n    Get domain part of an url.\n\n    For example: https://www.python.org/doc/ -> https://www.python.org\n    \"\"\"\n    parse_result = urlparse(url)\n    domain = \"{schema}://{netloc}\".format(\n        schema=parse_result.scheme, netloc=parse_result.netloc)\n    return domain", "code_tokens": "def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "docstring_tokens": "Get domain part of an url .", "label": 1}, {"idx": "cosqa-train-18934", "doc": "how to write text in a file through python", "code": "def write_text(filename: str, text: str) -> None:\n    \"\"\"\n    Writes text to a file.\n    \"\"\"\n    with open(filename, 'w') as f:  # type: TextIO\n        print(text, file=f)", "code_tokens": "def write_text ( filename : str , text : str ) -> None : with open ( filename , 'w' ) as f : # type: TextIO print ( text , file = f )", "docstring_tokens": "Writes text to a file .", "label": 0}, {"idx": "cosqa-train-18935", "doc": "how to logically and an array in python", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 1}, {"idx": "cosqa-train-18936", "doc": "python identify the third friday of a month", "code": "def after_third_friday(day=None):\n    \"\"\" check if day is after month's 3rd friday \"\"\"\n    day = day if day is not None else datetime.datetime.now()\n    now = day.replace(day=1, hour=16, minute=0, second=0, microsecond=0)\n    now += relativedelta.relativedelta(weeks=2, weekday=relativedelta.FR)\n    return day > now", "code_tokens": "def after_third_friday ( day = None ) : day = day if day is not None else datetime . datetime . now ( ) now = day . replace ( day = 1 , hour = 16 , minute = 0 , second = 0 , microsecond = 0 ) now += relativedelta . relativedelta ( weeks = 2 , weekday = relativedelta . FR ) return day > now", "docstring_tokens": "check if day is after month s 3rd friday", "label": 0}, {"idx": "cosqa-train-18937", "doc": "iterate for loop a fixed number of times python", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 0}, {"idx": "cosqa-train-18938", "doc": "python code to print tree in reverse", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-18939", "doc": "how to limit memory usage in python programes", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 1}, {"idx": "cosqa-train-18940", "doc": "get name by user id python", "code": "def get_account_id_by_fullname(self, fullname: str) -> str:\n        \"\"\" Locates the account by fullname \"\"\"\n        account = self.get_by_fullname(fullname)\n        return account.guid", "code_tokens": "def get_account_id_by_fullname ( self , fullname : str ) -> str : account = self . get_by_fullname ( fullname ) return account . guid", "docstring_tokens": "Locates the account by fullname", "label": 0}, {"idx": "cosqa-train-18941", "doc": "python get specific timezone name", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-18942", "doc": "data types of columns in python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-18943", "doc": "reshape shuffle matrix python", "code": "def _reshuffle(mat, shape):\n    \"\"\"Reshuffle the indicies of a bipartite matrix A[ij,kl] -> A[lj,ki].\"\"\"\n    return np.reshape(\n        np.transpose(np.reshape(mat, shape), (3, 1, 2, 0)),\n        (shape[3] * shape[1], shape[0] * shape[2]))", "code_tokens": "def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )", "docstring_tokens": "Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] .", "label": 0}, {"idx": "cosqa-train-18944", "doc": "to get all the column names in python", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 0}, {"idx": "cosqa-train-18945", "doc": "python select last items in list", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 0}, {"idx": "cosqa-train-18946", "doc": "python display contents of a text file", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-18947", "doc": "python test if pageobject is empty", "code": "def isFull(self):\n        \"\"\"\n        Returns True if the response buffer is full, and False otherwise.\n        The buffer is full if either (1) the number of items in the value\n        list is >= pageSize or (2) the total length of the serialised\n        elements in the page is >= maxBufferSize.\n\n        If page_size or max_response_length were not set in the request\n        then they're not checked.\n        \"\"\"\n        return (\n            (self._pageSize > 0 and self._numElements >= self._pageSize) or\n            (self._bufferSize >= self._maxBufferSize)\n        )", "code_tokens": "def isFull ( self ) : return ( ( self . _pageSize > 0 and self . _numElements >= self . _pageSize ) or ( self . _bufferSize >= self . _maxBufferSize ) )", "docstring_tokens": "Returns True if the response buffer is full and False otherwise . The buffer is full if either ( 1 ) the number of items in the value list is > = pageSize or ( 2 ) the total length of the serialised elements in the page is > = maxBufferSize .", "label": 0}, {"idx": "cosqa-train-18948", "doc": "python whether today is 3rd wendesday", "code": "def after_third_friday(day=None):\n    \"\"\" check if day is after month's 3rd friday \"\"\"\n    day = day if day is not None else datetime.datetime.now()\n    now = day.replace(day=1, hour=16, minute=0, second=0, microsecond=0)\n    now += relativedelta.relativedelta(weeks=2, weekday=relativedelta.FR)\n    return day > now", "code_tokens": "def after_third_friday ( day = None ) : day = day if day is not None else datetime . datetime . now ( ) now = day . replace ( day = 1 , hour = 16 , minute = 0 , second = 0 , microsecond = 0 ) now += relativedelta . relativedelta ( weeks = 2 , weekday = relativedelta . FR ) return day > now", "docstring_tokens": "check if day is after month s 3rd friday", "label": 0}, {"idx": "cosqa-train-18949", "doc": "python test if callable", "code": "def callable_validator(v: Any) -> AnyCallable:\n    \"\"\"\n    Perform a simple check if the value is callable.\n\n    Note: complete matching of argument type hints and return types is not performed\n    \"\"\"\n    if callable(v):\n        return v\n\n    raise errors.CallableError(value=v)", "code_tokens": "def callable_validator ( v : Any ) -> AnyCallable : if callable ( v ) : return v raise errors . CallableError ( value = v )", "docstring_tokens": "Perform a simple check if the value is callable .", "label": 0}, {"idx": "cosqa-train-18950", "doc": "python check file contains line", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 1}, {"idx": "cosqa-train-18951", "doc": "capitalize letter in python string", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-18952", "doc": "python minimum in a column", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 1}, {"idx": "cosqa-train-18953", "doc": "python string to lowercast", "code": "def camel_to_snake_case(string):\n    \"\"\"Converts 'string' presented in camel case to snake case.\n\n    e.g.: CamelCase => snake_case\n    \"\"\"\n    s = _1.sub(r'\\1_\\2', string)\n    return _2.sub(r'\\1_\\2', s).lower()", "code_tokens": "def camel_to_snake_case ( string ) : s = _1 . sub ( r'\\1_\\2' , string ) return _2 . sub ( r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Converts string presented in camel case to snake case .", "label": 0}, {"idx": "cosqa-train-18954", "doc": "python check if is an int", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 0}, {"idx": "cosqa-train-18955", "doc": "python underscore in for loop", "code": "def lower_camel_case_from_underscores(string):\n    \"\"\"generate a lower-cased camelCase string from an underscore_string.\n    For example: my_variable_name -> myVariableName\"\"\"\n    components = string.split('_')\n    string = components[0]\n    for component in components[1:]:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName", "label": 0}, {"idx": "cosqa-train-18956", "doc": "python sqlalchemy column data types", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 0}, {"idx": "cosqa-train-18957", "doc": "how to print values in list greater than 5 python", "code": "def _brief_print_list(lst, limit=7):\n    \"\"\"Print at most `limit` elements of list.\"\"\"\n    lst = list(lst)\n    if len(lst) > limit:\n        return _brief_print_list(lst[:limit//2], limit) + ', ..., ' + \\\n            _brief_print_list(lst[-limit//2:], limit)\n    return ', '.join([\"'%s'\"%str(i) for i in lst])", "code_tokens": "def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "docstring_tokens": "Print at most limit elements of list .", "label": 1}, {"idx": "cosqa-train-18958", "doc": "ironpython check if data table exists", "code": "def has_table(self, name):\n        \"\"\"Return ``True`` if the table *name* exists in the database.\"\"\"\n        return len(self.sql(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\",\n                            parameters=(name,), asrecarray=False, cache=False)) > 0", "code_tokens": "def has_table ( self , name ) : return len ( self . sql ( \"SELECT name FROM sqlite_master WHERE type='table' AND name=?\" , parameters = ( name , ) , asrecarray = False , cache = False ) ) > 0", "docstring_tokens": "Return True if the table * name * exists in the database .", "label": 1}, {"idx": "cosqa-train-18959", "doc": "round float up to int python", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 0}, {"idx": "cosqa-train-18960", "doc": "how to count the number of times a value appears in a list in functions python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 0}, {"idx": "cosqa-train-18961", "doc": "python longest substring of same char", "code": "def long_substr(data):\n    \"\"\"Return the longest common substring in a list of strings.\n    \n    Credit: http://stackoverflow.com/questions/2892931/longest-common-substring-from-more-than-two-strings-python\n    \"\"\"\n    substr = ''\n    if len(data) > 1 and len(data[0]) > 0:\n        for i in range(len(data[0])):\n            for j in range(len(data[0])-i+1):\n                if j > len(substr) and all(data[0][i:i+j] in x for x in data):\n                    substr = data[0][i:i+j]\n    elif len(data) == 1:\n        substr = data[0]\n    return substr", "code_tokens": "def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "docstring_tokens": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python", "label": 0}, {"idx": "cosqa-train-18962", "doc": "clear output in python 3", "code": "def suppress_stdout():\n    \"\"\"\n    Context manager that suppresses stdout.\n\n    Examples:\n        >>> with suppress_stdout():\n        ...     print('Test print')\n\n        >>> print('test')\n        test\n\n    \"\"\"\n    save_stdout = sys.stdout\n    sys.stdout = DevNull()\n    yield\n    sys.stdout = save_stdout", "code_tokens": "def suppress_stdout ( ) : save_stdout = sys . stdout sys . stdout = DevNull ( ) yield sys . stdout = save_stdout", "docstring_tokens": "Context manager that suppresses stdout .", "label": 1}, {"idx": "cosqa-train-18963", "doc": "limit execution time of a python function", "code": "def timeit (func, log, limit):\n    \"\"\"Print execution time of the function. For quick'n'dirty profiling.\"\"\"\n\n    def newfunc (*args, **kwargs):\n        \"\"\"Execute function and print execution time.\"\"\"\n        t = time.time()\n        res = func(*args, **kwargs)\n        duration = time.time() - t\n        if duration > limit:\n            print(func.__name__, \"took %0.2f seconds\" % duration, file=log)\n            print(args, file=log)\n            print(kwargs, file=log)\n        return res\n    return update_func_meta(newfunc, func)", "code_tokens": "def timeit ( func , log , limit ) : def newfunc ( * args , * * kwargs ) : \"\"\"Execute function and print execution time.\"\"\" t = time . time ( ) res = func ( * args , * * kwargs ) duration = time . time ( ) - t if duration > limit : print ( func . __name__ , \"took %0.2f seconds\" % duration , file = log ) print ( args , file = log ) print ( kwargs , file = log ) return res return update_func_meta ( newfunc , func )", "docstring_tokens": "Print execution time of the function . For quick n dirty profiling .", "label": 0}, {"idx": "cosqa-train-18964", "doc": "command line python pass argparse to function", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 0}, {"idx": "cosqa-train-18965", "doc": "python manipulate bits 32 bit ints", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 0}, {"idx": "cosqa-train-18966", "doc": "python add min to datetime", "code": "def date_to_datetime(d):\n    \"\"\"\n    >>> date_to_datetime(date(2000, 1, 2))\n    datetime.datetime(2000, 1, 2, 0, 0)\n    >>> date_to_datetime(datetime(2000, 1, 2, 3, 4, 5))\n    datetime.datetime(2000, 1, 2, 3, 4, 5)\n    \"\"\"\n    if not isinstance(d, datetime):\n        d = datetime.combine(d, datetime.min.time())\n    return d", "code_tokens": "def date_to_datetime ( d ) : if not isinstance ( d , datetime ) : d = datetime . combine ( d , datetime . min . time ( ) ) return d", "docstring_tokens": ">>> date_to_datetime ( date ( 2000 1 2 )) datetime . datetime ( 2000 1 2 0 0 ) >>> date_to_datetime ( datetime ( 2000 1 2 3 4 5 )) datetime . datetime ( 2000 1 2 3 4 5 )", "label": 0}, {"idx": "cosqa-train-18967", "doc": "how to read file from s3 using python using boto", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 1}, {"idx": "cosqa-train-18968", "doc": "turn a timestring in to a date time python", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 1}, {"idx": "cosqa-train-18969", "doc": "function for checking duplicates in lists python", "code": "def find_duplicates(l: list) -> set:\n    \"\"\"\n    Return the duplicates in a list.\n\n    The function relies on\n    https://stackoverflow.com/questions/9835762/find-and-list-duplicates-in-a-list .\n    Parameters\n    ----------\n    l : list\n        Name\n\n    Returns\n    -------\n    set\n        Duplicated values\n\n    >>> find_duplicates([1,2,3])\n    set()\n    >>> find_duplicates([1,2,1])\n    {1}\n    \"\"\"\n    return set([x for x in l if l.count(x) > 1])", "code_tokens": "def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "docstring_tokens": "Return the duplicates in a list .", "label": 0}, {"idx": "cosqa-train-18970", "doc": "python make dict from key list", "code": "def encode_list(key, list_):\n    # type: (str, Iterable) -> Dict[str, str]\n    \"\"\"\n    Converts a list into a space-separated string and puts it in a dictionary\n\n    :param key: Dictionary key to store the list\n    :param list_: A list of objects\n    :return: A dictionary key->string or an empty dictionary\n    \"\"\"\n    if not list_:\n        return {}\n    return {key: \" \".join(str(i) for i in list_)}", "code_tokens": "def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "docstring_tokens": "Converts a list into a space - separated string and puts it in a dictionary", "label": 0}, {"idx": "cosqa-train-18971", "doc": "get data type columns python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-18972", "doc": "python binary without string", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 0}, {"idx": "cosqa-train-18973", "doc": "get file from s3 python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 0}, {"idx": "cosqa-train-18974", "doc": "python sql alchemy delete sql table", "code": "def wipe_table(self, table: str) -> int:\n        \"\"\"Delete all records from a table. Use caution!\"\"\"\n        sql = \"DELETE FROM \" + self.delimit(table)\n        return self.db_exec(sql)", "code_tokens": "def wipe_table ( self , table : str ) -> int : sql = \"DELETE FROM \" + self . delimit ( table ) return self . db_exec ( sql )", "docstring_tokens": "Delete all records from a table . Use caution!", "label": 1}, {"idx": "cosqa-train-18975", "doc": "remove entries from a python dictionary", "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": "def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "docstring_tokens": "Return a new copied dictionary without the keys with None values from the given Mapping object .", "label": 0}, {"idx": "cosqa-train-18976", "doc": "how can i get the rdd index python", "code": "def zip_with_index(rdd):\n    \"\"\"\n    Alternate version of Spark's zipWithIndex that eagerly returns count.\n    \"\"\"\n    starts = [0]\n    if rdd.getNumPartitions() > 1:\n        nums = rdd.mapPartitions(lambda it: [sum(1 for _ in it)]).collect()\n        count = sum(nums)\n        for i in range(len(nums) - 1):\n            starts.append(starts[-1] + nums[i])\n    else:\n        count = rdd.count()\n\n    def func(k, it):\n        for i, v in enumerate(it, starts[k]):\n            yield v, i\n\n    return count, rdd.mapPartitionsWithIndex(func)", "code_tokens": "def zip_with_index ( rdd ) : starts = [ 0 ] if rdd . getNumPartitions ( ) > 1 : nums = rdd . mapPartitions ( lambda it : [ sum ( 1 for _ in it ) ] ) . collect ( ) count = sum ( nums ) for i in range ( len ( nums ) - 1 ) : starts . append ( starts [ - 1 ] + nums [ i ] ) else : count = rdd . count ( ) def func ( k , it ) : for i , v in enumerate ( it , starts [ k ] ) : yield v , i return count , rdd . mapPartitionsWithIndex ( func )", "docstring_tokens": "Alternate version of Spark s zipWithIndex that eagerly returns count .", "label": 0}, {"idx": "cosqa-train-18977", "doc": "python check if prime function", "code": "def is_prime(n):\n    \"\"\"\n    Check if n is a prime number\n    \"\"\"\n    if n % 2 == 0 and n > 2:\n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))", "code_tokens": "def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "docstring_tokens": "Check if n is a prime number", "label": 0}, {"idx": "cosqa-train-18978", "doc": "python reading json files into dictionary", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 1}, {"idx": "cosqa-train-18979", "doc": "how to check whether the set has nan python", "code": "def isfinite(data: mx.nd.NDArray) -> mx.nd.NDArray:\n    \"\"\"Performs an element-wise check to determine if the NDArray contains an infinite element or not.\n       TODO: remove this funciton after upgrade to MXNet 1.4.* in favor of mx.ndarray.contrib.isfinite()\n    \"\"\"\n    is_data_not_nan = data == data\n    is_data_not_infinite = data.abs() != np.inf\n    return mx.nd.logical_and(is_data_not_infinite, is_data_not_nan)", "code_tokens": "def isfinite ( data : mx . nd . NDArray ) -> mx . nd . NDArray : is_data_not_nan = data == data is_data_not_infinite = data . abs ( ) != np . inf return mx . nd . logical_and ( is_data_not_infinite , is_data_not_nan )", "docstring_tokens": "Performs an element - wise check to determine if the NDArray contains an infinite element or not . TODO : remove this funciton after upgrade to MXNet 1 . 4 . * in favor of mx . ndarray . contrib . isfinite ()", "label": 0}, {"idx": "cosqa-train-18980", "doc": "get date time object python from string", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 0}, {"idx": "cosqa-train-18981", "doc": "python repeat sequence certain amount of times", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 1}, {"idx": "cosqa-train-18982", "doc": "reading cursor position in python", "code": "def position(self) -> Position:\n        \"\"\"The current position of the cursor.\"\"\"\n        return Position(self._index, self._lineno, self._col_offset)", "code_tokens": "def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "docstring_tokens": "The current position of the cursor .", "label": 1}, {"idx": "cosqa-train-18983", "doc": "python making a list out of a string", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 0}, {"idx": "cosqa-train-18984", "doc": "python get key with greatest value", "code": "def get_default_bucket_key(buckets: List[Tuple[int, int]]) -> Tuple[int, int]:\n    \"\"\"\n    Returns the default bucket from a list of buckets, i.e. the largest bucket.\n\n    :param buckets: List of buckets.\n    :return: The largest bucket in the list.\n    \"\"\"\n    return max(buckets)", "code_tokens": "def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )", "docstring_tokens": "Returns the default bucket from a list of buckets i . e . the largest bucket .", "label": 1}, {"idx": "cosqa-train-18985", "doc": "make string empty in python", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 1}, {"idx": "cosqa-train-18986", "doc": "python tk get background color", "code": "def console_get_background_flag(con: tcod.console.Console) -> int:\n    \"\"\"Return this consoles current blend mode.\n\n    Args:\n        con (Console): Any Console instance.\n\n    .. deprecated:: 8.5\n        Check :any:`Console.default_bg_blend` instead.\n    \"\"\"\n    return int(lib.TCOD_console_get_background_flag(_console(con)))", "code_tokens": "def console_get_background_flag ( con : tcod . console . Console ) -> int : return int ( lib . TCOD_console_get_background_flag ( _console ( con ) ) )", "docstring_tokens": "Return this consoles current blend mode .", "label": 1}, {"idx": "cosqa-train-18987", "doc": "how to iterate from the last element in a list in python", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 1}, {"idx": "cosqa-train-18988", "doc": "rotating a list in python", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 1}, {"idx": "cosqa-train-18989", "doc": "python sanitize file name", "code": "def get_valid_filename(s):\n    \"\"\"\n    Shamelessly taken from Django.\n    https://github.com/django/django/blob/master/django/utils/text.py\n\n    Return the given string converted to a string that can be used for a clean\n    filename. Remove leading and trailing spaces; convert other spaces to\n    underscores; and remove anything that is not an alphanumeric, dash,\n    underscore, or dot.\n    >>> get_valid_filename(\"john's portrait in 2004.jpg\")\n    'johns_portrait_in_2004.jpg'\n    \"\"\"\n    s = str(s).strip().replace(' ', '_')\n    return re.sub(r'(?u)[^-\\w.]', '', s)", "code_tokens": "def get_valid_filename ( s ) : s = str ( s ) . strip ( ) . replace ( ' ' , '_' ) return re . sub ( r'(?u)[^-\\w.]' , '' , s )", "docstring_tokens": "Shamelessly taken from Django . https : // github . com / django / django / blob / master / django / utils / text . py", "label": 0}, {"idx": "cosqa-train-18990", "doc": "handle yaml files in python", "code": "def load_yaml(file):\n    \"\"\"If pyyaml > 5.1 use full_load to avoid warning\"\"\"\n    if hasattr(yaml, \"full_load\"):\n        return yaml.full_load(file)\n    else:\n        return yaml.load(file)", "code_tokens": "def load_yaml ( file ) : if hasattr ( yaml , \"full_load\" ) : return yaml . full_load ( file ) else : return yaml . load ( file )", "docstring_tokens": "If pyyaml > 5 . 1 use full_load to avoid warning", "label": 1}, {"idx": "cosqa-train-18991", "doc": "a function that determines the percentage of missing entries for each column in the dataset python", "code": "def warn_if_nans_exist(X):\n    \"\"\"Warn if nans exist in a numpy array.\"\"\"\n    null_count = count_rows_with_nans(X)\n    total = len(X)\n    percent = 100 * null_count / total\n\n    if null_count > 0:\n        warning_message = \\\n            'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\\n            'complete rows will be plotted.'.format(null_count, total, percent)\n        warnings.warn(warning_message, DataWarning)", "code_tokens": "def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "docstring_tokens": "Warn if nans exist in a numpy array .", "label": 0}, {"idx": "cosqa-train-18992", "doc": "python drop a key from dictionary", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-18993", "doc": "how to limit python memory", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 1}, {"idx": "cosqa-train-18994", "doc": "changing from list to string in python", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 1}, {"idx": "cosqa-train-18995", "doc": "definition of prime in python", "code": "def is_prime(n):\n    \"\"\"\n    Check if n is a prime number\n    \"\"\"\n    if n % 2 == 0 and n > 2:\n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))", "code_tokens": "def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "docstring_tokens": "Check if n is a prime number", "label": 1}, {"idx": "cosqa-train-18996", "doc": "python read a json file into dictionary", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 0}, {"idx": "cosqa-train-18997", "doc": "keep only uppercase words in string python", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-18998", "doc": "python check is an string", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 1}, {"idx": "cosqa-train-18999", "doc": "marshmallow python calling schema self for a nested field", "code": "def iter_fields(self, schema: Schema) -> Iterable[Tuple[str, Field]]:\n        \"\"\"\n        Iterate through marshmallow schema fields.\n\n        Generates: name, field pairs\n\n        \"\"\"\n        for name in sorted(schema.fields.keys()):\n            field = schema.fields[name]\n            yield field.dump_to or name, field", "code_tokens": "def iter_fields ( self , schema : Schema ) -> Iterable [ Tuple [ str , Field ] ] : for name in sorted ( schema . fields . keys ( ) ) : field = schema . fields [ name ] yield field . dump_to or name , field", "docstring_tokens": "Iterate through marshmallow schema fields .", "label": 1}, {"idx": "cosqa-train-19000", "doc": "python numpy how to get number of rows of matrix", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 1}, {"idx": "cosqa-train-19001", "doc": "from string to datetime in python", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 0}, {"idx": "cosqa-train-19002", "doc": "python extract numerical part of string", "code": "def numeric_part(s):\n    \"\"\"Returns the leading numeric part of a string.\n\n    >>> numeric_part(\"20-alpha\")\n    20\n    >>> numeric_part(\"foo\")\n    >>> numeric_part(\"16b\")\n    16\n    \"\"\"\n\n    m = re_numeric_part.match(s)\n    if m:\n        return int(m.group(1))\n    return None", "code_tokens": "def numeric_part ( s ) : m = re_numeric_part . match ( s ) if m : return int ( m . group ( 1 ) ) return None", "docstring_tokens": "Returns the leading numeric part of a string .", "label": 1}, {"idx": "cosqa-train-19003", "doc": "how to make a name randomizer in python", "code": "def random_name_gen(size=6):\n    \"\"\"Generate a random python attribute name.\"\"\"\n\n    return ''.join(\n        [random.choice(string.ascii_uppercase)] +\n        [random.choice(string.ascii_uppercase + string.digits) for i in range(size - 1)]\n    ) if size > 0 else ''", "code_tokens": "def random_name_gen ( size = 6 ) : return '' . join ( [ random . choice ( string . ascii_uppercase ) ] + [ random . choice ( string . ascii_uppercase + string . digits ) for i in range ( size - 1 ) ] ) if size > 0 else ''", "docstring_tokens": "Generate a random python attribute name .", "label": 0}, {"idx": "cosqa-train-19004", "doc": "count number of ocurrences of a number in a list python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 1}, {"idx": "cosqa-train-19005", "doc": "see if something is formatted url properly python", "code": "def looks_like_url(url):\n    \"\"\" Simplified check to see if the text appears to be a URL.\n\n    Similar to `urlparse` but much more basic.\n\n    Returns:\n      True if the url str appears to be valid.\n      False otherwise.\n\n    >>> url = looks_like_url(\"totalgood.org\")\n    >>> bool(url)\n    True\n    \"\"\"\n    if not isinstance(url, basestring):\n        return False\n    if not isinstance(url, basestring) or len(url) >= 1024 or not cre_url.match(url):\n        return False\n    return True", "code_tokens": "def looks_like_url ( url ) : if not isinstance ( url , basestring ) : return False if not isinstance ( url , basestring ) or len ( url ) >= 1024 or not cre_url . match ( url ) : return False return True", "docstring_tokens": "Simplified check to see if the text appears to be a URL .", "label": 1}, {"idx": "cosqa-train-19006", "doc": "how to check if my python is 64 or 32 bit", "code": "def check64bit(current_system=\"python\"):\n    \"\"\"checks if you are on a 64 bit platform\"\"\"\n    if current_system == \"python\":\n        return sys.maxsize > 2147483647\n    elif current_system == \"os\":\n        import platform\n        pm = platform.machine()\n        if pm != \"..\" and pm.endswith('64'):  # recent Python (not Iron)\n            return True\n        else:\n            if 'PROCESSOR_ARCHITEW6432' in os.environ:\n                return True  # 32 bit program running on 64 bit Windows\n            try:\n                # 64 bit Windows 64 bit program\n                return os.environ['PROCESSOR_ARCHITECTURE'].endswith('64')\n            except IndexError:\n                pass  # not Windows\n            try:\n                # this often works in Linux\n                return '64' in platform.architecture()[0]\n            except Exception:\n                # is an older version of Python, assume also an older os@\n                # (best we can guess)\n                return False", "code_tokens": "def check64bit ( current_system = \"python\" ) : if current_system == \"python\" : return sys . maxsize > 2147483647 elif current_system == \"os\" : import platform pm = platform . machine ( ) if pm != \"..\" and pm . endswith ( '64' ) : # recent Python (not Iron) return True else : if 'PROCESSOR_ARCHITEW6432' in os . environ : return True # 32 bit program running on 64 bit Windows try : # 64 bit Windows 64 bit program return os . environ [ 'PROCESSOR_ARCHITECTURE' ] . endswith ( '64' ) except IndexError : pass # not Windows try : # this often works in Linux return '64' in platform . architecture ( ) [ 0 ] except Exception : # is an older version of Python, assume also an older os@ # (best we can guess) return False", "docstring_tokens": "checks if you are on a 64 bit platform", "label": 1}, {"idx": "cosqa-train-19007", "doc": "any python list of strings", "code": "def quoted_or_list(items: List[str]) -> Optional[str]:\n    \"\"\"Given [A, B, C] return \"'A', 'B', or 'C'\".\n\n    Note: We use single quotes here, since these are also used by repr().\n    \"\"\"\n    return or_list([f\"'{item}'\" for item in items])", "code_tokens": "def quoted_or_list ( items : List [ str ] ) -> Optional [ str ] : return or_list ( [ f\"'{item}'\" for item in items ] )", "docstring_tokens": "Given [ A B C ] return A B or C .", "label": 0}, {"idx": "cosqa-train-19008", "doc": "python code to check if line in file exists", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 1}, {"idx": "cosqa-train-19009", "doc": "get time zone in python", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-19010", "doc": "python sqlalchemy get column type", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 1}, {"idx": "cosqa-train-19011", "doc": "how to skip reading a line python", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 1}, {"idx": "cosqa-train-19012", "doc": "python json file dictionary in a dictionary", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 0}, {"idx": "cosqa-train-19013", "doc": "check if column value is null python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-19014", "doc": "python string concat \"a\"/\"b\"", "code": "def urljoin(*args):\n    \"\"\"\n    Joins given arguments into a url, removing duplicate slashes\n    Thanks http://stackoverflow.com/a/11326230/1267398\n\n    >>> urljoin('/lol', '///lol', '/lol//')\n    '/lol/lol/lol'\n    \"\"\"\n    value = \"/\".join(map(lambda x: str(x).strip('/'), args))\n    return \"/{}\".format(value)", "code_tokens": "def urljoin ( * args ) : value = \"/\" . join ( map ( lambda x : str ( x ) . strip ( '/' ) , args ) ) return \"/{}\" . format ( value )", "docstring_tokens": "Joins given arguments into a url removing duplicate slashes Thanks http : // stackoverflow . com / a / 11326230 / 1267398", "label": 0}, {"idx": "cosqa-train-19015", "doc": "python input validation int or sentinal", "code": "def clean_int(x) -> int:\n    \"\"\"\n    Returns its parameter as an integer, or raises\n    ``django.forms.ValidationError``.\n    \"\"\"\n    try:\n        return int(x)\n    except ValueError:\n        raise forms.ValidationError(\n            \"Cannot convert to integer: {}\".format(repr(x)))", "code_tokens": "def clean_int ( x ) -> int : try : return int ( x ) except ValueError : raise forms . ValidationError ( \"Cannot convert to integer: {}\" . format ( repr ( x ) ) )", "docstring_tokens": "Returns its parameter as an integer or raises django . forms . ValidationError .", "label": 0}, {"idx": "cosqa-train-19016", "doc": "python delete a element from set", "code": "def remove_once(gset, elem):\n    \"\"\"Remove the element from a set, lists or dict.\n    \n        >>> L = [\"Lucy\"]; S = set([\"Sky\"]); D = { \"Diamonds\": True };\n        >>> remove_once(L, \"Lucy\"); remove_once(S, \"Sky\"); remove_once(D, \"Diamonds\");\n        >>> print L, S, D\n        [] set([]) {}\n\n    Returns the element if it was removed. Raises one of the exceptions in \n    :obj:`RemoveError` otherwise.\n    \"\"\"\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "code_tokens": "def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "docstring_tokens": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}", "label": 1}, {"idx": "cosqa-train-19017", "doc": "cplit a string to list in python", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 0}, {"idx": "cosqa-train-19018", "doc": "python last weekday of the month", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 1}, {"idx": "cosqa-train-19019", "doc": "python numpy calculate stdev", "code": "def stdev(self):\n        \"\"\" -> #float :func:numpy.std of the timing intervals \"\"\"\n        return round(np.std(self.array), self.precision)\\\n            if len(self.array) else None", "code_tokens": "def stdev ( self ) : return round ( np . std ( self . array ) , self . precision ) if len ( self . array ) else None", "docstring_tokens": "- > #float : func : numpy . std of the timing intervals", "label": 0}, {"idx": "cosqa-train-19020", "doc": "filter values in a dictionary based on condition python", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-19021", "doc": "python get content of text file", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-19022", "doc": "python first 500 elements of array", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 1}, {"idx": "cosqa-train-19023", "doc": "how to know if a text file is empty in python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 1}, {"idx": "cosqa-train-19024", "doc": "python list of indexes for each newline in string", "code": "def space_list(line: str) -> List[int]:\n    \"\"\"\n    Given a string, return a list of index positions where a blank space occurs.\n\n    :param line:\n    :return:\n\n    >>> space_list(\"    abc \")\n    [0, 1, 2, 3, 7]\n    \"\"\"\n    spaces = []\n    for idx, car in enumerate(list(line)):\n        if car == \" \":\n            spaces.append(idx)\n    return spaces", "code_tokens": "def space_list ( line : str ) -> List [ int ] : spaces = [ ] for idx , car in enumerate ( list ( line ) ) : if car == \" \" : spaces . append ( idx ) return spaces", "docstring_tokens": "Given a string return a list of index positions where a blank space occurs .", "label": 0}, {"idx": "cosqa-train-19025", "doc": "python check the column contains null", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-19026", "doc": "how to get column length row length of 2d array in python", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 1}, {"idx": "cosqa-train-19027", "doc": "returns property object instead of its value python", "code": "def get_property(self, name):\n        # type: (str) -> object\n        \"\"\"\n        Retrieves a framework or system property. As framework properties don't\n        change while it's running, this method don't need to be protected.\n\n        :param name: The property name\n        \"\"\"\n        with self.__properties_lock:\n            return self.__properties.get(name, os.getenv(name))", "code_tokens": "def get_property ( self , name ) : # type: (str) -> object with self . __properties_lock : return self . __properties . get ( name , os . getenv ( name ) )", "docstring_tokens": "Retrieves a framework or system property . As framework properties don t change while it s running this method don t need to be protected .", "label": 1}, {"idx": "cosqa-train-19028", "doc": "get every first item of array python", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 1}, {"idx": "cosqa-train-19029", "doc": "python compare none with integer", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 1}, {"idx": "cosqa-train-19030", "doc": "to get last 12 months of data in python", "code": "def get_period_last_3_months() -> str:\n    \"\"\" Returns the last week as a period string \"\"\"\n    today = Datum()\n    today.today()\n\n    # start_date = today - timedelta(weeks=13)\n    start_date = today.clone()\n    start_date.subtract_months(3)\n\n    period = get_period(start_date.date, today.date)\n    return period", "code_tokens": "def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "docstring_tokens": "Returns the last week as a period string", "label": 0}, {"idx": "cosqa-train-19031", "doc": "maximum value in a column in python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 0}, {"idx": "cosqa-train-19032", "doc": "finding least value in an array python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 1}, {"idx": "cosqa-train-19033", "doc": "check and see if any element in array meets condition python", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 1}, {"idx": "cosqa-train-19034", "doc": "strip blank space from string in python", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 0}, {"idx": "cosqa-train-19035", "doc": "check if a node is a leaf node python", "code": "def is_builtin_object(node: astroid.node_classes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == BUILTINS_NAME", "code_tokens": "def is_builtin_object ( node : astroid . node_classes . NodeNG ) -> bool : return node and node . root ( ) . name == BUILTINS_NAME", "docstring_tokens": "Returns True if the given node is an object from the __builtin__ module .", "label": 0}, {"idx": "cosqa-train-19036", "doc": "timing a function call python", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 1}, {"idx": "cosqa-train-19037", "doc": "midpoint of two values in python", "code": "def _mid(pt1, pt2):\n    \"\"\"\n    (Point, Point) -> Point\n    Return the point that lies in between the two input points.\n    \"\"\"\n    (x0, y0), (x1, y1) = pt1, pt2\n    return 0.5 * (x0 + x1), 0.5 * (y0 + y1)", "code_tokens": "def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "docstring_tokens": "( Point Point ) - > Point Return the point that lies in between the two input points .", "label": 0}, {"idx": "cosqa-train-19038", "doc": "python assert two values are not the same", "code": "def assert_equal(first, second, msg_fmt=\"{msg}\"):\n    \"\"\"Fail unless first equals second, as determined by the '==' operator.\n\n    >>> assert_equal(5, 5.0)\n    >>> assert_equal(\"Hello World!\", \"Goodbye!\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'Hello World!' != 'Goodbye!'\n\n    The following msg_fmt arguments are supported:\n    * msg - the default error message\n    * first - the first argument\n    * second - the second argument\n    \"\"\"\n\n    if isinstance(first, dict) and isinstance(second, dict):\n        assert_dict_equal(first, second, msg_fmt)\n    elif not first == second:\n        msg = \"{!r} != {!r}\".format(first, second)\n        fail(msg_fmt.format(msg=msg, first=first, second=second))", "code_tokens": "def assert_equal ( first , second , msg_fmt = \"{msg}\" ) : if isinstance ( first , dict ) and isinstance ( second , dict ) : assert_dict_equal ( first , second , msg_fmt ) elif not first == second : msg = \"{!r} != {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "docstring_tokens": "Fail unless first equals second as determined by the == operator .", "label": 0}, {"idx": "cosqa-train-19039", "doc": "detect language of a text python", "code": "def get_language(query: str) -> str:\n    \"\"\"Tries to work out the highlight.js language of a given file name or\n    shebang. Returns an empty string if none match.\n    \"\"\"\n    query = query.lower()\n    for language in LANGUAGES:\n        if query.endswith(language):\n            return language\n    return ''", "code_tokens": "def get_language ( query : str ) -> str : query = query . lower ( ) for language in LANGUAGES : if query . endswith ( language ) : return language return ''", "docstring_tokens": "Tries to work out the highlight . js language of a given file name or shebang . Returns an empty string if none match .", "label": 0}, {"idx": "cosqa-train-19040", "doc": "how to print python *args", "code": "def prin(*args, **kwargs):\n    r\"\"\"Like ``print``, but a function. I.e. prints out all arguments as\n    ``print`` would do. Specify output stream like this::\n\n      print('ERROR', `out=\"sys.stderr\"``).\n\n    \"\"\"\n    print >> kwargs.get('out',None), \" \".join([str(arg) for arg in args])", "code_tokens": "def prin ( * args , * * kwargs ) : print >> kwargs . get ( 'out' , None ) , \" \" . join ( [ str ( arg ) for arg in args ] )", "docstring_tokens": "r Like print but a function . I . e . prints out all arguments as print would do . Specify output stream like this ::", "label": 1}, {"idx": "cosqa-train-19041", "doc": "python call rest service using post", "code": "def post(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP POST operation to API endpoint.\"\"\"\n\n        return self._request('POST', endpoint, **kwargs)", "code_tokens": "def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "docstring_tokens": "HTTP POST operation to API endpoint .", "label": 0}, {"idx": "cosqa-train-19042", "doc": "using map in python to flip a dictionary", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 0}, {"idx": "cosqa-train-19043", "doc": "implement a tree python", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 1}, {"idx": "cosqa-train-19044", "doc": "python change type from int to boolean", "code": "def to_bool(value):\n    # type: (Any) -> bool\n    \"\"\"\n    Convert a value into a bool but handle \"truthy\" strings eg, yes, true, ok, y\n    \"\"\"\n    if isinstance(value, _compat.string_types):\n        return value.upper() in ('Y', 'YES', 'T', 'TRUE', '1', 'OK')\n    return bool(value)", "code_tokens": "def to_bool ( value ) : # type: (Any) -> bool if isinstance ( value , _compat . string_types ) : return value . upper ( ) in ( 'Y' , 'YES' , 'T' , 'TRUE' , '1' , 'OK' ) return bool ( value )", "docstring_tokens": "Convert a value into a bool but handle truthy strings eg yes true ok y", "label": 0}, {"idx": "cosqa-train-19045", "doc": "python program to unpack a tuple in saveral variable", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 0}, {"idx": "cosqa-train-19046", "doc": "get year from a date in python", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 0}, {"idx": "cosqa-train-19047", "doc": "wordnet python get synset", "code": "def has_synset(word: str) -> list:\n    \"\"\"\" Returns a list of synsets of a word after lemmatization. \"\"\"\n\n    return wn.synsets(lemmatize(word, neverstem=True))", "code_tokens": "def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "docstring_tokens": "Returns a list of synsets of a word after lemmatization .", "label": 1}, {"idx": "cosqa-train-19048", "doc": "c++ opencv python3 opencv read jpg diffrent", "code": "def version():\n    \"\"\"Wrapper for opj_version library routine.\"\"\"\n    OPENJPEG.opj_version.restype = ctypes.c_char_p\n    library_version = OPENJPEG.opj_version()\n    if sys.hexversion >= 0x03000000:\n        return library_version.decode('utf-8')\n    else:\n        return library_version", "code_tokens": "def version ( ) : OPENJPEG . opj_version . restype = ctypes . c_char_p library_version = OPENJPEG . opj_version ( ) if sys . hexversion >= 0x03000000 : return library_version . decode ( 'utf-8' ) else : return library_version", "docstring_tokens": "Wrapper for opj_version library routine .", "label": 0}, {"idx": "cosqa-train-19049", "doc": "python queue element stackoverflow", "code": "def full(self):\n        \"\"\"Return ``True`` if the queue is full, ``False``\n        otherwise (not reliable!).\n\n        Only applicable if :attr:`maxsize` is set.\n\n        \"\"\"\n        return self.maxsize and len(self.list) >= self.maxsize or False", "code_tokens": "def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False", "docstring_tokens": "Return True if the queue is full False otherwise ( not reliable! ) .", "label": 1}, {"idx": "cosqa-train-19050", "doc": "python split sting to tokens", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 1}, {"idx": "cosqa-train-19051", "doc": "python get last x bytes of file", "code": "def tail(filename, number_of_bytes):\n    \"\"\"Returns the last number_of_bytes of filename\"\"\"\n    with open(filename, \"rb\") as f:\n        if os.stat(filename).st_size > number_of_bytes:\n            f.seek(-number_of_bytes, 2)\n        return f.read()", "code_tokens": "def tail ( filename , number_of_bytes ) : with open ( filename , \"rb\" ) as f : if os . stat ( filename ) . st_size > number_of_bytes : f . seek ( - number_of_bytes , 2 ) return f . read ( )", "docstring_tokens": "Returns the last number_of_bytes of filename", "label": 1}, {"idx": "cosqa-train-19052", "doc": "set default editorfor python scripts windows", "code": "def find_editor() -> str:\n    \"\"\"Find a reasonable editor to use by default for the system that the cmd2 application is running on.\"\"\"\n    editor = os.environ.get('EDITOR')\n    if not editor:\n        if sys.platform[:3] == 'win':\n            editor = 'notepad'\n        else:\n            # Favor command-line editors first so we don't leave the terminal to edit\n            for editor in ['vim', 'vi', 'emacs', 'nano', 'pico', 'gedit', 'kate', 'subl', 'geany', 'atom']:\n                if which(editor):\n                    break\n    return editor", "code_tokens": "def find_editor ( ) -> str : editor = os . environ . get ( 'EDITOR' ) if not editor : if sys . platform [ : 3 ] == 'win' : editor = 'notepad' else : # Favor command-line editors first so we don't leave the terminal to edit for editor in [ 'vim' , 'vi' , 'emacs' , 'nano' , 'pico' , 'gedit' , 'kate' , 'subl' , 'geany' , 'atom' ] : if which ( editor ) : break return editor", "docstring_tokens": "Find a reasonable editor to use by default for the system that the cmd2 application is running on .", "label": 1}, {"idx": "cosqa-train-19053", "doc": "get current cursor position python", "code": "def position(self) -> Position:\n        \"\"\"The current position of the cursor.\"\"\"\n        return Position(self._index, self._lineno, self._col_offset)", "code_tokens": "def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "docstring_tokens": "The current position of the cursor .", "label": 1}, {"idx": "cosqa-train-19054", "doc": "python assert not equals", "code": "def assert_equal(first, second, msg_fmt=\"{msg}\"):\n    \"\"\"Fail unless first equals second, as determined by the '==' operator.\n\n    >>> assert_equal(5, 5.0)\n    >>> assert_equal(\"Hello World!\", \"Goodbye!\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'Hello World!' != 'Goodbye!'\n\n    The following msg_fmt arguments are supported:\n    * msg - the default error message\n    * first - the first argument\n    * second - the second argument\n    \"\"\"\n\n    if isinstance(first, dict) and isinstance(second, dict):\n        assert_dict_equal(first, second, msg_fmt)\n    elif not first == second:\n        msg = \"{!r} != {!r}\".format(first, second)\n        fail(msg_fmt.format(msg=msg, first=first, second=second))", "code_tokens": "def assert_equal ( first , second , msg_fmt = \"{msg}\" ) : if isinstance ( first , dict ) and isinstance ( second , dict ) : assert_dict_equal ( first , second , msg_fmt ) elif not first == second : msg = \"{!r} != {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "docstring_tokens": "Fail unless first equals second as determined by the == operator .", "label": 0}, {"idx": "cosqa-train-19055", "doc": "to check if there is na value in a column python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-19056", "doc": "python replace multiple value in string", "code": "def replaceStrs(s, *args):\n    r\"\"\"Replace all ``(frm, to)`` tuples in `args` in string `s`.\n\n    >>> replaceStrs(\"nothing is better than warm beer\",\n    ...             ('nothing','warm beer'), ('warm beer','nothing'))\n    'warm beer is better than nothing'\n\n    \"\"\"\n    if args == (): return s\n    mapping = dict((frm, to) for frm, to in args)\n    return re.sub(\"|\".join(map(re.escape, mapping.keys())),\n                  lambda match:mapping[match.group(0)], s)", "code_tokens": "def replaceStrs ( s , * args ) : if args == ( ) : return s mapping = dict ( ( frm , to ) for frm , to in args ) return re . sub ( \"|\" . join ( map ( re . escape , mapping . keys ( ) ) ) , lambda match : mapping [ match . group ( 0 ) ] , s )", "docstring_tokens": "r Replace all ( frm to ) tuples in args in string s .", "label": 1}, {"idx": "cosqa-train-19057", "doc": "python sqlalchemy contains string", "code": "def is_sqlatype_text_over_one_char(\n        coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type a string type that's more than one character\n    long?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return is_sqlatype_text_of_length_at_least(coltype, 2)", "code_tokens": "def is_sqlatype_text_over_one_char ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return is_sqlatype_text_of_length_at_least ( coltype , 2 )", "docstring_tokens": "Is the SQLAlchemy column type a string type that s more than one character long?", "label": 0}, {"idx": "cosqa-train-19058", "doc": "python concatenate numpy along axis", "code": "def uconcatenate(arrs, axis=0):\n    \"\"\"Concatenate a sequence of arrays.\n\n    This wrapper around numpy.concatenate preserves units. All input arrays\n    must have the same units.  See the documentation of numpy.concatenate for\n    full details.\n\n    Examples\n    --------\n    >>> from unyt import cm\n    >>> A = [1, 2, 3]*cm\n    >>> B = [2, 3, 4]*cm\n    >>> uconcatenate((A, B))\n    unyt_array([1, 2, 3, 2, 3, 4], 'cm')\n\n    \"\"\"\n    v = np.concatenate(arrs, axis=axis)\n    v = _validate_numpy_wrapper_units(v, arrs)\n    return v", "code_tokens": "def uconcatenate ( arrs , axis = 0 ) : v = np . concatenate ( arrs , axis = axis ) v = _validate_numpy_wrapper_units ( v , arrs ) return v", "docstring_tokens": "Concatenate a sequence of arrays .", "label": 0}, {"idx": "cosqa-train-19059", "doc": "pythonhow covert string on int", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-19060", "doc": "enum else if python", "code": "def has_value(cls, value: int) -> bool:\n        \"\"\"True if specified value exists in int enum; otherwise, False.\"\"\"\n        return any(value == item.value for item in cls)", "code_tokens": "def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "docstring_tokens": "True if specified value exists in int enum ; otherwise False .", "label": 0}, {"idx": "cosqa-train-19061", "doc": "read a file from s3 python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 0}, {"idx": "cosqa-train-19062", "doc": "how to call a python file to use in argparse for arguement python", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 1}, {"idx": "cosqa-train-19063", "doc": "python truncate leading zeros", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 0}, {"idx": "cosqa-train-19064", "doc": "python dictionary get case insensistive key", "code": "def get_case_insensitive_dict_key(d: Dict, k: str) -> Optional[str]:\n    \"\"\"\n    Within the dictionary ``d``, find a key that matches (in case-insensitive\n    fashion) the key ``k``, and return it (or ``None`` if there isn't one).\n    \"\"\"\n    for key in d.keys():\n        if k.lower() == key.lower():\n            return key\n    return None", "code_tokens": "def get_case_insensitive_dict_key ( d : Dict , k : str ) -> Optional [ str ] : for key in d . keys ( ) : if k . lower ( ) == key . lower ( ) : return key return None", "docstring_tokens": "Within the dictionary d find a key that matches ( in case - insensitive fashion ) the key k and return it ( or None if there isn t one ) .", "label": 1}, {"idx": "cosqa-train-19065", "doc": "select multiple of treeview row python", "code": "def get_view_selection(self):\n        \"\"\"Get actual tree selection object and all respective models of selected rows\"\"\"\n        if not self.MODEL_STORAGE_ID:\n            return None, None\n\n        # avoid selection requests on empty tree views -> case warnings in gtk3\n        if len(self.store) == 0:\n            paths = []\n        else:\n            model, paths = self._tree_selection.get_selected_rows()\n\n        # get all related models for selection from respective tree store field\n        selected_model_list = []\n        for path in paths:\n            model = self.store[path][self.MODEL_STORAGE_ID]\n            selected_model_list.append(model)\n        return self._tree_selection, selected_model_list", "code_tokens": "def get_view_selection ( self ) : if not self . MODEL_STORAGE_ID : return None , None # avoid selection requests on empty tree views -> case warnings in gtk3 if len ( self . store ) == 0 : paths = [ ] else : model , paths = self . _tree_selection . get_selected_rows ( ) # get all related models for selection from respective tree store field selected_model_list = [ ] for path in paths : model = self . store [ path ] [ self . MODEL_STORAGE_ID ] selected_model_list . append ( model ) return self . _tree_selection , selected_model_list", "docstring_tokens": "Get actual tree selection object and all respective models of selected rows", "label": 0}, {"idx": "cosqa-train-19066", "doc": "callin limit function in python", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 1}, {"idx": "cosqa-train-19067", "doc": "how to select a random number from normal distribution in python", "code": "def _gauss(mean: int, sigma: int) -> int:\n        \"\"\"\n        Creates a variation from a base value\n\n        Args:\n            mean: base value\n            sigma: gaussian sigma\n\n        Returns: random value\n\n        \"\"\"\n        return int(random.gauss(mean, sigma))", "code_tokens": "def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "docstring_tokens": "Creates a variation from a base value", "label": 0}, {"idx": "cosqa-train-19068", "doc": "check the cores in a processor python multiprocessing", "code": "def cpu_count() -> int:\n    \"\"\"Returns the number of processors on this machine.\"\"\"\n    if multiprocessing is None:\n        return 1\n    try:\n        return multiprocessing.cpu_count()\n    except NotImplementedError:\n        pass\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_CONF\")\n    except (AttributeError, ValueError):\n        pass\n    gen_log.error(\"Could not detect number of processors; assuming 1\")\n    return 1", "code_tokens": "def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( \"SC_NPROCESSORS_CONF\" ) except ( AttributeError , ValueError ) : pass gen_log . error ( \"Could not detect number of processors; assuming 1\" ) return 1", "docstring_tokens": "Returns the number of processors on this machine .", "label": 0}, {"idx": "cosqa-train-19069", "doc": "zeropadding to string in python", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 1}, {"idx": "cosqa-train-19070", "doc": "check column is null python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-19071", "doc": "python replace a char with another in a string", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 0}, {"idx": "cosqa-train-19072", "doc": "python math log index 0 is out of bounds for axis 0 with size 0", "code": "def _protected_log(x1):\n    \"\"\"Closure of log for zero arguments.\"\"\"\n    with np.errstate(divide='ignore', invalid='ignore'):\n        return np.where(np.abs(x1) > 0.001, np.log(np.abs(x1)), 0.)", "code_tokens": "def _protected_log ( x1 ) : with np . errstate ( divide = 'ignore' , invalid = 'ignore' ) : return np . where ( np . abs ( x1 ) > 0.001 , np . log ( np . abs ( x1 ) ) , 0. )", "docstring_tokens": "Closure of log for zero arguments .", "label": 0}, {"idx": "cosqa-train-19073", "doc": "delete item from a set python", "code": "def remove_once(gset, elem):\n    \"\"\"Remove the element from a set, lists or dict.\n    \n        >>> L = [\"Lucy\"]; S = set([\"Sky\"]); D = { \"Diamonds\": True };\n        >>> remove_once(L, \"Lucy\"); remove_once(S, \"Sky\"); remove_once(D, \"Diamonds\");\n        >>> print L, S, D\n        [] set([]) {}\n\n    Returns the element if it was removed. Raises one of the exceptions in \n    :obj:`RemoveError` otherwise.\n    \"\"\"\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "code_tokens": "def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "docstring_tokens": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}", "label": 1}, {"idx": "cosqa-train-19074", "doc": "python comprehension for flatmap", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 1}, {"idx": "cosqa-train-19075", "doc": "python how to check dtype", "code": "def is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n    return _is_dtype(arr_or_dtype, condition)", "code_tokens": "def is_string_dtype ( arr_or_dtype ) : # TODO: gh-15585: consider making the checks stricter. def condition ( dtype ) : return dtype . kind in ( 'O' , 'S' , 'U' ) and not is_period_dtype ( dtype ) return _is_dtype ( arr_or_dtype , condition )", "docstring_tokens": "Check whether the provided array or dtype is of the string dtype .", "label": 1}, {"idx": "cosqa-train-19076", "doc": "python get hostname from url", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 0}, {"idx": "cosqa-train-19077", "doc": "python how to add trailing zeroes", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 1}, {"idx": "cosqa-train-19078", "doc": "how to return first number in array of python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 1}, {"idx": "cosqa-train-19079", "doc": "python 3 if action is within a set time do nothing", "code": "def expired(self):\n        \"\"\"Boolean property if this action has expired\n        \"\"\"\n        if self.timeout is None:\n            return False\n\n        return monotonic() - self.start_time > self.timeout", "code_tokens": "def expired ( self ) : if self . timeout is None : return False return monotonic ( ) - self . start_time > self . timeout", "docstring_tokens": "Boolean property if this action has expired", "label": 1}, {"idx": "cosqa-train-19080", "doc": "python check if a set is a subset", "code": "def issubset(self, other):\n        \"\"\"\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        \"\"\"\n        if len(self) > len(other):  # Fast check for obvious cases\n            return False\n        return all(item in other for item in self)", "code_tokens": "def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "docstring_tokens": "Report whether another set contains this set .", "label": 0}, {"idx": "cosqa-train-19081", "doc": "rotating a list l n times in python", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 1}, {"idx": "cosqa-train-19082", "doc": "python setuptools extension output dir", "code": "def _extension(modpath: str) -> setuptools.Extension:\n    \"\"\"Make setuptools.Extension.\"\"\"\n    return setuptools.Extension(modpath, [modpath.replace(\".\", \"/\") + \".py\"])", "code_tokens": "def _extension ( modpath : str ) -> setuptools . Extension : return setuptools . Extension ( modpath , [ modpath . replace ( \".\" , \"/\" ) + \".py\" ] )", "docstring_tokens": "Make setuptools . Extension .", "label": 1}, {"idx": "cosqa-train-19083", "doc": "how to get the domain name from netloc in python", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 0}, {"idx": "cosqa-train-19084", "doc": "python check if type of variable is string", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 1}, {"idx": "cosqa-train-19085", "doc": "python change to bytes", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 1}, {"idx": "cosqa-train-19086", "doc": "get the last month from python", "code": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day", "code_tokens": "def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "docstring_tokens": "Returns day number of the last day of the month : param t : datetime : return : int", "label": 1}, {"idx": "cosqa-train-19087", "doc": "currnet position of the file cursor pythone", "code": "def position(self) -> Position:\n        \"\"\"The current position of the cursor.\"\"\"\n        return Position(self._index, self._lineno, self._col_offset)", "code_tokens": "def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "docstring_tokens": "The current position of the cursor .", "label": 0}, {"idx": "cosqa-train-19088", "doc": "how to make a string be a list python", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 0}, {"idx": "cosqa-train-19089", "doc": "how to get the last element in a series python", "code": "def last(self):\n        \"\"\"Last time step available.\n\n        Example:\n            >>> sdat = StagyyData('path/to/run')\n            >>> assert(sdat.steps.last is sdat.steps[-1])\n        \"\"\"\n        if self._last is UNDETERMINED:\n            # not necessarily the last one...\n            self._last = self.sdat.tseries.index[-1]\n        return self[self._last]", "code_tokens": "def last ( self ) : if self . _last is UNDETERMINED : # not necessarily the last one... self . _last = self . sdat . tseries . index [ - 1 ] return self [ self . _last ]", "docstring_tokens": "Last time step available .", "label": 0}, {"idx": "cosqa-train-19090", "doc": "python get index of element satisfying condition", "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:\n    \"\"\"\n    Finds the index of an item in list, which satisfies predicate\n    :param predicateFn: predicate function to run on items of list\n    :param items: list of tuples\n    :return: first index for which predicate function returns True\n    \"\"\"\n    try:\n        return next(i for i, v in enumerate(items) if predicateFn(v))\n    except StopIteration:\n        return -1", "code_tokens": "def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "docstring_tokens": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True", "label": 0}, {"idx": "cosqa-train-19091", "doc": "fibonacci python loops with return", "code": "def fib(n):\n    \"\"\"Fibonacci example function\n\n    Args:\n      n (int): integer\n\n    Returns:\n      int: n-th Fibonacci number\n    \"\"\"\n    assert n > 0\n    a, b = 1, 1\n    for i in range(n - 1):\n        a, b = b, a + b\n    return a", "code_tokens": "def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a", "docstring_tokens": "Fibonacci example function", "label": 0}, {"idx": "cosqa-train-19092", "doc": "how to suppress true output in python", "code": "def suppress_stdout():\n    \"\"\"\n    Context manager that suppresses stdout.\n\n    Examples:\n        >>> with suppress_stdout():\n        ...     print('Test print')\n\n        >>> print('test')\n        test\n\n    \"\"\"\n    save_stdout = sys.stdout\n    sys.stdout = DevNull()\n    yield\n    sys.stdout = save_stdout", "code_tokens": "def suppress_stdout ( ) : save_stdout = sys . stdout sys . stdout = DevNull ( ) yield sys . stdout = save_stdout", "docstring_tokens": "Context manager that suppresses stdout .", "label": 0}, {"idx": "cosqa-train-19093", "doc": "get types of all python columns", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-19094", "doc": "python limit the execution time of a function call", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 1}, {"idx": "cosqa-train-19095", "doc": "python sample file s3 fetch", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 1}, {"idx": "cosqa-train-19096", "doc": "how to rotate items in a list python", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 0}, {"idx": "cosqa-train-19097", "doc": "python check if a key exists", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 1}, {"idx": "cosqa-train-19098", "doc": "read a file into a set python", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 1}, {"idx": "cosqa-train-19099", "doc": "ndarray to string python", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 1}, {"idx": "cosqa-train-19100", "doc": "python delete all files with a given extension", "code": "def rmglob(pattern: str) -> None:\n    \"\"\"\n    Deletes all files whose filename matches the glob ``pattern`` (via\n    :func:`glob.glob`).\n    \"\"\"\n    for f in glob.glob(pattern):\n        os.remove(f)", "code_tokens": "def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "docstring_tokens": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .", "label": 1}, {"idx": "cosqa-train-19101", "doc": "how to define a float in python", "code": "def get_property_as_float(self, name: str) -> float:\n        \"\"\"Return the value of a float property.\n\n        :return: The property value (float).\n\n        Raises exception if property with name doesn't exist.\n\n        .. versionadded:: 1.0\n\n        Scriptable: Yes\n        \"\"\"\n        return float(self.__instrument.get_property(name))", "code_tokens": "def get_property_as_float ( self , name : str ) -> float : return float ( self . __instrument . get_property ( name ) )", "docstring_tokens": "Return the value of a float property .", "label": 0}, {"idx": "cosqa-train-19102", "doc": "zero padding in strings in python", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 0}, {"idx": "cosqa-train-19103", "doc": "how to list dynamo db table names using python", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 0}, {"idx": "cosqa-train-19104", "doc": "how to kill threads python", "code": "def _exit(self, status_code):\n        \"\"\"Properly kill Python process including zombie threads.\"\"\"\n        # If there are active threads still running infinite loops, sys.exit\n        # won't kill them but os._exit will. os._exit skips calling cleanup\n        # handlers, flushing stdio buffers, etc.\n        exit_func = os._exit if threading.active_count() > 1 else sys.exit\n        exit_func(status_code)", "code_tokens": "def _exit ( self , status_code ) : # If there are active threads still running infinite loops, sys.exit # won't kill them but os._exit will. os._exit skips calling cleanup # handlers, flushing stdio buffers, etc. exit_func = os . _exit if threading . active_count ( ) > 1 else sys . exit exit_func ( status_code )", "docstring_tokens": "Properly kill Python process including zombie threads .", "label": 0}, {"idx": "cosqa-train-19105", "doc": "python list to dictionary with indexs", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 0}, {"idx": "cosqa-train-19106", "doc": "get column names from the database in python pyodbc", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 0}, {"idx": "cosqa-train-19107", "doc": "how to delete something from a set python", "code": "def remove_once(gset, elem):\n    \"\"\"Remove the element from a set, lists or dict.\n    \n        >>> L = [\"Lucy\"]; S = set([\"Sky\"]); D = { \"Diamonds\": True };\n        >>> remove_once(L, \"Lucy\"); remove_once(S, \"Sky\"); remove_once(D, \"Diamonds\");\n        >>> print L, S, D\n        [] set([]) {}\n\n    Returns the element if it was removed. Raises one of the exceptions in \n    :obj:`RemoveError` otherwise.\n    \"\"\"\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "code_tokens": "def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "docstring_tokens": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}", "label": 1}, {"idx": "cosqa-train-19108", "doc": "python check type if string", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 1}, {"idx": "cosqa-train-19109", "doc": "delete blank str python", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 1}, {"idx": "cosqa-train-19110", "doc": "get read position python", "code": "def rl_get_point() -> int:  # pragma: no cover\n    \"\"\"\n    Returns the offset of the current cursor position in rl_line_buffer\n    \"\"\"\n    if rl_type == RlType.GNU:\n        return ctypes.c_int.in_dll(readline_lib, \"rl_point\").value\n\n    elif rl_type == RlType.PYREADLINE:\n        return readline.rl.mode.l_buffer.point\n\n    else:\n        return 0", "code_tokens": "def rl_get_point ( ) -> int : # pragma: no cover if rl_type == RlType . GNU : return ctypes . c_int . in_dll ( readline_lib , \"rl_point\" ) . value elif rl_type == RlType . PYREADLINE : return readline . rl . mode . l_buffer . point else : return 0", "docstring_tokens": "Returns the offset of the current cursor position in rl_line_buffer", "label": 1}, {"idx": "cosqa-train-19111", "doc": "change python path pylint", "code": "def get_pylint_options(config_dir='.'):\n    # type: (str) -> List[str]\n    \"\"\"Checks for local config overrides for `pylint`\n    and add them in the correct `pylint` `options` format.\n\n    :param config_dir:\n    :return: List [str]\n    \"\"\"\n    if PYLINT_CONFIG_NAME in os.listdir(config_dir):\n        pylint_config_path = PYLINT_CONFIG_NAME\n    else:\n        pylint_config_path = DEFAULT_PYLINT_CONFIG_PATH\n\n    return ['--rcfile={}'.format(pylint_config_path)]", "code_tokens": "def get_pylint_options ( config_dir = '.' ) : # type: (str) -> List[str] if PYLINT_CONFIG_NAME in os . listdir ( config_dir ) : pylint_config_path = PYLINT_CONFIG_NAME else : pylint_config_path = DEFAULT_PYLINT_CONFIG_PATH return [ '--rcfile={}' . format ( pylint_config_path ) ]", "docstring_tokens": "Checks for local config overrides for pylint and add them in the correct pylint options format .", "label": 1}, {"idx": "cosqa-train-19112", "doc": "python skip[ byte read file", "code": "def _skip(self, cnt):\n        \"\"\"Read and discard data\"\"\"\n        while cnt > 0:\n            if cnt > 8192:\n                buf = self.read(8192)\n            else:\n                buf = self.read(cnt)\n            if not buf:\n                break\n            cnt -= len(buf)", "code_tokens": "def _skip ( self , cnt ) : while cnt > 0 : if cnt > 8192 : buf = self . read ( 8192 ) else : buf = self . read ( cnt ) if not buf : break cnt -= len ( buf )", "docstring_tokens": "Read and discard data", "label": 0}, {"idx": "cosqa-train-19113", "doc": "python url extraction from domains", "code": "def get_domain(url):\n    \"\"\"\n    Get domain part of an url.\n\n    For example: https://www.python.org/doc/ -> https://www.python.org\n    \"\"\"\n    parse_result = urlparse(url)\n    domain = \"{schema}://{netloc}\".format(\n        schema=parse_result.scheme, netloc=parse_result.netloc)\n    return domain", "code_tokens": "def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "docstring_tokens": "Get domain part of an url .", "label": 1}, {"idx": "cosqa-train-19114", "doc": "empty file condition in python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 0}, {"idx": "cosqa-train-19115", "doc": "max on a list of ints in python", "code": "def argmax(iterable, key=None, both=False):\n    \"\"\"\n    >>> argmax([4,2,-5])\n    0\n    >>> argmax([4,2,-5], key=abs)\n    2\n    >>> argmax([4,2,-5], key=abs, both=True)\n    (2, 5)\n    \"\"\"\n    if key is not None:\n        it = imap(key, iterable)\n    else:\n        it = iter(iterable)\n    score, argmax = reduce(max, izip(it, count()))\n    if both:\n        return argmax, score\n    return argmax", "code_tokens": "def argmax ( iterable , key = None , both = False ) : if key is not None : it = imap ( key , iterable ) else : it = iter ( iterable ) score , argmax = reduce ( max , izip ( it , count ( ) ) ) if both : return argmax , score return argmax", "docstring_tokens": ">>> argmax ( [ 4 2 - 5 ] ) 0 >>> argmax ( [ 4 2 - 5 ] key = abs ) 2 >>> argmax ( [ 4 2 - 5 ] key = abs both = True ) ( 2 5 )", "label": 0}, {"idx": "cosqa-train-19116", "doc": "how to do a bitwise and function in python", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-19117", "doc": "python max column value", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 0}, {"idx": "cosqa-train-19118", "doc": "python determine if path is relative or absolute", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 0}, {"idx": "cosqa-train-19119", "doc": "python3 np arry to str", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 1}, {"idx": "cosqa-train-19120", "doc": "get first or default in python", "code": "def _get_or_default(mylist, i, default=None):\n    \"\"\"return list item number, or default if don't exist\"\"\"\n    if i >= len(mylist):\n        return default\n    else :\n        return mylist[i]", "code_tokens": "def _get_or_default ( mylist , i , default = None ) : if i >= len ( mylist ) : return default else : return mylist [ i ]", "docstring_tokens": "return list item number or default if don t exist", "label": 0}, {"idx": "cosqa-train-19121", "doc": "python3 hex to int", "code": "def hex_to_int(value):\n    \"\"\"\n    Convert hex string like \"\\x0A\\xE3\" to 2787.\n    \"\"\"\n    if version_info.major >= 3:\n        return int.from_bytes(value, \"big\")\n    return int(value.encode(\"hex\"), 16)", "code_tokens": "def hex_to_int ( value ) : if version_info . major >= 3 : return int . from_bytes ( value , \"big\" ) return int ( value . encode ( \"hex\" ) , 16 )", "docstring_tokens": "Convert hex string like \\ x0A \\ xE3 to 2787 .", "label": 1}, {"idx": "cosqa-train-19122", "doc": "remove links in python clean text", "code": "def remove_links(text):\n    \"\"\"\n    Helper function to remove the links from the input text\n\n    Args:\n        text (str): A string\n\n    Returns:\n        str: the same text, but with any substring that matches the regex\n        for a link removed and replaced with a space\n\n    Example:\n        >>> from tweet_parser.getter_methods.tweet_text import remove_links\n        >>> text = \"lorem ipsum dolor https://twitter.com/RobotPrincessFi\"\n        >>> remove_links(text)\n        'lorem ipsum dolor  '\n    \"\"\"\n    tco_link_regex = re.compile(\"https?://t.co/[A-z0-9].*\")\n    generic_link_regex = re.compile(\"(https?://)?(\\w*[.]\\w+)+([/?=&]+\\w+)*\")\n    remove_tco = re.sub(tco_link_regex, \" \", text)\n    remove_generic = re.sub(generic_link_regex, \" \", remove_tco)\n    return remove_generic", "code_tokens": "def remove_links ( text ) : tco_link_regex = re . compile ( \"https?://t.co/[A-z0-9].*\" ) generic_link_regex = re . compile ( \"(https?://)?(\\w*[.]\\w+)+([/?=&]+\\w+)*\" ) remove_tco = re . sub ( tco_link_regex , \" \" , text ) remove_generic = re . sub ( generic_link_regex , \" \" , remove_tco ) return remove_generic", "docstring_tokens": "Helper function to remove the links from the input text", "label": 0}, {"idx": "cosqa-train-19123", "doc": "usinf filter on dictionary python", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 1}, {"idx": "cosqa-train-19124", "doc": "validations for dict inside array jsonschema python", "code": "def validate(request: Union[Dict, List], schema: dict) -> Union[Dict, List]:\n    \"\"\"\n    Wraps jsonschema.validate, returning the same object passed in.\n\n    Args:\n        request: The deserialized-from-json request.\n        schema: The jsonschema schema to validate against.\n\n    Raises:\n        jsonschema.ValidationError\n    \"\"\"\n    jsonschema_validate(request, schema)\n    return request", "code_tokens": "def validate ( request : Union [ Dict , List ] , schema : dict ) -> Union [ Dict , List ] : jsonschema_validate ( request , schema ) return request", "docstring_tokens": "Wraps jsonschema . validate returning the same object passed in .", "label": 1}, {"idx": "cosqa-train-19125", "doc": "python is yaml load fails", "code": "def load_yaml(file):\n    \"\"\"If pyyaml > 5.1 use full_load to avoid warning\"\"\"\n    if hasattr(yaml, \"full_load\"):\n        return yaml.full_load(file)\n    else:\n        return yaml.load(file)", "code_tokens": "def load_yaml ( file ) : if hasattr ( yaml , \"full_load\" ) : return yaml . full_load ( file ) else : return yaml . load ( file )", "docstring_tokens": "If pyyaml > 5 . 1 use full_load to avoid warning", "label": 1}, {"idx": "cosqa-train-19126", "doc": "python list to tensorflow tensor", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 0}, {"idx": "cosqa-train-19127", "doc": "python hsv rgb transform", "code": "def hsv2rgb_spectrum(hsv):\n    \"\"\"Generates RGB values from HSV values in line with a typical light\n    spectrum.\"\"\"\n    h, s, v = hsv\n    return hsv2rgb_raw(((h * 192) >> 8, s, v))", "code_tokens": "def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "docstring_tokens": "Generates RGB values from HSV values in line with a typical light spectrum .", "label": 0}, {"idx": "cosqa-train-19128", "doc": "format decimals as percentages in a column, 2 decimals python", "code": "def format_exp_floats(decimals):\n    \"\"\"\n    sometimes the exp. column can be too large\n    \"\"\"\n    threshold = 10 ** 5\n    return (\n        lambda n: \"{:.{prec}e}\".format(n, prec=decimals) if n > threshold else \"{:4.{prec}f}\".format(n, prec=decimals)\n    )", "code_tokens": "def format_exp_floats ( decimals ) : threshold = 10 ** 5 return ( lambda n : \"{:.{prec}e}\" . format ( n , prec = decimals ) if n > threshold else \"{:4.{prec}f}\" . format ( n , prec = decimals ) )", "docstring_tokens": "sometimes the exp . column can be too large", "label": 0}, {"idx": "cosqa-train-19129", "doc": "how to log in in instagram using python", "code": "def login(self, user: str, passwd: str) -> None:\n        \"\"\"Log in to instagram with given username and password and internally store session object.\n\n        :raises InvalidArgumentException: If the provided username does not exist.\n        :raises BadCredentialsException: If the provided password is wrong.\n        :raises ConnectionException: If connection to Instagram failed.\n        :raises TwoFactorAuthRequiredException: First step of 2FA login done, now call :meth:`Instaloader.two_factor_login`.\"\"\"\n        self.context.login(user, passwd)", "code_tokens": "def login ( self , user : str , passwd : str ) -> None : self . context . login ( user , passwd )", "docstring_tokens": "Log in to instagram with given username and password and internally store session object .", "label": 0}, {"idx": "cosqa-train-19130", "doc": "python df check if column has specif nan value", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 0}, {"idx": "cosqa-train-19131", "doc": "get entire first dimension of 3dimension array python", "code": "def quaternion_imag(quaternion):\n    \"\"\"Return imaginary part of quaternion.\n\n    >>> quaternion_imag([3, 0, 1, 2])\n    array([0., 1., 2.])\n\n    \"\"\"\n    return np.array(quaternion[1:4], dtype=np.float64, copy=True)", "code_tokens": "def quaternion_imag ( quaternion ) : return np . array ( quaternion [ 1 : 4 ] , dtype = np . float64 , copy = True )", "docstring_tokens": "Return imaginary part of quaternion .", "label": 0}, {"idx": "cosqa-train-19132", "doc": "python how to skip a line", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 0}, {"idx": "cosqa-train-19133", "doc": "not a number equal python", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 0}, {"idx": "cosqa-train-19134", "doc": "python repeat a value n times in a list", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 1}, {"idx": "cosqa-train-19135", "doc": "how to keep leading zero's in an integer in python", "code": "def remove_leading_zeros(num: str) -> str:\n    \"\"\"\n    Strips zeros while handling -, M, and empty strings\n    \"\"\"\n    if not num:\n        return num\n    if num.startswith('M'):\n        ret = 'M' + num[1:].lstrip('0')\n    elif num.startswith('-'):\n        ret = '-' + num[1:].lstrip('0')\n    else:\n        ret = num.lstrip('0')\n    return '0' if ret in ('', 'M', '-') else ret", "code_tokens": "def remove_leading_zeros ( num : str ) -> str : if not num : return num if num . startswith ( 'M' ) : ret = 'M' + num [ 1 : ] . lstrip ( '0' ) elif num . startswith ( '-' ) : ret = '-' + num [ 1 : ] . lstrip ( '0' ) else : ret = num . lstrip ( '0' ) return '0' if ret in ( '' , 'M' , '-' ) else ret", "docstring_tokens": "Strips zeros while handling - M and empty strings", "label": 1}, {"idx": "cosqa-train-19136", "doc": "make empty 2d array python", "code": "def _create_empty_array(self, frames, always_2d, dtype):\n        \"\"\"Create an empty array with appropriate shape.\"\"\"\n        import numpy as np\n        if always_2d or self.channels > 1:\n            shape = frames, self.channels\n        else:\n            shape = frames,\n        return np.empty(shape, dtype, order='C')", "code_tokens": "def _create_empty_array ( self , frames , always_2d , dtype ) : import numpy as np if always_2d or self . channels > 1 : shape = frames , self . channels else : shape = frames , return np . empty ( shape , dtype , order = 'C' )", "docstring_tokens": "Create an empty array with appropriate shape .", "label": 0}, {"idx": "cosqa-train-19137", "doc": "python enum not json serializable", "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum:\n    \"\"\"\n    Converts an ``dict`` to a ``Enum``.\n    \"\"\"\n    return enum_class[d['name']]", "code_tokens": "def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "docstring_tokens": "Converts an dict to a Enum .", "label": 1}, {"idx": "cosqa-train-19138", "doc": "increase animation speed python", "code": "def increment_frame(self):\n        \"\"\"Increment a frame of the animation.\"\"\"\n        self.current_frame += 1\n\n        if self.current_frame >= self.end_frame:\n            # Wrap back to the beginning of the animation.\n            self.current_frame = 0", "code_tokens": "def increment_frame ( self ) : self . current_frame += 1 if self . current_frame >= self . end_frame : # Wrap back to the beginning of the animation. self . current_frame = 0", "docstring_tokens": "Increment a frame of the animation .", "label": 1}, {"idx": "cosqa-train-19139", "doc": "check if value is integeer python", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 0}, {"idx": "cosqa-train-19140", "doc": "python check if two path are the same", "code": "def samefile(a: str, b: str) -> bool:\n    \"\"\"Check if two pathes represent the same file.\"\"\"\n    try:\n        return os.path.samefile(a, b)\n    except OSError:\n        return os.path.normpath(a) == os.path.normpath(b)", "code_tokens": "def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )", "docstring_tokens": "Check if two pathes represent the same file .", "label": 0}, {"idx": "cosqa-train-19141", "doc": "how to replace some characters in a string in python", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 0}, {"idx": "cosqa-train-19142", "doc": "element wise product python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 0}, {"idx": "cosqa-train-19143", "doc": "python mysql yield all rows", "code": "async def fetchall(self) -> Iterable[sqlite3.Row]:\n        \"\"\"Fetch all remaining rows.\"\"\"\n        return await self._execute(self._cursor.fetchall)", "code_tokens": "async def fetchall ( self ) -> Iterable [ sqlite3 . Row ] : return await self . _execute ( self . _cursor . fetchall )", "docstring_tokens": "Fetch all remaining rows .", "label": 0}, {"idx": "cosqa-train-19144", "doc": "python how to define limit of function", "code": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)", "code_tokens": "def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "docstring_tokens": "Rate limit a function .", "label": 0}, {"idx": "cosqa-train-19145", "doc": "python string of hex to int", "code": "def hex_to_int(value):\n    \"\"\"\n    Convert hex string like \"\\x0A\\xE3\" to 2787.\n    \"\"\"\n    if version_info.major >= 3:\n        return int.from_bytes(value, \"big\")\n    return int(value.encode(\"hex\"), 16)", "code_tokens": "def hex_to_int ( value ) : if version_info . major >= 3 : return int . from_bytes ( value , \"big\" ) return int ( value . encode ( \"hex\" ) , 16 )", "docstring_tokens": "Convert hex string like \\ x0A \\ xE3 to 2787 .", "label": 1}, {"idx": "cosqa-train-19146", "doc": "python is integer or float", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 0}, {"idx": "cosqa-train-19147", "doc": "python how delete item in a list if partial duplicate", "code": "def de_duplicate(items):\n    \"\"\"Remove any duplicate item, preserving order\n\n    >>> de_duplicate([1, 2, 1, 2])\n    [1, 2]\n    \"\"\"\n    result = []\n    for item in items:\n        if item not in result:\n            result.append(item)\n    return result", "code_tokens": "def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "docstring_tokens": "Remove any duplicate item preserving order", "label": 0}, {"idx": "cosqa-train-19148", "doc": "how to uppercase first letter in each sentence python string upper method", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 0}, {"idx": "cosqa-train-19149", "doc": "python how to call main that has argparse", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 1}, {"idx": "cosqa-train-19150", "doc": "create a list of unique indexes python", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 0}, {"idx": "cosqa-train-19151", "doc": "how to check if a line is in a txt file python", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 1}, {"idx": "cosqa-train-19152", "doc": "python get two closest numbers in list", "code": "def closest_values(L):\n    \"\"\"Closest values\n\n    :param L: list of values\n    :returns: two values from L with minimal distance\n    :modifies: the order of L\n    :complexity: O(n log n), for n=len(L)\n    \"\"\"\n    assert len(L) >= 2\n    L.sort()\n    valmin, argmin = min((L[i] - L[i - 1], i) for i in range(1, len(L)))\n    return L[argmin - 1], L[argmin]", "code_tokens": "def closest_values ( L ) : assert len ( L ) >= 2 L . sort ( ) valmin , argmin = min ( ( L [ i ] - L [ i - 1 ] , i ) for i in range ( 1 , len ( L ) ) ) return L [ argmin - 1 ] , L [ argmin ]", "docstring_tokens": "Closest values", "label": 1}, {"idx": "cosqa-train-19153", "doc": "function that returns plural string python", "code": "def singularize(word):\n    \"\"\"\n    Return the singular form of a word, the reverse of :func:`pluralize`.\n\n    Examples::\n\n        >>> singularize(\"posts\")\n        \"post\"\n        >>> singularize(\"octopi\")\n        \"octopus\"\n        >>> singularize(\"sheep\")\n        \"sheep\"\n        >>> singularize(\"word\")\n        \"word\"\n        >>> singularize(\"CamelOctopi\")\n        \"CamelOctopus\"\n\n    \"\"\"\n    for inflection in UNCOUNTABLES:\n        if re.search(r'(?i)\\b(%s)\\Z' % inflection, word):\n            return word\n\n    for rule, replacement in SINGULARS:\n        if re.search(rule, word):\n            return re.sub(rule, replacement, word)\n    return word", "code_tokens": "def singularize ( word ) : for inflection in UNCOUNTABLES : if re . search ( r'(?i)\\b(%s)\\Z' % inflection , word ) : return word for rule , replacement in SINGULARS : if re . search ( rule , word ) : return re . sub ( rule , replacement , word ) return word", "docstring_tokens": "Return the singular form of a word the reverse of : func : pluralize .", "label": 0}, {"idx": "cosqa-train-19154", "doc": "cast string to bytearray python", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 1}, {"idx": "cosqa-train-19155", "doc": "python list the factors of an integer", "code": "def factors(n):\n    \"\"\"\n    Computes all the integer factors of the number `n`\n\n    Example:\n        >>> # ENABLE_DOCTEST\n        >>> from utool.util_alg import *  # NOQA\n        >>> import utool as ut\n        >>> result = sorted(ut.factors(10))\n        >>> print(result)\n        [1, 2, 5, 10]\n\n    References:\n        http://stackoverflow.com/questions/6800193/finding-all-the-factors\n    \"\"\"\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))", "code_tokens": "def factors ( n ) : return set ( reduce ( list . __add__ , ( [ i , n // i ] for i in range ( 1 , int ( n ** 0.5 ) + 1 ) if n % i == 0 ) ) )", "docstring_tokens": "Computes all the integer factors of the number n", "label": 1}, {"idx": "cosqa-train-19156", "doc": "how to get the env variables in python in crontab", "code": "def get_environment_info() -> dict:\n    \"\"\"\n    Information about Cauldron and its Python interpreter.\n\n    :return:\n        A dictionary containing information about the Cauldron and its\n        Python environment. This information is useful when providing feedback\n        and bug reports.\n    \"\"\"\n    data = _environ.systems.get_system_data()\n    data['cauldron'] = _environ.package_settings.copy()\n    return data", "code_tokens": "def get_environment_info ( ) -> dict : data = _environ . systems . get_system_data ( ) data [ 'cauldron' ] = _environ . package_settings . copy ( ) return data", "docstring_tokens": "Information about Cauldron and its Python interpreter .", "label": 1}, {"idx": "cosqa-train-19157", "doc": "return last matching index python", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-19158", "doc": "dot product of 2d matrix in python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 1}, {"idx": "cosqa-train-19159", "doc": "python strip all items in a list", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 0}, {"idx": "cosqa-train-19160", "doc": "extract model number from a split python", "code": "def detect_model_num(string):\n    \"\"\"Takes a string related to a model name and extract its model number.\n\n    For example:\n        '000000-bootstrap.index' => 0\n    \"\"\"\n    match = re.match(MODEL_NUM_REGEX, string)\n    if match:\n        return int(match.group())\n    return None", "code_tokens": "def detect_model_num ( string ) : match = re . match ( MODEL_NUM_REGEX , string ) if match : return int ( match . group ( ) ) return None", "docstring_tokens": "Takes a string related to a model name and extract its model number .", "label": 0}, {"idx": "cosqa-train-19161", "doc": "change column type from pbject to int python", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 0}, {"idx": "cosqa-train-19162", "doc": "python get unique values from object", "code": "def uniqued(iterable):\n    \"\"\"Return unique list of ``iterable`` items preserving order.\n\n    >>> uniqued('spameggs')\n    ['s', 'p', 'a', 'm', 'e', 'g']\n    \"\"\"\n    seen = set()\n    return [item for item in iterable if item not in seen and not seen.add(item)]", "code_tokens": "def uniqued ( iterable ) : seen = set ( ) return [ item for item in iterable if item not in seen and not seen . add ( item ) ]", "docstring_tokens": "Return unique list of iterable items preserving order .", "label": 1}, {"idx": "cosqa-train-19163", "doc": "how to loopback to a previous line in python", "code": "def auto_up(self, count=1, go_to_start_of_line_if_history_changes=False):\n        \"\"\"\n        If we're not on the first line (of a multiline input) go a line up,\n        otherwise go back in history. (If nothing is selected.)\n        \"\"\"\n        if self.complete_state:\n            self.complete_previous(count=count)\n        elif self.document.cursor_position_row > 0:\n            self.cursor_up(count=count)\n        elif not self.selection_state:\n            self.history_backward(count=count)\n\n            # Go to the start of the line?\n            if go_to_start_of_line_if_history_changes:\n                self.cursor_position += self.document.get_start_of_line_position()", "code_tokens": "def auto_up ( self , count = 1 , go_to_start_of_line_if_history_changes = False ) : if self . complete_state : self . complete_previous ( count = count ) elif self . document . cursor_position_row > 0 : self . cursor_up ( count = count ) elif not self . selection_state : self . history_backward ( count = count ) # Go to the start of the line? if go_to_start_of_line_if_history_changes : self . cursor_position += self . document . get_start_of_line_position ( )", "docstring_tokens": "If we re not on the first line ( of a multiline input ) go a line up otherwise go back in history . ( If nothing is selected . )", "label": 1}, {"idx": "cosqa-train-19164", "doc": "how to post prune decision tree python", "code": "def pruning(self, X, y, cost_mat):\n        \"\"\" Function that prune the decision tree.\n\n        Parameters\n        ----------\n\n        X : array-like of shape = [n_samples, n_features]\n            The input samples.\n\n        y_true : array indicator matrix\n            Ground truth (correct) labels.\n\n        cost_mat : array-like of shape = [n_samples, 4]\n            Cost matrix of the classification problem\n            Where the columns represents the costs of: false positives, false negatives,\n            true positives and true negatives, for each example.\n\n        \"\"\"\n        self.tree_.tree_pruned = copy.deepcopy(self.tree_.tree)\n        if self.tree_.n_nodes > 0:\n            self._pruning(X, y, cost_mat)\n            nodes_pruned = self._nodes(self.tree_.tree_pruned)\n            self.tree_.n_nodes_pruned = len(nodes_pruned)", "code_tokens": "def pruning ( self , X , y , cost_mat ) : self . tree_ . tree_pruned = copy . deepcopy ( self . tree_ . tree ) if self . tree_ . n_nodes > 0 : self . _pruning ( X , y , cost_mat ) nodes_pruned = self . _nodes ( self . tree_ . tree_pruned ) self . tree_ . n_nodes_pruned = len ( nodes_pruned )", "docstring_tokens": "Function that prune the decision tree .", "label": 1}, {"idx": "cosqa-train-19165", "doc": "python 3 covert string to date", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-19166", "doc": "how to get branches from git by python", "code": "def branches():\n    # type: () -> List[str]\n    \"\"\" Return a list of branches in the current repo.\n\n    Returns:\n        list[str]: A list of branches in the current repo.\n    \"\"\"\n    out = shell.run(\n        'git branch',\n        capture=True,\n        never_pretend=True\n    ).stdout.strip()\n    return [x.strip('* \\t\\n') for x in out.splitlines()]", "code_tokens": "def branches ( ) : # type: () -> List[str] out = shell . run ( 'git branch' , capture = True , never_pretend = True ) . stdout . strip ( ) return [ x . strip ( '* \\t\\n' ) for x in out . splitlines ( ) ]", "docstring_tokens": "Return a list of branches in the current repo .", "label": 0}, {"idx": "cosqa-train-19167", "doc": "python get type of self", "code": "def content_type(self) -> ContentType:\n        \"\"\"Return receiver's content type.\"\"\"\n        return self._ctype if self._ctype else self.parent.content_type()", "code_tokens": "def content_type ( self ) -> ContentType : return self . _ctype if self . _ctype else self . parent . content_type ( )", "docstring_tokens": "Return receiver s content type .", "label": 1}, {"idx": "cosqa-train-19168", "doc": "python list of lists last element", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 0}, {"idx": "cosqa-train-19169", "doc": "highest values of a dictionary values in python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 0}, {"idx": "cosqa-train-19170", "doc": "python string split to list of tuples", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 1}, {"idx": "cosqa-train-19171", "doc": "how to drop all column names in python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 0}, {"idx": "cosqa-train-19172", "doc": "index of the last occurrence in python", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-19173", "doc": "python determine a url relative or absolute", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 0}, {"idx": "cosqa-train-19174", "doc": "extract first row from a table in python sql", "code": "def fetchallfirstvalues(self, sql: str, *args) -> List[Any]:\n        \"\"\"Executes SQL; returns list of first values of each row.\"\"\"\n        rows = self.fetchall(sql, *args)\n        return [row[0] for row in rows]", "code_tokens": "def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "docstring_tokens": "Executes SQL ; returns list of first values of each row .", "label": 0}, {"idx": "cosqa-train-19175", "doc": "python url join query string", "code": "def url_concat(url, args):\n    \"\"\"Concatenate url and argument dictionary regardless of whether\n    url has existing query parameters.\n\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    \"\"\"\n    if not args: return url\n    if url[-1] not in ('?', '&'):\n        url += '&' if ('?' in url) else '?'\n    return url + urllib.urlencode(args)", "code_tokens": "def url_concat ( url , args ) : if not args : return url if url [ - 1 ] not in ( '?' , '&' ) : url += '&' if ( '?' in url ) else '?' return url + urllib . urlencode ( args )", "docstring_tokens": "Concatenate url and argument dictionary regardless of whether url has existing query parameters .", "label": 1}, {"idx": "cosqa-train-19176", "doc": "round to nearest even number python", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 0}, {"idx": "cosqa-train-19177", "doc": "python code for changing string to uppercase", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 0}, {"idx": "cosqa-train-19178", "doc": "max string length for given sting list python", "code": "def _prm_get_longest_stringsize(string_list):\n        \"\"\" Returns the longest string size for a string entry across data.\"\"\"\n        maxlength = 1\n\n        for stringar in string_list:\n            if isinstance(stringar, np.ndarray):\n                if stringar.ndim > 0:\n                    for string in stringar.ravel():\n                        maxlength = max(len(string), maxlength)\n                else:\n                    maxlength = max(len(stringar.tolist()), maxlength)\n            else:\n                maxlength = max(len(stringar), maxlength)\n\n        # Make the string Col longer than needed in order to allow later on slightly larger strings\n        return int(maxlength * 1.5)", "code_tokens": "def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "docstring_tokens": "Returns the longest string size for a string entry across data .", "label": 1}, {"idx": "cosqa-train-19179", "doc": "python flat list of list to list", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 1}, {"idx": "cosqa-train-19180", "doc": "count the occurence in a list python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 1}, {"idx": "cosqa-train-19181", "doc": "python abort script but not exit the gui", "code": "def do_quit(self, _: argparse.Namespace) -> bool:\n        \"\"\"Exit this application\"\"\"\n        self._should_quit = True\n        return self._STOP_AND_EXIT", "code_tokens": "def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "docstring_tokens": "Exit this application", "label": 0}, {"idx": "cosqa-train-19182", "doc": "python replace function with for loop", "code": "def replace_in_list(stringlist: Iterable[str],\n                    replacedict: Dict[str, str]) -> List[str]:\n    \"\"\"\n    Returns a list produced by applying :func:`multiple_replace` to every\n    string in ``stringlist``.\n\n    Args:\n        stringlist: list of source strings\n        replacedict: dictionary mapping \"original\" to \"replacement\" strings\n\n    Returns:\n        list of final strings\n\n    \"\"\"\n    newlist = []\n    for fromstring in stringlist:\n        newlist.append(multiple_replace(fromstring, replacedict))\n    return newlist", "code_tokens": "def replace_in_list ( stringlist : Iterable [ str ] , replacedict : Dict [ str , str ] ) -> List [ str ] : newlist = [ ] for fromstring in stringlist : newlist . append ( multiple_replace ( fromstring , replacedict ) ) return newlist", "docstring_tokens": "Returns a list produced by applying : func : multiple_replace to every string in stringlist .", "label": 0}, {"idx": "cosqa-train-19183", "doc": "python determine if data frame has a null", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-19184", "doc": "hashlib for file python", "code": "def _hash_the_file(hasher, filename):\n    \"\"\"Helper function for creating hash functions.\n\n    See implementation of :func:`dtoolcore.filehasher.shasum`\n    for more usage details.\n    \"\"\"\n    BUF_SIZE = 65536\n    with open(filename, 'rb') as f:\n        buf = f.read(BUF_SIZE)\n        while len(buf) > 0:\n            hasher.update(buf)\n            buf = f.read(BUF_SIZE)\n    return hasher", "code_tokens": "def _hash_the_file ( hasher , filename ) : BUF_SIZE = 65536 with open ( filename , 'rb' ) as f : buf = f . read ( BUF_SIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = f . read ( BUF_SIZE ) return hasher", "docstring_tokens": "Helper function for creating hash functions .", "label": 0}, {"idx": "cosqa-train-19185", "doc": "python hash function an integer", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 0}, {"idx": "cosqa-train-19186", "doc": "python fill the nan values in the dataset using median values of column", "code": "def fix_missing(df, col, name, na_dict):\n    \"\"\" Fill missing data in a column of df with the median, and add a {name}_na column\n    which specifies if the data was missing.\n    Parameters:\n    -----------\n    df: The data frame that will be changed.\n    col: The column of data to fix by filling in missing data.\n    name: The name of the new filled column in df.\n    na_dict: A dictionary of values to create na's of and the value to insert. If\n        name is not a key of na_dict the median will fill any missing data. Also\n        if name is not a key of na_dict and there is no missing data in col, then\n        no {name}_na column is not created.\n    Examples:\n    ---------\n    >>> df = pd.DataFrame({'col1' : [1, np.NaN, 3], 'col2' : [5, 2, 2]})\n    >>> df\n       col1 col2\n    0     1    5\n    1   nan    2\n    2     3    2\n    >>> fix_missing(df, df['col1'], 'col1', {})\n    >>> df\n       col1 col2 col1_na\n    0     1    5   False\n    1     2    2    True\n    2     3    2   False\n    >>> df = pd.DataFrame({'col1' : [1, np.NaN, 3], 'col2' : [5, 2, 2]})\n    >>> df\n       col1 col2\n    0     1    5\n    1   nan    2\n    2     3    2\n    >>> fix_missing(df, df['col2'], 'col2', {})\n    >>> df\n       col1 col2\n    0     1    5\n    1   nan    2\n    2     3    2\n    >>> df = pd.DataFrame({'col1' : [1, np.NaN, 3], 'col2' : [5, 2, 2]})\n    >>> df\n       col1 col2\n    0     1    5\n    1   nan    2\n    2     3    2\n    >>> fix_missing(df, df['col1'], 'col1', {'col1' : 500})\n    >>> df\n       col1 col2 col1_na\n    0     1    5   False\n    1   500    2    True\n    2     3    2   False\n    \"\"\"\n    if is_numeric_dtype(col):\n        if pd.isnull(col).sum() or (name in na_dict):\n            df[name+'_na'] = pd.isnull(col)\n            filler = na_dict[name] if name in na_dict else col.median()\n            df[name] = col.fillna(filler)\n            na_dict[name] = filler\n    return na_dict", "code_tokens": "def fix_missing ( df , col , name , na_dict ) : if is_numeric_dtype ( col ) : if pd . isnull ( col ) . sum ( ) or ( name in na_dict ) : df [ name + '_na' ] = pd . isnull ( col ) filler = na_dict [ name ] if name in na_dict else col . median ( ) df [ name ] = col . fillna ( filler ) na_dict [ name ] = filler return na_dict", "docstring_tokens": "Fill missing data in a column of df with the median and add a { name } _na column which specifies if the data was missing . Parameters : ----------- df : The data frame that will be changed . col : The column of data to fix by filling in missing data . name : The name of the new filled column in df . na_dict : A dictionary of values to create na s of and the value to insert . If name is not a key of na_dict the median will fill any missing data . Also if name is not a key of na_dict and there is no missing data in col then no { name } _na column is not created . Examples : --------- >>> df = pd . DataFrame ( { col1 : [ 1 np . NaN 3 ] col2 : [ 5 2 2 ] } ) >>> df col1 col2 0 1 5 1 nan 2 2 3 2 >>> fix_missing ( df df [ col1 ] col1 {} ) >>> df col1 col2 col1_na 0 1 5 False 1 2 2 True 2 3 2 False >>> df = pd . DataFrame ( { col1 : [ 1 np . NaN 3 ] col2 : [ 5 2 2 ] } ) >>> df col1 col2 0 1 5 1 nan 2 2 3 2 >>> fix_missing ( df df [ col2 ] col2 {} ) >>> df col1 col2 0 1 5 1 nan 2 2 3 2 >>> df = pd . DataFrame ( { col1 : [ 1 np . NaN 3 ] col2 : [ 5 2 2 ] } ) >>> df col1 col2 0 1 5 1 nan 2 2 3 2 >>> fix_missing ( df df [ col1 ] col1 { col1 : 500 } ) >>> df col1 col2 col1_na 0 1 5 False 1 500 2 True 2 3 2 False", "label": 1}, {"idx": "cosqa-train-19187", "doc": "if two strings are equal python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 1}, {"idx": "cosqa-train-19188", "doc": "pythong if not an integer", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 0}, {"idx": "cosqa-train-19189", "doc": "change an array into a list python", "code": "def listify(a):\n    \"\"\"\n    Convert a scalar ``a`` to a list and all iterables to list as well.\n\n    Examples\n    --------\n    >>> listify(0)\n    [0]\n\n    >>> listify([1,2,3])\n    [1, 2, 3]\n\n    >>> listify('a')\n    ['a']\n\n    >>> listify(np.array([1,2,3]))\n    [1, 2, 3]\n\n    >>> listify('string')\n    ['string']\n    \"\"\"\n    if a is None:\n        return []\n    elif not isinstance(a, (tuple, list, np.ndarray)):\n        return [a]\n    return list(a)", "code_tokens": "def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "docstring_tokens": "Convert a scalar a to a list and all iterables to list as well .", "label": 0}, {"idx": "cosqa-train-19190", "doc": "how to make letters uppercase in python skipping spaces", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-19191", "doc": "python check equal sequence", "code": "def same(*values):\n    \"\"\"\n    Check if all values in a sequence are equal.\n\n    Returns True on empty sequences.\n\n    Examples\n    --------\n    >>> same(1, 1, 1, 1)\n    True\n    >>> same(1, 2, 1)\n    False\n    >>> same()\n    True\n    \"\"\"\n    if not values:\n        return True\n    first, rest = values[0], values[1:]\n    return all(value == first for value in rest)", "code_tokens": "def same ( * values ) : if not values : return True first , rest = values [ 0 ] , values [ 1 : ] return all ( value == first for value in rest )", "docstring_tokens": "Check if all values in a sequence are equal .", "label": 1}, {"idx": "cosqa-train-19192", "doc": "function for checking dtype in python", "code": "def is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n    return _is_dtype(arr_or_dtype, condition)", "code_tokens": "def is_string_dtype ( arr_or_dtype ) : # TODO: gh-15585: consider making the checks stricter. def condition ( dtype ) : return dtype . kind in ( 'O' , 'S' , 'U' ) and not is_period_dtype ( dtype ) return _is_dtype ( arr_or_dtype , condition )", "docstring_tokens": "Check whether the provided array or dtype is of the string dtype .", "label": 1}, {"idx": "cosqa-train-19193", "doc": "if isprime(n) is a prime return true else return false python", "code": "def is_prime(n):\n    \"\"\"\n    Check if n is a prime number\n    \"\"\"\n    if n % 2 == 0 and n > 2:\n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))", "code_tokens": "def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "docstring_tokens": "Check if n is a prime number", "label": 1}, {"idx": "cosqa-train-19194", "doc": "python, truncating a string by length", "code": "def trunc(obj, max, left=0):\n    \"\"\"\n    Convert `obj` to string, eliminate newlines and truncate the string to `max`\n    characters. If there are more characters in the string add ``...`` to the\n    string. With `left=True`, the string can be truncated at the beginning.\n\n    @note: Does not catch exceptions when converting `obj` to string with `str`.\n\n    >>> trunc('This is a long text.', 8)\n    This ...\n    >>> trunc('This is a long text.', 8, left)\n    ...text.\n    \"\"\"\n    s = str(obj)\n    s = s.replace('\\n', '|')\n    if len(s) > max:\n        if left:\n            return '...'+s[len(s)-max+3:]\n        else:\n            return s[:(max-3)]+'...'\n    else:\n        return s", "code_tokens": "def trunc ( obj , max , left = 0 ) : s = str ( obj ) s = s . replace ( '\\n' , '|' ) if len ( s ) > max : if left : return '...' + s [ len ( s ) - max + 3 : ] else : return s [ : ( max - 3 ) ] + '...' else : return s", "docstring_tokens": "Convert obj to string eliminate newlines and truncate the string to max characters . If there are more characters in the string add ... to the string . With left = True the string can be truncated at the beginning .", "label": 0}, {"idx": "cosqa-train-19195", "doc": "python3 how to get the decode", "code": "def decodebytes(input):\n    \"\"\"Decode base64 string to byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _decodebytes_py3(input)\n    return _decodebytes_py2(input)", "code_tokens": "def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )", "docstring_tokens": "Decode base64 string to byte array .", "label": 1}, {"idx": "cosqa-train-19196", "doc": "capitalize each letter in python", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-19197", "doc": "python concatenate np array", "code": "def uconcatenate(arrs, axis=0):\n    \"\"\"Concatenate a sequence of arrays.\n\n    This wrapper around numpy.concatenate preserves units. All input arrays\n    must have the same units.  See the documentation of numpy.concatenate for\n    full details.\n\n    Examples\n    --------\n    >>> from unyt import cm\n    >>> A = [1, 2, 3]*cm\n    >>> B = [2, 3, 4]*cm\n    >>> uconcatenate((A, B))\n    unyt_array([1, 2, 3, 2, 3, 4], 'cm')\n\n    \"\"\"\n    v = np.concatenate(arrs, axis=axis)\n    v = _validate_numpy_wrapper_units(v, arrs)\n    return v", "code_tokens": "def uconcatenate ( arrs , axis = 0 ) : v = np . concatenate ( arrs , axis = axis ) v = _validate_numpy_wrapper_units ( v , arrs ) return v", "docstring_tokens": "Concatenate a sequence of arrays .", "label": 0}, {"idx": "cosqa-train-19198", "doc": "python 3 replace for loop with map", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-19199", "doc": "python index in list predicate", "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:\n    \"\"\"\n    Finds the index of an item in list, which satisfies predicate\n    :param predicateFn: predicate function to run on items of list\n    :param items: list of tuples\n    :return: first index for which predicate function returns True\n    \"\"\"\n    try:\n        return next(i for i, v in enumerate(items) if predicateFn(v))\n    except StopIteration:\n        return -1", "code_tokens": "def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "docstring_tokens": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True", "label": 1}, {"idx": "cosqa-train-19200", "doc": "length of a deque python", "code": "def count(self, elem):\n        \"\"\"\n        Return the number of elements equal to elem present in the queue\n\n        >>> pdeque([1, 2, 1]).count(1)\n        2\n        \"\"\"\n        return self._left_list.count(elem) + self._right_list.count(elem)", "code_tokens": "def count ( self , elem ) : return self . _left_list . count ( elem ) + self . _right_list . count ( elem )", "docstring_tokens": "Return the number of elements equal to elem present in the queue", "label": 0}, {"idx": "cosqa-train-19201", "doc": "python usb core no backend", "code": "def _close(self):\n        \"\"\"\n        Release the USB interface again.\n        \"\"\"\n        self._usb_handle.releaseInterface()\n        try:\n            # If we're using PyUSB >= 1.0 we can re-attach the kernel driver here.\n            self._usb_handle.dev.attach_kernel_driver(0)\n        except:\n            pass\n        self._usb_int = None\n        self._usb_handle = None\n        return True", "code_tokens": "def _close ( self ) : self . _usb_handle . releaseInterface ( ) try : # If we're using PyUSB >= 1.0 we can re-attach the kernel driver here. self . _usb_handle . dev . attach_kernel_driver ( 0 ) except : pass self . _usb_int = None self . _usb_handle = None return True", "docstring_tokens": "Release the USB interface again .", "label": 0}, {"idx": "cosqa-train-19202", "doc": "longest substring no repeating python", "code": "def long_substr(data):\n    \"\"\"Return the longest common substring in a list of strings.\n    \n    Credit: http://stackoverflow.com/questions/2892931/longest-common-substring-from-more-than-two-strings-python\n    \"\"\"\n    substr = ''\n    if len(data) > 1 and len(data[0]) > 0:\n        for i in range(len(data[0])):\n            for j in range(len(data[0])-i+1):\n                if j > len(substr) and all(data[0][i:i+j] in x for x in data):\n                    substr = data[0][i:i+j]\n    elif len(data) == 1:\n        substr = data[0]\n    return substr", "code_tokens": "def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "docstring_tokens": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python", "label": 1}, {"idx": "cosqa-train-19203", "doc": "python3 for each in map", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 1}, {"idx": "cosqa-train-19204", "doc": "python networkx longest path directed acyclic graph", "code": "def dag_longest_path(graph, source, target):\n    \"\"\"\n    Finds the longest path in a dag between two nodes\n    \"\"\"\n    if source == target:\n        return [source]\n    allpaths = nx.all_simple_paths(graph, source, target)\n    longest_path = []\n    for l in allpaths:\n        if len(l) > len(longest_path):\n            longest_path = l\n    return longest_path", "code_tokens": "def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "docstring_tokens": "Finds the longest path in a dag between two nodes", "label": 1}, {"idx": "cosqa-train-19205", "doc": "how to run spyder with multiple python versions", "code": "def get_versions(reporev=True):\n    \"\"\"Get version information for components used by Spyder\"\"\"\n    import sys\n    import platform\n\n    import qtpy\n    import qtpy.QtCore\n\n    revision = None\n    if reporev:\n        from spyder.utils import vcs\n        revision, branch = vcs.get_git_revision(os.path.dirname(__dir__))\n\n    if not sys.platform == 'darwin':  # To avoid a crash with our Mac app\n        system = platform.system()\n    else:\n        system = 'Darwin'\n\n    return {\n        'spyder': __version__,\n        'python': platform.python_version(),  # \"2.7.3\"\n        'bitness': 64 if sys.maxsize > 2**32 else 32,\n        'qt': qtpy.QtCore.__version__,\n        'qt_api': qtpy.API_NAME,      # PyQt5\n        'qt_api_ver': qtpy.PYQT_VERSION,\n        'system': system,   # Linux, Windows, ...\n        'release': platform.release(),  # XP, 10.6, 2.2.0, etc.\n        'revision': revision,  # '9fdf926eccce'\n    }", "code_tokens": "def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "docstring_tokens": "Get version information for components used by Spyder", "label": 0}, {"idx": "cosqa-train-19206", "doc": "python conver to unsigned int", "code": "def read32(bytestream):\n  \"\"\"Read 4 bytes from bytestream as an unsigned 32-bit integer.\"\"\"\n  dt = np.dtype(np.uint32).newbyteorder('>')\n  return np.frombuffer(bytestream.read(4), dtype=dt)[0]", "code_tokens": "def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "docstring_tokens": "Read 4 bytes from bytestream as an unsigned 32 - bit integer .", "label": 0}, {"idx": "cosqa-train-19207", "doc": "how to tell if link is relative python", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 0}, {"idx": "cosqa-train-19208", "doc": "how to evaluate each element of an array in a function python", "code": "def to_np(*args):\n    \"\"\" convert GPU arras to numpy and return them\"\"\"\n    if len(args) > 1:\n        return (cp.asnumpy(x) for x in args)\n    else:\n        return cp.asnumpy(args[0])", "code_tokens": "def to_np ( * args ) : if len ( args ) > 1 : return ( cp . asnumpy ( x ) for x in args ) else : return cp . asnumpy ( args [ 0 ] )", "docstring_tokens": "convert GPU arras to numpy and return them", "label": 0}, {"idx": "cosqa-train-19209", "doc": "how to remove blank spaces from lists python", "code": "def remove_blank_spaces(syllables: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of letters, remove any blank spaces or empty strings.\n\n    :param syllables:\n    :return:\n\n    >>> remove_blank_spaces(['', 'a', ' ', 'b', ' ', 'c', ''])\n    ['a', 'b', 'c']\n    \"\"\"\n    cleaned = []\n    for syl in syllables:\n        if syl == \" \" or syl == '':\n            pass\n        else:\n            cleaned.append(syl)\n    return cleaned", "code_tokens": "def remove_blank_spaces ( syllables : List [ str ] ) -> List [ str ] : cleaned = [ ] for syl in syllables : if syl == \" \" or syl == '' : pass else : cleaned . append ( syl ) return cleaned", "docstring_tokens": "Given a list of letters remove any blank spaces or empty strings .", "label": 0}, {"idx": "cosqa-train-19210", "doc": "python dict to sqlalchemy item", "code": "def dict_to_ddb(item):\n    # type: (Dict[str, Any]) -> Dict[str, Any]\n    # TODO: narrow these types down\n    \"\"\"Converts a native Python dictionary to a raw DynamoDB item.\n\n    :param dict item: Native item\n    :returns: DynamoDB item\n    :rtype: dict\n    \"\"\"\n    serializer = TypeSerializer()\n    return {key: serializer.serialize(value) for key, value in item.items()}", "code_tokens": "def dict_to_ddb ( item ) : # type: (Dict[str, Any]) -> Dict[str, Any] # TODO: narrow these types down serializer = TypeSerializer ( ) return { key : serializer . serialize ( value ) for key , value in item . items ( ) }", "docstring_tokens": "Converts a native Python dictionary to a raw DynamoDB item .", "label": 1}, {"idx": "cosqa-train-19211", "doc": "how to check if a string is an int python", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 0}, {"idx": "cosqa-train-19212", "doc": "python not equal to a set of values", "code": "def non_increasing(values):\n    \"\"\"True if values are not increasing.\"\"\"\n    return all(x >= y for x, y in zip(values, values[1:]))", "code_tokens": "def non_increasing ( values ) : return all ( x >= y for x , y in zip ( values , values [ 1 : ] ) )", "docstring_tokens": "True if values are not increasing .", "label": 1}, {"idx": "cosqa-train-19213", "doc": "prompt user in python eval(", "code": "def input(prompt=\"\"):\n\t\"\"\"input([prompt]) -> value\n\nEquivalent to eval(raw_input(prompt)).\"\"\"\n\t\n\tstring = stdin_decode(raw_input(prompt))\n\t\n\tcaller_frame = sys._getframe(1)\n\tglobals = caller_frame.f_globals\n\tlocals = caller_frame.f_locals\n\t\n\treturn eval(string, globals, locals)", "code_tokens": "def input ( prompt = \"\" ) : string = stdin_decode ( raw_input ( prompt ) ) caller_frame = sys . _getframe ( 1 ) globals = caller_frame . f_globals locals = caller_frame . f_locals return eval ( string , globals , locals )", "docstring_tokens": "input ( [ prompt ] ) - > value", "label": 0}, {"idx": "cosqa-train-19214", "doc": "python hide certain output", "code": "def suppress_stdout():\n    \"\"\"\n    Context manager that suppresses stdout.\n\n    Examples:\n        >>> with suppress_stdout():\n        ...     print('Test print')\n\n        >>> print('test')\n        test\n\n    \"\"\"\n    save_stdout = sys.stdout\n    sys.stdout = DevNull()\n    yield\n    sys.stdout = save_stdout", "code_tokens": "def suppress_stdout ( ) : save_stdout = sys . stdout sys . stdout = DevNull ( ) yield sys . stdout = save_stdout", "docstring_tokens": "Context manager that suppresses stdout .", "label": 0}, {"idx": "cosqa-train-19215", "doc": "python input default int", "code": "def convert_to_int(x: Any, default: int = None) -> int:\n    \"\"\"\n    Transforms its input into an integer, or returns ``default``.\n    \"\"\"\n    try:\n        return int(x)\n    except (TypeError, ValueError):\n        return default", "code_tokens": "def convert_to_int ( x : Any , default : int = None ) -> int : try : return int ( x ) except ( TypeError , ValueError ) : return default", "docstring_tokens": "Transforms its input into an integer or returns default .", "label": 0}, {"idx": "cosqa-train-19216", "doc": "python filter function return a series, but expected a scalar bool", "code": "def filter_bool(n: Node, query: str) -> bool:\n    \"\"\"\n    Filter and ensure that the returned value is of type bool.\n    \"\"\"\n    return _scalariter2item(n, query, bool)", "code_tokens": "def filter_bool ( n : Node , query : str ) -> bool : return _scalariter2item ( n , query , bool )", "docstring_tokens": "Filter and ensure that the returned value is of type bool .", "label": 1}, {"idx": "cosqa-train-19217", "doc": "python how to ask a true or false question", "code": "def ask_bool(question: str, default: bool = True) -> bool:\n    \"\"\"Asks a question yes no style\"\"\"\n    default_q = \"Y/n\" if default else \"y/N\"\n    answer = input(\"{0} [{1}]: \".format(question, default_q))\n    lower = answer.lower()\n    if not lower:\n        return default\n    return lower == \"y\"", "code_tokens": "def ask_bool ( question : str , default : bool = True ) -> bool : default_q = \"Y/n\" if default else \"y/N\" answer = input ( \"{0} [{1}]: \" . format ( question , default_q ) ) lower = answer . lower ( ) if not lower : return default return lower == \"y\"", "docstring_tokens": "Asks a question yes no style", "label": 0}, {"idx": "cosqa-train-19218", "doc": "get last month from python", "code": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day", "code_tokens": "def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "docstring_tokens": "Returns day number of the last day of the month : param t : datetime : return : int", "label": 1}, {"idx": "cosqa-train-19219", "doc": "check if two strings are equal python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 0}, {"idx": "cosqa-train-19220", "doc": "python turn true and false into logical", "code": "def to_bool(value: Any) -> bool:\n    \"\"\"Convert string or other Python object to boolean.\n\n    **Rationalle**\n\n    Passing flags is one of the most common cases of using environment vars and\n    as values are strings we need to have an easy way to convert them to\n    boolean Python value.\n\n    Without this function int or float string values can be converted as false\n    positives, e.g. ``bool('0') => True``, but using this function ensure that\n    digit flag be properly converted to boolean value.\n\n    :param value: String or other value.\n    \"\"\"\n    return bool(strtobool(value) if isinstance(value, str) else value)", "code_tokens": "def to_bool ( value : Any ) -> bool : return bool ( strtobool ( value ) if isinstance ( value , str ) else value )", "docstring_tokens": "Convert string or other Python object to boolean .", "label": 0}, {"idx": "cosqa-train-19221", "doc": "python calc page align", "code": "def page_align_content_length(length):\n    # type: (int) -> int\n    \"\"\"Compute page boundary alignment\n    :param int length: content length\n    :rtype: int\n    :return: aligned byte boundary\n    \"\"\"\n    mod = length % _PAGEBLOB_BOUNDARY\n    if mod != 0:\n        return length + (_PAGEBLOB_BOUNDARY - mod)\n    return length", "code_tokens": "def page_align_content_length ( length ) : # type: (int) -> int mod = length % _PAGEBLOB_BOUNDARY if mod != 0 : return length + ( _PAGEBLOB_BOUNDARY - mod ) return length", "docstring_tokens": "Compute page boundary alignment : param int length : content length : rtype : int : return : aligned byte boundary", "label": 1}, {"idx": "cosqa-train-19222", "doc": "how to split sentence based on delimeter using python", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 0}, {"idx": "cosqa-train-19223", "doc": "python rest api posting json request", "code": "def post(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP POST operation to API endpoint.\"\"\"\n\n        return self._request('POST', endpoint, **kwargs)", "code_tokens": "def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "docstring_tokens": "HTTP POST operation to API endpoint .", "label": 0}, {"idx": "cosqa-train-19224", "doc": "python get the number of cpu cores", "code": "def cpu_count() -> int:\n    \"\"\"Returns the number of processors on this machine.\"\"\"\n    if multiprocessing is None:\n        return 1\n    try:\n        return multiprocessing.cpu_count()\n    except NotImplementedError:\n        pass\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_CONF\")\n    except (AttributeError, ValueError):\n        pass\n    gen_log.error(\"Could not detect number of processors; assuming 1\")\n    return 1", "code_tokens": "def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( \"SC_NPROCESSORS_CONF\" ) except ( AttributeError , ValueError ) : pass gen_log . error ( \"Could not detect number of processors; assuming 1\" ) return 1", "docstring_tokens": "Returns the number of processors on this machine .", "label": 1}, {"idx": "cosqa-train-19225", "doc": "python method object pass in", "code": "def _request(self, method: str, endpoint: str, params: dict = None, data: dict = None, headers: dict = None) -> dict:\n        \"\"\"HTTP request method of interface implementation.\"\"\"", "code_tokens": "def _request ( self , method : str , endpoint : str , params : dict = None , data : dict = None , headers : dict = None ) -> dict :", "docstring_tokens": "HTTP request method of interface implementation .", "label": 1}, {"idx": "cosqa-train-19226", "doc": "python length of element in matrix", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 0}, {"idx": "cosqa-train-19227", "doc": "pythondetermine file format from binary", "code": "def from_buffer(buffer, mime=False):\n    \"\"\"\n    Accepts a binary string and returns the detected filetype.  Return\n    value is the mimetype if mime=True, otherwise a human readable\n    name.\n\n    >>> magic.from_buffer(open(\"testdata/test.pdf\").read(1024))\n    'PDF document, version 1.2'\n    \"\"\"\n    m = _get_magic_type(mime)\n    return m.from_buffer(buffer)", "code_tokens": "def from_buffer ( buffer , mime = False ) : m = _get_magic_type ( mime ) return m . from_buffer ( buffer )", "docstring_tokens": "Accepts a binary string and returns the detected filetype . Return value is the mimetype if mime = True otherwise a human readable name .", "label": 1}, {"idx": "cosqa-train-19228", "doc": "python adding query string to url", "code": "def url_concat(url, args):\n    \"\"\"Concatenate url and argument dictionary regardless of whether\n    url has existing query parameters.\n\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    \"\"\"\n    if not args: return url\n    if url[-1] not in ('?', '&'):\n        url += '&' if ('?' in url) else '?'\n    return url + urllib.urlencode(args)", "code_tokens": "def url_concat ( url , args ) : if not args : return url if url [ - 1 ] not in ( '?' , '&' ) : url += '&' if ( '?' in url ) else '?' return url + urllib . urlencode ( args )", "docstring_tokens": "Concatenate url and argument dictionary regardless of whether url has existing query parameters .", "label": 0}, {"idx": "cosqa-train-19229", "doc": "python unsupported operand type for nonetype", "code": "def getVectorFromType(self, dtype) -> Union[bool, None, Tuple[int, int]]:\n        \"\"\"\n        :see: doc of method on parent class\n        \"\"\"\n        if dtype == BIT:\n            return False\n        elif isinstance(dtype, Bits):\n            return [evalParam(dtype.width) - 1, hInt(0)]", "code_tokens": "def getVectorFromType ( self , dtype ) -> Union [ bool , None , Tuple [ int , int ] ] : if dtype == BIT : return False elif isinstance ( dtype , Bits ) : return [ evalParam ( dtype . width ) - 1 , hInt ( 0 ) ]", "docstring_tokens": ": see : doc of method on parent class", "label": 0}, {"idx": "cosqa-train-19230", "doc": "get a date from string python", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-19231", "doc": "python 3 string to byte encoding", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 1}, {"idx": "cosqa-train-19232", "doc": "how do i filter a python dictionary by its values", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 1}, {"idx": "cosqa-train-19233", "doc": "python how to get day of week name", "code": "def get_day_name(self) -> str:\n        \"\"\" Returns the day name \"\"\"\n        weekday = self.value.isoweekday() - 1\n        return calendar.day_name[weekday]", "code_tokens": "def get_day_name ( self ) -> str : weekday = self . value . isoweekday ( ) - 1 return calendar . day_name [ weekday ]", "docstring_tokens": "Returns the day name", "label": 1}, {"idx": "cosqa-train-19234", "doc": "python receive **kwargs pass on **kwargs", "code": "def use_kwargs(self, *args, **kwargs) -> typing.Callable:\n        \"\"\"Decorator that injects parsed arguments into a view function or method.\n\n        Receives the same arguments as `webargs.core.Parser.use_kwargs`.\n\n        \"\"\"\n        return super().use_kwargs(*args, **kwargs)", "code_tokens": "def use_kwargs ( self , * args , * * kwargs ) -> typing . Callable : return super ( ) . use_kwargs ( * args , * * kwargs )", "docstring_tokens": "Decorator that injects parsed arguments into a view function or method .", "label": 1}, {"idx": "cosqa-train-19235", "doc": "python force string to camel case", "code": "def convert_camel_case_string(name: str) -> str:\n    \"\"\"Convert camel case string to snake case\"\"\"\n    string = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name)\n    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", string).lower()", "code_tokens": "def convert_camel_case_string ( name : str ) -> str : string = re . sub ( \"(.)([A-Z][a-z]+)\" , r\"\\1_\\2\" , name ) return re . sub ( \"([a-z0-9])([A-Z])\" , r\"\\1_\\2\" , string ) . lower ( )", "docstring_tokens": "Convert camel case string to snake case", "label": 1}, {"idx": "cosqa-train-19236", "doc": "how to see if a text file is empty in python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 0}, {"idx": "cosqa-train-19237", "doc": "python user input to exit", "code": "def do_quit(self, _: argparse.Namespace) -> bool:\n        \"\"\"Exit this application\"\"\"\n        self._should_quit = True\n        return self._STOP_AND_EXIT", "code_tokens": "def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "docstring_tokens": "Exit this application", "label": 1}, {"idx": "cosqa-train-19238", "doc": "python how to generate only half of the permutations", "code": "def distinct_permutations(iterable):\n    \"\"\"Yield successive distinct permutations of the elements in *iterable*.\n\n        >>> sorted(distinct_permutations([1, 0, 1]))\n        [(0, 1, 1), (1, 0, 1), (1, 1, 0)]\n\n    Equivalent to ``set(permutations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    Duplicate permutations arise when there are duplicated elements in the\n    input iterable. The number of items returned is\n    `n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of\n    items input, and each `x_i` is the count of a distinct item in the input\n    sequence.\n\n    \"\"\"\n    def make_new_permutations(permutations, e):\n        \"\"\"Internal helper function.\n        The output permutations are built up by adding element *e* to the\n        current *permutations* at every possible position.\n        The key idea is to keep repeated elements (reverse) ordered:\n        if e1 == e2 and e1 is before e2 in the iterable, then all permutations\n        with e1 before e2 are ignored.\n\n        \"\"\"\n        for permutation in permutations:\n            for j in range(len(permutation)):\n                yield permutation[:j] + [e] + permutation[j:]\n                if permutation[j] == e:\n                    break\n            else:\n                yield permutation + [e]\n\n    permutations = [[]]\n    for e in iterable:\n        permutations = make_new_permutations(permutations, e)\n\n    return (tuple(t) for t in permutations)", "code_tokens": "def distinct_permutations ( iterable ) : def make_new_permutations ( permutations , e ) : \"\"\"Internal helper function.\n        The output permutations are built up by adding element *e* to the\n        current *permutations* at every possible position.\n        The key idea is to keep repeated elements (reverse) ordered:\n        if e1 == e2 and e1 is before e2 in the iterable, then all permutations\n        with e1 before e2 are ignored.\n\n        \"\"\" for permutation in permutations : for j in range ( len ( permutation ) ) : yield permutation [ : j ] + [ e ] + permutation [ j : ] if permutation [ j ] == e : break else : yield permutation + [ e ] permutations = [ [ ] ] for e in iterable : permutations = make_new_permutations ( permutations , e ) return ( tuple ( t ) for t in permutations )", "docstring_tokens": "Yield successive distinct permutations of the elements in * iterable * .", "label": 1}, {"idx": "cosqa-train-19239", "doc": "how to get horizontal alignment on python", "code": "def text_alignment(x, y):\n    \"\"\"\n    Align text labels based on the x- and y-axis coordinate values.\n\n    This function is used for computing the appropriate alignment of the text\n    label.\n\n    For example, if the text is on the \"right\" side of the plot, we want it to\n    be left-aligned. If the text is on the \"top\" side of the plot, we want it\n    to be bottom-aligned.\n\n    :param x, y: (`int` or `float`) x- and y-axis coordinate respectively.\n    :returns: A 2-tuple of strings, the horizontal and vertical alignments\n        respectively.\n    \"\"\"\n    if x == 0:\n        ha = \"center\"\n    elif x > 0:\n        ha = \"left\"\n    else:\n        ha = \"right\"\n    if y == 0:\n        va = \"center\"\n    elif y > 0:\n        va = \"bottom\"\n    else:\n        va = \"top\"\n\n    return ha, va", "code_tokens": "def text_alignment ( x , y ) : if x == 0 : ha = \"center\" elif x > 0 : ha = \"left\" else : ha = \"right\" if y == 0 : va = \"center\" elif y > 0 : va = \"bottom\" else : va = \"top\" return ha , va", "docstring_tokens": "Align text labels based on the x - and y - axis coordinate values .", "label": 1}, {"idx": "cosqa-train-19240", "doc": "invalid dimensions for image data in python", "code": "def _validate_image_rank(self, img_array):\n        \"\"\"\n        Images must be either 2D or 3D.\n        \"\"\"\n        if img_array.ndim == 1 or img_array.ndim > 3:\n            msg = \"{0}D imagery is not allowed.\".format(img_array.ndim)\n            raise IOError(msg)", "code_tokens": "def _validate_image_rank ( self , img_array ) : if img_array . ndim == 1 or img_array . ndim > 3 : msg = \"{0}D imagery is not allowed.\" . format ( img_array . ndim ) raise IOError ( msg )", "docstring_tokens": "Images must be either 2D or 3D .", "label": 1}, {"idx": "cosqa-train-19241", "doc": "get and post methods for python server", "code": "def _request(self, method: str, endpoint: str, params: dict = None, data: dict = None, headers: dict = None) -> dict:\n        \"\"\"HTTP request method of interface implementation.\"\"\"", "code_tokens": "def _request ( self , method : str , endpoint : str , params : dict = None , data : dict = None , headers : dict = None ) -> dict :", "docstring_tokens": "HTTP request method of interface implementation .", "label": 0}, {"idx": "cosqa-train-19242", "doc": "how to check if a file is empty using python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 1}, {"idx": "cosqa-train-19243", "doc": "python linux detect keypress", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 1}, {"idx": "cosqa-train-19244", "doc": "auto pylint python 2", "code": "def lint(fmt='colorized'):\n    \"\"\"Run verbose PyLint on source. Optionally specify fmt=html for HTML output.\"\"\"\n    if fmt == 'html':\n        outfile = 'pylint_report.html'\n        local('pylint -f %s davies > %s || true' % (fmt, outfile))\n        local('open %s' % outfile)\n    else:\n        local('pylint -f %s davies || true' % fmt)", "code_tokens": "def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "docstring_tokens": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output .", "label": 0}, {"idx": "cosqa-train-19245", "doc": "python hash for a file", "code": "def _hash_the_file(hasher, filename):\n    \"\"\"Helper function for creating hash functions.\n\n    See implementation of :func:`dtoolcore.filehasher.shasum`\n    for more usage details.\n    \"\"\"\n    BUF_SIZE = 65536\n    with open(filename, 'rb') as f:\n        buf = f.read(BUF_SIZE)\n        while len(buf) > 0:\n            hasher.update(buf)\n            buf = f.read(BUF_SIZE)\n    return hasher", "code_tokens": "def _hash_the_file ( hasher , filename ) : BUF_SIZE = 65536 with open ( filename , 'rb' ) as f : buf = f . read ( BUF_SIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = f . read ( BUF_SIZE ) return hasher", "docstring_tokens": "Helper function for creating hash functions .", "label": 1}, {"idx": "cosqa-train-19246", "doc": "remove special characters from column names in python", "code": "def normalize_column_names(df):\n    r\"\"\" Clean up whitespace in column names. See better version at `pugnlp.clean_columns`\n\n    >>> df = pd.DataFrame([[1, 2], [3, 4]], columns=['Hello World', 'not here'])\n    >>> normalize_column_names(df)\n    ['hello_world', 'not_here']\n    \"\"\"\n    columns = df.columns if hasattr(df, 'columns') else df\n    columns = [c.lower().replace(' ', '_') for c in columns]\n    return columns", "code_tokens": "def normalize_column_names ( df ) : columns = df . columns if hasattr ( df , 'columns' ) else df columns = [ c . lower ( ) . replace ( ' ' , '_' ) for c in columns ] return columns", "docstring_tokens": "r Clean up whitespace in column names . See better version at pugnlp . clean_columns", "label": 1}, {"idx": "cosqa-train-19247", "doc": "python hsv 2 rgb", "code": "def hsv2rgb_spectrum(hsv):\n    \"\"\"Generates RGB values from HSV values in line with a typical light\n    spectrum.\"\"\"\n    h, s, v = hsv\n    return hsv2rgb_raw(((h * 192) >> 8, s, v))", "code_tokens": "def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "docstring_tokens": "Generates RGB values from HSV values in line with a typical light spectrum .", "label": 0}, {"idx": "cosqa-train-19248", "doc": "how to read the contents of a text file in python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-19249", "doc": "how to titlecase words in python", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-19250", "doc": "python read adb devices", "code": "def list_adb_devices_by_usb_id():\n    \"\"\"List the usb id of all android devices connected to the computer that\n    are detected by adb.\n\n    Returns:\n        A list of strings that are android device usb ids. Empty if there's\n        none.\n    \"\"\"\n    out = adb.AdbProxy().devices(['-l'])\n    clean_lines = new_str(out, 'utf-8').strip().split('\\n')\n    results = []\n    for line in clean_lines:\n        tokens = line.strip().split()\n        if len(tokens) > 2 and tokens[1] == 'device':\n            results.append(tokens[2])\n    return results", "code_tokens": "def list_adb_devices_by_usb_id ( ) : out = adb . AdbProxy ( ) . devices ( [ '-l' ] ) clean_lines = new_str ( out , 'utf-8' ) . strip ( ) . split ( '\\n' ) results = [ ] for line in clean_lines : tokens = line . strip ( ) . split ( ) if len ( tokens ) > 2 and tokens [ 1 ] == 'device' : results . append ( tokens [ 2 ] ) return results", "docstring_tokens": "List the usb id of all android devices connected to the computer that are detected by adb .", "label": 1}, {"idx": "cosqa-train-19251", "doc": "python3 how to correct print out bit data", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 1}, {"idx": "cosqa-train-19252", "doc": "python change column name from camel to snake", "code": "def camel_to_snake(s: str) -> str:\n    \"\"\"Convert string from camel case to snake case.\"\"\"\n\n    return CAMEL_CASE_RE.sub(r'_\\1', s).strip().lower()", "code_tokens": "def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "docstring_tokens": "Convert string from camel case to snake case .", "label": 0}, {"idx": "cosqa-train-19253", "doc": "python get desktop size from linux", "code": "def get_window_dim():\n    \"\"\" gets the dimensions depending on python version and os\"\"\"\n    version = sys.version_info\n\n    if version >= (3, 3):\n        return _size_36()\n    if platform.system() == 'Windows':\n        return _size_windows()\n    return _size_27()", "code_tokens": "def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )", "docstring_tokens": "gets the dimensions depending on python version and os", "label": 0}, {"idx": "cosqa-train-19254", "doc": "python length longest string in array", "code": "def _prm_get_longest_stringsize(string_list):\n        \"\"\" Returns the longest string size for a string entry across data.\"\"\"\n        maxlength = 1\n\n        for stringar in string_list:\n            if isinstance(stringar, np.ndarray):\n                if stringar.ndim > 0:\n                    for string in stringar.ravel():\n                        maxlength = max(len(string), maxlength)\n                else:\n                    maxlength = max(len(stringar.tolist()), maxlength)\n            else:\n                maxlength = max(len(stringar), maxlength)\n\n        # Make the string Col longer than needed in order to allow later on slightly larger strings\n        return int(maxlength * 1.5)", "code_tokens": "def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "docstring_tokens": "Returns the longest string size for a string entry across data .", "label": 0}, {"idx": "cosqa-train-19255", "doc": "changing string to int with python", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-19256", "doc": "python count appearances in a list", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 0}, {"idx": "cosqa-train-19257", "doc": "how to detect number of cpu cores in python", "code": "def cpu_count() -> int:\n    \"\"\"Returns the number of processors on this machine.\"\"\"\n    if multiprocessing is None:\n        return 1\n    try:\n        return multiprocessing.cpu_count()\n    except NotImplementedError:\n        pass\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_CONF\")\n    except (AttributeError, ValueError):\n        pass\n    gen_log.error(\"Could not detect number of processors; assuming 1\")\n    return 1", "code_tokens": "def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( \"SC_NPROCESSORS_CONF\" ) except ( AttributeError , ValueError ) : pass gen_log . error ( \"Could not detect number of processors; assuming 1\" ) return 1", "docstring_tokens": "Returns the number of processors on this machine .", "label": 1}, {"idx": "cosqa-train-19258", "doc": "python windows check for keypress", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 1}, {"idx": "cosqa-train-19259", "doc": "tensorflow compatible with python", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 0}, {"idx": "cosqa-train-19260", "doc": "enum int comparison python", "code": "def has_value(cls, value: int) -> bool:\n        \"\"\"True if specified value exists in int enum; otherwise, False.\"\"\"\n        return any(value == item.value for item in cls)", "code_tokens": "def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "docstring_tokens": "True if specified value exists in int enum ; otherwise False .", "label": 0}, {"idx": "cosqa-train-19261", "doc": "median without numpy python", "code": "def fast_median(a):\n    \"\"\"Fast median operation for masked array using 50th-percentile\n    \"\"\"\n    a = checkma(a)\n    #return scoreatpercentile(a.compressed(), 50)\n    if a.count() > 0:\n        out = np.percentile(a.compressed(), 50)\n    else:\n        out = np.ma.masked\n    return out", "code_tokens": "def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out", "docstring_tokens": "Fast median operation for masked array using 50th - percentile", "label": 0}, {"idx": "cosqa-train-19262", "doc": "python execute function after specific ammount of time", "code": "def timeit (func, log, limit):\n    \"\"\"Print execution time of the function. For quick'n'dirty profiling.\"\"\"\n\n    def newfunc (*args, **kwargs):\n        \"\"\"Execute function and print execution time.\"\"\"\n        t = time.time()\n        res = func(*args, **kwargs)\n        duration = time.time() - t\n        if duration > limit:\n            print(func.__name__, \"took %0.2f seconds\" % duration, file=log)\n            print(args, file=log)\n            print(kwargs, file=log)\n        return res\n    return update_func_meta(newfunc, func)", "code_tokens": "def timeit ( func , log , limit ) : def newfunc ( * args , * * kwargs ) : \"\"\"Execute function and print execution time.\"\"\" t = time . time ( ) res = func ( * args , * * kwargs ) duration = time . time ( ) - t if duration > limit : print ( func . __name__ , \"took %0.2f seconds\" % duration , file = log ) print ( args , file = log ) print ( kwargs , file = log ) return res return update_func_meta ( newfunc , func )", "docstring_tokens": "Print execution time of the function . For quick n dirty profiling .", "label": 0}, {"idx": "cosqa-train-19263", "doc": "how to compute the minimum value of a tensor in python", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 1}, {"idx": "cosqa-train-19264", "doc": "function to count duplicates in list in python", "code": "def find_duplicates(l: list) -> set:\n    \"\"\"\n    Return the duplicates in a list.\n\n    The function relies on\n    https://stackoverflow.com/questions/9835762/find-and-list-duplicates-in-a-list .\n    Parameters\n    ----------\n    l : list\n        Name\n\n    Returns\n    -------\n    set\n        Duplicated values\n\n    >>> find_duplicates([1,2,3])\n    set()\n    >>> find_duplicates([1,2,1])\n    {1}\n    \"\"\"\n    return set([x for x in l if l.count(x) > 1])", "code_tokens": "def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "docstring_tokens": "Return the duplicates in a list .", "label": 1}, {"idx": "cosqa-train-19265", "doc": "return index for a certain value python", "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:\n    \"\"\"\n    Finds the index of an item in list, which satisfies predicate\n    :param predicateFn: predicate function to run on items of list\n    :param items: list of tuples\n    :return: first index for which predicate function returns True\n    \"\"\"\n    try:\n        return next(i for i, v in enumerate(items) if predicateFn(v))\n    except StopIteration:\n        return -1", "code_tokens": "def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "docstring_tokens": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True", "label": 0}, {"idx": "cosqa-train-19266", "doc": "question 3 what method do you call in an sqlite cursor object in python to run an sql command", "code": "def execute(cur, *args):\n    \"\"\"Utility function to print sqlite queries before executing.\n\n    Use instead of cur.execute().  First argument is cursor.\n\n    cur.execute(stmt)\n    becomes\n    util.execute(cur, stmt)\n    \"\"\"\n    stmt = args[0]\n    if len(args) > 1:\n        stmt = stmt.replace('%', '%%').replace('?', '%r')\n        print(stmt % (args[1]))\n    return cur.execute(*args)", "code_tokens": "def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )", "docstring_tokens": "Utility function to print sqlite queries before executing .", "label": 1}, {"idx": "cosqa-train-19267", "doc": "check if file is blank in python", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 0}, {"idx": "cosqa-train-19268", "doc": "how to change spyder to python 3", "code": "def get_versions(reporev=True):\n    \"\"\"Get version information for components used by Spyder\"\"\"\n    import sys\n    import platform\n\n    import qtpy\n    import qtpy.QtCore\n\n    revision = None\n    if reporev:\n        from spyder.utils import vcs\n        revision, branch = vcs.get_git_revision(os.path.dirname(__dir__))\n\n    if not sys.platform == 'darwin':  # To avoid a crash with our Mac app\n        system = platform.system()\n    else:\n        system = 'Darwin'\n\n    return {\n        'spyder': __version__,\n        'python': platform.python_version(),  # \"2.7.3\"\n        'bitness': 64 if sys.maxsize > 2**32 else 32,\n        'qt': qtpy.QtCore.__version__,\n        'qt_api': qtpy.API_NAME,      # PyQt5\n        'qt_api_ver': qtpy.PYQT_VERSION,\n        'system': system,   # Linux, Windows, ...\n        'release': platform.release(),  # XP, 10.6, 2.2.0, etc.\n        'revision': revision,  # '9fdf926eccce'\n    }", "code_tokens": "def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "docstring_tokens": "Get version information for components used by Spyder", "label": 0}, {"idx": "cosqa-train-19269", "doc": "python any letter in string", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-19270", "doc": "python boolean and or not", "code": "def _isbool(string):\n    \"\"\"\n    >>> _isbool(True)\n    True\n    >>> _isbool(\"False\")\n    True\n    >>> _isbool(1)\n    False\n    \"\"\"\n    return isinstance(string, _bool_type) or\\\n        (isinstance(string, (_binary_type, _text_type))\n         and\n         string in (\"True\", \"False\"))", "code_tokens": "def _isbool ( string ) : return isinstance ( string , _bool_type ) or ( isinstance ( string , ( _binary_type , _text_type ) ) and string in ( \"True\" , \"False\" ) )", "docstring_tokens": ">>> _isbool ( True ) True >>> _isbool ( False ) True >>> _isbool ( 1 ) False", "label": 1}, {"idx": "cosqa-train-19271", "doc": "python operate on a single bit", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 1}, {"idx": "cosqa-train-19272", "doc": "check if callable python", "code": "def callable_validator(v: Any) -> AnyCallable:\n    \"\"\"\n    Perform a simple check if the value is callable.\n\n    Note: complete matching of argument type hints and return types is not performed\n    \"\"\"\n    if callable(v):\n        return v\n\n    raise errors.CallableError(value=v)", "code_tokens": "def callable_validator ( v : Any ) -> AnyCallable : if callable ( v ) : return v raise errors . CallableError ( value = v )", "docstring_tokens": "Perform a simple check if the value is callable .", "label": 1}, {"idx": "cosqa-train-19273", "doc": "python flask shared cache", "code": "def setup_cache(app: Flask, cache_config) -> Optional[Cache]:\n    \"\"\"Setup the flask-cache on a flask app\"\"\"\n    if cache_config and cache_config.get('CACHE_TYPE') != 'null':\n        return Cache(app, config=cache_config)\n\n    return None", "code_tokens": "def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None", "docstring_tokens": "Setup the flask - cache on a flask app", "label": 0}, {"idx": "cosqa-train-19274", "doc": "python if os file doesn't exist", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 0}, {"idx": "cosqa-train-19275", "doc": "python merge greater than", "code": "def __gt__(self, other):\n    \"\"\"Greater than ordering.\"\"\"\n    if not isinstance(other, Key):\n      return NotImplemented\n    return self.__tuple() > other.__tuple()", "code_tokens": "def __gt__ ( self , other ) : if not isinstance ( other , Key ) : return NotImplemented return self . __tuple ( ) > other . __tuple ( )", "docstring_tokens": "Greater than ordering .", "label": 0}, {"idx": "cosqa-train-19276", "doc": "how to check int null value in python", "code": "def strictly_positive_int_or_none(val):\n    \"\"\"Parse `val` into either `None` or a strictly positive integer.\"\"\"\n    val = positive_int_or_none(val)\n    if val is None or val > 0:\n        return val\n    raise ValueError('\"{}\" must be strictly positive'.format(val))", "code_tokens": "def strictly_positive_int_or_none ( val ) : val = positive_int_or_none ( val ) if val is None or val > 0 : return val raise ValueError ( '\"{}\" must be strictly positive' . format ( val ) )", "docstring_tokens": "Parse val into either None or a strictly positive integer .", "label": 0}, {"idx": "cosqa-train-19277", "doc": "python check to see if a key exists", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 0}, {"idx": "cosqa-train-19278", "doc": "python np array yaml", "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]:\n    \"\"\" Write a numpy array to YAML.\n\n    It registers the array under the tag ``!numpy_array``.\n\n    Use with:\n\n    .. code-block:: python\n\n        >>> yaml = ruamel.yaml.YAML()\n        >>> yaml.representer.add_representer(np.ndarray, yaml.numpy_to_yaml)\n\n    Note:\n        We cannot use ``yaml.register_class`` because it won't register the proper type.\n        (It would register the type of the class, rather than of `numpy.ndarray`). Instead,\n        we use the above approach to register this method explicitly with the representer.\n    \"\"\"\n    return representer.represent_sequence(\n        \"!numpy_array\",\n        data.tolist()\n    )", "code_tokens": "def numpy_to_yaml ( representer : Representer , data : np . ndarray ) -> Sequence [ Any ] : return representer . represent_sequence ( \"!numpy_array\" , data . tolist ( ) )", "docstring_tokens": "Write a numpy array to YAML .", "label": 1}, {"idx": "cosqa-train-19279", "doc": "python config parser get list of sections", "code": "def sections(self) -> list:\n        \"\"\"List of sections.\"\"\"\n        self.config.read(self.filepath)\n        return self.config.sections()", "code_tokens": "def sections ( self ) -> list : self . config . read ( self . filepath ) return self . config . sections ( )", "docstring_tokens": "List of sections .", "label": 1}, {"idx": "cosqa-train-19280", "doc": "how to chk that an item is not in a list in python", "code": "def obj_in_list_always(target_list, obj):\n    \"\"\"\n    >>> l = [1,1,1]\n    >>> obj_in_list_always(l, 1)\n    True\n    >>> l.append(2)\n    >>> obj_in_list_always(l, 1)\n    False\n    \"\"\"\n    for item in set(target_list):\n        if item is not obj:\n            return False\n    return True", "code_tokens": "def obj_in_list_always ( target_list , obj ) : for item in set ( target_list ) : if item is not obj : return False return True", "docstring_tokens": ">>> l = [ 1 1 1 ] >>> obj_in_list_always ( l 1 ) True >>> l . append ( 2 ) >>> obj_in_list_always ( l 1 ) False", "label": 1}, {"idx": "cosqa-train-19281", "doc": "itertools get all partitions into 2 sets python", "code": "def integer_partition(size: int, nparts: int) -> Iterator[List[List[int]]]:\n    \"\"\" Partition a list of integers into a list of partitions \"\"\"\n    for part in algorithm_u(range(size), nparts):\n        yield part", "code_tokens": "def integer_partition ( size : int , nparts : int ) -> Iterator [ List [ List [ int ] ] ] : for part in algorithm_u ( range ( size ) , nparts ) : yield part", "docstring_tokens": "Partition a list of integers into a list of partitions", "label": 0}, {"idx": "cosqa-train-19282", "doc": "python 3 speed up for loop with map", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 1}, {"idx": "cosqa-train-19283", "doc": "how to throw an assertion error in python", "code": "def assert_raises(ex_type, func, *args, **kwargs):\n    r\"\"\"\n    Checks that a function raises an error when given specific arguments.\n\n    Args:\n        ex_type (Exception): exception type\n        func (callable): live python function\n\n    CommandLine:\n        python -m utool.util_assert assert_raises --show\n\n    Example:\n        >>> # ENABLE_DOCTEST\n        >>> from utool.util_assert import *  # NOQA\n        >>> import utool as ut\n        >>> ex_type = AssertionError\n        >>> func = len\n        >>> # Check that this raises an error when something else does not\n        >>> assert_raises(ex_type, assert_raises, ex_type, func, [])\n        >>> # Check this does not raise an error when something else does\n        >>> assert_raises(ValueError, [].index, 0)\n    \"\"\"\n    try:\n        func(*args, **kwargs)\n    except Exception as ex:\n        assert isinstance(ex, ex_type), (\n            'Raised %r but type should have been %r' % (ex, ex_type))\n        return True\n    else:\n        raise AssertionError('No error was raised')", "code_tokens": "def assert_raises ( ex_type , func , * args , * * kwargs ) : try : func ( * args , * * kwargs ) except Exception as ex : assert isinstance ( ex , ex_type ) , ( 'Raised %r but type should have been %r' % ( ex , ex_type ) ) return True else : raise AssertionError ( 'No error was raised' )", "docstring_tokens": "r Checks that a function raises an error when given specific arguments .", "label": 0}, {"idx": "cosqa-train-19284", "doc": "uuid to str python 3", "code": "def uuid2buid(value):\n    \"\"\"\n    Convert a UUID object to a 22-char BUID string\n\n    >>> u = uuid.UUID('33203dd2-f2ef-422f-aeb0-058d6f5f7089')\n    >>> uuid2buid(u)\n    'MyA90vLvQi-usAWNb19wiQ'\n    \"\"\"\n    if six.PY3:  # pragma: no cover\n        return urlsafe_b64encode(value.bytes).decode('utf-8').rstrip('=')\n    else:\n        return six.text_type(urlsafe_b64encode(value.bytes).rstrip('='))", "code_tokens": "def uuid2buid ( value ) : if six . PY3 : # pragma: no cover return urlsafe_b64encode ( value . bytes ) . decode ( 'utf-8' ) . rstrip ( '=' ) else : return six . text_type ( urlsafe_b64encode ( value . bytes ) . rstrip ( '=' ) )", "docstring_tokens": "Convert a UUID object to a 22 - char BUID string", "label": 0}, {"idx": "cosqa-train-19285", "doc": "python print nodes binary tree", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 1}, {"idx": "cosqa-train-19286", "doc": "checking if 2 strings are equal in python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 0}, {"idx": "cosqa-train-19287", "doc": "how to get the size of desktop using python", "code": "def get_window_dim():\n    \"\"\" gets the dimensions depending on python version and os\"\"\"\n    version = sys.version_info\n\n    if version >= (3, 3):\n        return _size_36()\n    if platform.system() == 'Windows':\n        return _size_windows()\n    return _size_27()", "code_tokens": "def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )", "docstring_tokens": "gets the dimensions depending on python version and os", "label": 1}, {"idx": "cosqa-train-19288", "doc": "instagram login python requests", "code": "def login(self, user: str, passwd: str) -> None:\n        \"\"\"Log in to instagram with given username and password and internally store session object.\n\n        :raises InvalidArgumentException: If the provided username does not exist.\n        :raises BadCredentialsException: If the provided password is wrong.\n        :raises ConnectionException: If connection to Instagram failed.\n        :raises TwoFactorAuthRequiredException: First step of 2FA login done, now call :meth:`Instaloader.two_factor_login`.\"\"\"\n        self.context.login(user, passwd)", "code_tokens": "def login ( self , user : str , passwd : str ) -> None : self . context . login ( user , passwd )", "docstring_tokens": "Log in to instagram with given username and password and internally store session object .", "label": 1}, {"idx": "cosqa-train-19289", "doc": "use requests with python asyncio", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 0}, {"idx": "cosqa-train-19290", "doc": "set maximum string length python", "code": "def truncate_string(value, max_width=None):\n    \"\"\"Truncate string values.\"\"\"\n    if isinstance(value, text_type) and max_width is not None and len(value) > max_width:\n        return value[:max_width]\n    return value", "code_tokens": "def truncate_string ( value , max_width = None ) : if isinstance ( value , text_type ) and max_width is not None and len ( value ) > max_width : return value [ : max_width ] return value", "docstring_tokens": "Truncate string values .", "label": 0}, {"idx": "cosqa-train-19291", "doc": "split python wordnet synosym", "code": "def has_synset(word: str) -> list:\n    \"\"\"\" Returns a list of synsets of a word after lemmatization. \"\"\"\n\n    return wn.synsets(lemmatize(word, neverstem=True))", "code_tokens": "def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "docstring_tokens": "Returns a list of synsets of a word after lemmatization .", "label": 1}, {"idx": "cosqa-train-19292", "doc": "compute shortest path in graph python", "code": "def dag_longest_path(graph, source, target):\n    \"\"\"\n    Finds the longest path in a dag between two nodes\n    \"\"\"\n    if source == target:\n        return [source]\n    allpaths = nx.all_simple_paths(graph, source, target)\n    longest_path = []\n    for l in allpaths:\n        if len(l) > len(longest_path):\n            longest_path = l\n    return longest_path", "code_tokens": "def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "docstring_tokens": "Finds the longest path in a dag between two nodes", "label": 0}, {"idx": "cosqa-train-19293", "doc": "how to make a string of numbers n python", "code": "def _numbers_units(N):\n    \"\"\"\n    >>> _numbers_units(45)\n    '123456789012345678901234567890123456789012345'\n    \"\"\"\n    lst = range(1, N + 1)\n    return \"\".join(list(map(lambda i: str(i % 10), lst)))", "code_tokens": "def _numbers_units ( N ) : lst = range ( 1 , N + 1 ) return \"\" . join ( list ( map ( lambda i : str ( i % 10 ) , lst ) ) )", "docstring_tokens": ">>> _numbers_units ( 45 ) 123456789012345678901234567890123456789012345", "label": 1}, {"idx": "cosqa-train-19294", "doc": "python get duplicate index", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 0}, {"idx": "cosqa-train-19295", "doc": "python restful post put", "code": "def put(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP PUT operation to API endpoint.\"\"\"\n\n        return self._request('PUT', endpoint, **kwargs)", "code_tokens": "def put ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'PUT' , endpoint , * * kwargs )", "docstring_tokens": "HTTP PUT operation to API endpoint .", "label": 1}, {"idx": "cosqa-train-19296", "doc": "how to you inverse a dictionary in python", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 1}, {"idx": "cosqa-train-19297", "doc": "how to drop ( ) in python column names", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 0}, {"idx": "cosqa-train-19298", "doc": "how to change dtype in python to int", "code": "def to_int64(a):\n    \"\"\"Return view of the recarray with all int32 cast to int64.\"\"\"\n    # build new dtype and replace i4 --> i8\n    def promote_i4(typestr):\n        if typestr[1:] == 'i4':\n            typestr = typestr[0]+'i8'\n        return typestr\n\n    dtype = [(name, promote_i4(typestr)) for name,typestr in a.dtype.descr]\n    return a.astype(dtype)", "code_tokens": "def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )", "docstring_tokens": "Return view of the recarray with all int32 cast to int64 .", "label": 0}, {"idx": "cosqa-train-19299", "doc": "python open iterate remove newline", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 1}, {"idx": "cosqa-train-19300", "doc": "python index for duplicate element", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 1}, {"idx": "cosqa-train-19301", "doc": "python progarm to insert an element in sorted array", "code": "def insert_ordered(value, array):\n    \"\"\"\n    This will insert the value into the array, keeping it sorted, and returning the\n    index where it was inserted\n    \"\"\"\n\n    index = 0\n\n    # search for the last array item that value is larger than\n    for n in range(0,len(array)):\n        if value >= array[n]: index = n+1\n\n    array.insert(index, value)\n    return index", "code_tokens": "def insert_ordered ( value , array ) : index = 0 # search for the last array item that value is larger than for n in range ( 0 , len ( array ) ) : if value >= array [ n ] : index = n + 1 array . insert ( index , value ) return index", "docstring_tokens": "This will insert the value into the array keeping it sorted and returning the index where it was inserted", "label": 1}, {"idx": "cosqa-train-19302", "doc": "python str to named tuple", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 0}, {"idx": "cosqa-train-19303", "doc": "how to invert dictionary in python", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 1}, {"idx": "cosqa-train-19304", "doc": "how to check verson of python being used", "code": "def check_python_version():\n    \"\"\"Check if the currently running Python version is new enough.\"\"\"\n    # Required due to multiple with statements on one line\n    req_version = (2, 7)\n    cur_version = sys.version_info\n    if cur_version >= req_version:\n        print(\"Python version... %sOK%s (found %s, requires %s)\" %\n              (Bcolors.OKGREEN, Bcolors.ENDC, str(platform.python_version()),\n               str(req_version[0]) + \".\" + str(req_version[1])))\n    else:\n        print(\"Python version... %sFAIL%s (found %s, requires %s)\" %\n              (Bcolors.FAIL, Bcolors.ENDC, str(cur_version),\n               str(req_version)))", "code_tokens": "def check_python_version ( ) : # Required due to multiple with statements on one line req_version = ( 2 , 7 ) cur_version = sys . version_info if cur_version >= req_version : print ( \"Python version... %sOK%s (found %s, requires %s)\" % ( Bcolors . OKGREEN , Bcolors . ENDC , str ( platform . python_version ( ) ) , str ( req_version [ 0 ] ) + \".\" + str ( req_version [ 1 ] ) ) ) else : print ( \"Python version... %sFAIL%s (found %s, requires %s)\" % ( Bcolors . FAIL , Bcolors . ENDC , str ( cur_version ) , str ( req_version ) ) )", "docstring_tokens": "Check if the currently running Python version is new enough .", "label": 1}, {"idx": "cosqa-train-19305", "doc": "python normalise list to sum to 1", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 1}, {"idx": "cosqa-train-19306", "doc": "python check if string is file", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 0}, {"idx": "cosqa-train-19307", "doc": "python read yaml to numpy", "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]:\n    \"\"\" Write a numpy array to YAML.\n\n    It registers the array under the tag ``!numpy_array``.\n\n    Use with:\n\n    .. code-block:: python\n\n        >>> yaml = ruamel.yaml.YAML()\n        >>> yaml.representer.add_representer(np.ndarray, yaml.numpy_to_yaml)\n\n    Note:\n        We cannot use ``yaml.register_class`` because it won't register the proper type.\n        (It would register the type of the class, rather than of `numpy.ndarray`). Instead,\n        we use the above approach to register this method explicitly with the representer.\n    \"\"\"\n    return representer.represent_sequence(\n        \"!numpy_array\",\n        data.tolist()\n    )", "code_tokens": "def numpy_to_yaml ( representer : Representer , data : np . ndarray ) -> Sequence [ Any ] : return representer . represent_sequence ( \"!numpy_array\" , data . tolist ( ) )", "docstring_tokens": "Write a numpy array to YAML .", "label": 1}, {"idx": "cosqa-train-19308", "doc": "read string from file into a set python", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 0}, {"idx": "cosqa-train-19309", "doc": "python filter lambda dict", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-19310", "doc": "python imaginary part of complex number array", "code": "def quaternion_imag(quaternion):\n    \"\"\"Return imaginary part of quaternion.\n\n    >>> quaternion_imag([3, 0, 1, 2])\n    array([ 0.,  1.,  2.])\n\n    \"\"\"\n    return numpy.array(quaternion[1:4], dtype=numpy.float64, copy=True)", "code_tokens": "def quaternion_imag ( quaternion ) : return numpy . array ( quaternion [ 1 : 4 ] , dtype = numpy . float64 , copy = True )", "docstring_tokens": "Return imaginary part of quaternion .", "label": 0}, {"idx": "cosqa-train-19311", "doc": "turn a list of str into int python", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-19312", "doc": "python check what datatypes contained in a column", "code": "def is_sqlatype_string(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type a string type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.String)", "code_tokens": "def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "docstring_tokens": "Is the SQLAlchemy column type a string type?", "label": 1}, {"idx": "cosqa-train-19313", "doc": "add dictionary to query string to url python", "code": "def url_concat(url, args):\n    \"\"\"Concatenate url and argument dictionary regardless of whether\n    url has existing query parameters.\n\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    \"\"\"\n    if not args: return url\n    if url[-1] not in ('?', '&'):\n        url += '&' if ('?' in url) else '?'\n    return url + urllib.urlencode(args)", "code_tokens": "def url_concat ( url , args ) : if not args : return url if url [ - 1 ] not in ( '?' , '&' ) : url += '&' if ( '?' in url ) else '?' return url + urllib . urlencode ( args )", "docstring_tokens": "Concatenate url and argument dictionary regardless of whether url has existing query parameters .", "label": 1}, {"idx": "cosqa-train-19314", "doc": "python code to check duplicates of index in a list", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 0}, {"idx": "cosqa-train-19315", "doc": "how to get percentile of a value in a list python", "code": "def percentile(sorted_list, percent, key=lambda x: x):\n    \"\"\"Find the percentile of a sorted list of values.\n\n    Arguments\n    ---------\n    sorted_list : list\n        A sorted (ascending) list of values.\n    percent : float\n        A float value from 0.0 to 1.0.\n    key : function, optional\n        An optional function to compute a value from each element of N.\n\n    Returns\n    -------\n    float\n        The desired percentile of the value list.\n\n    Examples\n    --------\n    >>> sorted_list = [4,6,8,9,11]\n    >>> percentile(sorted_list, 0.4)\n    7.0\n    >>> percentile(sorted_list, 0.44)\n    8.0\n    >>> percentile(sorted_list, 0.6)\n    8.5\n    >>> percentile(sorted_list, 0.99)\n    11.0\n    >>> percentile(sorted_list, 1)\n    11.0\n    >>> percentile(sorted_list, 0)\n    4.0\n    \"\"\"\n    if not sorted_list:\n        return None\n    if percent == 1:\n        return float(sorted_list[-1])\n    if percent == 0:\n        return float(sorted_list[0])\n    n = len(sorted_list)\n    i = percent * n\n    if ceil(i) == i:\n        i = int(i)\n        return (sorted_list[i-1] + sorted_list[i]) / 2\n    return float(sorted_list[ceil(i)-1])", "code_tokens": "def percentile ( sorted_list , percent , key = lambda x : x ) : if not sorted_list : return None if percent == 1 : return float ( sorted_list [ - 1 ] ) if percent == 0 : return float ( sorted_list [ 0 ] ) n = len ( sorted_list ) i = percent * n if ceil ( i ) == i : i = int ( i ) return ( sorted_list [ i - 1 ] + sorted_list [ i ] ) / 2 return float ( sorted_list [ ceil ( i ) - 1 ] )", "docstring_tokens": "Find the percentile of a sorted list of values .", "label": 1}, {"idx": "cosqa-train-19316", "doc": "python top 10 list", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 0}, {"idx": "cosqa-train-19317", "doc": "get first occurence of char in string python", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 0}, {"idx": "cosqa-train-19318", "doc": "same index for duplicates in python", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 0}, {"idx": "cosqa-train-19319", "doc": "python check if is str", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 0}, {"idx": "cosqa-train-19320", "doc": "python post request api", "code": "def post(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP POST operation to API endpoint.\"\"\"\n\n        return self._request('POST', endpoint, **kwargs)", "code_tokens": "def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "docstring_tokens": "HTTP POST operation to API endpoint .", "label": 0}, {"idx": "cosqa-train-19321", "doc": "python graphviz write dot file", "code": "def cmd_dot(conf: Config):\n    \"\"\"Print out a neat targets dependency tree based on requested targets.\n\n    Use graphviz to render the dot file, e.g.:\n\n    > ybt dot :foo :bar | dot -Tpng -o graph.png\n    \"\"\"\n    build_context = BuildContext(conf)\n    populate_targets_graph(build_context, conf)\n    if conf.output_dot_file is None:\n        write_dot(build_context, conf, sys.stdout)\n    else:\n        with open(conf.output_dot_file, 'w') as out_file:\n            write_dot(build_context, conf, out_file)", "code_tokens": "def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "docstring_tokens": "Print out a neat targets dependency tree based on requested targets .", "label": 0}, {"idx": "cosqa-train-19322", "doc": "how to determine what a python function is called by", "code": "def get_caller_module():\n    \"\"\"\n    Returns the name of the caller's module as a string.\n\n    >>> get_caller_module()\n    '__main__'\n    \"\"\"\n    stack = inspect.stack()\n    assert len(stack) > 1\n    caller = stack[2][0]\n    return caller.f_globals['__name__']", "code_tokens": "def get_caller_module ( ) : stack = inspect . stack ( ) assert len ( stack ) > 1 caller = stack [ 2 ] [ 0 ] return caller . f_globals [ '__name__' ]", "docstring_tokens": "Returns the name of the caller s module as a string .", "label": 0}, {"idx": "cosqa-train-19323", "doc": "turn a list of lists into a single list python", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 0}, {"idx": "cosqa-train-19324", "doc": "get last index of a character in python", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-19325", "doc": "count of bins in python histogram", "code": "def shape(self) -> Tuple[int, ...]:\n        \"\"\"Shape of histogram's data.\n\n        Returns\n        -------\n        One-element tuple with the number of bins along each axis.\n        \"\"\"\n        return tuple(bins.bin_count for bins in self._binnings)", "code_tokens": "def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )", "docstring_tokens": "Shape of histogram s data .", "label": 1}, {"idx": "cosqa-train-19326", "doc": "iterate a specific number of times python", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 1}, {"idx": "cosqa-train-19327", "doc": "how to filter matrix values to zero in python", "code": "def negate_mask(mask):\n    \"\"\"Returns the negated mask.\n\n    If elements of input mask have 0 and non-zero values, then the returned matrix will have all elements 0 (1) where\n    the original one has non-zero (0).\n\n    :param mask: Input mask\n    :type mask: np.array\n    :return: array of same shape and dtype=int8 as input array\n    :rtype: np.array\n    \"\"\"\n    res = np.ones(mask.shape, dtype=np.int8)\n    res[mask > 0] = 0\n\n    return res", "code_tokens": "def negate_mask ( mask ) : res = np . ones ( mask . shape , dtype = np . int8 ) res [ mask > 0 ] = 0 return res", "docstring_tokens": "Returns the negated mask . If elements of input mask have 0 and non - zero values then the returned matrix will have all elements 0 ( 1 ) where the original one has non - zero ( 0 ) . : param mask : Input mask : type mask : np . array : return : array of same shape and dtype = int8 as input array : rtype : np . array", "label": 0}, {"idx": "cosqa-train-19328", "doc": "python datetime to iso string", "code": "def to_iso_string(self) -> str:\n        \"\"\" Returns full ISO string for the given date \"\"\"\n        assert isinstance(self.value, datetime)\n        return datetime.isoformat(self.value)", "code_tokens": "def to_iso_string ( self ) -> str : assert isinstance ( self . value , datetime ) return datetime . isoformat ( self . value )", "docstring_tokens": "Returns full ISO string for the given date", "label": 1}, {"idx": "cosqa-train-19329", "doc": "asyncio python another loop unit tests", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 1}, {"idx": "cosqa-train-19330", "doc": "python mid points for all xy pairs", "code": "def _mid(pt1, pt2):\n    \"\"\"\n    (Point, Point) -> Point\n    Return the point that lies in between the two input points.\n    \"\"\"\n    (x0, y0), (x1, y1) = pt1, pt2\n    return 0.5 * (x0 + x1), 0.5 * (y0 + y1)", "code_tokens": "def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "docstring_tokens": "( Point Point ) - > Point Return the point that lies in between the two input points .", "label": 1}, {"idx": "cosqa-train-19331", "doc": "python returns the indices of the top values", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 0}, {"idx": "cosqa-train-19332", "doc": "python mem cache multi process", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 0}, {"idx": "cosqa-train-19333", "doc": "python get 3 closest values", "code": "def closest_values(L):\n    \"\"\"Closest values\n\n    :param L: list of values\n    :returns: two values from L with minimal distance\n    :modifies: the order of L\n    :complexity: O(n log n), for n=len(L)\n    \"\"\"\n    assert len(L) >= 2\n    L.sort()\n    valmin, argmin = min((L[i] - L[i - 1], i) for i in range(1, len(L)))\n    return L[argmin - 1], L[argmin]", "code_tokens": "def closest_values ( L ) : assert len ( L ) >= 2 L . sort ( ) valmin , argmin = min ( ( L [ i ] - L [ i - 1 ] , i ) for i in range ( 1 , len ( L ) ) ) return L [ argmin - 1 ] , L [ argmin ]", "docstring_tokens": "Closest values", "label": 0}, {"idx": "cosqa-train-19334", "doc": "how to truncate to two decimals in python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 1}, {"idx": "cosqa-train-19335", "doc": "python check if a process is running or not", "code": "def is_running(process_id: int) -> bool:\n    \"\"\"\n    Uses the Unix ``ps`` program to see if a process is running.\n    \"\"\"\n    pstr = str(process_id)\n    encoding = sys.getdefaultencoding()\n    s = subprocess.Popen([\"ps\", \"-p\", pstr], stdout=subprocess.PIPE)\n    for line in s.stdout:\n        strline = line.decode(encoding)\n        if pstr in strline:\n            return True\n    return False", "code_tokens": "def is_running ( process_id : int ) -> bool : pstr = str ( process_id ) encoding = sys . getdefaultencoding ( ) s = subprocess . Popen ( [ \"ps\" , \"-p\" , pstr ] , stdout = subprocess . PIPE ) for line in s . stdout : strline = line . decode ( encoding ) if pstr in strline : return True return False", "docstring_tokens": "Uses the Unix ps program to see if a process is running .", "label": 1}, {"idx": "cosqa-train-19336", "doc": "concatenate nyumpy arrays python", "code": "def uconcatenate(arrs, axis=0):\n    \"\"\"Concatenate a sequence of arrays.\n\n    This wrapper around numpy.concatenate preserves units. All input arrays\n    must have the same units.  See the documentation of numpy.concatenate for\n    full details.\n\n    Examples\n    --------\n    >>> from unyt import cm\n    >>> A = [1, 2, 3]*cm\n    >>> B = [2, 3, 4]*cm\n    >>> uconcatenate((A, B))\n    unyt_array([1, 2, 3, 2, 3, 4], 'cm')\n\n    \"\"\"\n    v = np.concatenate(arrs, axis=axis)\n    v = _validate_numpy_wrapper_units(v, arrs)\n    return v", "code_tokens": "def uconcatenate ( arrs , axis = 0 ) : v = np . concatenate ( arrs , axis = axis ) v = _validate_numpy_wrapper_units ( v , arrs ) return v", "docstring_tokens": "Concatenate a sequence of arrays .", "label": 0}, {"idx": "cosqa-train-19337", "doc": "in python how to create code to exit", "code": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)", "code_tokens": "def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "docstring_tokens": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting", "label": 0}, {"idx": "cosqa-train-19338", "doc": "how to count duplicates in python list", "code": "def find_duplicates(l: list) -> set:\n    \"\"\"\n    Return the duplicates in a list.\n\n    The function relies on\n    https://stackoverflow.com/questions/9835762/find-and-list-duplicates-in-a-list .\n    Parameters\n    ----------\n    l : list\n        Name\n\n    Returns\n    -------\n    set\n        Duplicated values\n\n    >>> find_duplicates([1,2,3])\n    set()\n    >>> find_duplicates([1,2,1])\n    {1}\n    \"\"\"\n    return set([x for x in l if l.count(x) > 1])", "code_tokens": "def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "docstring_tokens": "Return the duplicates in a list .", "label": 0}, {"idx": "cosqa-train-19339", "doc": "8 bit uint unpack python", "code": "def read32(bytestream):\n  \"\"\"Read 4 bytes from bytestream as an unsigned 32-bit integer.\"\"\"\n  dt = np.dtype(np.uint32).newbyteorder('>')\n  return np.frombuffer(bytestream.read(4), dtype=dt)[0]", "code_tokens": "def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "docstring_tokens": "Read 4 bytes from bytestream as an unsigned 32 - bit integer .", "label": 0}, {"idx": "cosqa-train-19340", "doc": "python get hostname from url string", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 0}, {"idx": "cosqa-train-19341", "doc": "python capitalize title case", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-19342", "doc": "read csv into numpy array python", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 0}, {"idx": "cosqa-train-19343", "doc": "number of bins in python histogram", "code": "def shape(self) -> Tuple[int, ...]:\n        \"\"\"Shape of histogram's data.\n\n        Returns\n        -------\n        One-element tuple with the number of bins along each axis.\n        \"\"\"\n        return tuple(bins.bin_count for bins in self._binnings)", "code_tokens": "def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )", "docstring_tokens": "Shape of histogram s data .", "label": 1}, {"idx": "cosqa-train-19344", "doc": "python memoryview to structure", "code": "def memory_read(self, start_position: int, size: int) -> memoryview:\n        \"\"\"\n        Read and return a view of ``size`` bytes from memory starting at ``start_position``.\n        \"\"\"\n        return self._memory.read(start_position, size)", "code_tokens": "def memory_read ( self , start_position : int , size : int ) -> memoryview : return self . _memory . read ( start_position , size )", "docstring_tokens": "Read and return a view of size bytes from memory starting at start_position .", "label": 1}, {"idx": "cosqa-train-19345", "doc": "how to check for empty file python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 1}, {"idx": "cosqa-train-19346", "doc": "finding the max depth of list python", "code": "def list_depth(list_, func=max, _depth=0):\n    \"\"\"\n    Returns the deepest level of nesting within a list of lists\n\n    Args:\n       list_  : a nested listlike object\n       func   : depth aggregation strategy (defaults to max)\n       _depth : internal var\n\n    Example:\n        >>> # ENABLE_DOCTEST\n        >>> from utool.util_list import *  # NOQA\n        >>> list_ = [[[[[1]]], [3]], [[1], [3]], [[1], [3]]]\n        >>> result = (list_depth(list_, _depth=0))\n        >>> print(result)\n\n    \"\"\"\n    depth_list = [list_depth(item, func=func, _depth=_depth + 1)\n                  for item in  list_ if util_type.is_listlike(item)]\n    if len(depth_list) > 0:\n        return func(depth_list)\n    else:\n        return _depth", "code_tokens": "def list_depth ( list_ , func = max , _depth = 0 ) : depth_list = [ list_depth ( item , func = func , _depth = _depth + 1 ) for item in list_ if util_type . is_listlike ( item ) ] if len ( depth_list ) > 0 : return func ( depth_list ) else : return _depth", "docstring_tokens": "Returns the deepest level of nesting within a list of lists", "label": 1}, {"idx": "cosqa-train-19347", "doc": "python test if string is an int", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 0}, {"idx": "cosqa-train-19348", "doc": "check if a set is empty in python", "code": "def is_any_type_set(sett: Set[Type]) -> bool:\n    \"\"\"\n    Helper method to check if a set of types is the {AnyObject} singleton\n\n    :param sett:\n    :return:\n    \"\"\"\n    return len(sett) == 1 and is_any_type(min(sett))", "code_tokens": "def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )", "docstring_tokens": "Helper method to check if a set of types is the { AnyObject } singleton", "label": 1}, {"idx": "cosqa-train-19349", "doc": "python csv to np array", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 1}, {"idx": "cosqa-train-19350", "doc": "stop running function and passing to other variable python", "code": "def stop(self) -> None:\n        \"\"\"Stops the analysis as soon as possible.\"\"\"\n        if self._stop and not self._posted_kork:\n            self._stop()\n            self._stop = None", "code_tokens": "def stop ( self ) -> None : if self . _stop and not self . _posted_kork : self . _stop ( ) self . _stop = None", "docstring_tokens": "Stops the analysis as soon as possible .", "label": 1}, {"idx": "cosqa-train-19351", "doc": "round to the nearest in python", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 1}, {"idx": "cosqa-train-19352", "doc": "python hash return int number", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 1}, {"idx": "cosqa-train-19353", "doc": "how to tell if a string holds a whitespace in python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 0}, {"idx": "cosqa-train-19354", "doc": "how to round to the nearest ten in python", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 0}, {"idx": "cosqa-train-19355", "doc": "get dtypes of columns python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 0}, {"idx": "cosqa-train-19356", "doc": "python 3 executemany many columns", "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None:\n        \"\"\"Execute the given multiquery.\"\"\"\n        await self._execute(self._cursor.executemany, sql, parameters)", "code_tokens": "async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "docstring_tokens": "Execute the given multiquery .", "label": 1}, {"idx": "cosqa-train-19357", "doc": "python urlparse get domain", "code": "def get_domain(url):\n    \"\"\"\n    Get domain part of an url.\n\n    For example: https://www.python.org/doc/ -> https://www.python.org\n    \"\"\"\n    parse_result = urlparse(url)\n    domain = \"{schema}://{netloc}\".format(\n        schema=parse_result.scheme, netloc=parse_result.netloc)\n    return domain", "code_tokens": "def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "docstring_tokens": "Get domain part of an url .", "label": 1}, {"idx": "cosqa-train-19358", "doc": "python pattern pluralize word", "code": "def pluralize(word):\n    \"\"\"\n    Return the plural form of a word.\n\n    Examples::\n\n        >>> pluralize(\"post\")\n        \"posts\"\n        >>> pluralize(\"octopus\")\n        \"octopi\"\n        >>> pluralize(\"sheep\")\n        \"sheep\"\n        >>> pluralize(\"CamelOctopus\")\n        \"CamelOctopi\"\n\n    \"\"\"\n    if not word or word.lower() in UNCOUNTABLES:\n        return word\n    else:\n        for rule, replacement in PLURALS:\n            if re.search(rule, word):\n                return re.sub(rule, replacement, word)\n        return word", "code_tokens": "def pluralize ( word ) : if not word or word . lower ( ) in UNCOUNTABLES : return word else : for rule , replacement in PLURALS : if re . search ( rule , word ) : return re . sub ( rule , replacement , word ) return word", "docstring_tokens": "Return the plural form of a word .", "label": 0}, {"idx": "cosqa-train-19359", "doc": "python call built in function using its string name", "code": "def method_caller(method_name, *args, **kwargs):\n\t\"\"\"\n\tReturn a function that will call a named method on the\n\ttarget object with optional positional and keyword\n\targuments.\n\n\t>>> lower = method_caller('lower')\n\t>>> lower('MyString')\n\t'mystring'\n\t\"\"\"\n\tdef call_method(target):\n\t\tfunc = getattr(target, method_name)\n\t\treturn func(*args, **kwargs)\n\treturn call_method", "code_tokens": "def method_caller ( method_name , * args , * * kwargs ) : def call_method ( target ) : func = getattr ( target , method_name ) return func ( * args , * * kwargs ) return call_method", "docstring_tokens": "Return a function that will call a named method on the target object with optional positional and keyword arguments .", "label": 1}, {"idx": "cosqa-train-19360", "doc": "python future asyncio multiple tbreads", "code": "async def parallel_results(future_map: Sequence[Tuple]) -> Dict:\n    \"\"\"\n    Run parallel execution of futures and return mapping of their results to the provided keys.\n    Just a neat shortcut around ``asyncio.gather()``\n\n    :param future_map: Keys to futures mapping, e.g.: ( ('nav', get_nav()), ('content, get_content()) )\n    :return: Dict with futures results mapped to keys {'nav': {1:2}, 'content': 'xyz'}\n    \"\"\"\n    ctx_methods = OrderedDict(future_map)\n    fs = list(ctx_methods.values())\n    results = await asyncio.gather(*fs)\n    results = {\n        key: results[idx] for idx, key in enumerate(ctx_methods.keys())\n    }\n    return results", "code_tokens": "async def parallel_results ( future_map : Sequence [ Tuple ] ) -> Dict : ctx_methods = OrderedDict ( future_map ) fs = list ( ctx_methods . values ( ) ) results = await asyncio . gather ( * fs ) results = { key : results [ idx ] for idx , key in enumerate ( ctx_methods . keys ( ) ) } return results", "docstring_tokens": "Run parallel execution of futures and return mapping of their results to the provided keys . Just a neat shortcut around asyncio . gather ()", "label": 0}, {"idx": "cosqa-train-19361", "doc": "how to cast a float as an int in python", "code": "def positive_int(val):\n    \"\"\"Parse `val` into a positive integer.\"\"\"\n    if isinstance(val, float):\n        raise ValueError('\"{}\" must not be a float'.format(val))\n    val = int(val)\n    if val >= 0:\n        return val\n    raise ValueError('\"{}\" must be positive'.format(val))", "code_tokens": "def positive_int ( val ) : if isinstance ( val , float ) : raise ValueError ( '\"{}\" must not be a float' . format ( val ) ) val = int ( val ) if val >= 0 : return val raise ValueError ( '\"{}\" must be positive' . format ( val ) )", "docstring_tokens": "Parse val into a positive integer .", "label": 1}, {"idx": "cosqa-train-19362", "doc": "python determine if string is all alpha", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-19363", "doc": "python list git branches", "code": "def branches():\n    # type: () -> List[str]\n    \"\"\" Return a list of branches in the current repo.\n\n    Returns:\n        list[str]: A list of branches in the current repo.\n    \"\"\"\n    out = shell.run(\n        'git branch',\n        capture=True,\n        never_pretend=True\n    ).stdout.strip()\n    return [x.strip('* \\t\\n') for x in out.splitlines()]", "code_tokens": "def branches ( ) : # type: () -> List[str] out = shell . run ( 'git branch' , capture = True , never_pretend = True ) . stdout . strip ( ) return [ x . strip ( '* \\t\\n' ) for x in out . splitlines ( ) ]", "docstring_tokens": "Return a list of branches in the current repo .", "label": 1}, {"idx": "cosqa-train-19364", "doc": "python how to select first 100 rows", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 1}, {"idx": "cosqa-train-19365", "doc": "sql like % in python", "code": "def execute(cur, *args):\n    \"\"\"Utility function to print sqlite queries before executing.\n\n    Use instead of cur.execute().  First argument is cursor.\n\n    cur.execute(stmt)\n    becomes\n    util.execute(cur, stmt)\n    \"\"\"\n    stmt = args[0]\n    if len(args) > 1:\n        stmt = stmt.replace('%', '%%').replace('?', '%r')\n        print(stmt % (args[1]))\n    return cur.execute(*args)", "code_tokens": "def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )", "docstring_tokens": "Utility function to print sqlite queries before executing .", "label": 0}, {"idx": "cosqa-train-19366", "doc": "calculate the area under a curve python", "code": "def signed_area(coords):\n    \"\"\"Return the signed area enclosed by a ring using the linear time\n    algorithm. A value >= 0 indicates a counter-clockwise oriented ring.\n    \"\"\"\n    xs, ys = map(list, zip(*coords))\n    xs.append(xs[1])\n    ys.append(ys[1])\n    return sum(xs[i]*(ys[i+1]-ys[i-1]) for i in range(1, len(coords)))/2.0", "code_tokens": "def signed_area ( coords ) : xs , ys = map ( list , zip ( * coords ) ) xs . append ( xs [ 1 ] ) ys . append ( ys [ 1 ] ) return sum ( xs [ i ] * ( ys [ i + 1 ] - ys [ i - 1 ] ) for i in range ( 1 , len ( coords ) ) ) / 2.0", "docstring_tokens": "Return the signed area enclosed by a ring using the linear time algorithm . A value > = 0 indicates a counter - clockwise oriented ring .", "label": 0}, {"idx": "cosqa-train-19367", "doc": "how to check a file is empty in python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 1}, {"idx": "cosqa-train-19368", "doc": "python keras fit method checkpoints", "code": "def classify_fit(fqdn, result, *argl, **argd):\n    \"\"\"Analyzes the result of a classification algorithm's fitting. See also\n    :func:`fit` for explanation of arguments.\n    \"\"\"\n    if len(argl) > 2:\n        #Usually fit is called with fit(machine, Xtrain, ytrain).\n        yP = argl[2]\n    out = _generic_fit(fqdn, result, classify_predict, yP, *argl, **argd)\n    return out", "code_tokens": "def classify_fit ( fqdn , result , * argl , * * argd ) : if len ( argl ) > 2 : #Usually fit is called with fit(machine, Xtrain, ytrain). yP = argl [ 2 ] out = _generic_fit ( fqdn , result , classify_predict , yP , * argl , * * argd ) return out", "docstring_tokens": "Analyzes the result of a classification algorithm s fitting . See also : func : fit for explanation of arguments .", "label": 0}, {"idx": "cosqa-train-19369", "doc": "python how to detect english words", "code": "def thai_to_eng(text: str) -> str:\n    \"\"\"\n    Correct text in one language that is incorrectly-typed with a keyboard layout in another language. (type Thai with English keyboard)\n\n    :param str text: Incorrect input (type English with Thai keyboard)\n    :return: English text\n    \"\"\"\n    return \"\".join(\n        [TH_EN_KEYB_PAIRS[ch] if (ch in TH_EN_KEYB_PAIRS) else ch for ch in text]\n    )", "code_tokens": "def thai_to_eng ( text : str ) -> str : return \"\" . join ( [ TH_EN_KEYB_PAIRS [ ch ] if ( ch in TH_EN_KEYB_PAIRS ) else ch for ch in text ] )", "docstring_tokens": "Correct text in one language that is incorrectly - typed with a keyboard layout in another language . ( type Thai with English keyboard )", "label": 1}, {"idx": "cosqa-train-19370", "doc": "how to receive the path of a file as a user input on python", "code": "def file_or_stdin() -> Callable:\n    \"\"\"\n    Returns a file descriptor from stdin or opening a file from a given path.\n    \"\"\"\n\n    def parse(path):\n        if path is None or path == \"-\":\n            return sys.stdin\n        else:\n            return data_io.smart_open(path)\n\n    return parse", "code_tokens": "def file_or_stdin ( ) -> Callable : def parse ( path ) : if path is None or path == \"-\" : return sys . stdin else : return data_io . smart_open ( path ) return parse", "docstring_tokens": "Returns a file descriptor from stdin or opening a file from a given path .", "label": 0}, {"idx": "cosqa-train-19371", "doc": "python str to dateal time", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 1}, {"idx": "cosqa-train-19372", "doc": "python async run in", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 1}, {"idx": "cosqa-train-19373", "doc": "check if a file with certain extension exist in python", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 0}, {"idx": "cosqa-train-19374", "doc": "python determine if path is relative or abso", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 0}, {"idx": "cosqa-train-19375", "doc": "python most frequent element in list", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 1}, {"idx": "cosqa-train-19376", "doc": "create sphere through data points in python", "code": "def arcball_map_to_sphere(point, center, radius):\n    \"\"\"Return unit sphere coordinates from window coordinates.\"\"\"\n    v0 = (point[0] - center[0]) / radius\n    v1 = (center[1] - point[1]) / radius\n    n = v0*v0 + v1*v1\n    if n > 1.0:\n        # position outside of sphere\n        n = math.sqrt(n)\n        return numpy.array([v0/n, v1/n, 0.0])\n    else:\n        return numpy.array([v0, v1, math.sqrt(1.0 - n)])", "code_tokens": "def arcball_map_to_sphere ( point , center , radius ) : v0 = ( point [ 0 ] - center [ 0 ] ) / radius v1 = ( center [ 1 ] - point [ 1 ] ) / radius n = v0 * v0 + v1 * v1 if n > 1.0 : # position outside of sphere n = math . sqrt ( n ) return numpy . array ( [ v0 / n , v1 / n , 0.0 ] ) else : return numpy . array ( [ v0 , v1 , math . sqrt ( 1.0 - n ) ] )", "docstring_tokens": "Return unit sphere coordinates from window coordinates .", "label": 1}, {"idx": "cosqa-train-19377", "doc": "python hash a int value", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 0}, {"idx": "cosqa-train-19378", "doc": "python using greater than with strings", "code": "def __gt__(self, other):\n        \"\"\"Test for greater than.\"\"\"\n        if isinstance(other, Address):\n            return str(self) > str(other)\n        raise TypeError", "code_tokens": "def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError", "docstring_tokens": "Test for greater than .", "label": 0}, {"idx": "cosqa-train-19379", "doc": "flatten a list of lists in python irregular simple", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 1}, {"idx": "cosqa-train-19380", "doc": "python3 apply function to each list element", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-19381", "doc": "how to delete an element in a python dictionary", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-19382", "doc": "python readlines skip blank lines", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-19383", "doc": "show tensor shape python", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 0}, {"idx": "cosqa-train-19384", "doc": "make string all uppercase python", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-19385", "doc": "can you cast a python list to a bytearray", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 0}, {"idx": "cosqa-train-19386", "doc": "truncate float two decimals python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 1}, {"idx": "cosqa-train-19387", "doc": "delete an element from a dictionary python", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-19388", "doc": "python list comprehension flatten", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 1}, {"idx": "cosqa-train-19389", "doc": "how to remove first line from legend matplotlib python", "code": "def impose_legend_limit(limit=30, axes=\"gca\", **kwargs):\n    \"\"\"\n    This will erase all but, say, 30 of the legend entries and remake the legend.\n    You'll probably have to move it back into your favorite position at this point.\n    \"\"\"\n    if axes==\"gca\": axes = _pylab.gca()\n\n    # make these axes current\n    _pylab.axes(axes)\n\n    # loop over all the lines_pylab.\n    for n in range(0,len(axes.lines)):\n        if n >  limit-1 and not n==len(axes.lines)-1: axes.lines[n].set_label(\"_nolegend_\")\n        if n == limit-1 and not n==len(axes.lines)-1: axes.lines[n].set_label(\"...\")\n\n    _pylab.legend(**kwargs)", "code_tokens": "def impose_legend_limit ( limit = 30 , axes = \"gca\" , * * kwargs ) : if axes == \"gca\" : axes = _pylab . gca ( ) # make these axes current _pylab . axes ( axes ) # loop over all the lines_pylab. for n in range ( 0 , len ( axes . lines ) ) : if n > limit - 1 and not n == len ( axes . lines ) - 1 : axes . lines [ n ] . set_label ( \"_nolegend_\" ) if n == limit - 1 and not n == len ( axes . lines ) - 1 : axes . lines [ n ] . set_label ( \"...\" ) _pylab . legend ( * * kwargs )", "docstring_tokens": "This will erase all but say 30 of the legend entries and remake the legend . You ll probably have to move it back into your favorite position at this point .", "label": 0}, {"idx": "cosqa-train-19390", "doc": "python argparse script docstring", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 1}, {"idx": "cosqa-train-19391", "doc": "python parse http status line, header line", "code": "def header_status(header):\n    \"\"\"Parse HTTP status line, return status (int) and reason.\"\"\"\n    status_line = header[:header.find('\\r')]\n    # 'HTTP/1.1 200 OK' -> (200, 'OK')\n    fields = status_line.split(None, 2)\n    return int(fields[1]), fields[2]", "code_tokens": "def header_status ( header ) : status_line = header [ : header . find ( '\\r' ) ] # 'HTTP/1.1 200 OK' -> (200, 'OK') fields = status_line . split ( None , 2 ) return int ( fields [ 1 ] ) , fields [ 2 ]", "docstring_tokens": "Parse HTTP status line return status ( int ) and reason .", "label": 0}, {"idx": "cosqa-train-19392", "doc": "python 3 lambda map", "code": "def mmap(func, iterable):\n    \"\"\"Wrapper to make map() behave the same on Py2 and Py3.\"\"\"\n\n    if sys.version_info[0] > 2:\n        return [i for i in map(func, iterable)]\n    else:\n        return map(func, iterable)", "code_tokens": "def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "docstring_tokens": "Wrapper to make map () behave the same on Py2 and Py3 .", "label": 0}, {"idx": "cosqa-train-19393", "doc": "how does underscore hide in python", "code": "def lower_camel_case_from_underscores(string):\n    \"\"\"generate a lower-cased camelCase string from an underscore_string.\n    For example: my_variable_name -> myVariableName\"\"\"\n    components = string.split('_')\n    string = components[0]\n    for component in components[1:]:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName", "label": 1}, {"idx": "cosqa-train-19394", "doc": "python top n elements of sorted dictionary", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 0}, {"idx": "cosqa-train-19395", "doc": "python2 python3 bytes strings", "code": "def strtobytes(input, encoding):\n    \"\"\"Take a str and transform it into a byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _strtobytes_py3(input, encoding)\n    return _strtobytes_py2(input, encoding)", "code_tokens": "def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "docstring_tokens": "Take a str and transform it into a byte array .", "label": 1}, {"idx": "cosqa-train-19396", "doc": "subtract months from date python\\", "code": "def months_ago(date, nb_months=1):\n    \"\"\"\n    Return the given `date` with `nb_months` substracted from it.\n    \"\"\"\n    nb_years = nb_months // 12\n    nb_months = nb_months % 12\n\n    month_diff = date.month - nb_months\n\n    if month_diff > 0:\n        new_month = month_diff\n    else:\n        new_month = 12 + month_diff\n        nb_years += 1\n\n    return date.replace(day=1, month=new_month, year=date.year - nb_years)", "code_tokens": "def months_ago ( date , nb_months = 1 ) : nb_years = nb_months // 12 nb_months = nb_months % 12 month_diff = date . month - nb_months if month_diff > 0 : new_month = month_diff else : new_month = 12 + month_diff nb_years += 1 return date . replace ( day = 1 , month = new_month , year = date . year - nb_years )", "docstring_tokens": "Return the given date with nb_months substracted from it .", "label": 1}, {"idx": "cosqa-train-19397", "doc": "graph viz python dot executable", "code": "def cmd_dot(conf: Config):\n    \"\"\"Print out a neat targets dependency tree based on requested targets.\n\n    Use graphviz to render the dot file, e.g.:\n\n    > ybt dot :foo :bar | dot -Tpng -o graph.png\n    \"\"\"\n    build_context = BuildContext(conf)\n    populate_targets_graph(build_context, conf)\n    if conf.output_dot_file is None:\n        write_dot(build_context, conf, sys.stdout)\n    else:\n        with open(conf.output_dot_file, 'w') as out_file:\n            write_dot(build_context, conf, out_file)", "code_tokens": "def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "docstring_tokens": "Print out a neat targets dependency tree based on requested targets .", "label": 1}, {"idx": "cosqa-train-19398", "doc": "how to multiply every value in a list by a constant python", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 1}, {"idx": "cosqa-train-19399", "doc": "python readline skip blank line", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-19400", "doc": "how to get mimetype of a file in python", "code": "def guess_mimetype(filename):\n    \"\"\"Guesses the mimetype of a file based on the given ``filename``.\n\n    .. code-block:: python\n\n        >>> guess_mimetype('example.txt')\n        'text/plain'\n        >>> guess_mimetype('/foo/bar/example')\n        'application/octet-stream'\n\n    Parameters\n    ----------\n    filename : str\n        The file name or path for which the mimetype is to be guessed\n    \"\"\"\n    fn = os.path.basename(filename)\n    return mimetypes.guess_type(fn)[0] or 'application/octet-stream'", "code_tokens": "def guess_mimetype ( filename ) : fn = os . path . basename ( filename ) return mimetypes . guess_type ( fn ) [ 0 ] or 'application/octet-stream'", "docstring_tokens": "Guesses the mimetype of a file based on the given filename .", "label": 0}, {"idx": "cosqa-train-19401", "doc": "python is not float", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 0}, {"idx": "cosqa-train-19402", "doc": "python return top n elements", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 0}, {"idx": "cosqa-train-19403", "doc": "how to check if a key as been created in python", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 0}, {"idx": "cosqa-train-19404", "doc": "how to rotate elements of a list left python", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 1}, {"idx": "cosqa-train-19405", "doc": "python remove key from dictionary if exists", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-19406", "doc": "get column type data frame python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-19407", "doc": "how will you check in a string that all characters are alphanumeric python", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 0}, {"idx": "cosqa-train-19408", "doc": "how to rotate a list n times in python", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 0}, {"idx": "cosqa-train-19409", "doc": "traverse all but the last item in a list in python", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 1}, {"idx": "cosqa-train-19410", "doc": "replace a pattern with single slash in python", "code": "def normalize_pattern(pattern):\n    \"\"\"Converts backslashes in path patterns to forward slashes.\n\n    Doesn't normalize regular expressions - they may contain escapes.\n    \"\"\"\n    if not (pattern.startswith('RE:') or pattern.startswith('!RE:')):\n        pattern = _slashes.sub('/', pattern)\n    if len(pattern) > 1:\n        pattern = pattern.rstrip('/')\n    return pattern", "code_tokens": "def normalize_pattern ( pattern ) : if not ( pattern . startswith ( 'RE:' ) or pattern . startswith ( '!RE:' ) ) : pattern = _slashes . sub ( '/' , pattern ) if len ( pattern ) > 1 : pattern = pattern . rstrip ( '/' ) return pattern", "docstring_tokens": "Converts backslashes in path patterns to forward slashes .", "label": 1}, {"idx": "cosqa-train-19411", "doc": "uniques values of alist in python", "code": "def uniqued(iterable):\n    \"\"\"Return unique list of ``iterable`` items preserving order.\n\n    >>> uniqued('spameggs')\n    ['s', 'p', 'a', 'm', 'e', 'g']\n    \"\"\"\n    seen = set()\n    return [item for item in iterable if item not in seen and not seen.add(item)]", "code_tokens": "def uniqued ( iterable ) : seen = set ( ) return [ item for item in iterable if item not in seen and not seen . add ( item ) ]", "docstring_tokens": "Return unique list of iterable items preserving order .", "label": 0}, {"idx": "cosqa-train-19412", "doc": "reading json from file python", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 1}, {"idx": "cosqa-train-19413", "doc": "how to remove columns in a data frame in python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 0}, {"idx": "cosqa-train-19414", "doc": "python method for reading keypress? in linux", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 1}, {"idx": "cosqa-train-19415", "doc": "python round up to the nearest", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 0}, {"idx": "cosqa-train-19416", "doc": "python string to json string", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 0}, {"idx": "cosqa-train-19417", "doc": "panda python string to date time", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 0}, {"idx": "cosqa-train-19418", "doc": "scala fold equivalent in python", "code": "def _collection_literal_to_py_ast(\n    ctx: GeneratorContext, form: Iterable[LispForm]\n) -> Iterable[GeneratedPyAST]:\n    \"\"\"Turn a quoted collection literal of Lisp forms into Python AST nodes.\n\n    This function can only handle constant values. It does not call back into\n    the generic AST generators, so only constant values will be generated down\n    this path.\"\"\"\n    yield from map(partial(_const_val_to_py_ast, ctx), form)", "code_tokens": "def _collection_literal_to_py_ast ( ctx : GeneratorContext , form : Iterable [ LispForm ] ) -> Iterable [ GeneratedPyAST ] : yield from map ( partial ( _const_val_to_py_ast , ctx ) , form )", "docstring_tokens": "Turn a quoted collection literal of Lisp forms into Python AST nodes .", "label": 0}, {"idx": "cosqa-train-19419", "doc": "python function nested list to list", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 0}, {"idx": "cosqa-train-19420", "doc": "how to delete an entry in a dictionary python", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 0}, {"idx": "cosqa-train-19421", "doc": "how to see if a path is valid in python", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 0}, {"idx": "cosqa-train-19422", "doc": "intersecting of two nonlinear lines python", "code": "def segment_intersection(start0, end0, start1, end1):\n    r\"\"\"Determine the intersection of two line segments.\n\n    Assumes each line is parametric\n\n    .. math::\n\n       \\begin{alignat*}{2}\n        L_0(s) &= S_0 (1 - s) + E_0 s &&= S_0 + s \\Delta_0 \\\\\n        L_1(t) &= S_1 (1 - t) + E_1 t &&= S_1 + t \\Delta_1.\n       \\end{alignat*}\n\n    To solve :math:`S_0 + s \\Delta_0 = S_1 + t \\Delta_1`, we use the\n    cross product:\n\n    .. math::\n\n       \\left(S_0 + s \\Delta_0\\right) \\times \\Delta_1 =\n           \\left(S_1 + t \\Delta_1\\right) \\times \\Delta_1 \\Longrightarrow\n       s \\left(\\Delta_0 \\times \\Delta_1\\right) =\n           \\left(S_1 - S_0\\right) \\times \\Delta_1.\n\n    Similarly\n\n    .. math::\n\n       \\Delta_0 \\times \\left(S_0 + s \\Delta_0\\right) =\n           \\Delta_0 \\times \\left(S_1 + t \\Delta_1\\right) \\Longrightarrow\n       \\left(S_1 - S_0\\right) \\times \\Delta_0 =\n           \\Delta_0 \\times \\left(S_0 - S_1\\right) =\n           t \\left(\\Delta_0 \\times \\Delta_1\\right).\n\n    .. note::\n\n       Since our points are in :math:`\\mathbf{R}^2`, the \"traditional\"\n       cross product in :math:`\\mathbf{R}^3` will always point in the\n       :math:`z` direction, so in the above we mean the :math:`z`\n       component of the cross product, rather than the entire vector.\n\n    For example, the diagonal lines\n\n    .. math::\n\n       \\begin{align*}\n        L_0(s) &= \\left[\\begin{array}{c} 0 \\\\ 0 \\end{array}\\right] (1 - s) +\n                  \\left[\\begin{array}{c} 2 \\\\ 2 \\end{array}\\right] s \\\\\n        L_1(t) &= \\left[\\begin{array}{c} -1 \\\\ 2 \\end{array}\\right] (1 - t) +\n                  \\left[\\begin{array}{c} 1 \\\\ 0 \\end{array}\\right] t\n       \\end{align*}\n\n    intersect at :math:`L_0\\left(\\frac{1}{4}\\right) =\n    L_1\\left(\\frac{3}{4}\\right) =\n    \\frac{1}{2} \\left[\\begin{array}{c} 1 \\\\ 1 \\end{array}\\right]`.\n\n    .. image:: ../images/segment_intersection1.png\n       :align: center\n\n    .. testsetup:: segment-intersection1, segment-intersection2\n\n       import numpy as np\n       from bezier._geometric_intersection import segment_intersection\n\n    .. doctest:: segment-intersection1\n       :options: +NORMALIZE_WHITESPACE\n\n       >>> start0 = np.asfortranarray([0.0, 0.0])\n       >>> end0 = np.asfortranarray([2.0, 2.0])\n       >>> start1 = np.asfortranarray([-1.0, 2.0])\n       >>> end1 = np.asfortranarray([1.0, 0.0])\n       >>> s, t, _ = segment_intersection(start0, end0, start1, end1)\n       >>> s\n       0.25\n       >>> t\n       0.75\n\n    .. testcleanup:: segment-intersection1\n\n       import make_images\n       make_images.segment_intersection1(start0, end0, start1, end1, s)\n\n    Taking the parallel (but different) lines\n\n    .. math::\n\n       \\begin{align*}\n        L_0(s) &= \\left[\\begin{array}{c} 1 \\\\ 0 \\end{array}\\right] (1 - s) +\n                  \\left[\\begin{array}{c} 0 \\\\ 1 \\end{array}\\right] s \\\\\n        L_1(t) &= \\left[\\begin{array}{c} -1 \\\\ 3 \\end{array}\\right] (1 - t) +\n                  \\left[\\begin{array}{c} 3 \\\\ -1 \\end{array}\\right] t\n       \\end{align*}\n\n    we should be able to determine that the lines don't intersect, but\n    this function is not meant for that check:\n\n    .. image:: ../images/segment_intersection2.png\n       :align: center\n\n    .. doctest:: segment-intersection2\n       :options: +NORMALIZE_WHITESPACE\n\n       >>> start0 = np.asfortranarray([1.0, 0.0])\n       >>> end0 = np.asfortranarray([0.0, 1.0])\n       >>> start1 = np.asfortranarray([-1.0, 3.0])\n       >>> end1 = np.asfortranarray([3.0, -1.0])\n       >>> _, _, success = segment_intersection(start0, end0, start1, end1)\n       >>> success\n       False\n\n    .. testcleanup:: segment-intersection2\n\n       import make_images\n       make_images.segment_intersection2(start0, end0, start1, end1)\n\n    Instead, we use :func:`parallel_lines_parameters`:\n\n    .. testsetup:: segment-intersection2-continued\n\n       import numpy as np\n       from bezier._geometric_intersection import parallel_lines_parameters\n\n       start0 = np.asfortranarray([1.0, 0.0])\n       end0 = np.asfortranarray([0.0, 1.0])\n       start1 = np.asfortranarray([-1.0, 3.0])\n       end1 = np.asfortranarray([3.0, -1.0])\n\n    .. doctest:: segment-intersection2-continued\n\n       >>> disjoint, _ = parallel_lines_parameters(start0, end0, start1, end1)\n       >>> disjoint\n       True\n\n    .. note::\n\n       There is also a Fortran implementation of this function, which\n       will be used if it can be built.\n\n    Args:\n        start0 (numpy.ndarray): A 1D NumPy ``2``-array that is the start\n            vector :math:`S_0` of the parametric line :math:`L_0(s)`.\n        end0 (numpy.ndarray): A 1D NumPy ``2``-array that is the end\n            vector :math:`E_0` of the parametric line :math:`L_0(s)`.\n        start1 (numpy.ndarray): A 1D NumPy ``2``-array that is the start\n            vector :math:`S_1` of the parametric line :math:`L_1(s)`.\n        end1 (numpy.ndarray): A 1D NumPy ``2``-array that is the end\n            vector :math:`E_1` of the parametric line :math:`L_1(s)`.\n\n    Returns:\n        Tuple[float, float, bool]: Pair of :math:`s_{\\ast}` and\n        :math:`t_{\\ast}` such that the lines intersect:\n        :math:`L_0\\left(s_{\\ast}\\right) = L_1\\left(t_{\\ast}\\right)` and then\n        a boolean indicating if an intersection was found (i.e. if the lines\n        aren't parallel).\n    \"\"\"\n    delta0 = end0 - start0\n    delta1 = end1 - start1\n    cross_d0_d1 = _helpers.cross_product(delta0, delta1)\n    if cross_d0_d1 == 0.0:\n        return None, None, False\n\n    else:\n        start_delta = start1 - start0\n        s = _helpers.cross_product(start_delta, delta1) / cross_d0_d1\n        t = _helpers.cross_product(start_delta, delta0) / cross_d0_d1\n        return s, t, True", "code_tokens": "def segment_intersection ( start0 , end0 , start1 , end1 ) : delta0 = end0 - start0 delta1 = end1 - start1 cross_d0_d1 = _helpers . cross_product ( delta0 , delta1 ) if cross_d0_d1 == 0.0 : return None , None , False else : start_delta = start1 - start0 s = _helpers . cross_product ( start_delta , delta1 ) / cross_d0_d1 t = _helpers . cross_product ( start_delta , delta0 ) / cross_d0_d1 return s , t , True", "docstring_tokens": "r Determine the intersection of two line segments .", "label": 1}, {"idx": "cosqa-train-19423", "doc": "python determine if any values in an array meet a condition", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 0}, {"idx": "cosqa-train-19424", "doc": "how to turn a date number in python into a date", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 1}, {"idx": "cosqa-train-19425", "doc": "python hash table check if key exist", "code": "def check_key(self, key: str) -> bool:\n        \"\"\"\n        Checks if key exists in datastore. True if yes, False if no.\n\n        :param: SHA512 hash key\n\n        :return: whether or key not exists in datastore\n        \"\"\"\n        keys = self.get_keys()\n        return key in keys", "code_tokens": "def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "docstring_tokens": "Checks if key exists in datastore . True if yes False if no .", "label": 1}, {"idx": "cosqa-train-19426", "doc": "python opencv getgaussian kernel", "code": "def kernel(self, spread=1):\n        \"\"\" This will return whatever kind of kernel we want to use.\n            Must have signature (ndarray size NxM, ndarray size 1xM) -> ndarray size Nx1\n        \"\"\"\n        # TODO: use self.kernel_type to choose function\n\n        def gaussian(data, pixel):\n            return mvn.pdf(data, mean=pixel, cov=spread)\n\n        return gaussian", "code_tokens": "def kernel ( self , spread = 1 ) : # TODO: use self.kernel_type to choose function def gaussian ( data , pixel ) : return mvn . pdf ( data , mean = pixel , cov = spread ) return gaussian", "docstring_tokens": "This will return whatever kind of kernel we want to use . Must have signature ( ndarray size NxM ndarray size 1xM ) - > ndarray size Nx1", "label": 0}, {"idx": "cosqa-train-19427", "doc": "check the datatype fo a column python", "code": "def is_sqlatype_string(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type a string type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.String)", "code_tokens": "def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "docstring_tokens": "Is the SQLAlchemy column type a string type?", "label": 0}, {"idx": "cosqa-train-19428", "doc": "how to read a stream in python", "code": "def decode_value(stream):\n    \"\"\"Decode the contents of a value from a serialized stream.\n\n    :param stream: Source data stream\n    :type stream: io.BytesIO\n    :returns: Decoded value\n    :rtype: bytes\n    \"\"\"\n    length = decode_length(stream)\n    (value,) = unpack_value(\">{:d}s\".format(length), stream)\n    return value", "code_tokens": "def decode_value ( stream ) : length = decode_length ( stream ) ( value , ) = unpack_value ( \">{:d}s\" . format ( length ) , stream ) return value", "docstring_tokens": "Decode the contents of a value from a serialized stream .", "label": 0}, {"idx": "cosqa-train-19429", "doc": "python check if two nodes are connected in a graph", "code": "def is_intersection(g, n):\n    \"\"\"\n    Determine if a node is an intersection\n\n    graph: 1 -->-- 2 -->-- 3\n\n    >>> is_intersection(g, 2)\n    False\n\n    graph:\n     1 -- 2 -- 3\n          |\n          4\n\n    >>> is_intersection(g, 2)\n    True\n\n    Parameters\n    ----------\n    g : networkx DiGraph\n    n : node id\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n    return len(set(g.predecessors(n) + g.successors(n))) > 2", "code_tokens": "def is_intersection ( g , n ) : return len ( set ( g . predecessors ( n ) + g . successors ( n ) ) ) > 2", "docstring_tokens": "Determine if a node is an intersection", "label": 0}, {"idx": "cosqa-train-19430", "doc": "how to check the presence of nan values in python", "code": "def warn_if_nans_exist(X):\n    \"\"\"Warn if nans exist in a numpy array.\"\"\"\n    null_count = count_rows_with_nans(X)\n    total = len(X)\n    percent = 100 * null_count / total\n\n    if null_count > 0:\n        warning_message = \\\n            'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\\n            'complete rows will be plotted.'.format(null_count, total, percent)\n        warnings.warn(warning_message, DataWarning)", "code_tokens": "def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "docstring_tokens": "Warn if nans exist in a numpy array .", "label": 0}, {"idx": "cosqa-train-19431", "doc": "how to compute dot product on python using a loop", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 1}, {"idx": "cosqa-train-19432", "doc": "get synset in use contextually in a sentence python", "code": "def has_synset(word: str) -> list:\n    \"\"\"\" Returns a list of synsets of a word after lemmatization. \"\"\"\n\n    return wn.synsets(lemmatize(word, neverstem=True))", "code_tokens": "def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "docstring_tokens": "Returns a list of synsets of a word after lemmatization .", "label": 0}, {"idx": "cosqa-train-19433", "doc": "python pylint similar lines in", "code": "def lint(fmt='colorized'):\n    \"\"\"Run verbose PyLint on source. Optionally specify fmt=html for HTML output.\"\"\"\n    if fmt == 'html':\n        outfile = 'pylint_report.html'\n        local('pylint -f %s davies > %s || true' % (fmt, outfile))\n        local('open %s' % outfile)\n    else:\n        local('pylint -f %s davies || true' % fmt)", "code_tokens": "def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "docstring_tokens": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output .", "label": 0}, {"idx": "cosqa-train-19434", "doc": "how to generate the numbers of pi using python", "code": "def getPiLambert(n):\n    \"\"\"Returns a list containing first n digits of Pi\n    \"\"\"\n    mypi = piGenLambert()\n    result = []\n    if n > 0:\n        result += [next(mypi) for i in range(n)]\n    mypi.close()\n    return result", "code_tokens": "def getPiLambert ( n ) : mypi = piGenLambert ( ) result = [ ] if n > 0 : result += [ next ( mypi ) for i in range ( n ) ] mypi . close ( ) return result", "docstring_tokens": "Returns a list containing first n digits of Pi", "label": 1}, {"idx": "cosqa-train-19435", "doc": "python datetime third friday of a month", "code": "def after_third_friday(day=None):\n    \"\"\" check if day is after month's 3rd friday \"\"\"\n    day = day if day is not None else datetime.datetime.now()\n    now = day.replace(day=1, hour=16, minute=0, second=0, microsecond=0)\n    now += relativedelta.relativedelta(weeks=2, weekday=relativedelta.FR)\n    return day > now", "code_tokens": "def after_third_friday ( day = None ) : day = day if day is not None else datetime . datetime . now ( ) now = day . replace ( day = 1 , hour = 16 , minute = 0 , second = 0 , microsecond = 0 ) now += relativedelta . relativedelta ( weeks = 2 , weekday = relativedelta . FR ) return day > now", "docstring_tokens": "check if day is after month s 3rd friday", "label": 1}, {"idx": "cosqa-train-19436", "doc": "python github store the latest tag", "code": "def _get_latest_version():\n    \"\"\"Gets latest Dusty binary version using the GitHub api\"\"\"\n    url = 'https://api.github.com/repos/{}/releases/latest'.format(constants.DUSTY_GITHUB_PATH)\n    conn = urllib.urlopen(url)\n    if conn.getcode() >= 300:\n        raise RuntimeError('GitHub api returned code {}; can\\'t determine latest version.  Aborting'.format(conn.getcode()))\n    json_data = conn.read()\n    return json.loads(json_data)['tag_name']", "code_tokens": "def _get_latest_version ( ) : url = 'https://api.github.com/repos/{}/releases/latest' . format ( constants . DUSTY_GITHUB_PATH ) conn = urllib . urlopen ( url ) if conn . getcode ( ) >= 300 : raise RuntimeError ( 'GitHub api returned code {}; can\\'t determine latest version.  Aborting' . format ( conn . getcode ( ) ) ) json_data = conn . read ( ) return json . loads ( json_data ) [ 'tag_name' ]", "docstring_tokens": "Gets latest Dusty binary version using the GitHub api", "label": 1}, {"idx": "cosqa-train-19437", "doc": "longest path in an undirected tree python", "code": "def dag_longest_path(graph, source, target):\n    \"\"\"\n    Finds the longest path in a dag between two nodes\n    \"\"\"\n    if source == target:\n        return [source]\n    allpaths = nx.all_simple_paths(graph, source, target)\n    longest_path = []\n    for l in allpaths:\n        if len(l) > len(longest_path):\n            longest_path = l\n    return longest_path", "code_tokens": "def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "docstring_tokens": "Finds the longest path in a dag between two nodes", "label": 1}, {"idx": "cosqa-train-19438", "doc": "invert dictionary with list python", "code": "def inverted_dict_of_lists(d):\n    \"\"\"Return a dict where the keys are all the values listed in the values of the original dict\n\n    >>> inverted_dict_of_lists({0: ['a', 'b'], 1: 'cd'}) == {'a': 0, 'b': 0, 'cd': 1}\n    True\n    \"\"\"\n    new_dict = {}\n    for (old_key, old_value_list) in viewitems(dict(d)):\n        for new_key in listify(old_value_list):\n            new_dict[new_key] = old_key\n    return new_dict", "code_tokens": "def inverted_dict_of_lists ( d ) : new_dict = { } for ( old_key , old_value_list ) in viewitems ( dict ( d ) ) : for new_key in listify ( old_value_list ) : new_dict [ new_key ] = old_key return new_dict", "docstring_tokens": "Return a dict where the keys are all the values listed in the values of the original dict", "label": 1}, {"idx": "cosqa-train-19439", "doc": "python if hash key exists", "code": "def check_key(self, key: str) -> bool:\n        \"\"\"\n        Checks if key exists in datastore. True if yes, False if no.\n\n        :param: SHA512 hash key\n\n        :return: whether or key not exists in datastore\n        \"\"\"\n        keys = self.get_keys()\n        return key in keys", "code_tokens": "def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "docstring_tokens": "Checks if key exists in datastore . True if yes False if no .", "label": 1}, {"idx": "cosqa-train-19440", "doc": "python delete from a dictionary if exists", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-19441", "doc": "python getch curses check if key is press", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 1}, {"idx": "cosqa-train-19442", "doc": "python attribute dictionary compare eq", "code": "def simple_eq(one: Instance, two: Instance, attrs: List[str]) -> bool:\n    \"\"\"\n    Test if two objects are equal, based on a comparison of the specified\n    attributes ``attrs``.\n    \"\"\"\n    return all(getattr(one, a) == getattr(two, a) for a in attrs)", "code_tokens": "def simple_eq ( one : Instance , two : Instance , attrs : List [ str ] ) -> bool : return all ( getattr ( one , a ) == getattr ( two , a ) for a in attrs )", "docstring_tokens": "Test if two objects are equal based on a comparison of the specified attributes attrs .", "label": 0}, {"idx": "cosqa-train-19443", "doc": "how to read from stream python", "code": "def decode_value(stream):\n    \"\"\"Decode the contents of a value from a serialized stream.\n\n    :param stream: Source data stream\n    :type stream: io.BytesIO\n    :returns: Decoded value\n    :rtype: bytes\n    \"\"\"\n    length = decode_length(stream)\n    (value,) = unpack_value(\">{:d}s\".format(length), stream)\n    return value", "code_tokens": "def decode_value ( stream ) : length = decode_length ( stream ) ( value , ) = unpack_value ( \">{:d}s\" . format ( length ) , stream ) return value", "docstring_tokens": "Decode the contents of a value from a serialized stream .", "label": 0}, {"idx": "cosqa-train-19444", "doc": "count the number of occurences in series of lists python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 0}, {"idx": "cosqa-train-19445", "doc": "filter on dictionary values python", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 1}, {"idx": "cosqa-train-19446", "doc": "read non blank lines python", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 1}, {"idx": "cosqa-train-19447", "doc": "check if there are only files or directories python", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 1}, {"idx": "cosqa-train-19448", "doc": "python get column with max element", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 0}, {"idx": "cosqa-train-19449", "doc": "get first 100 array elements python", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 0}, {"idx": "cosqa-train-19450", "doc": "python django date isoformat", "code": "def to_iso_string(self) -> str:\n        \"\"\" Returns full ISO string for the given date \"\"\"\n        assert isinstance(self.value, datetime)\n        return datetime.isoformat(self.value)", "code_tokens": "def to_iso_string ( self ) -> str : assert isinstance ( self . value , datetime ) return datetime . isoformat ( self . value )", "docstring_tokens": "Returns full ISO string for the given date", "label": 0}, {"idx": "cosqa-train-19451", "doc": "python round up to specific", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 1}, {"idx": "cosqa-train-19452", "doc": "how to tell if a float object is null python", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 0}, {"idx": "cosqa-train-19453", "doc": "how to identify if a string is an integer in python", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-19454", "doc": "remove none items in dict python", "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": "def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "docstring_tokens": "Return a new copied dictionary without the keys with None values from the given Mapping object .", "label": 1}, {"idx": "cosqa-train-19455", "doc": "restrict float number to fixed decimal in python for series", "code": "def shift(self, m: Union[float, pd.Series]) -> Union[int, pd.Series]:\n        \"\"\"Shifts floats so that the first 10 decimal digits are significant.\"\"\"\n        out = m % 1 * self.TEN_DIGIT_MODULUS // 1\n        if isinstance(out, pd.Series):\n            return out.astype(int)\n        return int(out)", "code_tokens": "def shift ( self , m : Union [ float , pd . Series ] ) -> Union [ int , pd . Series ] : out = m % 1 * self . TEN_DIGIT_MODULUS // 1 if isinstance ( out , pd . Series ) : return out . astype ( int ) return int ( out )", "docstring_tokens": "Shifts floats so that the first 10 decimal digits are significant .", "label": 0}, {"idx": "cosqa-train-19456", "doc": "python how to check if shape is empty", "code": "def is_empty_shape(sh: ShExJ.Shape) -> bool:\n        \"\"\" Determine whether sh has any value \"\"\"\n        return sh.closed is None and sh.expression is None and sh.extra is None and \\\n            sh.semActs is None", "code_tokens": "def is_empty_shape ( sh : ShExJ . Shape ) -> bool : return sh . closed is None and sh . expression is None and sh . extra is None and sh . semActs is None", "docstring_tokens": "Determine whether sh has any value", "label": 0}, {"idx": "cosqa-train-19457", "doc": "python how to verify file location", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-19458", "doc": "python get window dimensions", "code": "def get_window_dim():\n    \"\"\" gets the dimensions depending on python version and os\"\"\"\n    version = sys.version_info\n\n    if version >= (3, 3):\n        return _size_36()\n    if platform.system() == 'Windows':\n        return _size_windows()\n    return _size_27()", "code_tokens": "def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )", "docstring_tokens": "gets the dimensions depending on python version and os", "label": 1}, {"idx": "cosqa-train-19459", "doc": "how to check whether a lines exists in a file in python", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 0}, {"idx": "cosqa-train-19460", "doc": "sort a list of files depending on date modified python", "code": "def sort_by_modified(files_or_folders: list) -> list:\n    \"\"\"\n    Sort files or folders by modified time\n\n    Args:\n        files_or_folders: list of files or folders\n\n    Returns:\n        list\n    \"\"\"\n    return sorted(files_or_folders, key=os.path.getmtime, reverse=True)", "code_tokens": "def sort_by_modified ( files_or_folders : list ) -> list : return sorted ( files_or_folders , key = os . path . getmtime , reverse = True )", "docstring_tokens": "Sort files or folders by modified time", "label": 1}, {"idx": "cosqa-train-19461", "doc": "python + asign sql output to a varaible", "code": "def execute(cur, *args):\n    \"\"\"Utility function to print sqlite queries before executing.\n\n    Use instead of cur.execute().  First argument is cursor.\n\n    cur.execute(stmt)\n    becomes\n    util.execute(cur, stmt)\n    \"\"\"\n    stmt = args[0]\n    if len(args) > 1:\n        stmt = stmt.replace('%', '%%').replace('?', '%r')\n        print(stmt % (args[1]))\n    return cur.execute(*args)", "code_tokens": "def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )", "docstring_tokens": "Utility function to print sqlite queries before executing .", "label": 1}, {"idx": "cosqa-train-19462", "doc": "dot product algorithm in python 3 without numpy", "code": "def kdot(x, y, K=2):\n    \"\"\"Algorithm 5.10. Dot product algorithm in K-fold working precision,\n    K >= 3.\n    \"\"\"\n    xx = x.reshape(-1, x.shape[-1])\n    yy = y.reshape(y.shape[0], -1)\n\n    xx = numpy.ascontiguousarray(xx)\n    yy = numpy.ascontiguousarray(yy)\n\n    r = _accupy.kdot_helper(xx, yy).reshape((-1,) + x.shape[:-1] + y.shape[1:])\n    return ksum(r, K - 1)", "code_tokens": "def kdot ( x , y , K = 2 ) : xx = x . reshape ( - 1 , x . shape [ - 1 ] ) yy = y . reshape ( y . shape [ 0 ] , - 1 ) xx = numpy . ascontiguousarray ( xx ) yy = numpy . ascontiguousarray ( yy ) r = _accupy . kdot_helper ( xx , yy ) . reshape ( ( - 1 , ) + x . shape [ : - 1 ] + y . shape [ 1 : ] ) return ksum ( r , K - 1 )", "docstring_tokens": "Algorithm 5 . 10 . Dot product algorithm in K - fold working precision K > = 3 .", "label": 0}, {"idx": "cosqa-train-19463", "doc": "python 3 list of unique strings", "code": "def uniqued(iterable):\n    \"\"\"Return unique list of ``iterable`` items preserving order.\n\n    >>> uniqued('spameggs')\n    ['s', 'p', 'a', 'm', 'e', 'g']\n    \"\"\"\n    seen = set()\n    return [item for item in iterable if item not in seen and not seen.add(item)]", "code_tokens": "def uniqued ( iterable ) : seen = set ( ) return [ item for item in iterable if item not in seen and not seen . add ( item ) ]", "docstring_tokens": "Return unique list of iterable items preserving order .", "label": 1}, {"idx": "cosqa-train-19464", "doc": "json to pure string python", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 1}, {"idx": "cosqa-train-19465", "doc": "python string replace a certain character", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 1}, {"idx": "cosqa-train-19466", "doc": "random walk steps python", "code": "def returned(n):\n\t\"\"\"Generate a random walk and return True if the walker has returned to\n\tthe origin after taking `n` steps.\n\t\"\"\"\n\t## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk\n\tfor pos in randwalk() >> drop(1) >> takei(xrange(n-1)):\n\t\tif pos == Origin:\n\t\t\treturn True\n\treturn False", "code_tokens": "def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "docstring_tokens": "Generate a random walk and return True if the walker has returned to the origin after taking n steps .", "label": 1}, {"idx": "cosqa-train-19467", "doc": "how to get the items in dict with highest values python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 0}, {"idx": "cosqa-train-19468", "doc": "python 16 bit per channel color hsv", "code": "def hsv2rgb_spectrum(hsv):\n    \"\"\"Generates RGB values from HSV values in line with a typical light\n    spectrum.\"\"\"\n    h, s, v = hsv\n    return hsv2rgb_raw(((h * 192) >> 8, s, v))", "code_tokens": "def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "docstring_tokens": "Generates RGB values from HSV values in line with a typical light spectrum .", "label": 1}, {"idx": "cosqa-train-19469", "doc": "read file from aws s3 bucket in python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 0}, {"idx": "cosqa-train-19470", "doc": "python str extract case insensitive", "code": "def lowercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the lowercase chars in the given string.\"\"\"\n        return ''.join([c if c.islower() else '' for c in str(string)])", "code_tokens": "def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the lowercase chars in the given string .", "label": 0}, {"idx": "cosqa-train-19471", "doc": "read json object as dict from file in python 3", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 1}, {"idx": "cosqa-train-19472", "doc": "python pad array to make same size", "code": "def pad(a, desiredlength):\n    \"\"\"\n    Pad an n-dimensional numpy array with zeros along the zero-th dimension\n    so that it is the desired length.  Return it unchanged if it is greater\n    than or equal to the desired length\n    \"\"\"\n\n    if len(a) >= desiredlength:\n        return a\n\n    islist = isinstance(a, list)\n    a = np.array(a)\n    diff = desiredlength - len(a)\n    shape = list(a.shape)\n    shape[0] = diff\n\n    padded = np.concatenate([a, np.zeros(shape, dtype=a.dtype)])\n    return padded.tolist() if islist else padded", "code_tokens": "def pad ( a , desiredlength ) : if len ( a ) >= desiredlength : return a islist = isinstance ( a , list ) a = np . array ( a ) diff = desiredlength - len ( a ) shape = list ( a . shape ) shape [ 0 ] = diff padded = np . concatenate ( [ a , np . zeros ( shape , dtype = a . dtype ) ] ) return padded . tolist ( ) if islist else padded", "docstring_tokens": "Pad an n - dimensional numpy array with zeros along the zero - th dimension so that it is the desired length . Return it unchanged if it is greater than or equal to the desired length", "label": 0}, {"idx": "cosqa-train-19473", "doc": "how to code python to translate a language", "code": "def get_language():\n    \"\"\"\n    Wrapper around Django's `get_language` utility.\n    For Django >= 1.8, `get_language` returns None in case no translation is activate.\n    Here we patch this behavior e.g. for back-end functionality requiring access to translated fields\n    \"\"\"\n    from parler import appsettings\n    language = dj_get_language()\n    if language is None and appsettings.PARLER_DEFAULT_ACTIVATE:\n        return appsettings.PARLER_DEFAULT_LANGUAGE_CODE\n    else:\n        return language", "code_tokens": "def get_language ( ) : from parler import appsettings language = dj_get_language ( ) if language is None and appsettings . PARLER_DEFAULT_ACTIVATE : return appsettings . PARLER_DEFAULT_LANGUAGE_CODE else : return language", "docstring_tokens": "Wrapper around Django s get_language utility . For Django > = 1 . 8 get_language returns None in case no translation is activate . Here we patch this behavior e . g . for back - end functionality requiring access to translated fields", "label": 0}, {"idx": "cosqa-train-19474", "doc": "what different between python for windows and linux", "code": "def _darwin_current_arch(self):\n        \"\"\"Add Mac OS X support.\"\"\"\n        if sys.platform == \"darwin\":\n            if sys.maxsize > 2 ** 32: # 64bits.\n                return platform.mac_ver()[2] # Both Darwin and Python are 64bits.\n            else: # Python 32 bits\n                return platform.processor()", "code_tokens": "def _darwin_current_arch ( self ) : if sys . platform == \"darwin\" : if sys . maxsize > 2 ** 32 : # 64bits. return platform . mac_ver ( ) [ 2 ] # Both Darwin and Python are 64bits. else : # Python 32 bits return platform . processor ( )", "docstring_tokens": "Add Mac OS X support .", "label": 0}, {"idx": "cosqa-train-19475", "doc": "change a string to a date python", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-19476", "doc": "flatten the dictionary in python", "code": "def flatten_multidict(multidict):\n    \"\"\"Return flattened dictionary from ``MultiDict``.\"\"\"\n    return dict([(key, value if len(value) > 1 else value[0])\n                 for (key, value) in multidict.iterlists()])", "code_tokens": "def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "docstring_tokens": "Return flattened dictionary from MultiDict .", "label": 0}, {"idx": "cosqa-train-19477", "doc": "time zones in django python", "code": "def usetz_now():\n    \"\"\"Determine current time depending on USE_TZ setting.\n\n    Affects Django 1.4 and above only. if `USE_TZ = True`, then returns\n    current time according to timezone, else returns current UTC time.\n\n    \"\"\"\n    USE_TZ = getattr(settings, 'USE_TZ', False)\n    if USE_TZ and DJANGO_VERSION >= '1.4':\n        return now()\n    else:\n        return datetime.utcnow()", "code_tokens": "def usetz_now ( ) : USE_TZ = getattr ( settings , 'USE_TZ' , False ) if USE_TZ and DJANGO_VERSION >= '1.4' : return now ( ) else : return datetime . utcnow ( )", "docstring_tokens": "Determine current time depending on USE_TZ setting .", "label": 0}, {"idx": "cosqa-train-19478", "doc": "identify if float is null in python", "code": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))", "code_tokens": "def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "docstring_tokens": "Return true if a value is a finite number .", "label": 1}, {"idx": "cosqa-train-19479", "doc": "python ensure string length fill wih 0s to right", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 0}, {"idx": "cosqa-train-19480", "doc": "python3 parse iso date", "code": "def _parse_date(string: str) -> datetime.date:\n    \"\"\"Parse an ISO format date (YYYY-mm-dd).\n\n    >>> _parse_date('1990-01-02')\n    datetime.date(1990, 1, 2)\n    \"\"\"\n    return datetime.datetime.strptime(string, '%Y-%m-%d').date()", "code_tokens": "def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )", "docstring_tokens": "Parse an ISO format date ( YYYY - mm - dd ) .", "label": 1}, {"idx": "cosqa-train-19481", "doc": "how to create a set with words from a filepython", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 1}, {"idx": "cosqa-train-19482", "doc": "python list comprehension list into single", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 1}, {"idx": "cosqa-train-19483", "doc": "how to get the maximum cell in one row in python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 1}, {"idx": "cosqa-train-19484", "doc": "can key in dictionary be a float in python", "code": "def dictlist_convert_to_float(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, convert\n    (in place) ``d[key]`` to a float. If that fails, convert it to ``None``.\n    \"\"\"\n    for d in dict_list:\n        try:\n            d[key] = float(d[key])\n        except ValueError:\n            d[key] = None", "code_tokens": "def dictlist_convert_to_float ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : try : d [ key ] = float ( d [ key ] ) except ValueError : d [ key ] = None", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d convert ( in place ) d [ key ] to a float . If that fails convert it to None .", "label": 1}, {"idx": "cosqa-train-19485", "doc": "construct file name python format string", "code": "def infer_format(filename:str) -> str:\n    \"\"\"Return extension identifying format of given filename\"\"\"\n    _, ext = os.path.splitext(filename)\n    return ext", "code_tokens": "def infer_format ( filename : str ) -> str : _ , ext = os . path . splitext ( filename ) return ext", "docstring_tokens": "Return extension identifying format of given filename", "label": 0}, {"idx": "cosqa-train-19486", "doc": "get the most frequent value in a list python", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 1}, {"idx": "cosqa-train-19487", "doc": "get all lowercase chars python", "code": "def lowercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the lowercase chars in the given string.\"\"\"\n        return ''.join([c if c.islower() else '' for c in str(string)])", "code_tokens": "def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the lowercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-19488", "doc": "remove string from column names python", "code": "def normalize_column_names(df):\n    r\"\"\" Clean up whitespace in column names. See better version at `pugnlp.clean_columns`\n\n    >>> df = pd.DataFrame([[1, 2], [3, 4]], columns=['Hello World', 'not here'])\n    >>> normalize_column_names(df)\n    ['hello_world', 'not_here']\n    \"\"\"\n    columns = df.columns if hasattr(df, 'columns') else df\n    columns = [c.lower().replace(' ', '_') for c in columns]\n    return columns", "code_tokens": "def normalize_column_names ( df ) : columns = df . columns if hasattr ( df , 'columns' ) else df columns = [ c . lower ( ) . replace ( ' ' , '_' ) for c in columns ] return columns", "docstring_tokens": "r Clean up whitespace in column names . See better version at pugnlp . clean_columns", "label": 0}, {"idx": "cosqa-train-19489", "doc": "how to split a sentence by spaces to a list python", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 1}, {"idx": "cosqa-train-19490", "doc": "python sqlalchemy mssql decimal type", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 0}, {"idx": "cosqa-train-19491", "doc": "using python to send commands over serial", "code": "def command(self, cmd, *args):\n        \"\"\"\n        Sends a command and an (optional) sequence of arguments through to the\n        delegated serial interface. Note that the arguments are passed through\n        as data.\n        \"\"\"\n        self._serial_interface.command(cmd)\n        if len(args) > 0:\n            self._serial_interface.data(list(args))", "code_tokens": "def command ( self , cmd , * args ) : self . _serial_interface . command ( cmd ) if len ( args ) > 0 : self . _serial_interface . data ( list ( args ) )", "docstring_tokens": "Sends a command and an ( optional ) sequence of arguments through to the delegated serial interface . Note that the arguments are passed through as data .", "label": 1}, {"idx": "cosqa-train-19492", "doc": "python extract host from url", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 0}, {"idx": "cosqa-train-19493", "doc": "change list of int to string python", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 0}, {"idx": "cosqa-train-19494", "doc": "show data types of columns in python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-19495", "doc": "python iterate text file remove newlines", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-19496", "doc": "python enum value is from enum", "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum:\n    \"\"\"\n    Converts an ``dict`` to a ``Enum``.\n    \"\"\"\n    return enum_class[d['name']]", "code_tokens": "def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "docstring_tokens": "Converts an dict to a Enum .", "label": 0}, {"idx": "cosqa-train-19497", "doc": "python how to say if not equal to an integer", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 1}, {"idx": "cosqa-train-19498", "doc": "python get column types", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 0}, {"idx": "cosqa-train-19499", "doc": "elasticsearch python bulk slow", "code": "def bulk_load_docs(es, docs):\n    \"\"\"Bulk load docs\n\n    Args:\n        es: elasticsearch handle\n        docs: Iterator of doc objects - includes index_name\n    \"\"\"\n\n    chunk_size = 200\n\n    try:\n        results = elasticsearch.helpers.bulk(es, docs, chunk_size=chunk_size)\n        log.debug(f\"Elasticsearch documents loaded: {results[0]}\")\n\n        # elasticsearch.helpers.parallel_bulk(es, terms, chunk_size=chunk_size, thread_count=4)\n        if len(results[1]) > 0:\n            log.error(\"Bulk load errors {}\".format(results))\n    except elasticsearch.ElasticsearchException as e:\n        log.error(\"Indexing error: {}\\n\".format(e))", "code_tokens": "def bulk_load_docs ( es , docs ) : chunk_size = 200 try : results = elasticsearch . helpers . bulk ( es , docs , chunk_size = chunk_size ) log . debug ( f\"Elasticsearch documents loaded: {results[0]}\" ) # elasticsearch.helpers.parallel_bulk(es, terms, chunk_size=chunk_size, thread_count=4) if len ( results [ 1 ] ) > 0 : log . error ( \"Bulk load errors {}\" . format ( results ) ) except elasticsearch . ElasticsearchException as e : log . error ( \"Indexing error: {}\\n\" . format ( e ) )", "docstring_tokens": "Bulk load docs", "label": 1}, {"idx": "cosqa-train-19500", "doc": "parsing a date string python", "code": "def _parse_date(string: str) -> datetime.date:\n    \"\"\"Parse an ISO format date (YYYY-mm-dd).\n\n    >>> _parse_date('1990-01-02')\n    datetime.date(1990, 1, 2)\n    \"\"\"\n    return datetime.datetime.strptime(string, '%Y-%m-%d').date()", "code_tokens": "def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )", "docstring_tokens": "Parse an ISO format date ( YYYY - mm - dd ) .", "label": 1}, {"idx": "cosqa-train-19501", "doc": "how to get the character codes for the chars in the string python", "code": "def get_codes(s: Union[str, 'ChainedBase']) -> List[str]:\n    \"\"\" Grab all escape codes from a string.\n        Returns a list of all escape codes.\n    \"\"\"\n    return codegrabpat.findall(str(s))", "code_tokens": "def get_codes ( s : Union [ str , 'ChainedBase' ] ) -> List [ str ] : return codegrabpat . findall ( str ( s ) )", "docstring_tokens": "Grab all escape codes from a string . Returns a list of all escape codes .", "label": 1}, {"idx": "cosqa-train-19502", "doc": "how to turn a string into a tuple pythons", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 1}, {"idx": "cosqa-train-19503", "doc": "color to python tuple", "code": "def hex_color_to_tuple(hex):\n    \"\"\" convent hex color to tuple\n    \"#ffffff\"   ->  (255, 255, 255)\n    \"#ffff00ff\" ->  (255, 255, 0, 255)\n    \"\"\"\n    hex = hex[1:]\n    length = len(hex) // 2\n    return tuple(int(hex[i*2:i*2+2], 16) for i in range(length))", "code_tokens": "def hex_color_to_tuple ( hex ) : hex = hex [ 1 : ] length = len ( hex ) // 2 return tuple ( int ( hex [ i * 2 : i * 2 + 2 ] , 16 ) for i in range ( length ) )", "docstring_tokens": "convent hex color to tuple #ffffff - > ( 255 255 255 ) #ffff00ff - > ( 255 255 0 255 )", "label": 0}, {"idx": "cosqa-train-19504", "doc": "python how to check if key does not exists", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 1}, {"idx": "cosqa-train-19505", "doc": "check if enum is valid python", "code": "def is_valid(cls, arg):\n        \"\"\"Return True if arg is valid value for the class.  If the string\n        value is wrong for the enumeration, the encoding will fail.\n        \"\"\"\n        return (isinstance(arg, (int, long)) and (arg >= 0)) or \\\n            isinstance(arg, basestring)", "code_tokens": "def is_valid ( cls , arg ) : return ( isinstance ( arg , ( int , long ) ) and ( arg >= 0 ) ) or isinstance ( arg , basestring )", "docstring_tokens": "Return True if arg is valid value for the class . If the string value is wrong for the enumeration the encoding will fail .", "label": 1}, {"idx": "cosqa-train-19506", "doc": "python setting a default value for an attribute", "code": "def setdefault(self, name: str, default: Any=None) -> Any:\n        \"\"\"Set an attribute with a default value.\"\"\"\n        return self.__dict__.setdefault(name, default)", "code_tokens": "def setdefault ( self , name : str , default : Any = None ) -> Any : return self . __dict__ . setdefault ( name , default )", "docstring_tokens": "Set an attribute with a default value .", "label": 0}, {"idx": "cosqa-train-19507", "doc": "sample api post call python", "code": "def post(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP POST operation to API endpoint.\"\"\"\n\n        return self._request('POST', endpoint, **kwargs)", "code_tokens": "def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "docstring_tokens": "HTTP POST operation to API endpoint .", "label": 0}, {"idx": "cosqa-train-19508", "doc": "how to get the base 10value for a string in python", "code": "def decode(string, base):\n    \"\"\"\n    Given a string (string) and a numeric base (base),\n    decode the string into an integer.\n\n    Returns the integer\n    \"\"\"\n\n    base = int(base)\n    code_string = get_code_string(base)\n    result = 0\n    if base == 16:\n        string = string.lower()\n    while len(string) > 0:\n        result *= base\n        result += code_string.find(string[0])\n        string = string[1:]\n    return result", "code_tokens": "def decode ( string , base ) : base = int ( base ) code_string = get_code_string ( base ) result = 0 if base == 16 : string = string . lower ( ) while len ( string ) > 0 : result *= base result += code_string . find ( string [ 0 ] ) string = string [ 1 : ] return result", "docstring_tokens": "Given a string ( string ) and a numeric base ( base ) decode the string into an integer .", "label": 1}, {"idx": "cosqa-train-19509", "doc": "mulyiple indexing list python", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 1}, {"idx": "cosqa-train-19510", "doc": "how to graph a complex function in python", "code": "def enrich_complexes(graph: BELGraph) -> None:\n    \"\"\"Add all of the members of the complex abundances to the graph.\"\"\"\n    nodes = list(get_nodes_by_function(graph, COMPLEX))\n    for u in nodes:\n        for v in u.members:\n            graph.add_has_component(u, v)", "code_tokens": "def enrich_complexes ( graph : BELGraph ) -> None : nodes = list ( get_nodes_by_function ( graph , COMPLEX ) ) for u in nodes : for v in u . members : graph . add_has_component ( u , v )", "docstring_tokens": "Add all of the members of the complex abundances to the graph .", "label": 1}, {"idx": "cosqa-train-19511", "doc": "how to know the datatype of column+ sql + python", "code": "def get_datatype(self, table: str, column: str) -> str:\n        \"\"\"Returns database SQL datatype for a column: e.g. VARCHAR.\"\"\"\n        return self.flavour.get_datatype(self, table, column).upper()", "code_tokens": "def get_datatype ( self , table : str , column : str ) -> str : return self . flavour . get_datatype ( self , table , column ) . upper ( )", "docstring_tokens": "Returns database SQL datatype for a column : e . g . VARCHAR .", "label": 0}, {"idx": "cosqa-train-19512", "doc": "skip over blank lines in file python", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-19513", "doc": "generate graph from dot file python", "code": "def cmd_dot(conf: Config):\n    \"\"\"Print out a neat targets dependency tree based on requested targets.\n\n    Use graphviz to render the dot file, e.g.:\n\n    > ybt dot :foo :bar | dot -Tpng -o graph.png\n    \"\"\"\n    build_context = BuildContext(conf)\n    populate_targets_graph(build_context, conf)\n    if conf.output_dot_file is None:\n        write_dot(build_context, conf, sys.stdout)\n    else:\n        with open(conf.output_dot_file, 'w') as out_file:\n            write_dot(build_context, conf, out_file)", "code_tokens": "def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "docstring_tokens": "Print out a neat targets dependency tree based on requested targets .", "label": 0}, {"idx": "cosqa-train-19514", "doc": "using recursion in python to print a binary tree", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-19515", "doc": "python matrix to orthogonal", "code": "def is_orthogonal(\n        matrix: np.ndarray,\n        *,\n        rtol: float = 1e-5,\n        atol: float = 1e-8) -> bool:\n    \"\"\"Determines if a matrix is approximately orthogonal.\n\n    A matrix is orthogonal if it's square and real and its transpose is its\n    inverse.\n\n    Args:\n        matrix: The matrix to check.\n        rtol: The per-matrix-entry relative tolerance on equality.\n        atol: The per-matrix-entry absolute tolerance on equality.\n\n    Returns:\n        Whether the matrix is orthogonal within the given tolerance.\n    \"\"\"\n    return (matrix.shape[0] == matrix.shape[1] and\n            np.all(np.imag(matrix) == 0) and\n            np.allclose(matrix.dot(matrix.T), np.eye(matrix.shape[0]),\n                        rtol=rtol,\n                        atol=atol))", "code_tokens": "def is_orthogonal ( matrix : np . ndarray , * , rtol : float = 1e-5 , atol : float = 1e-8 ) -> bool : return ( matrix . shape [ 0 ] == matrix . shape [ 1 ] and np . all ( np . imag ( matrix ) == 0 ) and np . allclose ( matrix . dot ( matrix . T ) , np . eye ( matrix . shape [ 0 ] ) , rtol = rtol , atol = atol ) )", "docstring_tokens": "Determines if a matrix is approximately orthogonal .", "label": 0}, {"idx": "cosqa-train-19516", "doc": "python numpy fill with custom values", "code": "def layer_with(self, sample: np.ndarray, value: int) -> np.ndarray:\n        \"\"\"Create an identical 2d array where the second row is filled with value\"\"\"\n        b = np.full((2, len(sample)), value, dtype=float)\n        b[0] = sample\n        return b", "code_tokens": "def layer_with ( self , sample : np . ndarray , value : int ) -> np . ndarray : b = np . full ( ( 2 , len ( sample ) ) , value , dtype = float ) b [ 0 ] = sample return b", "docstring_tokens": "Create an identical 2d array where the second row is filled with value", "label": 0}, {"idx": "cosqa-train-19517", "doc": "invert a dictionary in python", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 1}, {"idx": "cosqa-train-19518", "doc": "how to check path is a file or directory in python", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-19519", "doc": "validate minimum string length of user input in python", "code": "def input_validate_str(string, name, max_len=None, exact_len=None):\n    \"\"\" Input validation for strings. \"\"\"\n    if type(string) is not str:\n        raise pyhsm.exception.YHSM_WrongInputType(name, str, type(string))\n    if max_len != None and len(string) > max_len:\n        raise pyhsm.exception.YHSM_InputTooLong(name, max_len, len(string))\n    if exact_len != None and len(string) != exact_len:\n        raise pyhsm.exception.YHSM_WrongInputSize(name, exact_len, len(string))\n    return string", "code_tokens": "def input_validate_str ( string , name , max_len = None , exact_len = None ) : if type ( string ) is not str : raise pyhsm . exception . YHSM_WrongInputType ( name , str , type ( string ) ) if max_len != None and len ( string ) > max_len : raise pyhsm . exception . YHSM_InputTooLong ( name , max_len , len ( string ) ) if exact_len != None and len ( string ) != exact_len : raise pyhsm . exception . YHSM_WrongInputSize ( name , exact_len , len ( string ) ) return string", "docstring_tokens": "Input validation for strings .", "label": 0}, {"idx": "cosqa-train-19520", "doc": "python get index of element each time it appears in list", "code": "def index(self, item):\n        \"\"\" Not recommended for use on large lists due to time\n            complexity, but it works\n\n            -> #int list index of @item\n        \"\"\"\n        for i, x in enumerate(self.iter()):\n            if x == item:\n                return i\n        return None", "code_tokens": "def index ( self , item ) : for i , x in enumerate ( self . iter ( ) ) : if x == item : return i return None", "docstring_tokens": "Not recommended for use on large lists due to time complexity but it works", "label": 1}, {"idx": "cosqa-train-19521", "doc": "python check if string contains a line in file", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 1}, {"idx": "cosqa-train-19522", "doc": "invert a dictionary python", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 0}, {"idx": "cosqa-train-19523", "doc": "change a string list to int in python", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-19524", "doc": "che3ck if string is equal to whitespace python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 0}, {"idx": "cosqa-train-19525", "doc": "covert string to int in python", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 0}, {"idx": "cosqa-train-19526", "doc": "python check the date a file was altered", "code": "def has_changed (filename):\n    \"\"\"Check if filename has changed since the last check. If this\n    is the first check, assume the file is changed.\"\"\"\n    key = os.path.abspath(filename)\n    mtime = get_mtime(key)\n    if key not in _mtime_cache:\n        _mtime_cache[key] = mtime\n        return True\n    return mtime > _mtime_cache[key]", "code_tokens": "def has_changed ( filename ) : key = os . path . abspath ( filename ) mtime = get_mtime ( key ) if key not in _mtime_cache : _mtime_cache [ key ] = mtime return True return mtime > _mtime_cache [ key ]", "docstring_tokens": "Check if filename has changed since the last check . If this is the first check assume the file is changed .", "label": 1}, {"idx": "cosqa-train-19527", "doc": "connecting to an access database with python pyodbc", "code": "def connect_to_database_odbc_access(self,\n                                        dsn: str,\n                                        autocommit: bool = True) -> None:\n        \"\"\"Connects to an Access database via ODBC, with the DSN\n        prespecified.\"\"\"\n        self.connect(engine=ENGINE_ACCESS, interface=INTERFACE_ODBC,\n                     dsn=dsn, autocommit=autocommit)", "code_tokens": "def connect_to_database_odbc_access ( self , dsn : str , autocommit : bool = True ) -> None : self . connect ( engine = ENGINE_ACCESS , interface = INTERFACE_ODBC , dsn = dsn , autocommit = autocommit )", "docstring_tokens": "Connects to an Access database via ODBC with the DSN prespecified .", "label": 0}, {"idx": "cosqa-train-19528", "doc": "remove data frame columns python", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 1}, {"idx": "cosqa-train-19529", "doc": "python default value return tuple", "code": "def _get_tuple(self, fields):\n    \"\"\"\n    :param fields: a list which contains either 0,1,or 2 values\n    :return: a tuple with default values of '';\n    \"\"\"\n    v1 = ''\n    v2 = ''\n    if len(fields) > 0:\n      v1 = fields[0]\n    if len(fields) > 1:\n      v2 = fields[1]\n    return v1, v2", "code_tokens": "def _get_tuple ( self , fields ) : v1 = '' v2 = '' if len ( fields ) > 0 : v1 = fields [ 0 ] if len ( fields ) > 1 : v2 = fields [ 1 ] return v1 , v2", "docstring_tokens": ": param fields : a list which contains either 0 1 or 2 values : return : a tuple with default values of ;", "label": 1}, {"idx": "cosqa-train-19530", "doc": "python for loop except first and last elements in list", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 0}, {"idx": "cosqa-train-19531", "doc": "python reload is not defined", "code": "def autoreload(self, parameter_s=''):\n        r\"\"\"%autoreload => Reload modules automatically\n\n        %autoreload\n        Reload all modules (except those excluded by %aimport) automatically\n        now.\n\n        %autoreload 0\n        Disable automatic reloading.\n\n        %autoreload 1\n        Reload all modules imported with %aimport every time before executing\n        the Python code typed.\n\n        %autoreload 2\n        Reload all modules (except those excluded by %aimport) every time\n        before executing the Python code typed.\n\n        Reloading Python modules in a reliable way is in general\n        difficult, and unexpected things may occur. %autoreload tries to\n        work around common pitfalls by replacing function code objects and\n        parts of classes previously in the module with new versions. This\n        makes the following things to work:\n\n        - Functions and classes imported via 'from xxx import foo' are upgraded\n          to new versions when 'xxx' is reloaded.\n\n        - Methods and properties of classes are upgraded on reload, so that\n          calling 'c.foo()' on an object 'c' created before the reload causes\n          the new code for 'foo' to be executed.\n\n        Some of the known remaining caveats are:\n\n        - Replacing code objects does not always succeed: changing a @property\n          in a class to an ordinary method or a method to a member variable\n          can cause problems (but in old objects only).\n\n        - Functions that are removed (eg. via monkey-patching) from a module\n          before it is reloaded are not upgraded.\n\n        - C extension modules cannot be reloaded, and so cannot be\n          autoreloaded.\n\n        \"\"\"\n        if parameter_s == '':\n            self._reloader.check(True)\n        elif parameter_s == '0':\n            self._reloader.enabled = False\n        elif parameter_s == '1':\n            self._reloader.check_all = False\n            self._reloader.enabled = True\n        elif parameter_s == '2':\n            self._reloader.check_all = True\n            self._reloader.enabled = True", "code_tokens": "def autoreload ( self , parameter_s = '' ) : if parameter_s == '' : self . _reloader . check ( True ) elif parameter_s == '0' : self . _reloader . enabled = False elif parameter_s == '1' : self . _reloader . check_all = False self . _reloader . enabled = True elif parameter_s == '2' : self . _reloader . check_all = True self . _reloader . enabled = True", "docstring_tokens": "r %autoreload = > Reload modules automatically", "label": 1}, {"idx": "cosqa-train-19532", "doc": "python kmeans get the optimal cluster number", "code": "def _centroids(n_clusters: int, points: List[List[float]]) -> List[List[float]]:\n    \"\"\" Return n_clusters centroids of points\n    \"\"\"\n\n    k_means = KMeans(n_clusters=n_clusters)\n    k_means.fit(points)\n\n    closest, _ = pairwise_distances_argmin_min(k_means.cluster_centers_, points)\n\n    return list(map(list, np.array(points)[closest.tolist()]))", "code_tokens": "def _centroids ( n_clusters : int , points : List [ List [ float ] ] ) -> List [ List [ float ] ] : k_means = KMeans ( n_clusters = n_clusters ) k_means . fit ( points ) closest , _ = pairwise_distances_argmin_min ( k_means . cluster_centers_ , points ) return list ( map ( list , np . array ( points ) [ closest . tolist ( ) ] ) )", "docstring_tokens": "Return n_clusters centroids of points", "label": 1}, {"idx": "cosqa-train-19533", "doc": "python generate all permutations", "code": "def product(*args, **kwargs):\n    \"\"\" Yields all permutations with replacement:\n        list(product(\"cat\", repeat=2)) => \n        [(\"c\", \"c\"), \n         (\"c\", \"a\"), \n         (\"c\", \"t\"), \n         (\"a\", \"c\"), \n         (\"a\", \"a\"), \n         (\"a\", \"t\"), \n         (\"t\", \"c\"), \n         (\"t\", \"a\"), \n         (\"t\", \"t\")]\n    \"\"\"\n    p = [[]]\n    for iterable in map(tuple, args) * kwargs.get(\"repeat\", 1):\n        p = [x + [y] for x in p for y in iterable]\n    for p in p:\n        yield tuple(p)", "code_tokens": "def product ( * args , * * kwargs ) : p = [ [ ] ] for iterable in map ( tuple , args ) * kwargs . get ( \"repeat\" , 1 ) : p = [ x + [ y ] for x in p for y in iterable ] for p in p : yield tuple ( p )", "docstring_tokens": "Yields all permutations with replacement : list ( product ( cat repeat = 2 )) = > [ ( c c ) ( c a ) ( c t ) ( a c ) ( a a ) ( a t ) ( t c ) ( t a ) ( t t ) ]", "label": 1}, {"idx": "cosqa-train-19534", "doc": "python check if a valid date", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 1}, {"idx": "cosqa-train-19535", "doc": "python + calculate matrix product of the two tensors", "code": "def inner(tensor0: BKTensor, tensor1: BKTensor) -> BKTensor:\n    \"\"\"Return the inner product between two tensors\"\"\"\n    # Note: Relying on fact that vdot flattens arrays\n    return np.vdot(tensor0, tensor1)", "code_tokens": "def inner ( tensor0 : BKTensor , tensor1 : BKTensor ) -> BKTensor : # Note: Relying on fact that vdot flattens arrays return np . vdot ( tensor0 , tensor1 )", "docstring_tokens": "Return the inner product between two tensors", "label": 0}, {"idx": "cosqa-train-19536", "doc": "python how to turn a string list into a list", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 1}, {"idx": "cosqa-train-19537", "doc": "get document frequency from tokenized lists python", "code": "def _sum_cycles_from_tokens(self, tokens: List[str]) -> int:\n        \"\"\"Sum the total number of cycles over a list of tokens.\"\"\"\n        return sum((int(self._nonnumber_pattern.sub('', t)) for t in tokens))", "code_tokens": "def _sum_cycles_from_tokens ( self , tokens : List [ str ] ) -> int : return sum ( ( int ( self . _nonnumber_pattern . sub ( '' , t ) ) for t in tokens ) )", "docstring_tokens": "Sum the total number of cycles over a list of tokens .", "label": 0}, {"idx": "cosqa-train-19538", "doc": "chaning list entries from string to int in python", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-19539", "doc": "capitalize letters in string python", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-19540", "doc": "how to change list of strings to integers python", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 0}, {"idx": "cosqa-train-19541", "doc": "how to check for an empty file python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 0}, {"idx": "cosqa-train-19542", "doc": "elements of a list to string in python", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 1}, {"idx": "cosqa-train-19543", "doc": "how to type cast an unsigned long to int in python", "code": "def read32(bytestream):\n  \"\"\"Read 4 bytes from bytestream as an unsigned 32-bit integer.\"\"\"\n  dt = np.dtype(np.uint32).newbyteorder('>')\n  return np.frombuffer(bytestream.read(4), dtype=dt)[0]", "code_tokens": "def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "docstring_tokens": "Read 4 bytes from bytestream as an unsigned 32 - bit integer .", "label": 0}, {"idx": "cosqa-train-19544", "doc": "python if array is all 1", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 1}, {"idx": "cosqa-train-19545", "doc": "how to check if a string is whitespace in python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 1}, {"idx": "cosqa-train-19546", "doc": "how to check if a string contains all letters in python", "code": "def chars(string: any) -> str:\n        \"\"\"Return all (and only) the chars in the given string.\"\"\"\n        return ''.join([c if c.isalpha() else '' for c in str(string)])", "code_tokens": "def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the chars in the given string .", "label": 1}, {"idx": "cosqa-train-19547", "doc": "rms average equation python", "code": "def rms(x):\n    \"\"\"\"Root Mean Square\"\n\n    Arguments:\n        x (seq of float): A sequence of numerical values\n\n    Returns:\n        The square root of the average of the squares of the values\n\n        math.sqrt(sum(x_i**2 for x_i in x) / len(x))\n\n        or\n\n        return (np.array(x) ** 2).mean() ** 0.5\n\n    >>> rms([0, 2, 4, 4])\n    3.0\n    \"\"\"\n    try:\n        return (np.array(x) ** 2).mean() ** 0.5\n    except:\n        x = np.array(dropna(x))\n        invN = 1.0 / len(x)\n        return (sum(invN * (x_i ** 2) for x_i in x)) ** .5", "code_tokens": "def rms ( x ) : try : return ( np . array ( x ) ** 2 ) . mean ( ) ** 0.5 except : x = np . array ( dropna ( x ) ) invN = 1.0 / len ( x ) return ( sum ( invN * ( x_i ** 2 ) for x_i in x ) ) ** .5", "docstring_tokens": "Root Mean Square", "label": 1}, {"idx": "cosqa-train-19548", "doc": "linux python memcache return none", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 1}, {"idx": "cosqa-train-19549", "doc": "links to html pages with no duplicates code on python", "code": "def get_unique_links(self):\n        \"\"\" Get all unique links in the html of the page source.\n            Page links include those obtained from:\n            \"a\"->\"href\", \"img\"->\"src\", \"link\"->\"href\", and \"script\"->\"src\". \"\"\"\n        page_url = self.get_current_url()\n        soup = self.get_beautiful_soup(self.get_page_source())\n        links = page_utils._get_unique_links(page_url, soup)\n        return links", "code_tokens": "def get_unique_links ( self ) : page_url = self . get_current_url ( ) soup = self . get_beautiful_soup ( self . get_page_source ( ) ) links = page_utils . _get_unique_links ( page_url , soup ) return links", "docstring_tokens": "Get all unique links in the html of the page source . Page links include those obtained from : a - > href img - > src link - > href and script - > src .", "label": 0}, {"idx": "cosqa-train-19550", "doc": "python determine if prime and what factors", "code": "def is_prime(n):\n    \"\"\"\n    Check if n is a prime number\n    \"\"\"\n    if n % 2 == 0 and n > 2:\n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))", "code_tokens": "def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "docstring_tokens": "Check if n is a prime number", "label": 0}, {"idx": "cosqa-train-19551", "doc": "python choose top 4", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 1}, {"idx": "cosqa-train-19552", "doc": "python requests post parametes dict", "code": "def post(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP POST operation to API endpoint.\"\"\"\n\n        return self._request('POST', endpoint, **kwargs)", "code_tokens": "def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "docstring_tokens": "HTTP POST operation to API endpoint .", "label": 0}, {"idx": "cosqa-train-19553", "doc": "python datetime from isoformat string", "code": "def datetime_from_isoformat(value: str):\n    \"\"\"Return a datetime object from an isoformat string.\n\n    Args:\n        value (str): Datetime string in isoformat.\n\n    \"\"\"\n    if sys.version_info >= (3, 7):\n        return datetime.fromisoformat(value)\n\n    return datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%f')", "code_tokens": "def datetime_from_isoformat ( value : str ) : if sys . version_info >= ( 3 , 7 ) : return datetime . fromisoformat ( value ) return datetime . strptime ( value , '%Y-%m-%dT%H:%M:%S.%f' )", "docstring_tokens": "Return a datetime object from an isoformat string .", "label": 1}, {"idx": "cosqa-train-19554", "doc": "python check if two paths are equal", "code": "def samefile(a: str, b: str) -> bool:\n    \"\"\"Check if two pathes represent the same file.\"\"\"\n    try:\n        return os.path.samefile(a, b)\n    except OSError:\n        return os.path.normpath(a) == os.path.normpath(b)", "code_tokens": "def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )", "docstring_tokens": "Check if two pathes represent the same file .", "label": 1}, {"idx": "cosqa-train-19555", "doc": "python win32api mouse event", "code": "def mouse_event(dwFlags: int, dx: int, dy: int, dwData: int, dwExtraInfo: int) -> None:\n    \"\"\"mouse_event from Win32.\"\"\"\n    ctypes.windll.user32.mouse_event(dwFlags, dx, dy, dwData, dwExtraInfo)", "code_tokens": "def mouse_event ( dwFlags : int , dx : int , dy : int , dwData : int , dwExtraInfo : int ) -> None : ctypes . windll . user32 . mouse_event ( dwFlags , dx , dy , dwData , dwExtraInfo )", "docstring_tokens": "mouse_event from Win32 .", "label": 0}, {"idx": "cosqa-train-19556", "doc": "python flask how to access local cache", "code": "def setup_cache(app: Flask, cache_config) -> Optional[Cache]:\n    \"\"\"Setup the flask-cache on a flask app\"\"\"\n    if cache_config and cache_config.get('CACHE_TYPE') != 'null':\n        return Cache(app, config=cache_config)\n\n    return None", "code_tokens": "def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None", "docstring_tokens": "Setup the flask - cache on a flask app", "label": 1}, {"idx": "cosqa-train-19557", "doc": "conda env python not found", "code": "def _find_conda():\n    \"\"\"Find the conda executable robustly across conda versions.\n\n    Returns\n    -------\n    conda : str\n        Path to the conda executable.\n\n    Raises\n    ------\n    IOError\n        If the executable cannot be found in either the CONDA_EXE environment\n        variable or in the PATH.\n\n    Notes\n    -----\n    In POSIX platforms in conda >= 4.4, conda can be set up as a bash function\n    rather than an executable. (This is to enable the syntax\n    ``conda activate env-name``.) In this case, the environment variable\n    ``CONDA_EXE`` contains the path to the conda executable. In other cases,\n    we use standard search for the appropriate name in the PATH.\n\n    See https://github.com/airspeed-velocity/asv/issues/645 for more details.\n    \"\"\"\n    if 'CONDA_EXE' in os.environ:\n        conda = os.environ['CONDA_EXE']\n    else:\n        conda = util.which('conda')\n    return conda", "code_tokens": "def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda", "docstring_tokens": "Find the conda executable robustly across conda versions .", "label": 0}, {"idx": "cosqa-train-19558", "doc": "python raise without parentheses", "code": "def assert_or_raise(stmt: bool, exception: Exception,\n                    *exception_args, **exception_kwargs) -> None:\n  \"\"\"\n  If the statement is false, raise the given exception.\n  \"\"\"\n  if not stmt:\n    raise exception(*exception_args, **exception_kwargs)", "code_tokens": "def assert_or_raise ( stmt : bool , exception : Exception , * exception_args , * * exception_kwargs ) -> None : if not stmt : raise exception ( * exception_args , * * exception_kwargs )", "docstring_tokens": "If the statement is false raise the given exception .", "label": 1}, {"idx": "cosqa-train-19559", "doc": "how to use split on a list in python", "code": "def multi_split(s, split):\n    # type: (S, Iterable[S]) -> List[S]\n    \"\"\"Splits on multiple given separators.\"\"\"\n    for r in split:\n        s = s.replace(r, \"|\")\n    return [i for i in s.split(\"|\") if len(i) > 0]", "code_tokens": "def multi_split ( s , split ) : # type: (S, Iterable[S]) -> List[S] for r in split : s = s . replace ( r , \"|\" ) return [ i for i in s . split ( \"|\" ) if len ( i ) > 0 ]", "docstring_tokens": "Splits on multiple given separators .", "label": 1}, {"idx": "cosqa-train-19560", "doc": "how to get contents of text file in python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-19561", "doc": "python tostring javascript compatible", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 0}, {"idx": "cosqa-train-19562", "doc": "how to perform bitwise operation in python", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-19563", "doc": "python validate value is number", "code": "def clean_int(x) -> int:\n    \"\"\"\n    Returns its parameter as an integer, or raises\n    ``django.forms.ValidationError``.\n    \"\"\"\n    try:\n        return int(x)\n    except ValueError:\n        raise forms.ValidationError(\n            \"Cannot convert to integer: {}\".format(repr(x)))", "code_tokens": "def clean_int ( x ) -> int : try : return int ( x ) except ValueError : raise forms . ValidationError ( \"Cannot convert to integer: {}\" . format ( repr ( x ) ) )", "docstring_tokens": "Returns its parameter as an integer or raises django . forms . ValidationError .", "label": 0}, {"idx": "cosqa-train-19564", "doc": "python get the depth of list of list", "code": "def list_depth(list_, func=max, _depth=0):\n    \"\"\"\n    Returns the deepest level of nesting within a list of lists\n\n    Args:\n       list_  : a nested listlike object\n       func   : depth aggregation strategy (defaults to max)\n       _depth : internal var\n\n    Example:\n        >>> # ENABLE_DOCTEST\n        >>> from utool.util_list import *  # NOQA\n        >>> list_ = [[[[[1]]], [3]], [[1], [3]], [[1], [3]]]\n        >>> result = (list_depth(list_, _depth=0))\n        >>> print(result)\n\n    \"\"\"\n    depth_list = [list_depth(item, func=func, _depth=_depth + 1)\n                  for item in  list_ if util_type.is_listlike(item)]\n    if len(depth_list) > 0:\n        return func(depth_list)\n    else:\n        return _depth", "code_tokens": "def list_depth ( list_ , func = max , _depth = 0 ) : depth_list = [ list_depth ( item , func = func , _depth = _depth + 1 ) for item in list_ if util_type . is_listlike ( item ) ] if len ( depth_list ) > 0 : return func ( depth_list ) else : return _depth", "docstring_tokens": "Returns the deepest level of nesting within a list of lists", "label": 1}, {"idx": "cosqa-train-19565", "doc": "python determine if variable type is lambda function", "code": "def is_inside_lambda(node: astroid.node_classes.NodeNG) -> bool:\n    \"\"\"Return true if given node is inside lambda\"\"\"\n    parent = node.parent\n    while parent is not None:\n        if isinstance(parent, astroid.Lambda):\n            return True\n        parent = parent.parent\n    return False", "code_tokens": "def is_inside_lambda ( node : astroid . node_classes . NodeNG ) -> bool : parent = node . parent while parent is not None : if isinstance ( parent , astroid . Lambda ) : return True parent = parent . parent return False", "docstring_tokens": "Return true if given node is inside lambda", "label": 1}, {"idx": "cosqa-train-19566", "doc": "how to read file from aws s3 using python s3fs", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 1}, {"idx": "cosqa-train-19567", "doc": "all links to html pages with no duplicates vode in python", "code": "def get_unique_links(self):\n        \"\"\" Get all unique links in the html of the page source.\n            Page links include those obtained from:\n            \"a\"->\"href\", \"img\"->\"src\", \"link\"->\"href\", and \"script\"->\"src\". \"\"\"\n        page_url = self.get_current_url()\n        soup = self.get_beautiful_soup(self.get_page_source())\n        links = page_utils._get_unique_links(page_url, soup)\n        return links", "code_tokens": "def get_unique_links ( self ) : page_url = self . get_current_url ( ) soup = self . get_beautiful_soup ( self . get_page_source ( ) ) links = page_utils . _get_unique_links ( page_url , soup ) return links", "docstring_tokens": "Get all unique links in the html of the page source . Page links include those obtained from : a - > href img - > src link - > href and script - > src .", "label": 1}, {"idx": "cosqa-train-19568", "doc": "finding maximum value of column python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 1}, {"idx": "cosqa-train-19569", "doc": "how to check if a request is valid or not in python", "code": "def identify_request(request: RequestType) -> bool:\n    \"\"\"\n    Try to identify whether this is an ActivityPub request.\n    \"\"\"\n    # noinspection PyBroadException\n    try:\n        data = json.loads(decode_if_bytes(request.body))\n        if \"@context\" in data:\n            return True\n    except Exception:\n        pass\n    return False", "code_tokens": "def identify_request ( request : RequestType ) -> bool : # noinspection PyBroadException try : data = json . loads ( decode_if_bytes ( request . body ) ) if \"@context\" in data : return True except Exception : pass return False", "docstring_tokens": "Try to identify whether this is an ActivityPub request .", "label": 1}, {"idx": "cosqa-train-19570", "doc": "python types of all panda columns", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 0}, {"idx": "cosqa-train-19571", "doc": "how to check type of object in column in python", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 0}, {"idx": "cosqa-train-19572", "doc": "extract hostname from url python", "code": "def url_host(url: str) -> str:\n    \"\"\"\n    Parses hostname from URL.\n    :param url: URL\n    :return: hostname\n    \"\"\"\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "code_tokens": "def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "docstring_tokens": "Parses hostname from URL . : param url : URL : return : hostname", "label": 1}, {"idx": "cosqa-train-19573", "doc": "if key exists python do this", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 1}, {"idx": "cosqa-train-19574", "doc": "python list iterator know this is the last", "code": "def enum_mark_last(iterable, start=0):\n    \"\"\"\n    Returns a generator over iterable that tells whether the current item is the last one.\n    Usage:\n        >>> iterable = range(10)\n        >>> for index, is_last, item in enum_mark_last(iterable):\n        >>>     print(index, item, end='\\n' if is_last else ', ')\n    \"\"\"\n    it = iter(iterable)\n    count = start\n    try:\n        last = next(it)\n    except StopIteration:\n        return\n    for val in it:\n        yield count, False, last\n        last = val\n        count += 1\n    yield count, True, last", "code_tokens": "def enum_mark_last ( iterable , start = 0 ) : it = iter ( iterable ) count = start try : last = next ( it ) except StopIteration : return for val in it : yield count , False , last last = val count += 1 yield count , True , last", "docstring_tokens": "Returns a generator over iterable that tells whether the current item is the last one . Usage : >>> iterable = range ( 10 ) >>> for index is_last item in enum_mark_last ( iterable ) : >>> print ( index item end = \\ n if is_last else )", "label": 0}, {"idx": "cosqa-train-19575", "doc": "get the unique index of a list item python", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 1}, {"idx": "cosqa-train-19576", "doc": "python print function name and all params", "code": "def get_all_args(fn) -> list:\n    \"\"\"\n    Returns a list of all arguments for the function fn.\n\n    >>> def foo(x, y, z=100): return x + y + z\n    >>> get_all_args(foo)\n    ['x', 'y', 'z']\n    \"\"\"\n    sig = inspect.signature(fn)\n    return list(sig.parameters)", "code_tokens": "def get_all_args ( fn ) -> list : sig = inspect . signature ( fn ) return list ( sig . parameters )", "docstring_tokens": "Returns a list of all arguments for the function fn .", "label": 0}, {"idx": "cosqa-train-19577", "doc": "listen udev python detect keyboard", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 0}, {"idx": "cosqa-train-19578", "doc": "python dateutil get current time zone", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-19579", "doc": "how to flat a list of list python", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 1}, {"idx": "cosqa-train-19580", "doc": "python reusing a single request session", "code": "def copy_session(session: requests.Session) -> requests.Session:\n    \"\"\"Duplicates a requests.Session.\"\"\"\n    new = requests.Session()\n    new.cookies = requests.utils.cookiejar_from_dict(requests.utils.dict_from_cookiejar(session.cookies))\n    new.headers = session.headers.copy()\n    return new", "code_tokens": "def copy_session ( session : requests . Session ) -> requests . Session : new = requests . Session ( ) new . cookies = requests . utils . cookiejar_from_dict ( requests . utils . dict_from_cookiejar ( session . cookies ) ) new . headers = session . headers . copy ( ) return new", "docstring_tokens": "Duplicates a requests . Session .", "label": 0}, {"idx": "cosqa-train-19581", "doc": "python check for whitespace", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 0}, {"idx": "cosqa-train-19582", "doc": "how to draw a simple tree diagram in python without igraph", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-19583", "doc": "python passing a flattened list", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 0}, {"idx": "cosqa-train-19584", "doc": "python spacy create noun chunker", "code": "def enumerate_chunks (phrase, spacy_nlp):\n    \"\"\"\n    iterate through the noun phrases\n    \"\"\"\n    if (len(phrase) > 1):\n        found = False\n        text = \" \".join([rl.text for rl in phrase])\n        doc = spacy_nlp(text.strip(), parse=True)\n\n        for np in doc.noun_chunks:\n            if np.text != text:\n                found = True\n                yield np.text, find_chunk(phrase, np.text.split(\" \"))\n\n        if not found and all([rl.pos[0] != \"v\" for rl in phrase]):\n            yield text, phrase", "code_tokens": "def enumerate_chunks ( phrase , spacy_nlp ) : if ( len ( phrase ) > 1 ) : found = False text = \" \" . join ( [ rl . text for rl in phrase ] ) doc = spacy_nlp ( text . strip ( ) , parse = True ) for np in doc . noun_chunks : if np . text != text : found = True yield np . text , find_chunk ( phrase , np . text . split ( \" \" ) ) if not found and all ( [ rl . pos [ 0 ] != \"v\" for rl in phrase ] ) : yield text , phrase", "docstring_tokens": "iterate through the noun phrases", "label": 1}, {"idx": "cosqa-train-19585", "doc": "python custom hash functions", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 0}, {"idx": "cosqa-train-19586", "doc": "function that \"standardizes\" a column python", "code": "def convert_column(self, values):\n        \"\"\"Normalize values.\"\"\"\n        assert all(values >= 0), 'Cannot normalize a column with negatives'\n        total = sum(values)\n        if total > 0:\n            return values / total\n        else:\n            return values", "code_tokens": "def convert_column ( self , values ) : assert all ( values >= 0 ) , 'Cannot normalize a column with negatives' total = sum ( values ) if total > 0 : return values / total else : return values", "docstring_tokens": "Normalize values .", "label": 0}, {"idx": "cosqa-train-19587", "doc": "iterator python has next", "code": "def __next__(self):\n        \"\"\"\n        :return: int\n        \"\"\"\n        self.current += 1\n        if self.current > self.total:\n            raise StopIteration\n        else:\n            return self.iterable[self.current - 1]", "code_tokens": "def __next__ ( self ) : self . current += 1 if self . current > self . total : raise StopIteration else : return self . iterable [ self . current - 1 ]", "docstring_tokens": ": return : int", "label": 0}, {"idx": "cosqa-train-19588", "doc": "unique function in python for lists", "code": "def uniqued(iterable):\n    \"\"\"Return unique list of items preserving order.\n\n    >>> uniqued([3, 2, 1, 3, 2, 1, 0])\n    [3, 2, 1, 0]\n    \"\"\"\n    seen = set()\n    add = seen.add\n    return [i for i in iterable if i not in seen and not add(i)]", "code_tokens": "def uniqued ( iterable ) : seen = set ( ) add = seen . add return [ i for i in iterable if i not in seen and not add ( i ) ]", "docstring_tokens": "Return unique list of items preserving order .", "label": 0}, {"idx": "cosqa-train-19589", "doc": "python flask auto run", "code": "def run_web(self, flask, host='127.0.0.1', port=5000, **options):\n        # type: (Zsl, str, int, **Any)->None\n        \"\"\"Alias for Flask.run\"\"\"\n        return flask.run(\n            host=flask.config.get('FLASK_HOST', host),\n            port=flask.config.get('FLASK_PORT', port),\n            debug=flask.config.get('DEBUG', False),\n            **options\n        )", "code_tokens": "def run_web ( self , flask , host = '127.0.0.1' , port = 5000 , * * options ) : # type: (Zsl, str, int, **Any)->None return flask . run ( host = flask . config . get ( 'FLASK_HOST' , host ) , port = flask . config . get ( 'FLASK_PORT' , port ) , debug = flask . config . get ( 'DEBUG' , False ) , * * options )", "docstring_tokens": "Alias for Flask . run", "label": 0}, {"idx": "cosqa-train-19590", "doc": "delete table from sql using python using sql server native", "code": "def wipe_table(self, table: str) -> int:\n        \"\"\"Delete all records from a table. Use caution!\"\"\"\n        sql = \"DELETE FROM \" + self.delimit(table)\n        return self.db_exec(sql)", "code_tokens": "def wipe_table ( self , table : str ) -> int : sql = \"DELETE FROM \" + self . delimit ( table ) return self . db_exec ( sql )", "docstring_tokens": "Delete all records from a table . Use caution!", "label": 0}, {"idx": "cosqa-train-19591", "doc": "how to write text to a file in a python", "code": "def write_text(filename: str, text: str) -> None:\n    \"\"\"\n    Writes text to a file.\n    \"\"\"\n    with open(filename, 'w') as f:  # type: TextIO\n        print(text, file=f)", "code_tokens": "def write_text ( filename : str , text : str ) -> None : with open ( filename , 'w' ) as f : # type: TextIO print ( text , file = f )", "docstring_tokens": "Writes text to a file .", "label": 0}, {"idx": "cosqa-train-19592", "doc": "python dealth last week", "code": "def get_period_last_3_months() -> str:\n    \"\"\" Returns the last week as a period string \"\"\"\n    today = Datum()\n    today.today()\n\n    # start_date = today - timedelta(weeks=13)\n    start_date = today.clone()\n    start_date.subtract_months(3)\n\n    period = get_period(start_date.date, today.date)\n    return period", "code_tokens": "def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "docstring_tokens": "Returns the last week as a period string", "label": 0}, {"idx": "cosqa-train-19593", "doc": "python median filter 3d array", "code": "def fast_median(a):\n    \"\"\"Fast median operation for masked array using 50th-percentile\n    \"\"\"\n    a = checkma(a)\n    #return scoreatpercentile(a.compressed(), 50)\n    if a.count() > 0:\n        out = np.percentile(a.compressed(), 50)\n    else:\n        out = np.ma.masked\n    return out", "code_tokens": "def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out", "docstring_tokens": "Fast median operation for masked array using 50th - percentile", "label": 1}, {"idx": "cosqa-train-19594", "doc": "python determine if filename is media file", "code": "def _is_video(filepath) -> bool:\n    \"\"\"Check filename extension to see if it's a video file.\"\"\"\n    if os.path.exists(filepath):  # Could be broken symlink\n        extension = os.path.splitext(filepath)[1]\n        return extension in ('.mkv', '.mp4', '.avi')\n    else:\n        return False", "code_tokens": "def _is_video ( filepath ) -> bool : if os . path . exists ( filepath ) : # Could be broken symlink extension = os . path . splitext ( filepath ) [ 1 ] return extension in ( '.mkv' , '.mp4' , '.avi' ) else : return False", "docstring_tokens": "Check filename extension to see if it s a video file .", "label": 0}, {"idx": "cosqa-train-19595", "doc": "remove an entry from a dict python", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-19596", "doc": "how to capitalize words in python with str", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-19597", "doc": "verify if value exists in hash table python", "code": "def check_key(self, key: str) -> bool:\n        \"\"\"\n        Checks if key exists in datastore. True if yes, False if no.\n\n        :param: SHA512 hash key\n\n        :return: whether or key not exists in datastore\n        \"\"\"\n        keys = self.get_keys()\n        return key in keys", "code_tokens": "def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "docstring_tokens": "Checks if key exists in datastore . True if yes False if no .", "label": 1}, {"idx": "cosqa-train-19598", "doc": "how to get the number of value fall in each bins histogram python", "code": "def shape(self) -> Tuple[int, ...]:\n        \"\"\"Shape of histogram's data.\n\n        Returns\n        -------\n        One-element tuple with the number of bins along each axis.\n        \"\"\"\n        return tuple(bins.bin_count for bins in self._binnings)", "code_tokens": "def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )", "docstring_tokens": "Shape of histogram s data .", "label": 0}, {"idx": "cosqa-train-19599", "doc": "python how to change column to uppercase", "code": "def str_upper(x):\n    \"\"\"Converts all strings in a column to uppercase.\n\n    :returns: an expression containing the converted strings.\n\n    Example:\n\n    >>> import vaex\n    >>> text = ['Something', 'very pretty', 'is coming', 'our', 'way.']\n    >>> df = vaex.from_arrays(text=text)\n    >>> df\n      #  text\n      0  Something\n      1  very pretty\n      2  is coming\n      3  our\n      4  way.\n\n\n    >>> df.text.str.upper()\n    Expression = str_upper(text)\n    Length: 5 dtype: str (expression)\n    ---------------------------------\n    0    SOMETHING\n    1  VERY PRETTY\n    2    IS COMING\n    3          OUR\n    4         WAY.\n\n    \"\"\"\n    sl = _to_string_sequence(x).upper()\n    return column.ColumnStringArrow(sl.bytes, sl.indices, sl.length, sl.offset, string_sequence=sl)", "code_tokens": "def str_upper ( x ) : sl = _to_string_sequence ( x ) . upper ( ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "docstring_tokens": "Converts all strings in a column to uppercase .", "label": 0}, {"idx": "cosqa-train-19600", "doc": "combine multiple pdfs into one python", "code": "def combine_pdf_as_bytes(pdfs: List[BytesIO]) -> bytes:\n    \"\"\"Combine PDFs and return a byte-string with the result.\n\n    Arguments\n    ---------\n    pdfs\n        A list of BytesIO representations of PDFs\n\n    \"\"\"\n    writer = PdfWriter()\n    for pdf in pdfs:\n        writer.addpages(PdfReader(pdf).pages)\n    bio = BytesIO()\n    writer.write(bio)\n    bio.seek(0)\n    output = bio.read()\n    bio.close()\n    return output", "code_tokens": "def combine_pdf_as_bytes ( pdfs : List [ BytesIO ] ) -> bytes : writer = PdfWriter ( ) for pdf in pdfs : writer . addpages ( PdfReader ( pdf ) . pages ) bio = BytesIO ( ) writer . write ( bio ) bio . seek ( 0 ) output = bio . read ( ) bio . close ( ) return output", "docstring_tokens": "Combine PDFs and return a byte - string with the result .", "label": 1}, {"idx": "cosqa-train-19601", "doc": "python get number of cpu cores", "code": "def cpu_count() -> int:\n    \"\"\"Returns the number of processors on this machine.\"\"\"\n    if multiprocessing is None:\n        return 1\n    try:\n        return multiprocessing.cpu_count()\n    except NotImplementedError:\n        pass\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_CONF\")\n    except (AttributeError, ValueError):\n        pass\n    gen_log.error(\"Could not detect number of processors; assuming 1\")\n    return 1", "code_tokens": "def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( \"SC_NPROCESSORS_CONF\" ) except ( AttributeError , ValueError ) : pass gen_log . error ( \"Could not detect number of processors; assuming 1\" ) return 1", "docstring_tokens": "Returns the number of processors on this machine .", "label": 1}, {"idx": "cosqa-train-19602", "doc": "python numpy ndarray to string", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 1}, {"idx": "cosqa-train-19603", "doc": "python using arrays to return multiple values", "code": "def to_np(*args):\n    \"\"\" convert GPU arras to numpy and return them\"\"\"\n    if len(args) > 1:\n        return (cp.asnumpy(x) for x in args)\n    else:\n        return cp.asnumpy(args[0])", "code_tokens": "def to_np ( * args ) : if len ( args ) > 1 : return ( cp . asnumpy ( x ) for x in args ) else : return cp . asnumpy ( args [ 0 ] )", "docstring_tokens": "convert GPU arras to numpy and return them", "label": 1}, {"idx": "cosqa-train-19604", "doc": "python if i is not equal to and integer", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 1}, {"idx": "cosqa-train-19605", "doc": "psutil python memory leak", "code": "def psutil_phymem_usage():\n    \"\"\"\n    Return physical memory usage (float)\n    Requires the cross-platform psutil (>=v0.3) library\n    (https://github.com/giampaolo/psutil)\n    \"\"\"\n    import psutil\n    # This is needed to avoid a deprecation warning error with\n    # newer psutil versions\n    try:\n        percent = psutil.virtual_memory().percent\n    except:\n        percent = psutil.phymem_usage().percent\n    return percent", "code_tokens": "def psutil_phymem_usage ( ) : import psutil # This is needed to avoid a deprecation warning error with\n # newer psutil versions\n try : percent = psutil . virtual_memory ( ) . percent except : percent = psutil . phymem_usage ( ) . percent return percent", "docstring_tokens": "Return physical memory usage ( float ) Requires the cross - platform psutil ( > = v0 . 3 ) library ( https : // github . com / giampaolo / psutil )", "label": 0}, {"idx": "cosqa-train-19606", "doc": "generating integer partitions python", "code": "def integer_partition(size: int, nparts: int) -> Iterator[List[List[int]]]:\n    \"\"\" Partition a list of integers into a list of partitions \"\"\"\n    for part in algorithm_u(range(size), nparts):\n        yield part", "code_tokens": "def integer_partition ( size : int , nparts : int ) -> Iterator [ List [ List [ int ] ] ] : for part in algorithm_u ( range ( size ) , nparts ) : yield part", "docstring_tokens": "Partition a list of integers into a list of partitions", "label": 0}, {"idx": "cosqa-train-19607", "doc": "how to use the capitalize function in python", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 1}, {"idx": "cosqa-train-19608", "doc": "how to check if a string is int or not python", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 0}, {"idx": "cosqa-train-19609", "doc": "verify date string yyyymmdd python", "code": "def valid_date(x: str) -> bool:\n    \"\"\"\n    Retrun ``True`` if ``x`` is a valid YYYYMMDD date;\n    otherwise return ``False``.\n    \"\"\"\n    try:\n        if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT):\n            raise ValueError\n        return True\n    except ValueError:\n        return False", "code_tokens": "def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "docstring_tokens": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False .", "label": 1}, {"idx": "cosqa-train-19610", "doc": "python check if date is expired", "code": "def session_expired(self):\n        \"\"\"\n        Returns True if login_time not set or seconds since\n        login time is greater than 200 mins.\n        \"\"\"\n        if not self._login_time or (datetime.datetime.now()-self._login_time).total_seconds() > 12000:\n            return True", "code_tokens": "def session_expired ( self ) : if not self . _login_time or ( datetime . datetime . now ( ) - self . _login_time ) . total_seconds ( ) > 12000 : return True", "docstring_tokens": "Returns True if login_time not set or seconds since login time is greater than 200 mins .", "label": 1}, {"idx": "cosqa-train-19611", "doc": "return list of top values python", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 0}, {"idx": "cosqa-train-19612", "doc": "how to make random names in python", "code": "def random_name_gen(size=6):\n    \"\"\"Generate a random python attribute name.\"\"\"\n\n    return ''.join(\n        [random.choice(string.ascii_uppercase)] +\n        [random.choice(string.ascii_uppercase + string.digits) for i in range(size - 1)]\n    ) if size > 0 else ''", "code_tokens": "def random_name_gen ( size = 6 ) : return '' . join ( [ random . choice ( string . ascii_uppercase ) ] + [ random . choice ( string . ascii_uppercase + string . digits ) for i in range ( size - 1 ) ] ) if size > 0 else ''", "docstring_tokens": "Generate a random python attribute name .", "label": 0}, {"idx": "cosqa-train-19613", "doc": "python parse tuple rest", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 1}, {"idx": "cosqa-train-19614", "doc": "use python to realize auto completion", "code": "def repl_complete(text: str, state: int) -> Optional[str]:\n    \"\"\"Completer function for Python's readline/libedit implementation.\"\"\"\n    # Can't complete Keywords, Numerals\n    if __NOT_COMPLETEABLE.match(text):\n        return None\n    elif text.startswith(\":\"):\n        completions = kw.complete(text)\n    else:\n        ns = get_current_ns()\n        completions = ns.complete(text)\n\n    return list(completions)[state] if completions is not None else None", "code_tokens": "def repl_complete ( text : str , state : int ) -> Optional [ str ] : # Can't complete Keywords, Numerals if __NOT_COMPLETEABLE . match ( text ) : return None elif text . startswith ( \":\" ) : completions = kw . complete ( text ) else : ns = get_current_ns ( ) completions = ns . complete ( text ) return list ( completions ) [ state ] if completions is not None else None", "docstring_tokens": "Completer function for Python s readline / libedit implementation .", "label": 0}, {"idx": "cosqa-train-19615", "doc": "python remove all instances of a char", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 1}, {"idx": "cosqa-train-19616", "doc": "how to print few elements from a list in python", "code": "def _brief_print_list(lst, limit=7):\n    \"\"\"Print at most `limit` elements of list.\"\"\"\n    lst = list(lst)\n    if len(lst) > limit:\n        return _brief_print_list(lst[:limit//2], limit) + ', ..., ' + \\\n            _brief_print_list(lst[-limit//2:], limit)\n    return ', '.join([\"'%s'\"%str(i) for i in lst])", "code_tokens": "def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "docstring_tokens": "Print at most limit elements of list .", "label": 0}, {"idx": "cosqa-train-19617", "doc": "python normalize set of numbers", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 1}, {"idx": "cosqa-train-19618", "doc": "rest json schema validation python", "code": "def validate(request: Union[Dict, List], schema: dict) -> Union[Dict, List]:\n    \"\"\"\n    Wraps jsonschema.validate, returning the same object passed in.\n\n    Args:\n        request: The deserialized-from-json request.\n        schema: The jsonschema schema to validate against.\n\n    Raises:\n        jsonschema.ValidationError\n    \"\"\"\n    jsonschema_validate(request, schema)\n    return request", "code_tokens": "def validate ( request : Union [ Dict , List ] , schema : dict ) -> Union [ Dict , List ] : jsonschema_validate ( request , schema ) return request", "docstring_tokens": "Wraps jsonschema . validate returning the same object passed in .", "label": 1}, {"idx": "cosqa-train-19619", "doc": "how to check file is empty or not in python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 1}, {"idx": "cosqa-train-19620", "doc": "get all max values in dict python", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 0}, {"idx": "cosqa-train-19621", "doc": "last day of month datetime python", "code": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day", "code_tokens": "def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "docstring_tokens": "Returns day number of the last day of the month : param t : datetime : return : int", "label": 1}, {"idx": "cosqa-train-19622", "doc": "casting a string to integer python", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 0}, {"idx": "cosqa-train-19623", "doc": "how to standardize numbers to between 0 and 1 in python", "code": "def normalize(numbers):\n    \"\"\"Multiply each number by a constant such that the sum is 1.0\n    >>> normalize([1,2,1])\n    [0.25, 0.5, 0.25]\n    \"\"\"\n    total = float(sum(numbers))\n    return [n / total for n in numbers]", "code_tokens": "def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "docstring_tokens": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]", "label": 0}, {"idx": "cosqa-train-19624", "doc": "strip non latin characters from python text", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 1}, {"idx": "cosqa-train-19625", "doc": "python skip over blank lines while reading", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-19626", "doc": "remove all encountered char in str python", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 0}, {"idx": "cosqa-train-19627", "doc": "make set of numbers a list python", "code": "def ranges_to_set(lst):\n    \"\"\"\n    Convert a list of ranges to a set of numbers::\n\n    >>> ranges = [(1,3), (5,6)]\n    >>> sorted(list(ranges_to_set(ranges)))\n    [1, 2, 3, 5, 6]\n\n    \"\"\"\n    return set(itertools.chain(*(range(x[0], x[1]+1) for x in lst)))", "code_tokens": "def ranges_to_set ( lst ) : return set ( itertools . chain ( * ( range ( x [ 0 ] , x [ 1 ] + 1 ) for x in lst ) ) )", "docstring_tokens": "Convert a list of ranges to a set of numbers ::", "label": 0}, {"idx": "cosqa-train-19628", "doc": "python change a list of number to string", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 0}, {"idx": "cosqa-train-19629", "doc": "count number of occurrences in a list python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 0}, {"idx": "cosqa-train-19630", "doc": "python create code dependecy graph", "code": "def make_dep_graph(depender):\n\t\"\"\"Returns a digraph string fragment based on the passed-in module\n\t\"\"\"\n\tshutit_global.shutit_global_object.yield_to_draw()\n\tdigraph = ''\n\tfor dependee_id in depender.depends_on:\n\t\tdigraph = (digraph + '\"' + depender.module_id + '\"->\"' + dependee_id + '\";\\n')\n\treturn digraph", "code_tokens": "def make_dep_graph ( depender ) : shutit_global . shutit_global_object . yield_to_draw ( ) digraph = '' for dependee_id in depender . depends_on : digraph = ( digraph + '\"' + depender . module_id + '\"->\"' + dependee_id + '\";\\n' ) return digraph", "docstring_tokens": "Returns a digraph string fragment based on the passed - in module", "label": 1}, {"idx": "cosqa-train-19631", "doc": "get single col python 2d array", "code": "def quaternion_imag(quaternion):\n    \"\"\"Return imaginary part of quaternion.\n\n    >>> quaternion_imag([3, 0, 1, 2])\n    array([ 0.,  1.,  2.])\n\n    \"\"\"\n    return numpy.array(quaternion[1:4], dtype=numpy.float64, copy=True)", "code_tokens": "def quaternion_imag ( quaternion ) : return numpy . array ( quaternion [ 1 : 4 ] , dtype = numpy . float64 , copy = True )", "docstring_tokens": "Return imaginary part of quaternion .", "label": 0}, {"idx": "cosqa-train-19632", "doc": "how to replace multiple strings with one string in python 3", "code": "def multiple_replace(string, replacements):\n    # type: (str, Dict[str,str]) -> str\n    \"\"\"Simultaneously replace multiple strigns in a string\n\n    Args:\n        string (str): Input string\n        replacements (Dict[str,str]): Replacements dictionary\n\n    Returns:\n        str: String with replacements\n\n    \"\"\"\n    pattern = re.compile(\"|\".join([re.escape(k) for k in sorted(replacements, key=len, reverse=True)]), flags=re.DOTALL)\n    return pattern.sub(lambda x: replacements[x.group(0)], string)", "code_tokens": "def multiple_replace ( string , replacements ) : # type: (str, Dict[str,str]) -> str pattern = re . compile ( \"|\" . join ( [ re . escape ( k ) for k in sorted ( replacements , key = len , reverse = True ) ] ) , flags = re . DOTALL ) return pattern . sub ( lambda x : replacements [ x . group ( 0 ) ] , string )", "docstring_tokens": "Simultaneously replace multiple strigns in a string", "label": 0}, {"idx": "cosqa-train-19633", "doc": "python code to check if file is empty", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 1}, {"idx": "cosqa-train-19634", "doc": "python read last lines", "code": "def _read_section(self):\n        \"\"\"Read and return an entire section\"\"\"\n        lines = [self._last[self._last.find(\":\")+1:]]\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            lines.append(self._last)\n            self._last = self._f.readline()\n        return lines", "code_tokens": "def _read_section ( self ) : lines = [ self . _last [ self . _last . find ( \":\" ) + 1 : ] ] self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : lines . append ( self . _last ) self . _last = self . _f . readline ( ) return lines", "docstring_tokens": "Read and return an entire section", "label": 0}, {"idx": "cosqa-train-19635", "doc": "python parse a line into tokens", "code": "def get_tokens(line: str) -> Iterator[str]:\n    \"\"\"\n    Yields tokens from input string.\n\n    :param line: Input string.\n    :return: Iterator over tokens.\n    \"\"\"\n    for token in line.rstrip().split():\n        if len(token) > 0:\n            yield token", "code_tokens": "def get_tokens ( line : str ) -> Iterator [ str ] : for token in line . rstrip ( ) . split ( ) : if len ( token ) > 0 : yield token", "docstring_tokens": "Yields tokens from input string .", "label": 1}, {"idx": "cosqa-train-19636", "doc": "python join list to string by comma", "code": "def list_to_str(lst):\n    \"\"\"\n    Turn a list into a comma- and/or and-separated string.\n\n    Parameters\n    ----------\n    lst : :obj:`list`\n        A list of strings to join into a single string.\n\n    Returns\n    -------\n    str_ : :obj:`str`\n        A string with commas and/or ands separating th elements from ``lst``.\n\n    \"\"\"\n    if len(lst) == 1:\n        str_ = lst[0]\n    elif len(lst) == 2:\n        str_ = ' and '.join(lst)\n    elif len(lst) > 2:\n        str_ = ', '.join(lst[:-1])\n        str_ += ', and {0}'.format(lst[-1])\n    else:\n        raise ValueError('List of length 0 provided.')\n    return str_", "code_tokens": "def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "docstring_tokens": "Turn a list into a comma - and / or and - separated string .", "label": 0}, {"idx": "cosqa-train-19637", "doc": "python how to make randomwalk work", "code": "def returned(n):\n\t\"\"\"Generate a random walk and return True if the walker has returned to\n\tthe origin after taking `n` steps.\n\t\"\"\"\n\t## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk\n\tfor pos in randwalk() >> drop(1) >> takei(xrange(n-1)):\n\t\tif pos == Origin:\n\t\t\treturn True\n\treturn False", "code_tokens": "def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "docstring_tokens": "Generate a random walk and return True if the walker has returned to the origin after taking n steps .", "label": 0}, {"idx": "cosqa-train-19638", "doc": "python get the maximum length of string objects in a list", "code": "def _prm_get_longest_stringsize(string_list):\n        \"\"\" Returns the longest string size for a string entry across data.\"\"\"\n        maxlength = 1\n\n        for stringar in string_list:\n            if isinstance(stringar, np.ndarray):\n                if stringar.ndim > 0:\n                    for string in stringar.ravel():\n                        maxlength = max(len(string), maxlength)\n                else:\n                    maxlength = max(len(stringar.tolist()), maxlength)\n            else:\n                maxlength = max(len(stringar), maxlength)\n\n        # Make the string Col longer than needed in order to allow later on slightly larger strings\n        return int(maxlength * 1.5)", "code_tokens": "def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "docstring_tokens": "Returns the longest string size for a string entry across data .", "label": 1}, {"idx": "cosqa-train-19639", "doc": "how to store the smallest number in array in python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 0}, {"idx": "cosqa-train-19640", "doc": "fibonacci sequence upto 8 python", "code": "def fib(n):\n    \"\"\"Fibonacci example function\n\n    Args:\n      n (int): integer\n\n    Returns:\n      int: n-th Fibonacci number\n    \"\"\"\n    assert n > 0\n    a, b = 1, 1\n    for i in range(n - 1):\n        a, b = b, a + b\n    return a", "code_tokens": "def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a", "docstring_tokens": "Fibonacci example function", "label": 1}, {"idx": "cosqa-train-19641", "doc": "multiply matrix with different constant in python", "code": "def __rmatmul__(self, other):\n        \"\"\"\n        Matrix multiplication using binary `@` operator in Python>=3.5.\n        \"\"\"\n        return self.T.dot(np.transpose(other)).T", "code_tokens": "def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T", "docstring_tokens": "Matrix multiplication using binary", "label": 1}, {"idx": "cosqa-train-19642", "doc": "python for enumerate last item", "code": "def enum_mark_last(iterable, start=0):\n    \"\"\"\n    Returns a generator over iterable that tells whether the current item is the last one.\n    Usage:\n        >>> iterable = range(10)\n        >>> for index, is_last, item in enum_mark_last(iterable):\n        >>>     print(index, item, end='\\n' if is_last else ', ')\n    \"\"\"\n    it = iter(iterable)\n    count = start\n    try:\n        last = next(it)\n    except StopIteration:\n        return\n    for val in it:\n        yield count, False, last\n        last = val\n        count += 1\n    yield count, True, last", "code_tokens": "def enum_mark_last ( iterable , start = 0 ) : it = iter ( iterable ) count = start try : last = next ( it ) except StopIteration : return for val in it : yield count , False , last last = val count += 1 yield count , True , last", "docstring_tokens": "Returns a generator over iterable that tells whether the current item is the last one . Usage : >>> iterable = range ( 10 ) >>> for index is_last item in enum_mark_last ( iterable ) : >>> print ( index item end = \\ n if is_last else )", "label": 0}, {"idx": "cosqa-train-19643", "doc": "python code to calculate the most frequent", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 0}, {"idx": "cosqa-train-19644", "doc": "serial python send commands", "code": "def command(self, cmd, *args):\n        \"\"\"\n        Sends a command and an (optional) sequence of arguments through to the\n        delegated serial interface. Note that the arguments are passed through\n        as data.\n        \"\"\"\n        self._serial_interface.command(cmd)\n        if len(args) > 0:\n            self._serial_interface.data(list(args))", "code_tokens": "def command ( self , cmd , * args ) : self . _serial_interface . command ( cmd ) if len ( args ) > 0 : self . _serial_interface . data ( list ( args ) )", "docstring_tokens": "Sends a command and an ( optional ) sequence of arguments through to the delegated serial interface . Note that the arguments are passed through as data .", "label": 1}, {"idx": "cosqa-train-19645", "doc": "remove all the items from the dictionary in python", "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]:\n    \"\"\"\n    Return a new copied dictionary without the keys with ``None`` values from\n    the given Mapping object.\n    \"\"\"\n    return {k: v for k, v in obj.items() if v is not None}", "code_tokens": "def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "docstring_tokens": "Return a new copied dictionary without the keys with None values from the given Mapping object .", "label": 0}, {"idx": "cosqa-train-19646", "doc": "python sqlalchemy set data type", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 0}, {"idx": "cosqa-train-19647", "doc": "python how to check if any two variables are greater than zero", "code": "def non_increasing(values):\n    \"\"\"True if values are not increasing.\"\"\"\n    return all(x >= y for x, y in zip(values, values[1:]))", "code_tokens": "def non_increasing ( values ) : return all ( x >= y for x , y in zip ( values , values [ 1 : ] ) )", "docstring_tokens": "True if values are not increasing .", "label": 0}, {"idx": "cosqa-train-19648", "doc": "get window dimensions python", "code": "def get_window_dim():\n    \"\"\" gets the dimensions depending on python version and os\"\"\"\n    version = sys.version_info\n\n    if version >= (3, 3):\n        return _size_36()\n    if platform.system() == 'Windows':\n        return _size_windows()\n    return _size_27()", "code_tokens": "def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )", "docstring_tokens": "gets the dimensions depending on python version and os", "label": 1}, {"idx": "cosqa-train-19649", "doc": "get last 5 months on a date column in python", "code": "def get_period_last_3_months() -> str:\n    \"\"\" Returns the last week as a period string \"\"\"\n    today = Datum()\n    today.today()\n\n    # start_date = today - timedelta(weeks=13)\n    start_date = today.clone()\n    start_date.subtract_months(3)\n\n    period = get_period(start_date.date, today.date)\n    return period", "code_tokens": "def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "docstring_tokens": "Returns the last week as a period string", "label": 0}, {"idx": "cosqa-train-19650", "doc": "initialize a 2d array in python without numpy", "code": "def to_0d_array(value: Any) -> np.ndarray:\n    \"\"\"Given a value, wrap it in a 0-D numpy.ndarray.\n    \"\"\"\n    if np.isscalar(value) or (isinstance(value, np.ndarray) and\n                              value.ndim == 0):\n        return np.array(value)\n    else:\n        return to_0d_object_array(value)", "code_tokens": "def to_0d_array ( value : Any ) -> np . ndarray : if np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and value . ndim == 0 ) : return np . array ( value ) else : return to_0d_object_array ( value )", "docstring_tokens": "Given a value wrap it in a 0 - D numpy . ndarray .", "label": 1}, {"idx": "cosqa-train-19651", "doc": "how to test if a set is a subset of another in python", "code": "def issubset(self, other):\n        \"\"\"\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        \"\"\"\n        if len(self) > len(other):  # Fast check for obvious cases\n            return False\n        return all(item in other for item in self)", "code_tokens": "def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "docstring_tokens": "Report whether another set contains this set .", "label": 0}, {"idx": "cosqa-train-19652", "doc": "python semantic completion youcompleteme", "code": "def repl_complete(text: str, state: int) -> Optional[str]:\n    \"\"\"Completer function for Python's readline/libedit implementation.\"\"\"\n    # Can't complete Keywords, Numerals\n    if __NOT_COMPLETEABLE.match(text):\n        return None\n    elif text.startswith(\":\"):\n        completions = kw.complete(text)\n    else:\n        ns = get_current_ns()\n        completions = ns.complete(text)\n\n    return list(completions)[state] if completions is not None else None", "code_tokens": "def repl_complete ( text : str , state : int ) -> Optional [ str ] : # Can't complete Keywords, Numerals if __NOT_COMPLETEABLE . match ( text ) : return None elif text . startswith ( \":\" ) : completions = kw . complete ( text ) else : ns = get_current_ns ( ) completions = ns . complete ( text ) return list ( completions ) [ state ] if completions is not None else None", "docstring_tokens": "Completer function for Python s readline / libedit implementation .", "label": 1}, {"idx": "cosqa-train-19653", "doc": "showing hypthsis symbols in python", "code": "def fprint(expr, print_ascii=False):\n    r\"\"\"This function chooses whether to use ascii characters to represent\n    a symbolic expression in the notebook or to use sympy's pprint.\n\n    >>> from sympy import cos\n    >>> omega=Symbol(\"omega\")\n    >>> fprint(cos(omega),print_ascii=True)\n    cos(omega)\n\n\n    \"\"\"\n    if print_ascii:\n        pprint(expr, use_unicode=False, num_columns=120)\n    else:\n        return expr", "code_tokens": "def fprint ( expr , print_ascii = False ) : if print_ascii : pprint ( expr , use_unicode = False , num_columns = 120 ) else : return expr", "docstring_tokens": "r This function chooses whether to use ascii characters to represent a symbolic expression in the notebook or to use sympy s pprint .", "label": 0}, {"idx": "cosqa-train-19654", "doc": "python array to torch tensor", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 1}, {"idx": "cosqa-train-19655", "doc": "to check if a particular string is whitespace python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 1}, {"idx": "cosqa-train-19656", "doc": "python'float' object has no attribute 'getvalue'", "code": "def get_property_as_float(self, name: str) -> float:\n        \"\"\"Return the value of a float property.\n\n        :return: The property value (float).\n\n        Raises exception if property with name doesn't exist.\n\n        .. versionadded:: 1.0\n\n        Scriptable: Yes\n        \"\"\"\n        return float(self.__instrument.get_property(name))", "code_tokens": "def get_property_as_float ( self , name : str ) -> float : return float ( self . __instrument . get_property ( name ) )", "docstring_tokens": "Return the value of a float property .", "label": 1}, {"idx": "cosqa-train-19657", "doc": "print all cycles in a directed graph in python", "code": "def get_triangles(graph: DiGraph) -> SetOfNodeTriples:\n    \"\"\"Get a set of triples representing the 3-cycles from a directional graph.\n\n    Each 3-cycle is returned once, with nodes in sorted order.\n    \"\"\"\n    return {\n        tuple(sorted([a, b, c], key=str))\n        for a, b in graph.edges()\n        for c in graph.successors(b)\n        if graph.has_edge(c, a)\n    }", "code_tokens": "def get_triangles ( graph : DiGraph ) -> SetOfNodeTriples : return { tuple ( sorted ( [ a , b , c ] , key = str ) ) for a , b in graph . edges ( ) for c in graph . successors ( b ) if graph . has_edge ( c , a ) }", "docstring_tokens": "Get a set of triples representing the 3 - cycles from a directional graph .", "label": 0}, {"idx": "cosqa-train-19658", "doc": "check if a path is a file or a directory in python", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 1}, {"idx": "cosqa-train-19659", "doc": "python remove file using wildcard", "code": "def rmglob(pattern: str) -> None:\n    \"\"\"\n    Deletes all files whose filename matches the glob ``pattern`` (via\n    :func:`glob.glob`).\n    \"\"\"\n    for f in glob.glob(pattern):\n        os.remove(f)", "code_tokens": "def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "docstring_tokens": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .", "label": 1}, {"idx": "cosqa-train-19660", "doc": "check if a column is null python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-19661", "doc": "python check if line exists in file", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 1}, {"idx": "cosqa-train-19662", "doc": "python third friday of month", "code": "def after_third_friday(day=None):\n    \"\"\" check if day is after month's 3rd friday \"\"\"\n    day = day if day is not None else datetime.datetime.now()\n    now = day.replace(day=1, hour=16, minute=0, second=0, microsecond=0)\n    now += relativedelta.relativedelta(weeks=2, weekday=relativedelta.FR)\n    return day > now", "code_tokens": "def after_third_friday ( day = None ) : day = day if day is not None else datetime . datetime . now ( ) now = day . replace ( day = 1 , hour = 16 , minute = 0 , second = 0 , microsecond = 0 ) now += relativedelta . relativedelta ( weeks = 2 , weekday = relativedelta . FR ) return day > now", "docstring_tokens": "check if day is after month s 3rd friday", "label": 1}, {"idx": "cosqa-train-19663", "doc": "python limit duration function execution metadata", "code": "def timeit (func, log, limit):\n    \"\"\"Print execution time of the function. For quick'n'dirty profiling.\"\"\"\n\n    def newfunc (*args, **kwargs):\n        \"\"\"Execute function and print execution time.\"\"\"\n        t = time.time()\n        res = func(*args, **kwargs)\n        duration = time.time() - t\n        if duration > limit:\n            print(func.__name__, \"took %0.2f seconds\" % duration, file=log)\n            print(args, file=log)\n            print(kwargs, file=log)\n        return res\n    return update_func_meta(newfunc, func)", "code_tokens": "def timeit ( func , log , limit ) : def newfunc ( * args , * * kwargs ) : \"\"\"Execute function and print execution time.\"\"\" t = time . time ( ) res = func ( * args , * * kwargs ) duration = time . time ( ) - t if duration > limit : print ( func . __name__ , \"took %0.2f seconds\" % duration , file = log ) print ( args , file = log ) print ( kwargs , file = log ) return res return update_func_meta ( newfunc , func )", "docstring_tokens": "Print execution time of the function . For quick n dirty profiling .", "label": 1}, {"idx": "cosqa-train-19664", "doc": "bit mask funtion in python", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-19665", "doc": "assert in or assertcontain in python", "code": "def assert_in(first, second, msg_fmt=\"{msg}\"):\n    \"\"\"Fail if first is not in collection second.\n\n    >>> assert_in(\"foo\", [4, \"foo\", {}])\n    >>> assert_in(\"bar\", [4, \"foo\", {}])\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'bar' not in [4, 'foo', {}]\n\n    The following msg_fmt arguments are supported:\n    * msg - the default error message\n    * first - the element looked for\n    * second - the container looked in\n    \"\"\"\n\n    if first not in second:\n        msg = \"{!r} not in {!r}\".format(first, second)\n        fail(msg_fmt.format(msg=msg, first=first, second=second))", "code_tokens": "def assert_in ( first , second , msg_fmt = \"{msg}\" ) : if first not in second : msg = \"{!r} not in {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "docstring_tokens": "Fail if first is not in collection second .", "label": 0}, {"idx": "cosqa-train-19666", "doc": "are python dictionaries case sensitive", "code": "def get_case_insensitive_dict_key(d: Dict, k: str) -> Optional[str]:\n    \"\"\"\n    Within the dictionary ``d``, find a key that matches (in case-insensitive\n    fashion) the key ``k``, and return it (or ``None`` if there isn't one).\n    \"\"\"\n    for key in d.keys():\n        if k.lower() == key.lower():\n            return key\n    return None", "code_tokens": "def get_case_insensitive_dict_key ( d : Dict , k : str ) -> Optional [ str ] : for key in d . keys ( ) : if k . lower ( ) == key . lower ( ) : return key return None", "docstring_tokens": "Within the dictionary d find a key that matches ( in case - insensitive fashion ) the key k and return it ( or None if there isn t one ) .", "label": 0}, {"idx": "cosqa-train-19667", "doc": "python code to check for whitespaces", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 1}, {"idx": "cosqa-train-19668", "doc": "how to determine an object's data type python", "code": "def maybe_infer_dtype_type(element):\n    \"\"\"Try to infer an object's dtype, for use in arithmetic ops\n\n    Uses `element.dtype` if that's available.\n    Objects implementing the iterator protocol are cast to a NumPy array,\n    and from there the array's type is used.\n\n    Parameters\n    ----------\n    element : object\n        Possibly has a `.dtype` attribute, and possibly the iterator\n        protocol.\n\n    Returns\n    -------\n    tipo : type\n\n    Examples\n    --------\n    >>> from collections import namedtuple\n    >>> Foo = namedtuple(\"Foo\", \"dtype\")\n    >>> maybe_infer_dtype_type(Foo(np.dtype(\"i8\")))\n    numpy.int64\n    \"\"\"\n    tipo = None\n    if hasattr(element, 'dtype'):\n        tipo = element.dtype\n    elif is_list_like(element):\n        element = np.asarray(element)\n        tipo = element.dtype\n    return tipo", "code_tokens": "def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "docstring_tokens": "Try to infer an object s dtype for use in arithmetic ops", "label": 1}, {"idx": "cosqa-train-19669", "doc": "python break or exit command", "code": "def do_quit(self, _: argparse.Namespace) -> bool:\n        \"\"\"Exit this application\"\"\"\n        self._should_quit = True\n        return self._STOP_AND_EXIT", "code_tokens": "def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "docstring_tokens": "Exit this application", "label": 0}, {"idx": "cosqa-train-19670", "doc": "python flatten list inside list", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 1}, {"idx": "cosqa-train-19671", "doc": "python return ordereddict from db cursor", "code": "def dictfetchall(cursor: Cursor) -> List[Dict[str, Any]]:\n    \"\"\"\n    Return all rows from a cursor as a list of :class:`OrderedDict` objects.\n\n    Args:\n        cursor: the cursor\n\n    Returns:\n        a list (one item per row) of :class:`OrderedDict` objects whose key are\n        column names and whose values are the row values\n    \"\"\"\n    columns = get_fieldnames_from_cursor(cursor)\n    return [\n        OrderedDict(zip(columns, row))\n        for row in cursor.fetchall()\n    ]", "code_tokens": "def dictfetchall ( cursor : Cursor ) -> List [ Dict [ str , Any ] ] : columns = get_fieldnames_from_cursor ( cursor ) return [ OrderedDict ( zip ( columns , row ) ) for row in cursor . fetchall ( ) ]", "docstring_tokens": "Return all rows from a cursor as a list of : class : OrderedDict objects .", "label": 1}, {"idx": "cosqa-train-19672", "doc": "write a function that counts the number of times an element appears in a list python", "code": "def count(args):\n    \"\"\" count occurences in a list of lists\n    >>> count([['a','b'],['a']])\n    defaultdict(int, {'a' : 2, 'b' : 1})\n    \"\"\"\n    counts = defaultdict(int)\n    for arg in args:\n        for item in arg:\n            counts[item] = counts[item] + 1\n    return counts", "code_tokens": "def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "docstring_tokens": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )", "label": 1}, {"idx": "cosqa-train-19673", "doc": "python get url from just a domain name", "code": "def get_domain(url):\n    \"\"\"\n    Get domain part of an url.\n\n    For example: https://www.python.org/doc/ -> https://www.python.org\n    \"\"\"\n    parse_result = urlparse(url)\n    domain = \"{schema}://{netloc}\".format(\n        schema=parse_result.scheme, netloc=parse_result.netloc)\n    return domain", "code_tokens": "def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "docstring_tokens": "Get domain part of an url .", "label": 0}, {"idx": "cosqa-train-19674", "doc": "how to pass an http request in python", "code": "def _request(self, method: str, endpoint: str, params: dict = None, data: dict = None, headers: dict = None) -> dict:\n        \"\"\"HTTP request method of interface implementation.\"\"\"", "code_tokens": "def _request ( self , method : str , endpoint : str , params : dict = None , data : dict = None , headers : dict = None ) -> dict :", "docstring_tokens": "HTTP request method of interface implementation .", "label": 1}, {"idx": "cosqa-train-19675", "doc": "comparison to see if it is non numerical value in python", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 1}, {"idx": "cosqa-train-19676", "doc": "python skip for new line in file", "code": "def _skip_section(self):\n        \"\"\"Skip a section\"\"\"\n        self._last = self._f.readline()\n        while len(self._last) > 0 and len(self._last[0].strip()) == 0:\n            self._last = self._f.readline()", "code_tokens": "def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "docstring_tokens": "Skip a section", "label": 1}, {"idx": "cosqa-train-19677", "doc": "how display contents of a text file in python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-19678", "doc": "python create dictionary given list of values and list of keys", "code": "def encode_list(key, list_):\n    # type: (str, Iterable) -> Dict[str, str]\n    \"\"\"\n    Converts a list into a space-separated string and puts it in a dictionary\n\n    :param key: Dictionary key to store the list\n    :param list_: A list of objects\n    :return: A dictionary key->string or an empty dictionary\n    \"\"\"\n    if not list_:\n        return {}\n    return {key: \" \".join(str(i) for i in list_)}", "code_tokens": "def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "docstring_tokens": "Converts a list into a space - separated string and puts it in a dictionary", "label": 1}, {"idx": "cosqa-train-19679", "doc": "move to new row after every space python", "code": "def backspace(self):\n        \"\"\"\n        Moves the cursor one place to the left, erasing the character at the\n        current position. Cannot move beyond column zero, nor onto the\n        previous line.\n        \"\"\"\n        if self._cx + self._cw >= 0:\n            self.erase()\n            self._cx -= self._cw\n\n        self.flush()", "code_tokens": "def backspace ( self ) : if self . _cx + self . _cw >= 0 : self . erase ( ) self . _cx -= self . _cw self . flush ( )", "docstring_tokens": "Moves the cursor one place to the left erasing the character at the current position . Cannot move beyond column zero nor onto the previous line .", "label": 0}, {"idx": "cosqa-train-19680", "doc": "python make sure string is a valid filename", "code": "def get_valid_filename(s):\n    \"\"\"\n    Shamelessly taken from Django.\n    https://github.com/django/django/blob/master/django/utils/text.py\n\n    Return the given string converted to a string that can be used for a clean\n    filename. Remove leading and trailing spaces; convert other spaces to\n    underscores; and remove anything that is not an alphanumeric, dash,\n    underscore, or dot.\n    >>> get_valid_filename(\"john's portrait in 2004.jpg\")\n    'johns_portrait_in_2004.jpg'\n    \"\"\"\n    s = str(s).strip().replace(' ', '_')\n    return re.sub(r'(?u)[^-\\w.]', '', s)", "code_tokens": "def get_valid_filename ( s ) : s = str ( s ) . strip ( ) . replace ( ' ' , '_' ) return re . sub ( r'(?u)[^-\\w.]' , '' , s )", "docstring_tokens": "Shamelessly taken from Django . https : // github . com / django / django / blob / master / django / utils / text . py", "label": 0}, {"idx": "cosqa-train-19681", "doc": "timing a python function", "code": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing", "code_tokens": "def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "docstring_tokens": "Time execution of function . Returns ( res seconds ) .", "label": 1}, {"idx": "cosqa-train-19682", "doc": "python conver list of strings to int", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 0}, {"idx": "cosqa-train-19683", "doc": "comparing int to none python", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 1}, {"idx": "cosqa-train-19684", "doc": "python 3 extract tuple", "code": "def _parse_tuple_string(argument):\n        \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"\n        if isinstance(argument, str):\n            return tuple(int(p.strip()) for p in argument.split(','))\n        return argument", "code_tokens": "def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "docstring_tokens": "Return a tuple from parsing a b c d - > ( a b c d )", "label": 0}, {"idx": "cosqa-train-19685", "doc": "python to capitalize alternate", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-19686", "doc": "how to remove numpy array to make string python", "code": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)", "code_tokens": "def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "docstring_tokens": "Format numpy array as a string .", "label": 0}, {"idx": "cosqa-train-19687", "doc": "case sensitive in string in python", "code": "def lowercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the lowercase chars in the given string.\"\"\"\n        return ''.join([c if c.islower() else '' for c in str(string)])", "code_tokens": "def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the lowercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-19688", "doc": "how to read json file into a python dictionary", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 1}, {"idx": "cosqa-train-19689", "doc": "python identify if there are any nulls in column", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 1}, {"idx": "cosqa-train-19690", "doc": "how to return the last index calue python\\", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-19691", "doc": "python best way to store bit field", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-19692", "doc": "forceing a string into a number python comand", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 1}, {"idx": "cosqa-train-19693", "doc": "python get first column of table", "code": "def fetchallfirstvalues(self, sql: str, *args) -> List[Any]:\n        \"\"\"Executes SQL; returns list of first values of each row.\"\"\"\n        rows = self.fetchall(sql, *args)\n        return [row[0] for row in rows]", "code_tokens": "def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "docstring_tokens": "Executes SQL ; returns list of first values of each row .", "label": 0}, {"idx": "cosqa-train-19694", "doc": "python capitalize letters in string", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-19695", "doc": "jquery serialize to python dict", "code": "def to_json(self) -> Mapping:\n        \"\"\"Return the properties of this :class:`Sample` as JSON serializable.\n\n        \"\"\"\n        return {str(x): str(y) for x, y in self.items()}", "code_tokens": "def to_json ( self ) -> Mapping : return { str ( x ) : str ( y ) for x , y in self . items ( ) }", "docstring_tokens": "Return the properties of this : class : Sample as JSON serializable .", "label": 0}, {"idx": "cosqa-train-19696", "doc": "how to make letters obtained from strings uppercase in python", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-19697", "doc": "python generate fibanacci using lambda", "code": "def fib(n):\n    \"\"\"Fibonacci example function\n\n    Args:\n      n (int): integer\n\n    Returns:\n      int: n-th Fibonacci number\n    \"\"\"\n    assert n > 0\n    a, b = 1, 1\n    for i in range(n - 1):\n        a, b = b, a + b\n    return a", "code_tokens": "def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a", "docstring_tokens": "Fibonacci example function", "label": 0}, {"idx": "cosqa-train-19698", "doc": "python variable index range in memoryview", "code": "def read(self, start_position: int, size: int) -> memoryview:\n        \"\"\"\n        Return a view into the memory\n        \"\"\"\n        return memoryview(self._bytes)[start_position:start_position + size]", "code_tokens": "def read ( self , start_position : int , size : int ) -> memoryview : return memoryview ( self . _bytes ) [ start_position : start_position + size ]", "docstring_tokens": "Return a view into the memory", "label": 0}, {"idx": "cosqa-train-19699", "doc": "howto read file from s3 directly by path in python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 1}, {"idx": "cosqa-train-19700", "doc": "how to discard first text of a string in pythong", "code": "def remove_leading(needle, haystack):\n    \"\"\"Remove leading needle string (if exists).\n\n    >>> remove_leading('Test', 'TestThisAndThat')\n    'ThisAndThat'\n    >>> remove_leading('Test', 'ArbitraryName')\n    'ArbitraryName'\n    \"\"\"\n    if haystack[:len(needle)] == needle:\n        return haystack[len(needle):]\n    return haystack", "code_tokens": "def remove_leading ( needle , haystack ) : if haystack [ : len ( needle ) ] == needle : return haystack [ len ( needle ) : ] return haystack", "docstring_tokens": "Remove leading needle string ( if exists ) .", "label": 0}, {"idx": "cosqa-train-19701", "doc": "python read csv to numpy array", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 0}, {"idx": "cosqa-train-19702", "doc": "python tensor dot product", "code": "def inner(tensor0: BKTensor, tensor1: BKTensor) -> BKTensor:\n    \"\"\"Return the inner product between two tensors\"\"\"\n    # Note: Relying on fact that vdot flattens arrays\n    return np.vdot(tensor0, tensor1)", "code_tokens": "def inner ( tensor0 : BKTensor , tensor1 : BKTensor ) -> BKTensor : # Note: Relying on fact that vdot flattens arrays return np . vdot ( tensor0 , tensor1 )", "docstring_tokens": "Return the inner product between two tensors", "label": 1}, {"idx": "cosqa-train-19703", "doc": "python check memory usage stackoverflow", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 0}, {"idx": "cosqa-train-19704", "doc": "python unix detect key press", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 1}, {"idx": "cosqa-train-19705", "doc": "python get last index of character", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 0}, {"idx": "cosqa-train-19706", "doc": "printing a tree recursively python", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-19707", "doc": "python change a string to a date", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-19708", "doc": "python check for trailing whitespace", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 1}, {"idx": "cosqa-train-19709", "doc": "most frequent substring of strings, python", "code": "def long_substr(data):\n    \"\"\"Return the longest common substring in a list of strings.\n    \n    Credit: http://stackoverflow.com/questions/2892931/longest-common-substring-from-more-than-two-strings-python\n    \"\"\"\n    substr = ''\n    if len(data) > 1 and len(data[0]) > 0:\n        for i in range(len(data[0])):\n            for j in range(len(data[0])-i+1):\n                if j > len(substr) and all(data[0][i:i+j] in x for x in data):\n                    substr = data[0][i:i+j]\n    elif len(data) == 1:\n        substr = data[0]\n    return substr", "code_tokens": "def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "docstring_tokens": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python", "label": 1}, {"idx": "cosqa-train-19710", "doc": "python asyncio start server connection refuse", "code": "async def async_run(self) -> None:\n        \"\"\"\n        Asynchronously run the worker, does not close connections. Useful when testing.\n        \"\"\"\n        self.main_task = self.loop.create_task(self.main())\n        await self.main_task", "code_tokens": "async def async_run ( self ) -> None : self . main_task = self . loop . create_task ( self . main ( ) ) await self . main_task", "docstring_tokens": "Asynchronously run the worker does not close connections . Useful when testing .", "label": 1}, {"idx": "cosqa-train-19711", "doc": "python test async coroutine is running", "code": "async def async_run(self) -> None:\n        \"\"\"\n        Asynchronously run the worker, does not close connections. Useful when testing.\n        \"\"\"\n        self.main_task = self.loop.create_task(self.main())\n        await self.main_task", "code_tokens": "async def async_run ( self ) -> None : self . main_task = self . loop . create_task ( self . main ( ) ) await self . main_task", "docstring_tokens": "Asynchronously run the worker does not close connections . Useful when testing .", "label": 0}, {"idx": "cosqa-train-19712", "doc": "create dictionary of indices in list in python", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 0}, {"idx": "cosqa-train-19713", "doc": "how to get table names from dynamo in python", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 1}, {"idx": "cosqa-train-19714", "doc": "largest common substring python", "code": "def long_substr(data):\n    \"\"\"Return the longest common substring in a list of strings.\n    \n    Credit: http://stackoverflow.com/questions/2892931/longest-common-substring-from-more-than-two-strings-python\n    \"\"\"\n    substr = ''\n    if len(data) > 1 and len(data[0]) > 0:\n        for i in range(len(data[0])):\n            for j in range(len(data[0])-i+1):\n                if j > len(substr) and all(data[0][i:i+j] in x for x in data):\n                    substr = data[0][i:i+j]\n    elif len(data) == 1:\n        substr = data[0]\n    return substr", "code_tokens": "def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "docstring_tokens": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python", "label": 0}, {"idx": "cosqa-train-19715", "doc": "python 3 detect keyboard press linux", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 1}, {"idx": "cosqa-train-19716", "doc": "how to do bitwise or on a string of bits in python", "code": "def bfx(value, msb, lsb):\n    \"\"\"! @brief Extract a value from a bitfield.\"\"\"\n    mask = bitmask((msb, lsb))\n    return (value & mask) >> lsb", "code_tokens": "def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-19717", "doc": "python exclude words from list", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 1}, {"idx": "cosqa-train-19718", "doc": "dot product of two vectors python sympy", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 1}, {"idx": "cosqa-train-19719", "doc": "reduce trailing zeros python", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 1}, {"idx": "cosqa-train-19720", "doc": "check if two string equal python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 0}, {"idx": "cosqa-train-19721", "doc": "create a set python from a text file", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 1}, {"idx": "cosqa-train-19722", "doc": "most frequent items in list python", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 1}, {"idx": "cosqa-train-19723", "doc": "pdf to text converter returning me invalid pdf file python", "code": "def availability_pdf() -> bool:\n    \"\"\"\n    Is a PDF-to-text tool available?\n    \"\"\"\n    pdftotext = tools['pdftotext']\n    if pdftotext:\n        return True\n    elif pdfminer:\n        log.warning(\"PDF conversion: pdftotext missing; \"\n                    \"using pdfminer (less efficient)\")\n        return True\n    else:\n        return False", "code_tokens": "def availability_pdf ( ) -> bool : pdftotext = tools [ 'pdftotext' ] if pdftotext : return True elif pdfminer : log . warning ( \"PDF conversion: pdftotext missing; \" \"using pdfminer (less efficient)\" ) return True else : return False", "docstring_tokens": "Is a PDF - to - text tool available?", "label": 0}, {"idx": "cosqa-train-19724", "doc": "how to capitalize all the characters in python", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 1}, {"idx": "cosqa-train-19725", "doc": "truncate variable to three decimals python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 1}, {"idx": "cosqa-train-19726", "doc": "check if a directory is empty python", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 0}, {"idx": "cosqa-train-19727", "doc": "python get overlap between two schedules", "code": "def CheckDisjointCalendars(self):\n    \"\"\"Check whether any old service periods intersect with any new ones.\n\n    This is a rather coarse check based on\n    transitfeed.SevicePeriod.GetDateRange.\n\n    Returns:\n      True if the calendars are disjoint or False if not.\n    \"\"\"\n    # TODO: Do an exact check here.\n\n    a_service_periods = self.feed_merger.a_schedule.GetServicePeriodList()\n    b_service_periods = self.feed_merger.b_schedule.GetServicePeriodList()\n\n    for a_service_period in a_service_periods:\n      a_start, a_end = a_service_period.GetDateRange()\n      for b_service_period in b_service_periods:\n        b_start, b_end = b_service_period.GetDateRange()\n        overlap_start = max(a_start, b_start)\n        overlap_end = min(a_end, b_end)\n        if overlap_end >= overlap_start:\n          return False\n    return True", "code_tokens": "def CheckDisjointCalendars ( self ) : # TODO: Do an exact check here. a_service_periods = self . feed_merger . a_schedule . GetServicePeriodList ( ) b_service_periods = self . feed_merger . b_schedule . GetServicePeriodList ( ) for a_service_period in a_service_periods : a_start , a_end = a_service_period . GetDateRange ( ) for b_service_period in b_service_periods : b_start , b_end = b_service_period . GetDateRange ( ) overlap_start = max ( a_start , b_start ) overlap_end = min ( a_end , b_end ) if overlap_end >= overlap_start : return False return True", "docstring_tokens": "Check whether any old service periods intersect with any new ones .", "label": 0}, {"idx": "cosqa-train-19728", "doc": "take top items in a list python", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 0}, {"idx": "cosqa-train-19729", "doc": "print \"hello world\" if a is greater than b in python", "code": "def __gt__(self, other):\n        \"\"\"Test for greater than.\"\"\"\n        if isinstance(other, Address):\n            return str(self) > str(other)\n        raise TypeError", "code_tokens": "def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError", "docstring_tokens": "Test for greater than .", "label": 0}, {"idx": "cosqa-train-19730", "doc": "python fill null value in dictionary", "code": "def inject_nulls(data: Mapping, field_names) -> dict:\n    \"\"\"Insert None as value for missing fields.\"\"\"\n\n    record = dict()\n\n    for field in field_names:\n        record[field] = data.get(field, None)\n\n    return record", "code_tokens": "def inject_nulls ( data : Mapping , field_names ) -> dict : record = dict ( ) for field in field_names : record [ field ] = data . get ( field , None ) return record", "docstring_tokens": "Insert None as value for missing fields .", "label": 1}, {"idx": "cosqa-train-19731", "doc": "python connect to oracle database without dsn", "code": "def connect_to_database_odbc_access(self,\n                                        dsn: str,\n                                        autocommit: bool = True) -> None:\n        \"\"\"Connects to an Access database via ODBC, with the DSN\n        prespecified.\"\"\"\n        self.connect(engine=ENGINE_ACCESS, interface=INTERFACE_ODBC,\n                     dsn=dsn, autocommit=autocommit)", "code_tokens": "def connect_to_database_odbc_access ( self , dsn : str , autocommit : bool = True ) -> None : self . connect ( engine = ENGINE_ACCESS , interface = INTERFACE_ODBC , dsn = dsn , autocommit = autocommit )", "docstring_tokens": "Connects to an Access database via ODBC with the DSN prespecified .", "label": 0}, {"idx": "cosqa-train-19732", "doc": "python how to grep a file for a string", "code": "def grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''", "code_tokens": "def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "docstring_tokens": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .", "label": 0}, {"idx": "cosqa-train-19733", "doc": "remove element python xml tree", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 1}, {"idx": "cosqa-train-19734", "doc": "python write to file indentation", "code": "def PrintIndented(self, file, ident, code):\n        \"\"\"Takes an array, add indentation to each entry and prints it.\"\"\"\n        for entry in code:\n            print >>file, '%s%s' % (ident, entry)", "code_tokens": "def PrintIndented ( self , file , ident , code ) : for entry in code : print >> file , '%s%s' % ( ident , entry )", "docstring_tokens": "Takes an array add indentation to each entry and prints it .", "label": 1}, {"idx": "cosqa-train-19735", "doc": "how to keep bit values on python", "code": "def pack_bits( longbits ):\n    \"\"\"Crunch a 64-bit int (8 bool bytes) into a bitfield.\"\"\"\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "code_tokens": "def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "docstring_tokens": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .", "label": 0}, {"idx": "cosqa-train-19736", "doc": "how to get contents fromtext file python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-19737", "doc": "python how to check the queue length", "code": "def full(self):\n        \"\"\"Return ``True`` if the queue is full, ``False``\n        otherwise (not reliable!).\n\n        Only applicable if :attr:`maxsize` is set.\n\n        \"\"\"\n        return self.maxsize and len(self.list) >= self.maxsize or False", "code_tokens": "def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False", "docstring_tokens": "Return True if the queue is full False otherwise ( not reliable! ) .", "label": 0}, {"idx": "cosqa-train-19738", "doc": "python density map gaussian kernel", "code": "def kernel(self, spread=1):\n        \"\"\" This will return whatever kind of kernel we want to use.\n            Must have signature (ndarray size NxM, ndarray size 1xM) -> ndarray size Nx1\n        \"\"\"\n        # TODO: use self.kernel_type to choose function\n\n        def gaussian(data, pixel):\n            return mvn.pdf(data, mean=pixel, cov=spread)\n\n        return gaussian", "code_tokens": "def kernel ( self , spread = 1 ) : # TODO: use self.kernel_type to choose function def gaussian ( data , pixel ) : return mvn . pdf ( data , mean = pixel , cov = spread ) return gaussian", "docstring_tokens": "This will return whatever kind of kernel we want to use . Must have signature ( ndarray size NxM ndarray size 1xM ) - > ndarray size Nx1", "label": 0}, {"idx": "cosqa-train-19739", "doc": "reshape shuffle array python", "code": "def _reshuffle(mat, shape):\n    \"\"\"Reshuffle the indicies of a bipartite matrix A[ij,kl] -> A[lj,ki].\"\"\"\n    return np.reshape(\n        np.transpose(np.reshape(mat, shape), (3, 1, 2, 0)),\n        (shape[3] * shape[1], shape[0] * shape[2]))", "code_tokens": "def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )", "docstring_tokens": "Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] .", "label": 0}, {"idx": "cosqa-train-19740", "doc": "python hashlib function an integer", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 0}, {"idx": "cosqa-train-19741", "doc": "python truncate an existing data frame to keep the column names", "code": "def clean_column_names(df: DataFrame) -> DataFrame:\n    \"\"\"\n    Strip the whitespace from all column names in the given DataFrame\n    and return the result.\n    \"\"\"\n    f = df.copy()\n    f.columns = [col.strip() for col in f.columns]\n    return f", "code_tokens": "def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "docstring_tokens": "Strip the whitespace from all column names in the given DataFrame and return the result .", "label": 0}, {"idx": "cosqa-train-19742", "doc": "del element in dictionary in python", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-19743", "doc": "python delete a value from a set", "code": "def remove_once(gset, elem):\n    \"\"\"Remove the element from a set, lists or dict.\n    \n        >>> L = [\"Lucy\"]; S = set([\"Sky\"]); D = { \"Diamonds\": True };\n        >>> remove_once(L, \"Lucy\"); remove_once(S, \"Sky\"); remove_once(D, \"Diamonds\");\n        >>> print L, S, D\n        [] set([]) {}\n\n    Returns the element if it was removed. Raises one of the exceptions in \n    :obj:`RemoveError` otherwise.\n    \"\"\"\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "code_tokens": "def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "docstring_tokens": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}", "label": 0}, {"idx": "cosqa-train-19744", "doc": "python how to check type is string", "code": "def is_unicode(string):\n    \"\"\"Validates that the object itself is some kinda string\"\"\"\n    str_type = str(type(string))\n\n    if str_type.find('str') > 0 or str_type.find('unicode') > 0:\n        return True\n\n    return False", "code_tokens": "def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "docstring_tokens": "Validates that the object itself is some kinda string", "label": 0}, {"idx": "cosqa-train-19745", "doc": "python reset window color", "code": "def ResetConsoleColor() -> bool:\n    \"\"\"\n    Reset to the default text color on console window.\n    Return bool, True if succeed otherwise False.\n    \"\"\"\n    if sys.stdout:\n        sys.stdout.flush()\n    bool(ctypes.windll.kernel32.SetConsoleTextAttribute(_ConsoleOutputHandle, _DefaultConsoleColor))", "code_tokens": "def ResetConsoleColor ( ) -> bool : if sys . stdout : sys . stdout . flush ( ) bool ( ctypes . windll . kernel32 . SetConsoleTextAttribute ( _ConsoleOutputHandle , _DefaultConsoleColor ) )", "docstring_tokens": "Reset to the default text color on console window . Return bool True if succeed otherwise False .", "label": 1}, {"idx": "cosqa-train-19746", "doc": "skip first return value in tuple python", "code": "def pairwise(iterable):\n    \"\"\"From itertools cookbook. [a, b, c, ...] -> (a, b), (b, c), ...\"\"\"\n    first, second = tee(iterable)\n    next(second, None)\n    return zip(first, second)", "code_tokens": "def pairwise ( iterable ) : first , second = tee ( iterable ) next ( second , None ) return zip ( first , second )", "docstring_tokens": "From itertools cookbook . [ a b c ... ] - > ( a b ) ( b c ) ...", "label": 1}, {"idx": "cosqa-train-19747", "doc": "check whether column contain nulls python", "code": "def is_not_null(df: DataFrame, col_name: str) -> bool:\n    \"\"\"\n    Return ``True`` if the given DataFrame has a column of the given\n    name (string), and there exists at least one non-NaN value in that\n    column; return ``False`` otherwise.\n    \"\"\"\n    if (\n        isinstance(df, pd.DataFrame)\n        and col_name in df.columns\n        and df[col_name].notnull().any()\n    ):\n        return True\n    else:\n        return False", "code_tokens": "def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "docstring_tokens": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .", "label": 0}, {"idx": "cosqa-train-19748", "doc": "get user cpu usage python", "code": "def memory_usage():\n    \"\"\"return memory usage of python process in MB\n\n    from\n    http://fa.bianp.net/blog/2013/different-ways-to-get-memory-consumption-or-lessons-learned-from-memory_profiler/\n    psutil is quicker\n\n    >>> isinstance(memory_usage(),float)\n    True\n\n    \"\"\"\n    try:\n        import psutil\n        import os\n    except ImportError:\n        return _memory_usage_ps()\n\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info()[0] / float(2 ** 20)\n    return mem", "code_tokens": "def memory_usage ( ) : try : import psutil import os except ImportError : return _memory_usage_ps ( ) process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) [ 0 ] / float ( 2 ** 20 ) return mem", "docstring_tokens": "return memory usage of python process in MB", "label": 1}, {"idx": "cosqa-train-19749", "doc": "python how to get rid of repeating items in a list", "code": "def de_duplicate(items):\n    \"\"\"Remove any duplicate item, preserving order\n\n    >>> de_duplicate([1, 2, 1, 2])\n    [1, 2]\n    \"\"\"\n    result = []\n    for item in items:\n        if item not in result:\n            result.append(item)\n    return result", "code_tokens": "def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "docstring_tokens": "Remove any duplicate item preserving order", "label": 1}, {"idx": "cosqa-train-19750", "doc": "python 3 remove file with pattern", "code": "def rmglob(pattern: str) -> None:\n    \"\"\"\n    Deletes all files whose filename matches the glob ``pattern`` (via\n    :func:`glob.glob`).\n    \"\"\"\n    for f in glob.glob(pattern):\n        os.remove(f)", "code_tokens": "def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "docstring_tokens": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .", "label": 1}, {"idx": "cosqa-train-19751", "doc": "python white space check", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 1}, {"idx": "cosqa-train-19752", "doc": "inverse dictionary python with a function", "code": "def inverted_dict(d):\n    \"\"\"Return a dict with swapped keys and values\n\n    >>> inverted_dict({0: ('a', 'b'), 1: 'cd'}) == {'cd': 1, ('a', 'b'): 0}\n    True\n    \"\"\"\n    return dict((force_hashable(v), k) for (k, v) in viewitems(dict(d)))", "code_tokens": "def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "docstring_tokens": "Return a dict with swapped keys and values", "label": 0}, {"idx": "cosqa-train-19753", "doc": "python check if hessian is invertible", "code": "def almost_hermitian(gate: Gate) -> bool:\n    \"\"\"Return true if gate tensor is (almost) Hermitian\"\"\"\n    return np.allclose(asarray(gate.asoperator()),\n                       asarray(gate.H.asoperator()))", "code_tokens": "def almost_hermitian ( gate : Gate ) -> bool : return np . allclose ( asarray ( gate . asoperator ( ) ) , asarray ( gate . H . asoperator ( ) ) )", "docstring_tokens": "Return true if gate tensor is ( almost ) Hermitian", "label": 0}, {"idx": "cosqa-train-19754", "doc": "python turn list of string into integers", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-19755", "doc": "test if set is empty python", "code": "def is_any_type_set(sett: Set[Type]) -> bool:\n    \"\"\"\n    Helper method to check if a set of types is the {AnyObject} singleton\n\n    :param sett:\n    :return:\n    \"\"\"\n    return len(sett) == 1 and is_any_type(min(sett))", "code_tokens": "def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )", "docstring_tokens": "Helper method to check if a set of types is the { AnyObject } singleton", "label": 0}, {"idx": "cosqa-train-19756", "doc": "python create dict with list of list", "code": "def encode_list(key, list_):\n    # type: (str, Iterable) -> Dict[str, str]\n    \"\"\"\n    Converts a list into a space-separated string and puts it in a dictionary\n\n    :param key: Dictionary key to store the list\n    :param list_: A list of objects\n    :return: A dictionary key->string or an empty dictionary\n    \"\"\"\n    if not list_:\n        return {}\n    return {key: \" \".join(str(i) for i in list_)}", "code_tokens": "def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "docstring_tokens": "Converts a list into a space - separated string and puts it in a dictionary", "label": 1}, {"idx": "cosqa-train-19757", "doc": "check if a set is a subset python", "code": "def issubset(self, other):\n        \"\"\"\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        \"\"\"\n        if len(self) > len(other):  # Fast check for obvious cases\n            return False\n        return all(item in other for item in self)", "code_tokens": "def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "docstring_tokens": "Report whether another set contains this set .", "label": 1}, {"idx": "cosqa-train-19758", "doc": "python turn list of lists into one list", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 1}, {"idx": "cosqa-train-19759", "doc": "python argparse specify flad", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 1}, {"idx": "cosqa-train-19760", "doc": "change data to bytes in python", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 0}, {"idx": "cosqa-train-19761", "doc": "return indices to python list items meeting a specific condition", "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:\n    \"\"\"\n    Finds the index of an item in list, which satisfies predicate\n    :param predicateFn: predicate function to run on items of list\n    :param items: list of tuples\n    :return: first index for which predicate function returns True\n    \"\"\"\n    try:\n        return next(i for i, v in enumerate(items) if predicateFn(v))\n    except StopIteration:\n        return -1", "code_tokens": "def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "docstring_tokens": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True", "label": 0}, {"idx": "cosqa-train-19762", "doc": "python queue check size", "code": "def full(self):\n        \"\"\"Return ``True`` if the queue is full, ``False``\n        otherwise (not reliable!).\n\n        Only applicable if :attr:`maxsize` is set.\n\n        \"\"\"\n        return self.maxsize and len(self.list) >= self.maxsize or False", "code_tokens": "def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False", "docstring_tokens": "Return True if the queue is full False otherwise ( not reliable! ) .", "label": 0}, {"idx": "cosqa-train-19763", "doc": "check first index of a string python", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 0}, {"idx": "cosqa-train-19764", "doc": "python argparser hidden variable", "code": "def default_parser() -> argparse.ArgumentParser:\n    \"\"\"Create a parser for CLI arguments and options.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog=CONSOLE_SCRIPT,\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n    )\n    build_parser(parser)\n    return parser", "code_tokens": "def default_parser ( ) -> argparse . ArgumentParser : parser = argparse . ArgumentParser ( prog = CONSOLE_SCRIPT , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) build_parser ( parser ) return parser", "docstring_tokens": "Create a parser for CLI arguments and options .", "label": 0}, {"idx": "cosqa-train-19765", "doc": "how to capaitalize the first letter in each word python", "code": "def titleize(text):\n    \"\"\"Capitalizes all the words and replaces some characters in the string \n    to create a nicer looking title.\n    \"\"\"\n    if len(text) == 0: # if empty string, return it\n        return text\n    else:\n        text = text.lower() # lower all char\n        # delete redundant empty space \n        chunks = [chunk[0].upper() + chunk[1:] for chunk in text.split(\" \") if len(chunk) >= 1]\n        return \" \".join(chunks)", "code_tokens": "def titleize ( text ) : if len ( text ) == 0 : # if empty string, return it return text else : text = text . lower ( ) # lower all char # delete redundant empty space  chunks = [ chunk [ 0 ] . upper ( ) + chunk [ 1 : ] for chunk in text . split ( \" \" ) if len ( chunk ) >= 1 ] return \" \" . join ( chunks )", "docstring_tokens": "Capitalizes all the words and replaces some characters in the string to create a nicer looking title .", "label": 1}, {"idx": "cosqa-train-19766", "doc": "equivallent function in python for hash array in perl", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 1}, {"idx": "cosqa-train-19767", "doc": "python if string is int", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 0}, {"idx": "cosqa-train-19768", "doc": "python check if string in line of file", "code": "def is_line_in_file(filename: str, line: str) -> bool:\n    \"\"\"\n    Detects whether a line is present within a file.\n\n    Args:\n        filename: file to check\n        line: line to search for (as an exact match)\n    \"\"\"\n    assert \"\\n\" not in line\n    with open(filename, \"r\") as file:\n        for fileline in file:\n            if fileline == line:\n                return True\n        return False", "code_tokens": "def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "docstring_tokens": "Detects whether a line is present within a file .", "label": 0}, {"idx": "cosqa-train-19769", "doc": "messge pack setup int type in python", "code": "def set_int(bytearray_, byte_index, _int):\n    \"\"\"\n    Set value in bytearray to int\n    \"\"\"\n    # make sure were dealing with an int\n    _int = int(_int)\n    _bytes = struct.unpack('2B', struct.pack('>h', _int))\n    bytearray_[byte_index:byte_index + 2] = _bytes\n    return bytearray_", "code_tokens": "def set_int ( bytearray_ , byte_index , _int ) : # make sure were dealing with an int _int = int ( _int ) _bytes = struct . unpack ( '2B' , struct . pack ( '>h' , _int ) ) bytearray_ [ byte_index : byte_index + 2 ] = _bytes return bytearray_", "docstring_tokens": "Set value in bytearray to int", "label": 1}, {"idx": "cosqa-train-19770", "doc": "python concurrent future asyncio future", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 1}, {"idx": "cosqa-train-19771", "doc": "python split according to a list of delimiters", "code": "def multi_split(s, split):\n    # type: (S, Iterable[S]) -> List[S]\n    \"\"\"Splits on multiple given separators.\"\"\"\n    for r in split:\n        s = s.replace(r, \"|\")\n    return [i for i in s.split(\"|\") if len(i) > 0]", "code_tokens": "def multi_split ( s , split ) : # type: (S, Iterable[S]) -> List[S] for r in split : s = s . replace ( r , \"|\" ) return [ i for i in s . split ( \"|\" ) if len ( i ) > 0 ]", "docstring_tokens": "Splits on multiple given separators .", "label": 1}, {"idx": "cosqa-train-19772", "doc": "python from most recent strptime and retrieve last 12 months", "code": "def get_period_last_3_months() -> str:\n    \"\"\" Returns the last week as a period string \"\"\"\n    today = Datum()\n    today.today()\n\n    # start_date = today - timedelta(weeks=13)\n    start_date = today.clone()\n    start_date.subtract_months(3)\n\n    period = get_period(start_date.date, today.date)\n    return period", "code_tokens": "def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "docstring_tokens": "Returns the last week as a period string", "label": 0}, {"idx": "cosqa-train-19773", "doc": "list the columns in a table in python", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 1}, {"idx": "cosqa-train-19774", "doc": "how to print out dtypes for all columns in python", "code": "def dtypes(self):\n        \"\"\"Returns all column names and their data types as a list.\n\n        >>> df.dtypes\n        [('age', 'int'), ('name', 'string')]\n        \"\"\"\n        return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]", "code_tokens": "def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "docstring_tokens": "Returns all column names and their data types as a list .", "label": 1}, {"idx": "cosqa-train-19775", "doc": "python list with duplicate items get index", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 1}, {"idx": "cosqa-train-19776", "doc": "how to get the file extension in python", "code": "def infer_format(filename:str) -> str:\n    \"\"\"Return extension identifying format of given filename\"\"\"\n    _, ext = os.path.splitext(filename)\n    return ext", "code_tokens": "def infer_format ( filename : str ) -> str : _ , ext = os . path . splitext ( filename ) return ext", "docstring_tokens": "Return extension identifying format of given filename", "label": 1}, {"idx": "cosqa-train-19777", "doc": "how to get text file python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-19778", "doc": "python string remove blank", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 1}, {"idx": "cosqa-train-19779", "doc": "how to filter a dictionary of values in python", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-19780", "doc": "how to hash integers python", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 1}, {"idx": "cosqa-train-19781", "doc": "python dict get value filter by another key", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-19782", "doc": "python engine has no cursor attribute", "code": "async def cursor(self) -> Cursor:\n        \"\"\"Create an aiosqlite cursor wrapping a sqlite3 cursor object.\"\"\"\n        return Cursor(self, await self._execute(self._conn.cursor))", "code_tokens": "async def cursor ( self ) -> Cursor : return Cursor ( self , await self . _execute ( self . _conn . cursor ) )", "docstring_tokens": "Create an aiosqlite cursor wrapping a sqlite3 cursor object .", "label": 1}, {"idx": "cosqa-train-19783", "doc": "python int and float equals string or float", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 1}, {"idx": "cosqa-train-19784", "doc": "filename and extension of file in python", "code": "def infer_format(filename:str) -> str:\n    \"\"\"Return extension identifying format of given filename\"\"\"\n    _, ext = os.path.splitext(filename)\n    return ext", "code_tokens": "def infer_format ( filename : str ) -> str : _ , ext = os . path . splitext ( filename ) return ext", "docstring_tokens": "Return extension identifying format of given filename", "label": 0}, {"idx": "cosqa-train-19785", "doc": "python3 decode byte string", "code": "def decodebytes(input):\n    \"\"\"Decode base64 string to byte array.\"\"\"\n    py_version = sys.version_info[0]\n    if py_version >= 3:\n        return _decodebytes_py3(input)\n    return _decodebytes_py2(input)", "code_tokens": "def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )", "docstring_tokens": "Decode base64 string to byte array .", "label": 1}, {"idx": "cosqa-train-19786", "doc": "returning single value in sql stored procedure python", "code": "def fetchvalue(self, sql: str, *args) -> Optional[Any]:\n        \"\"\"Executes SQL; returns the first value of the first row, or None.\"\"\"\n        row = self.fetchone(sql, *args)\n        if row is None:\n            return None\n        return row[0]", "code_tokens": "def fetchvalue ( self , sql : str , * args ) -> Optional [ Any ] : row = self . fetchone ( sql , * args ) if row is None : return None return row [ 0 ]", "docstring_tokens": "Executes SQL ; returns the first value of the first row or None .", "label": 0}, {"idx": "cosqa-train-19787", "doc": "jsonstring to string python", "code": "def string(value) -> str:\n        \"\"\" string dict/object/value to JSON \"\"\"\n        return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)", "code_tokens": "def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "docstring_tokens": "string dict / object / value to JSON", "label": 0}, {"idx": "cosqa-train-19788", "doc": "type of a column python", "code": "def is_sqlatype_integer(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type an integer type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.Integer)", "code_tokens": "def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "docstring_tokens": "Is the SQLAlchemy column type an integer type?", "label": 1}, {"idx": "cosqa-train-19789", "doc": "python detect key press linux", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 1}, {"idx": "cosqa-train-19790", "doc": "print all leaf nodes of a binary tree python", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-19791", "doc": "to check the nan and null values in python", "code": "def warn_if_nans_exist(X):\n    \"\"\"Warn if nans exist in a numpy array.\"\"\"\n    null_count = count_rows_with_nans(X)\n    total = len(X)\n    percent = 100 * null_count / total\n\n    if null_count > 0:\n        warning_message = \\\n            'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\\n            'complete rows will be plotted.'.format(null_count, total, percent)\n        warnings.warn(warning_message, DataWarning)", "code_tokens": "def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "docstring_tokens": "Warn if nans exist in a numpy array .", "label": 1}, {"idx": "cosqa-train-19792", "doc": "python xml elementtree remove child node", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 0}, {"idx": "cosqa-train-19793", "doc": "how to make a distance function in python", "code": "def dfromdm(dm):\n    \"\"\"Returns distance given distance modulus.\n    \"\"\"\n    if np.size(dm)>1:\n        dm = np.atleast_1d(dm)\n    return 10**(1+dm/5)", "code_tokens": "def dfromdm ( dm ) : if np . size ( dm ) > 1 : dm = np . atleast_1d ( dm ) return 10 ** ( 1 + dm / 5 )", "docstring_tokens": "Returns distance given distance modulus .", "label": 0}, {"idx": "cosqa-train-19794", "doc": "determine win folder size in python", "code": "def get_window_dim():\n    \"\"\" gets the dimensions depending on python version and os\"\"\"\n    version = sys.version_info\n\n    if version >= (3, 3):\n        return _size_36()\n    if platform.system() == 'Windows':\n        return _size_windows()\n    return _size_27()", "code_tokens": "def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )", "docstring_tokens": "gets the dimensions depending on python version and os", "label": 1}, {"idx": "cosqa-train-19795", "doc": "how to check if the date is last date of the month python", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 0}, {"idx": "cosqa-train-19796", "doc": "python get browser size", "code": "def get_window_dim():\n    \"\"\" gets the dimensions depending on python version and os\"\"\"\n    version = sys.version_info\n\n    if version >= (3, 3):\n        return _size_36()\n    if platform.system() == 'Windows':\n        return _size_windows()\n    return _size_27()", "code_tokens": "def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )", "docstring_tokens": "gets the dimensions depending on python version and os", "label": 1}, {"idx": "cosqa-train-19797", "doc": "python from string to date time", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 1}, {"idx": "cosqa-train-19798", "doc": "read json object from file as dict python", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 1}, {"idx": "cosqa-train-19799", "doc": "rgb to hsv for image python", "code": "def hsv2rgb_spectrum(hsv):\n    \"\"\"Generates RGB values from HSV values in line with a typical light\n    spectrum.\"\"\"\n    h, s, v = hsv\n    return hsv2rgb_raw(((h * 192) >> 8, s, v))", "code_tokens": "def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "docstring_tokens": "Generates RGB values from HSV values in line with a typical light spectrum .", "label": 1}, {"idx": "cosqa-train-19800", "doc": "how to do product xy on python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 0}, {"idx": "cosqa-train-19801", "doc": "longest common substring python", "code": "def long_substr(data):\n    \"\"\"Return the longest common substring in a list of strings.\n    \n    Credit: http://stackoverflow.com/questions/2892931/longest-common-substring-from-more-than-two-strings-python\n    \"\"\"\n    substr = ''\n    if len(data) > 1 and len(data[0]) > 0:\n        for i in range(len(data[0])):\n            for j in range(len(data[0])-i+1):\n                if j > len(substr) and all(data[0][i:i+j] in x for x in data):\n                    substr = data[0][i:i+j]\n    elif len(data) == 1:\n        substr = data[0]\n    return substr", "code_tokens": "def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "docstring_tokens": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python", "label": 0}, {"idx": "cosqa-train-19802", "doc": "get min of a series python", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 1}, {"idx": "cosqa-train-19803", "doc": "python how to get max from rows in column", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 1}, {"idx": "cosqa-train-19804", "doc": "get the year from a date in python", "code": "def year(date):\n    \"\"\" Returns the year.\n\n    :param date:\n        The string date with this format %m/%d/%Y\n    :type date:\n        String\n\n    :returns:\n        int\n\n    :example:\n        >>> year('05/1/2015')\n        2015\n    \"\"\"\n    try:\n        fmt = '%m/%d/%Y'\n        return datetime.strptime(date, fmt).timetuple().tm_year\n    except ValueError:\n        return 0", "code_tokens": "def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "docstring_tokens": "Returns the year .", "label": 1}, {"idx": "cosqa-train-19805", "doc": "how to change indents to 4 spaces on python", "code": "def add_colons(s):\n    \"\"\"Add colons after every second digit.\n\n    This function is used in functions to prettify serials.\n\n    >>> add_colons('teststring')\n    'te:st:st:ri:ng'\n    \"\"\"\n    return ':'.join([s[i:i + 2] for i in range(0, len(s), 2)])", "code_tokens": "def add_colons ( s ) : return ':' . join ( [ s [ i : i + 2 ] for i in range ( 0 , len ( s ) , 2 ) ] )", "docstring_tokens": "Add colons after every second digit .", "label": 0}, {"idx": "cosqa-train-19806", "doc": "python name pylint is not defined", "code": "def lint(fmt='colorized'):\n    \"\"\"Run verbose PyLint on source. Optionally specify fmt=html for HTML output.\"\"\"\n    if fmt == 'html':\n        outfile = 'pylint_report.html'\n        local('pylint -f %s davies > %s || true' % (fmt, outfile))\n        local('open %s' % outfile)\n    else:\n        local('pylint -f %s davies || true' % fmt)", "code_tokens": "def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "docstring_tokens": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output .", "label": 1}, {"idx": "cosqa-train-19807", "doc": "python how to capitalize letters of a input string", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 0}, {"idx": "cosqa-train-19808", "doc": "finding the degree of a node in python", "code": "def spanning_tree_count(graph: nx.Graph) -> int:\n    \"\"\"Return the number of unique spanning trees of a graph, using\n    Kirchhoff's matrix tree theorem.\n    \"\"\"\n    laplacian = nx.laplacian_matrix(graph).toarray()\n    comatrix = laplacian[:-1, :-1]\n    det = np.linalg.det(comatrix)\n    count = int(round(det))\n    return count", "code_tokens": "def spanning_tree_count ( graph : nx . Graph ) -> int : laplacian = nx . laplacian_matrix ( graph ) . toarray ( ) comatrix = laplacian [ : - 1 , : - 1 ] det = np . linalg . det ( comatrix ) count = int ( round ( det ) ) return count", "docstring_tokens": "Return the number of unique spanning trees of a graph using Kirchhoff s matrix tree theorem .", "label": 0}, {"idx": "cosqa-train-19809", "doc": "dot product using python", "code": "def dotproduct(X, Y):\n    \"\"\"Return the sum of the element-wise product of vectors x and y.\n    >>> dotproduct([1, 2, 3], [1000, 100, 10])\n    1230\n    \"\"\"\n    return sum([x * y for x, y in zip(X, Y)])", "code_tokens": "def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "docstring_tokens": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230", "label": 0}, {"idx": "cosqa-train-19810", "doc": "python function for determing data type", "code": "def maybe_infer_dtype_type(element):\n    \"\"\"Try to infer an object's dtype, for use in arithmetic ops\n\n    Uses `element.dtype` if that's available.\n    Objects implementing the iterator protocol are cast to a NumPy array,\n    and from there the array's type is used.\n\n    Parameters\n    ----------\n    element : object\n        Possibly has a `.dtype` attribute, and possibly the iterator\n        protocol.\n\n    Returns\n    -------\n    tipo : type\n\n    Examples\n    --------\n    >>> from collections import namedtuple\n    >>> Foo = namedtuple(\"Foo\", \"dtype\")\n    >>> maybe_infer_dtype_type(Foo(np.dtype(\"i8\")))\n    numpy.int64\n    \"\"\"\n    tipo = None\n    if hasattr(element, 'dtype'):\n        tipo = element.dtype\n    elif is_list_like(element):\n        element = np.asarray(element)\n        tipo = element.dtype\n    return tipo", "code_tokens": "def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "docstring_tokens": "Try to infer an object s dtype for use in arithmetic ops", "label": 1}, {"idx": "cosqa-train-19811", "doc": "python split list by token", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 0}, {"idx": "cosqa-train-19812", "doc": "python unsigned int slices", "code": "def read32(bytestream):\n  \"\"\"Read 4 bytes from bytestream as an unsigned 32-bit integer.\"\"\"\n  dt = np.dtype(np.uint32).newbyteorder('>')\n  return np.frombuffer(bytestream.read(4), dtype=dt)[0]", "code_tokens": "def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "docstring_tokens": "Read 4 bytes from bytestream as an unsigned 32 - bit integer .", "label": 0}, {"idx": "cosqa-train-19813", "doc": "how to add an element to a set in python", "code": "def dict_of_sets_add(dictionary, key, value):\n    # type: (DictUpperBound, Any, Any) -> None\n    \"\"\"Add value to a set in a dictionary by key\n\n    Args:\n        dictionary (DictUpperBound): Dictionary to which to add values\n        key (Any): Key within dictionary\n        value (Any): Value to add to set in dictionary\n\n    Returns:\n        None\n\n    \"\"\"\n    set_objs = dictionary.get(key, set())\n    set_objs.add(value)\n    dictionary[key] = set_objs", "code_tokens": "def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "docstring_tokens": "Add value to a set in a dictionary by key", "label": 0}, {"idx": "cosqa-train-19814", "doc": "python for last to first", "code": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second", "code_tokens": "def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "docstring_tokens": "Yield all items from iterable except the last one .", "label": 0}, {"idx": "cosqa-train-19815", "doc": "cast string into integer python", "code": "def try_cast_int(s):\n    \"\"\"(str) -> int\n    All the digits in a given string are concatenated and converted into a single number.\n    \"\"\"\n    try:\n        temp = re.findall('\\d', str(s))\n        temp = ''.join(temp)\n        return int(temp)\n    except:\n        return s", "code_tokens": "def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "docstring_tokens": "( str ) - > int All the digits in a given string are concatenated and converted into a single number .", "label": 0}, {"idx": "cosqa-train-19816", "doc": "the index of the first elements bigger than 0 python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 1}, {"idx": "cosqa-train-19817", "doc": "python unresolved reference 'struct'", "code": "def define_struct(defn):\n    \"\"\"\n    Register a struct definition globally\n\n    >>> define_struct('struct abcd {int x; int y;}')\n    \"\"\"\n    struct = parse_type(defn)\n    ALL_TYPES[struct.name] = struct\n    return struct", "code_tokens": "def define_struct ( defn ) : struct = parse_type ( defn ) ALL_TYPES [ struct . name ] = struct return struct", "docstring_tokens": "Register a struct definition globally", "label": 1}, {"idx": "cosqa-train-19818", "doc": "vs code python linting", "code": "def lint(fmt='colorized'):\n    \"\"\"Run verbose PyLint on source. Optionally specify fmt=html for HTML output.\"\"\"\n    if fmt == 'html':\n        outfile = 'pylint_report.html'\n        local('pylint -f %s davies > %s || true' % (fmt, outfile))\n        local('open %s' % outfile)\n    else:\n        local('pylint -f %s davies || true' % fmt)", "code_tokens": "def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "docstring_tokens": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output .", "label": 1}, {"idx": "cosqa-train-19819", "doc": "python get current selection", "code": "def get_current_item(self):\n        \"\"\"Returns (first) selected item or None\"\"\"\n        l = self.selectedIndexes()\n        if len(l) > 0:\n            return self.model().get_item(l[0])", "code_tokens": "def get_current_item ( self ) : l = self . selectedIndexes ( ) if len ( l ) > 0 : return self . model ( ) . get_item ( l [ 0 ] )", "docstring_tokens": "Returns ( first ) selected item or None", "label": 1}, {"idx": "cosqa-train-19820", "doc": "procedure median, takes 3 inputs and return the median/python", "code": "def median(data):\n    \"\"\"\n    Return the median of numeric data, unsing the \"mean of middle two\" method.\n    If ``data`` is empty, ``0`` is returned.\n\n    Examples\n    --------\n\n    >>> median([1, 3, 5])\n    3.0\n\n    When the number of data points is even, the median is interpolated:\n    >>> median([1, 3, 5, 7])\n    4.0\n    \"\"\"\n\n    if len(data) == 0:\n        return None\n\n    data = sorted(data)\n    return float((data[len(data) // 2] + data[(len(data) - 1) // 2]) / 2.)", "code_tokens": "def median ( data ) : if len ( data ) == 0 : return None data = sorted ( data ) return float ( ( data [ len ( data ) // 2 ] + data [ ( len ( data ) - 1 ) // 2 ] ) / 2. )", "docstring_tokens": "Return the median of numeric data unsing the mean of middle two method . If data is empty 0 is returned .", "label": 1}, {"idx": "cosqa-train-19821", "doc": "finding the minimum of a column python", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-19822", "doc": "how to get size of row in matrix python", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 1}, {"idx": "cosqa-train-19823", "doc": "python variable names starting in underscore", "code": "def lower_camel_case_from_underscores(string):\n    \"\"\"generate a lower-cased camelCase string from an underscore_string.\n    For example: my_variable_name -> myVariableName\"\"\"\n    components = string.split('_')\n    string = components[0]\n    for component in components[1:]:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName", "label": 1}, {"idx": "cosqa-train-19824", "doc": "how to get month before month's last date in python", "code": "def get_last_weekday_in_month(year, month, weekday):\n        \"\"\"Get the last weekday in a given month. e.g:\n\n        >>> # the last monday in Jan 2013\n        >>> Calendar.get_last_weekday_in_month(2013, 1, MON)\n        datetime.date(2013, 1, 28)\n        \"\"\"\n        day = date(year, month, monthrange(year, month)[1])\n        while True:\n            if day.weekday() == weekday:\n                break\n            day = day - timedelta(days=1)\n        return day", "code_tokens": "def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "docstring_tokens": "Get the last weekday in a given month . e . g :", "label": 0}, {"idx": "cosqa-train-19825", "doc": "check if set is subset of other set python", "code": "def issubset(self, other):\n        \"\"\"\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        \"\"\"\n        if len(self) > len(other):  # Fast check for obvious cases\n            return False\n        return all(item in other for item in self)", "code_tokens": "def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "docstring_tokens": "Report whether another set contains this set .", "label": 1}, {"idx": "cosqa-train-19826", "doc": "test all values in an array at once python", "code": "def isarray(array, test, dim=2):\n    \"\"\"Returns True if test is True for all array elements.\n    Otherwise, returns False.\n    \"\"\"\n    if dim > 1:\n        return all(isarray(array[i], test, dim - 1)\n                   for i in range(len(array)))\n    return all(test(i) for i in array)", "code_tokens": "def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "docstring_tokens": "Returns True if test is True for all array elements . Otherwise returns False .", "label": 1}, {"idx": "cosqa-train-19827", "doc": "select column for max column in python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 1}, {"idx": "cosqa-train-19828", "doc": "draw tree recursively in python", "code": "def debugTreePrint(node,pfx=\"->\"):\n  \"\"\"Purely a debugging aid: Ascii-art picture of a tree descended from node\"\"\"\n  print pfx,node.item\n  for c in node.children:\n    debugTreePrint(c,\"  \"+pfx)", "code_tokens": "def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "docstring_tokens": "Purely a debugging aid : Ascii - art picture of a tree descended from node", "label": 0}, {"idx": "cosqa-train-19829", "doc": "create date from string in python", "code": "def get_from_gnucash26_date(date_str: str) -> date:\n    \"\"\" Creates a datetime from GnuCash 2.6 date string \"\"\"\n    date_format = \"%Y%m%d\"\n    result = datetime.strptime(date_str, date_format).date()\n    return result", "code_tokens": "def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "docstring_tokens": "Creates a datetime from GnuCash 2 . 6 date string", "label": 0}, {"idx": "cosqa-train-19830", "doc": "python identify datatype of column", "code": "def get_datatype(self, table: str, column: str) -> str:\n        \"\"\"Returns database SQL datatype for a column: e.g. VARCHAR.\"\"\"\n        return self.flavour.get_datatype(self, table, column).upper()", "code_tokens": "def get_datatype ( self , table : str , column : str ) -> str : return self . flavour . get_datatype ( self , table , column ) . upper ( )", "docstring_tokens": "Returns database SQL datatype for a column : e . g . VARCHAR .", "label": 0}, {"idx": "cosqa-train-19831", "doc": "python type cast all strings in list to int", "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]:\n    \"\"\"\n    Convert a list of strings to a list of integers.\n\n    :param strings: a list of string\n    :return: a list of converted integers\n\n    .. doctest::\n\n        >>> strings_to_integers(['1', '1.0', '-0.2'])\n        [1, 1, 0]\n    \"\"\"\n    return strings_to_(strings, lambda x: int(float(x)))", "code_tokens": "def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "docstring_tokens": "Convert a list of strings to a list of integers .", "label": 1}, {"idx": "cosqa-train-19832", "doc": "python networkx graph filter degree", "code": "def get_input_nodes(G: nx.DiGraph) -> List[str]:\n    \"\"\" Get all input nodes from a network. \"\"\"\n    return [n for n, d in G.in_degree() if d == 0]", "code_tokens": "def get_input_nodes ( G : nx . DiGraph ) -> List [ str ] : return [ n for n , d in G . in_degree ( ) if d == 0 ]", "docstring_tokens": "Get all input nodes from a network .", "label": 1}, {"idx": "cosqa-train-19833", "doc": "replace multiple characters with replace python", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 0}, {"idx": "cosqa-train-19834", "doc": "how to get the time zone from a time and a reference time python", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 1}, {"idx": "cosqa-train-19835", "doc": "get list of attribute in python", "code": "def attr_names(cls) -> List[str]:\n        \"\"\"\n        Returns annotated attribute names\n        :return: List[str]\n        \"\"\"\n        return [k for k, v in cls.attr_types().items()]", "code_tokens": "def attr_names ( cls ) -> List [ str ] : return [ k for k , v in cls . attr_types ( ) . items ( ) ]", "docstring_tokens": "Returns annotated attribute names : return : List [ str ]", "label": 0}, {"idx": "cosqa-train-19836", "doc": "fastest way to extract all lines that match pattern from file python", "code": "def grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''", "code_tokens": "def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "docstring_tokens": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .", "label": 0}, {"idx": "cosqa-train-19837", "doc": "python round function to nearest ten", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 0}, {"idx": "cosqa-train-19838", "doc": "python replace string from right", "code": "def right_replace(string, old, new, count=1):\n    \"\"\"\n    Right replaces ``count`` occurrences of ``old`` with ``new`` in ``string``.\n    For example::\n\n        right_replace('one_two_two', 'two', 'three') -> 'one_two_three'\n    \"\"\"\n    if not string:\n        return string\n    return new.join(string.rsplit(old, count))", "code_tokens": "def right_replace ( string , old , new , count = 1 ) : if not string : return string return new . join ( string . rsplit ( old , count ) )", "docstring_tokens": "Right replaces count occurrences of old with new in string . For example ::", "label": 1}, {"idx": "cosqa-train-19839", "doc": "python function to multiply matrix", "code": "def __rmatmul__(self, other):\n        \"\"\"\n        Matrix multiplication using binary `@` operator in Python>=3.5.\n        \"\"\"\n        return self.T.dot(np.transpose(other)).T", "code_tokens": "def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T", "docstring_tokens": "Matrix multiplication using binary", "label": 0}, {"idx": "cosqa-train-19840", "doc": "python checking memory leak", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 1}, {"idx": "cosqa-train-19841", "doc": "python split sentence on comma", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 0}, {"idx": "cosqa-train-19842", "doc": "python return the positions of all the 1 in array", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 0}, {"idx": "cosqa-train-19843", "doc": "check if string is int in python", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 1}, {"idx": "cosqa-train-19844", "doc": "python how to see the size of matrix", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 0}, {"idx": "cosqa-train-19845", "doc": "check if letter is a blank space python", "code": "def is_blankspace(self, char):\n        \"\"\"\n        Test if a character is a blankspace.\n\n        Parameters\n        ----------\n        char : str\n            The character to test.\n\n        Returns\n        -------\n        ret : bool\n            True if character is a blankspace, False otherwise.\n\n        \"\"\"\n        if len(char) > 1:\n            raise TypeError(\"Expected a char.\")\n        if char in self.blankspaces:\n            return True\n        return False", "code_tokens": "def is_blankspace ( self , char ) : if len ( char ) > 1 : raise TypeError ( \"Expected a char.\" ) if char in self . blankspaces : return True return False", "docstring_tokens": "Test if a character is a blankspace .", "label": 0}, {"idx": "cosqa-train-19846", "doc": "filter that is removing element python", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 1}, {"idx": "cosqa-train-19847", "doc": "python repeat each element of list n times", "code": "def stretch(iterable, n=2):\n    r\"\"\"Repeat each item in `iterable` `n` times.\n\n    Example:\n\n    >>> list(stretch(range(3), 2))\n    [0, 0, 1, 1, 2, 2]\n    \"\"\"\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "code_tokens": "def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "docstring_tokens": "r Repeat each item in iterable n times .", "label": 1}, {"idx": "cosqa-train-19848", "doc": "how do yo ushuffle a list in python", "code": "def consistent_shuffle(*lists):\n    \"\"\"\n    Shuffle lists consistently.\n\n    Parameters\n    ----------\n    *lists\n        Variable length number of lists\n\n    Returns\n    -------\n    shuffled_lists : tuple of lists\n        All of the lists are shuffled consistently\n\n    Examples\n    --------\n    >>> import mpu, random; random.seed(8)\n    >>> mpu.consistent_shuffle([1,2,3], ['a', 'b', 'c'], ['A', 'B', 'C'])\n    ([3, 2, 1], ['c', 'b', 'a'], ['C', 'B', 'A'])\n    \"\"\"\n    perm = list(range(len(lists[0])))\n    random.shuffle(perm)\n    lists = tuple([sublist[index] for index in perm]\n                  for sublist in lists)\n    return lists", "code_tokens": "def consistent_shuffle ( * lists ) : perm = list ( range ( len ( lists [ 0 ] ) ) ) random . shuffle ( perm ) lists = tuple ( [ sublist [ index ] for index in perm ] for sublist in lists ) return lists", "docstring_tokens": "Shuffle lists consistently .", "label": 1}, {"idx": "cosqa-train-19849", "doc": "remove an entry from a dict in python", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 1}, {"idx": "cosqa-train-19850", "doc": "using % and ? as placeholders sqlite3 python", "code": "def execute(cur, *args):\n    \"\"\"Utility function to print sqlite queries before executing.\n\n    Use instead of cur.execute().  First argument is cursor.\n\n    cur.execute(stmt)\n    becomes\n    util.execute(cur, stmt)\n    \"\"\"\n    stmt = args[0]\n    if len(args) > 1:\n        stmt = stmt.replace('%', '%%').replace('?', '%r')\n        print(stmt % (args[1]))\n    return cur.execute(*args)", "code_tokens": "def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )", "docstring_tokens": "Utility function to print sqlite queries before executing .", "label": 1}, {"idx": "cosqa-train-19851", "doc": "python check if no files in directory bytes", "code": "def file_exists(fname):\n    \"\"\"Check if a file exists and is non-empty.\n    \"\"\"\n    try:\n        return fname and os.path.exists(fname) and os.path.getsize(fname) > 0\n    except OSError:\n        return False", "code_tokens": "def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "docstring_tokens": "Check if a file exists and is non - empty .", "label": 1}, {"idx": "cosqa-train-19852", "doc": "concatenate np arrays in python", "code": "def uconcatenate(arrs, axis=0):\n    \"\"\"Concatenate a sequence of arrays.\n\n    This wrapper around numpy.concatenate preserves units. All input arrays\n    must have the same units.  See the documentation of numpy.concatenate for\n    full details.\n\n    Examples\n    --------\n    >>> from unyt import cm\n    >>> A = [1, 2, 3]*cm\n    >>> B = [2, 3, 4]*cm\n    >>> uconcatenate((A, B))\n    unyt_array([1, 2, 3, 2, 3, 4], 'cm')\n\n    \"\"\"\n    v = np.concatenate(arrs, axis=axis)\n    v = _validate_numpy_wrapper_units(v, arrs)\n    return v", "code_tokens": "def uconcatenate ( arrs , axis = 0 ) : v = np . concatenate ( arrs , axis = axis ) v = _validate_numpy_wrapper_units ( v , arrs ) return v", "docstring_tokens": "Concatenate a sequence of arrays .", "label": 1}, {"idx": "cosqa-train-19853", "doc": "check if queue is empty python", "code": "def full(self):\n        \"\"\"Return ``True`` if the queue is full, ``False``\n        otherwise (not reliable!).\n\n        Only applicable if :attr:`maxsize` is set.\n\n        \"\"\"\n        return self.maxsize and len(self.list) >= self.maxsize or False", "code_tokens": "def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False", "docstring_tokens": "Return True if the queue is full False otherwise ( not reliable! ) .", "label": 1}, {"idx": "cosqa-train-19854", "doc": "how to test for empty quotes in python", "code": "def is_quoted(arg: str) -> bool:\n    \"\"\"\n    Checks if a string is quoted\n    :param arg: the string being checked for quotes\n    :return: True if a string is quoted\n    \"\"\"\n    return len(arg) > 1 and arg[0] == arg[-1] and arg[0] in constants.QUOTES", "code_tokens": "def is_quoted ( arg : str ) -> bool : return len ( arg ) > 1 and arg [ 0 ] == arg [ - 1 ] and arg [ 0 ] in constants . QUOTES", "docstring_tokens": "Checks if a string is quoted : param arg : the string being checked for quotes : return : True if a string is quoted", "label": 1}, {"idx": "cosqa-train-19855", "doc": "how to get timezone from datetime in python", "code": "def get_timezone() -> Tuple[datetime.tzinfo, str]:\n    \"\"\"Discover the current time zone and it's standard string representation (for source{d}).\"\"\"\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "code_tokens": "def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "docstring_tokens": "Discover the current time zone and it s standard string representation ( for source { d } ) .", "label": 0}, {"idx": "cosqa-train-19856", "doc": "python replace a specific character in a string", "code": "def __replace_all(repls: dict, input: str) -> str:\n    \"\"\" Replaces from a string **input** all the occurrences of some\n    symbols according to mapping **repls**.\n\n    :param dict repls: where #key is the old character and\n    #value is the one to substitute with;\n    :param str input: original string where to apply the\n    replacements;\n    :return: *(str)* the string with the desired characters replaced\n    \"\"\"\n    return re.sub('|'.join(re.escape(key) for key in repls.keys()),\n                  lambda k: repls[k.group(0)], input)", "code_tokens": "def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "docstring_tokens": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .", "label": 0}, {"idx": "cosqa-train-19857", "doc": "python casting to a bytestream", "code": "def to_bytes(data: Any) -> bytearray:\n    \"\"\"\n    Convert anything to a ``bytearray``.\n    \n    See\n    \n    - http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3\n    - http://stackoverflow.com/questions/10459067/how-to-convert-my-bytearrayb-x9e-x18k-x9a-to-something-like-this-x9e-x1\n    \"\"\"  # noqa\n    if isinstance(data, int):\n        return bytearray([data])\n    return bytearray(data, encoding='latin-1')", "code_tokens": "def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "docstring_tokens": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1", "label": 1}, {"idx": "cosqa-train-19858", "doc": "get the max column value python", "code": "def argmax(self, rows: List[Row], column: ComparableColumn) -> List[Row]:\n        \"\"\"\n        Takes a list of rows and a column name and returns a list containing a single row (dict from\n        columns to cells) that has the maximum numerical value in the given column. We return a list\n        instead of a single dict to be consistent with the return type of ``select`` and\n        ``all_rows``.\n        \"\"\"\n        if not rows:\n            return []\n        value_row_pairs = [(row.values[column.name], row) for row in rows]\n        if not value_row_pairs:\n            return []\n        # Returns a list containing the row with the max cell value.\n        return [sorted(value_row_pairs, key=lambda x: x[0], reverse=True)[0][1]]", "code_tokens": "def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "docstring_tokens": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .", "label": 0}, {"idx": "cosqa-train-19859", "doc": "python sqlalchemy get table columns", "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]:\n    \"\"\"\n    Get all the database column names for the specified table.\n    \"\"\"\n    return [info.name for info in gen_columns_info(engine, tablename)]", "code_tokens": "def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "docstring_tokens": "Get all the database column names for the specified table .", "label": 1}, {"idx": "cosqa-train-19860", "doc": "python get host cpu usage per core", "code": "def cpu_count() -> int:\n    \"\"\"Returns the number of processors on this machine.\"\"\"\n    if multiprocessing is None:\n        return 1\n    try:\n        return multiprocessing.cpu_count()\n    except NotImplementedError:\n        pass\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_CONF\")\n    except (AttributeError, ValueError):\n        pass\n    gen_log.error(\"Could not detect number of processors; assuming 1\")\n    return 1", "code_tokens": "def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( \"SC_NPROCESSORS_CONF\" ) except ( AttributeError , ValueError ) : pass gen_log . error ( \"Could not detect number of processors; assuming 1\" ) return 1", "docstring_tokens": "Returns the number of processors on this machine .", "label": 0}, {"idx": "cosqa-train-19861", "doc": "python asyncio method has no attribute run", "code": "async def async_run(self) -> None:\n        \"\"\"\n        Asynchronously run the worker, does not close connections. Useful when testing.\n        \"\"\"\n        self.main_task = self.loop.create_task(self.main())\n        await self.main_task", "code_tokens": "async def async_run ( self ) -> None : self . main_task = self . loop . create_task ( self . main ( ) ) await self . main_task", "docstring_tokens": "Asynchronously run the worker does not close connections . Useful when testing .", "label": 0}, {"idx": "cosqa-train-19862", "doc": "python method to get the current index of an item in a list", "code": "def _rindex(mylist: Sequence[T], x: T) -> int:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return len(mylist) - mylist[::-1].index(x) - 1", "code_tokens": "def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "docstring_tokens": "Index of the last occurrence of x in the sequence .", "label": 1}, {"idx": "cosqa-train-19863", "doc": "rotate between items in a list python", "code": "def iprotate(l, steps=1):\n    r\"\"\"Like rotate, but modifies `l` in-place.\n\n    >>> l = [1,2,3]\n    >>> iprotate(l) is l\n    True\n    >>> l\n    [2, 3, 1]\n    >>> iprotate(iprotate(l, 2), -3)\n    [1, 2, 3]\n\n    \"\"\"\n    if len(l):\n        steps %= len(l)\n        if steps:\n            firstPart = l[:steps]\n            del l[:steps]\n            l.extend(firstPart)\n    return l", "code_tokens": "def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "docstring_tokens": "r Like rotate but modifies l in - place .", "label": 1}, {"idx": "cosqa-train-19864", "doc": "flatten a list of lists in python", "code": "def flatten_list(x: List[Any]) -> List[Any]:\n    \"\"\"\n    Converts a list of lists into a flat list.\n    \n    Args:\n        x: list of lists \n\n    Returns:\n        flat list\n        \n    As per\n    http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python\n\n    \"\"\"  # noqa\n    return [item for sublist in x for item in sublist]", "code_tokens": "def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "docstring_tokens": "Converts a list of lists into a flat list . Args : x : list of lists", "label": 1}, {"idx": "cosqa-train-19865", "doc": "python get only first item in a list", "code": "def head(self) -> Any:\n        \"\"\"Retrive first element in List.\"\"\"\n\n        lambda_list = self._get_value()\n        return lambda_list(lambda head, _: head)", "code_tokens": "def head ( self ) -> Any : lambda_list = self . _get_value ( ) return lambda_list ( lambda head , _ : head )", "docstring_tokens": "Retrive first element in List .", "label": 1}, {"idx": "cosqa-train-19866", "doc": "python dictionary key to float", "code": "def dictlist_convert_to_float(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, convert\n    (in place) ``d[key]`` to a float. If that fails, convert it to ``None``.\n    \"\"\"\n    for d in dict_list:\n        try:\n            d[key] = float(d[key])\n        except ValueError:\n            d[key] = None", "code_tokens": "def dictlist_convert_to_float ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : try : d [ key ] = float ( d [ key ] ) except ValueError : d [ key ] = None", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d convert ( in place ) d [ key ] to a float . If that fails convert it to None .", "label": 1}, {"idx": "cosqa-train-19867", "doc": "python io skip malformed lines", "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:\n    \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"\n    for line in file_like:\n        line = line.rstrip('\\r\\n')\n        if line:\n            yield line", "code_tokens": "def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "docstring_tokens": "Helper for iterating only nonempty lines without line breaks", "label": 0}, {"idx": "cosqa-train-19868", "doc": "python3 django static images not show with right path", "code": "def compatible_staticpath(path):\n    \"\"\"\n    Try to return a path to static the static files compatible all\n    the way back to Django 1.2. If anyone has a cleaner or better\n    way to do this let me know!\n    \"\"\"\n\n    if VERSION >= (1, 10):\n        # Since Django 1.10, forms.Media automatically invoke static\n        # lazily on the path if it is relative.\n        return path\n    try:\n        # >= 1.4\n        from django.templatetags.static import static\n        return static(path)\n    except ImportError:\n        pass\n    try:\n        # >= 1.3\n        return '%s/%s' % (settings.STATIC_URL.rstrip('/'), path)\n    except AttributeError:\n        pass\n    try:\n        return '%s/%s' % (settings.PAGEDOWN_URL.rstrip('/'), path)\n    except AttributeError:\n        pass\n    return '%s/%s' % (settings.MEDIA_URL.rstrip('/'), path)", "code_tokens": "def compatible_staticpath ( path ) : if VERSION >= ( 1 , 10 ) : # Since Django 1.10, forms.Media automatically invoke static # lazily on the path if it is relative. return path try : # >= 1.4 from django . templatetags . static import static return static ( path ) except ImportError : pass try : # >= 1.3 return '%s/%s' % ( settings . STATIC_URL . rstrip ( '/' ) , path ) except AttributeError : pass try : return '%s/%s' % ( settings . PAGEDOWN_URL . rstrip ( '/' ) , path ) except AttributeError : pass return '%s/%s' % ( settings . MEDIA_URL . rstrip ( '/' ) , path )", "docstring_tokens": "Try to return a path to static the static files compatible all the way back to Django 1 . 2 . If anyone has a cleaner or better way to do this let me know!", "label": 1}, {"idx": "cosqa-train-19869", "doc": "s3 python create and delete \"folder \"", "code": "def mkdir(self, target_folder):\n        \"\"\"\n        Create a folder on S3.\n\n        Examples\n        --------\n            >>> s3utils.mkdir(\"path/to/my_folder\")\n            Making directory: path/to/my_folder\n        \"\"\"\n        self.printv(\"Making directory: %s\" % target_folder)\n        self.k.key = re.sub(r\"^/|/$\", \"\", target_folder) + \"/\"\n        self.k.set_contents_from_string('')\n        self.k.close()", "code_tokens": "def mkdir ( self , target_folder ) : self . printv ( \"Making directory: %s\" % target_folder ) self . k . key = re . sub ( r\"^/|/$\" , \"\" , target_folder ) + \"/\" self . k . set_contents_from_string ( '' ) self . k . close ( )", "docstring_tokens": "Create a folder on S3 .", "label": 0}, {"idx": "cosqa-train-19870", "doc": "python pull first column from table", "code": "def fetchallfirstvalues(self, sql: str, *args) -> List[Any]:\n        \"\"\"Executes SQL; returns list of first values of each row.\"\"\"\n        rows = self.fetchall(sql, *args)\n        return [row[0] for row in rows]", "code_tokens": "def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "docstring_tokens": "Executes SQL ; returns list of first values of each row .", "label": 0}, {"idx": "cosqa-train-19871", "doc": "grep a file in python", "code": "def grep(pattern, filename):\n    \"\"\"Very simple grep that returns the first matching line in a file.\n    String matching only, does not do REs as currently implemented.\n    \"\"\"\n    try:\n        # for line in file\n        # if line matches pattern:\n        #    return line\n        return next((L for L in open(filename) if L.find(pattern) >= 0))\n    except StopIteration:\n        return ''", "code_tokens": "def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "docstring_tokens": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .", "label": 0}, {"idx": "cosqa-train-19872", "doc": "counting token frequency in python", "code": "def _sum_cycles_from_tokens(self, tokens: List[str]) -> int:\n        \"\"\"Sum the total number of cycles over a list of tokens.\"\"\"\n        return sum((int(self._nonnumber_pattern.sub('', t)) for t in tokens))", "code_tokens": "def _sum_cycles_from_tokens ( self , tokens : List [ str ] ) -> int : return sum ( ( int ( self . _nonnumber_pattern . sub ( '' , t ) ) for t in tokens ) )", "docstring_tokens": "Sum the total number of cycles over a list of tokens .", "label": 1}, {"idx": "cosqa-train-19873", "doc": "keep unique element in list python", "code": "def uniqued(iterable):\n    \"\"\"Return unique list of items preserving order.\n\n    >>> uniqued([3, 2, 1, 3, 2, 1, 0])\n    [3, 2, 1, 0]\n    \"\"\"\n    seen = set()\n    add = seen.add\n    return [i for i in iterable if i not in seen and not add(i)]", "code_tokens": "def uniqued ( iterable ) : seen = set ( ) add = seen . add return [ i for i in iterable if i not in seen and not add ( i ) ]", "docstring_tokens": "Return unique list of items preserving order .", "label": 1}, {"idx": "cosqa-train-19874", "doc": "create new dictionary from two python", "code": "def extend(a: dict, b: dict) -> dict:\n    \"\"\"Merge two dicts and return a new dict. Much like subclassing works.\"\"\"\n    res = a.copy()\n    res.update(b)\n    return res", "code_tokens": "def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res", "docstring_tokens": "Merge two dicts and return a new dict . Much like subclassing works .", "label": 1}, {"idx": "cosqa-train-19875", "doc": "how to change a list of int to a string python", "code": "def list_to_str(list, separator=','):\n    \"\"\"\n    >>> list = [0, 0, 7]\n    >>> list_to_str(list)\n    '0,0,7'\n    \"\"\"\n    list = [str(x) for x in list]\n    return separator.join(list)", "code_tokens": "def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "docstring_tokens": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7", "label": 1}, {"idx": "cosqa-train-19876", "doc": "python force the program to exit", "code": "def do_quit(self, _: argparse.Namespace) -> bool:\n        \"\"\"Exit this application\"\"\"\n        self._should_quit = True\n        return self._STOP_AND_EXIT", "code_tokens": "def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "docstring_tokens": "Exit this application", "label": 1}, {"idx": "cosqa-train-19877", "doc": "python load json into dict", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 1}, {"idx": "cosqa-train-19878", "doc": "how to get index of item in list python without index function", "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:\n    \"\"\"\n    Finds the index of an item in list, which satisfies predicate\n    :param predicateFn: predicate function to run on items of list\n    :param items: list of tuples\n    :return: first index for which predicate function returns True\n    \"\"\"\n    try:\n        return next(i for i, v in enumerate(items) if predicateFn(v))\n    except StopIteration:\n        return -1", "code_tokens": "def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "docstring_tokens": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True", "label": 0}, {"idx": "cosqa-train-19879", "doc": "turn list of lists into one list python", "code": "def flatten_list(l: List[list]) -> list:\n    \"\"\" takes a list of lists, l and returns a flat list\n    \"\"\"\n    return [v for inner_l in l for v in inner_l]", "code_tokens": "def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "docstring_tokens": "takes a list of lists l and returns a flat list", "label": 1}, {"idx": "cosqa-train-19880", "doc": "how to see content of text file in python", "code": "def read_text_from_file(path: str) -> str:\n    \"\"\" Reads text file contents \"\"\"\n    with open(path) as text_file:\n        content = text_file.read()\n\n    return content", "code_tokens": "def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "docstring_tokens": "Reads text file contents", "label": 1}, {"idx": "cosqa-train-19881", "doc": "how to execute a parser script in python", "code": "def cli_run():\n    \"\"\"docstring for argparse\"\"\"\n    parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow')\n    parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+')\n    parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda')\n    args = parser.parse_args()\n    main(args)", "code_tokens": "def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "docstring_tokens": "docstring for argparse", "label": 1}, {"idx": "cosqa-train-19882", "doc": "python read csv to numpy matrix including strings", "code": "def csv_to_numpy(string_like, dtype=None):  # type: (str) -> np.array\n    \"\"\"Convert a CSV object to a numpy array.\n\n    Args:\n        string_like (str): CSV string.\n        dtype (dtype, optional):  Data type of the resulting array. If None, the dtypes will be determined by the\n                                        contents of each column, individually. This argument can only be used to\n                                        'upcast' the array.  For downcasting, use the .astype(t) method.\n    Returns:\n        (np.array): numpy array\n    \"\"\"\n    stream = StringIO(string_like)\n    return np.genfromtxt(stream, dtype=dtype, delimiter=',')", "code_tokens": "def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "docstring_tokens": "Convert a CSV object to a numpy array .", "label": 0}, {"idx": "cosqa-train-19883", "doc": "python lower roundoff float", "code": "def proper_round(n):\n    \"\"\"\n    rounds float to closest int\n    :rtype: int\n    :param n: float\n    \"\"\"\n    return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0", "code_tokens": "def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "docstring_tokens": "rounds float to closest int : rtype : int : param n : float", "label": 1}, {"idx": "cosqa-train-19884", "doc": "python how to tell if file is empty", "code": "def isfile_notempty(inputfile: str) -> bool:\n        \"\"\"Check if the input filename with path is a file and is not empty.\"\"\"\n        try:\n            return isfile(inputfile) and getsize(inputfile) > 0\n        except TypeError:\n            raise TypeError('inputfile is not a valid type')", "code_tokens": "def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )", "docstring_tokens": "Check if the input filename with path is a file and is not empty .", "label": 1}, {"idx": "cosqa-train-19885", "doc": "python tensor to a single float", "code": "def fcast(value: float) -> TensorLike:\n    \"\"\"Cast to float tensor\"\"\"\n    newvalue = tf.cast(value, FTYPE)\n    if DEVICE == 'gpu':\n        newvalue = newvalue.gpu()  # Why is this needed?  # pragma: no cover\n    return newvalue", "code_tokens": "def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "docstring_tokens": "Cast to float tensor", "label": 0}, {"idx": "cosqa-train-19886", "doc": "select first 10 rows in python", "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\\n        -> Generator[Any, None, None]:\n    \"\"\"\n    Generate the first value in each row.\n\n    Args:\n        cursor: the cursor\n        arraysize: split fetches into chunks of this many records\n\n    Yields:\n        the first value of each row\n    \"\"\"\n    return (row[0] for row in genrows(cursor, arraysize))", "code_tokens": "def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "docstring_tokens": "Generate the first value in each row .", "label": 0}, {"idx": "cosqa-train-19887", "doc": "how to check csv file is empty in python", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 0}, {"idx": "cosqa-train-19888", "doc": "python string rules with lower and uppercase letters", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 1}, {"idx": "cosqa-train-19889", "doc": "datetime to excel timestamp python3", "code": "def excel_datetime(timestamp, epoch=None):\n    \"\"\"Return datetime object from timestamp in Excel serial format.\n\n    Convert LSM time stamps.\n\n    >>> excel_datetime(40237.029999999795)\n    datetime.datetime(2010, 2, 28, 0, 43, 11, 999982)\n\n    \"\"\"\n    if epoch is None:\n        epoch = datetime.datetime.fromordinal(693594)\n    return epoch + datetime.timedelta(timestamp)", "code_tokens": "def excel_datetime ( timestamp , epoch = None ) : if epoch is None : epoch = datetime . datetime . fromordinal ( 693594 ) return epoch + datetime . timedelta ( timestamp )", "docstring_tokens": "Return datetime object from timestamp in Excel serial format .", "label": 0}, {"idx": "cosqa-train-19890", "doc": "python get the minimum value along axis in numpy", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 1}, {"idx": "cosqa-train-19891", "doc": "moving average predictionn using python on sales data aset", "code": "def simple_moving_average(x, n=10):\n    \"\"\"\n    Calculate simple moving average\n\n    Parameters\n    ----------\n    x : ndarray\n        A numpy array\n    n : integer\n        The number of sample points used to make average\n\n    Returns\n    -------\n    ndarray\n        A 1 x n numpy array instance\n    \"\"\"\n    if x.ndim > 1 and len(x[0]) > 1:\n        x = np.average(x, axis=1)\n    a = np.ones(n) / float(n)\n    return np.convolve(x, a, 'valid')", "code_tokens": "def simple_moving_average ( x , n = 10 ) : if x . ndim > 1 and len ( x [ 0 ] ) > 1 : x = np . average ( x , axis = 1 ) a = np . ones ( n ) / float ( n ) return np . convolve ( x , a , 'valid' )", "docstring_tokens": "Calculate simple moving average", "label": 0}, {"idx": "cosqa-train-19892", "doc": "remove duplicate from list python", "code": "def de_duplicate(items):\n    \"\"\"Remove any duplicate item, preserving order\n\n    >>> de_duplicate([1, 2, 1, 2])\n    [1, 2]\n    \"\"\"\n    result = []\n    for item in items:\n        if item not in result:\n            result.append(item)\n    return result", "code_tokens": "def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "docstring_tokens": "Remove any duplicate item preserving order", "label": 1}, {"idx": "cosqa-train-19893", "doc": "remove python xml elementtree", "code": "def recClearTag(element):\n    \"\"\"Applies maspy.xml.clearTag() to the tag attribute of the \"element\" and\n    recursively to all child elements.\n\n    :param element: an :instance:`xml.etree.Element`\n    \"\"\"\n    children = element.getchildren()\n    if len(children) > 0:\n        for child in children:\n            recClearTag(child)\n    element.tag = clearTag(element.tag)", "code_tokens": "def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "docstring_tokens": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .", "label": 0}, {"idx": "cosqa-train-19894", "doc": "max called on an array python", "code": "def argmax(iterable, key=None, both=False):\n    \"\"\"\n    >>> argmax([4,2,-5])\n    0\n    >>> argmax([4,2,-5], key=abs)\n    2\n    >>> argmax([4,2,-5], key=abs, both=True)\n    (2, 5)\n    \"\"\"\n    if key is not None:\n        it = imap(key, iterable)\n    else:\n        it = iter(iterable)\n    score, argmax = reduce(max, izip(it, count()))\n    if both:\n        return argmax, score\n    return argmax", "code_tokens": "def argmax ( iterable , key = None , both = False ) : if key is not None : it = imap ( key , iterable ) else : it = iter ( iterable ) score , argmax = reduce ( max , izip ( it , count ( ) ) ) if both : return argmax , score return argmax", "docstring_tokens": ">>> argmax ( [ 4 2 - 5 ] ) 0 >>> argmax ( [ 4 2 - 5 ] key = abs ) 2 >>> argmax ( [ 4 2 - 5 ] key = abs both = True ) ( 2 5 )", "label": 0}, {"idx": "cosqa-train-19895", "doc": "logarithmic plot zero python", "code": "def _protected_log(x1):\n    \"\"\"Closure of log for zero arguments.\"\"\"\n    with np.errstate(divide='ignore', invalid='ignore'):\n        return np.where(np.abs(x1) > 0.001, np.log(np.abs(x1)), 0.)", "code_tokens": "def _protected_log ( x1 ) : with np . errstate ( divide = 'ignore' , invalid = 'ignore' ) : return np . where ( np . abs ( x1 ) > 0.001 , np . log ( np . abs ( x1 ) ) , 0. )", "docstring_tokens": "Closure of log for zero arguments .", "label": 0}, {"idx": "cosqa-train-19896", "doc": "python simulate keyboard events linux", "code": "def _kbhit_unix() -> bool:\n    \"\"\"\n    Under UNIX: is a keystroke available?\n    \"\"\"\n    dr, dw, de = select.select([sys.stdin], [], [], 0)\n    return dr != []", "code_tokens": "def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "docstring_tokens": "Under UNIX : is a keystroke available?", "label": 1}, {"idx": "cosqa-train-19897", "doc": "python return top 10 prediction results with probabilites", "code": "def mostLikely(self, pred):\n    \"\"\" Helper function to return a scalar value representing the most\n        likely outcome given a probability distribution\n    \"\"\"\n    if len(pred) == 1:\n      return pred.keys()[0]\n\n    mostLikelyOutcome = None\n    maxProbability = 0\n\n    for prediction, probability in pred.items():\n      if probability > maxProbability:\n        mostLikelyOutcome = prediction\n        maxProbability = probability\n\n    return mostLikelyOutcome", "code_tokens": "def mostLikely ( self , pred ) : if len ( pred ) == 1 : return pred . keys ( ) [ 0 ] mostLikelyOutcome = None maxProbability = 0 for prediction , probability in pred . items ( ) : if probability > maxProbability : mostLikelyOutcome = prediction maxProbability = probability return mostLikelyOutcome", "docstring_tokens": "Helper function to return a scalar value representing the most likely outcome given a probability distribution", "label": 1}, {"idx": "cosqa-train-19898", "doc": "index of min in vecotr python", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 1}, {"idx": "cosqa-train-19899", "doc": "json file to dict in python", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 1}, {"idx": "cosqa-train-19900", "doc": "python list comprehension moving average", "code": "def moving_average(arr: np.ndarray, n: int = 3) -> np.ndarray:\n    \"\"\" Calculate the moving overage over an array.\n\n    Algorithm from: https://stackoverflow.com/a/14314054\n\n    Args:\n        arr (np.ndarray): Array over which to calculate the moving average.\n        n (int): Number of elements over which to calculate the moving average. Default: 3\n    Returns:\n        np.ndarray: Moving average calculated over n.\n    \"\"\"\n    ret = np.cumsum(arr, dtype=float)\n    ret[n:] = ret[n:] - ret[:-n]\n    return ret[n - 1:] / n", "code_tokens": "def moving_average ( arr : np . ndarray , n : int = 3 ) -> np . ndarray : ret = np . cumsum ( arr , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n", "docstring_tokens": "Calculate the moving overage over an array .", "label": 0}, {"idx": "cosqa-train-19901", "doc": "how to truncate decimals python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 0}, {"idx": "cosqa-train-19902", "doc": "python delete all files with certain extension", "code": "def rmglob(pattern: str) -> None:\n    \"\"\"\n    Deletes all files whose filename matches the glob ``pattern`` (via\n    :func:`glob.glob`).\n    \"\"\"\n    for f in glob.glob(pattern):\n        os.remove(f)", "code_tokens": "def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "docstring_tokens": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .", "label": 1}, {"idx": "cosqa-train-19903", "doc": "python change plural to singular", "code": "def singularize(word):\n    \"\"\"\n    Return the singular form of a word, the reverse of :func:`pluralize`.\n\n    Examples::\n\n        >>> singularize(\"posts\")\n        \"post\"\n        >>> singularize(\"octopi\")\n        \"octopus\"\n        >>> singularize(\"sheep\")\n        \"sheep\"\n        >>> singularize(\"word\")\n        \"word\"\n        >>> singularize(\"CamelOctopi\")\n        \"CamelOctopus\"\n\n    \"\"\"\n    for inflection in UNCOUNTABLES:\n        if re.search(r'(?i)\\b(%s)\\Z' % inflection, word):\n            return word\n\n    for rule, replacement in SINGULARS:\n        if re.search(rule, word):\n            return re.sub(rule, replacement, word)\n    return word", "code_tokens": "def singularize ( word ) : for inflection in UNCOUNTABLES : if re . search ( r'(?i)\\b(%s)\\Z' % inflection , word ) : return word for rule , replacement in SINGULARS : if re . search ( rule , word ) : return re . sub ( rule , replacement , word ) return word", "docstring_tokens": "Return the singular form of a word the reverse of : func : pluralize .", "label": 1}, {"idx": "cosqa-train-19904", "doc": "how to pytorch tensors can be converted to python scalars", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 0}, {"idx": "cosqa-train-19905", "doc": "python separate string to list", "code": "def _str_to_list(value, separator):\n    \"\"\"Convert a string to a list with sanitization.\"\"\"\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "code_tokens": "def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "docstring_tokens": "Convert a string to a list with sanitization .", "label": 1}, {"idx": "cosqa-train-19906", "doc": "python opencv hsv black range", "code": "def hsv2rgb_spectrum(hsv):\n    \"\"\"Generates RGB values from HSV values in line with a typical light\n    spectrum.\"\"\"\n    h, s, v = hsv\n    return hsv2rgb_raw(((h * 192) >> 8, s, v))", "code_tokens": "def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "docstring_tokens": "Generates RGB values from HSV values in line with a typical light spectrum .", "label": 1}, {"idx": "cosqa-train-19907", "doc": "python if string contains space delete space", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 0}, {"idx": "cosqa-train-19908", "doc": "python remove all instances of a char in a string", "code": "def clean(ctx, text):\n    \"\"\"\n    Removes all non-printable characters from a text string\n    \"\"\"\n    text = conversions.to_string(text, ctx)\n    return ''.join([c for c in text if ord(c) >= 32])", "code_tokens": "def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "docstring_tokens": "Removes all non - printable characters from a text string", "label": 0}, {"idx": "cosqa-train-19909", "doc": "python merge to dic", "code": "def extend(a: dict, b: dict) -> dict:\n    \"\"\"Merge two dicts and return a new dict. Much like subclassing works.\"\"\"\n    res = a.copy()\n    res.update(b)\n    return res", "code_tokens": "def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res", "docstring_tokens": "Merge two dicts and return a new dict . Much like subclassing works .", "label": 0}, {"idx": "cosqa-train-19910", "doc": "python minimum of multiple series", "code": "def last_location_of_minimum(x):\n    \"\"\"\n    Returns the last location of the minimal value of x.\n    The position is calculated relatively to the length of x.\n\n    :param x: the time series to calculate the feature of\n    :type x: numpy.ndarray\n    :return: the value of this feature\n    :return type: float\n    \"\"\"\n    x = np.asarray(x)\n    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN", "code_tokens": "def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "docstring_tokens": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .", "label": 0}, {"idx": "cosqa-train-19911", "doc": "python to title case with apostrophe in string", "code": "def snake_to_camel(s: str) -> str:\n    \"\"\"Convert string from snake case to camel case.\"\"\"\n\n    fragments = s.split('_')\n\n    return fragments[0] + ''.join(x.title() for x in fragments[1:])", "code_tokens": "def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "docstring_tokens": "Convert string from snake case to camel case .", "label": 1}, {"idx": "cosqa-train-19912", "doc": "deleting a element from a dictionary python", "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None:\n    \"\"\"\n    Process an iterable of dictionaries. For each dictionary ``d``, delete\n    ``d[key]`` if it exists.\n    \"\"\"\n    for d in dict_list:\n        d.pop(key, None)", "code_tokens": "def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "docstring_tokens": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .", "label": 0}, {"idx": "cosqa-train-19913", "doc": "use python to check if a process is running", "code": "def is_running(process_id: int) -> bool:\n    \"\"\"\n    Uses the Unix ``ps`` program to see if a process is running.\n    \"\"\"\n    pstr = str(process_id)\n    encoding = sys.getdefaultencoding()\n    s = subprocess.Popen([\"ps\", \"-p\", pstr], stdout=subprocess.PIPE)\n    for line in s.stdout:\n        strline = line.decode(encoding)\n        if pstr in strline:\n            return True\n    return False", "code_tokens": "def is_running ( process_id : int ) -> bool : pstr = str ( process_id ) encoding = sys . getdefaultencoding ( ) s = subprocess . Popen ( [ \"ps\" , \"-p\" , pstr ] , stdout = subprocess . PIPE ) for line in s . stdout : strline = line . decode ( encoding ) if pstr in strline : return True return False", "docstring_tokens": "Uses the Unix ps program to see if a process is running .", "label": 1}, {"idx": "cosqa-train-19914", "doc": "catch logarithm zero python", "code": "def _protected_log(x1):\n    \"\"\"Closure of log for zero arguments.\"\"\"\n    with np.errstate(divide='ignore', invalid='ignore'):\n        return np.where(np.abs(x1) > 0.001, np.log(np.abs(x1)), 0.)", "code_tokens": "def _protected_log ( x1 ) : with np . errstate ( divide = 'ignore' , invalid = 'ignore' ) : return np . where ( np . abs ( x1 ) > 0.001 , np . log ( np . abs ( x1 ) ) , 0. )", "docstring_tokens": "Closure of log for zero arguments .", "label": 0}, {"idx": "cosqa-train-19915", "doc": "python how to make a list a hashable type", "code": "def _my_hash(arg_list):\n    # type: (List[Any]) -> int\n    \"\"\"Simple helper hash function\"\"\"\n    res = 0\n    for arg in arg_list:\n        res = res * 31 + hash(arg)\n    return res", "code_tokens": "def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "docstring_tokens": "Simple helper hash function", "label": 0}, {"idx": "cosqa-train-19916", "doc": "how to check datatype of a column in python", "code": "def is_sqlatype_string(coltype: Union[TypeEngine, VisitableType]) -> bool:\n    \"\"\"\n    Is the SQLAlchemy column type a string type?\n    \"\"\"\n    coltype = _coltype_to_typeengine(coltype)\n    return isinstance(coltype, sqltypes.String)", "code_tokens": "def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "docstring_tokens": "Is the SQLAlchemy column type a string type?", "label": 0}, {"idx": "cosqa-train-19917", "doc": "python, odbc, ms access check if record exists", "code": "def has_obstory_metadata(self, status_id):\n        \"\"\"\n        Check for the presence of the given metadata item\n\n        :param string status_id:\n            The metadata item ID\n        :return:\n            True if we have a metadata item with this ID, False otherwise\n        \"\"\"\n        self.con.execute('SELECT 1 FROM archive_metadata WHERE publicId=%s;', (status_id,))\n        return len(self.con.fetchall()) > 0", "code_tokens": "def has_obstory_metadata ( self , status_id ) : self . con . execute ( 'SELECT 1 FROM archive_metadata WHERE publicId=%s;' , ( status_id , ) ) return len ( self . con . fetchall ( ) ) > 0", "docstring_tokens": "Check for the presence of the given metadata item", "label": 0}, {"idx": "cosqa-train-19918", "doc": "how to check if file exist in key python", "code": "def has_key(cls, *args):\n        \"\"\"\n        Check whether flyweight object with specified key has already been created.\n\n        Returns:\n            bool: True if already created, False if not\n        \"\"\"\n        key = args if len(args) > 1 else args[0]\n        return key in cls._instances", "code_tokens": "def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "docstring_tokens": "Check whether flyweight object with specified key has already been created .", "label": 0}, {"idx": "cosqa-train-19919", "doc": "python top n elements", "code": "def top(self, topn=10):\n        \"\"\"\n        Get a list of the top ``topn`` features in this :class:`.Feature`\\.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n        >>> myFeature = Feature([('the', 2), ('pine', 1), ('trapezoid', 5)])\n        >>> myFeature.top(1)\n        [('trapezoid', 5)]\n\n        Parameters\n        ----------\n        topn : int\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]", "code_tokens": "def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "docstring_tokens": "Get a list of the top topn features in this : class : . Feature \\ .", "label": 1}, {"idx": "cosqa-train-19920", "doc": "python assert command not found", "code": "def require(executable: str, explanation: str = \"\") -> None:\n    \"\"\"\n    Ensures that the external tool is available.\n    Asserts upon failure.\n    \"\"\"\n    assert shutil.which(executable), \"Need {!r} on the PATH.{}\".format(\n        executable, \"\\n\" + explanation if explanation else \"\")", "code_tokens": "def require ( executable : str , explanation : str = \"\" ) -> None : assert shutil . which ( executable ) , \"Need {!r} on the PATH.{}\" . format ( executable , \"\\n\" + explanation if explanation else \"\" )", "docstring_tokens": "Ensures that the external tool is available . Asserts upon failure .", "label": 1}, {"idx": "cosqa-train-19921", "doc": "python length of column 1 of np array", "code": "def rank(tensor: BKTensor) -> int:\n    \"\"\"Return the number of dimensions of a tensor\"\"\"\n    if isinstance(tensor, np.ndarray):\n        return len(tensor.shape)\n\n    return len(tensor[0].size())", "code_tokens": "def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "docstring_tokens": "Return the number of dimensions of a tensor", "label": 0}, {"idx": "cosqa-train-19922", "doc": "create a dict with keys as list indices python", "code": "def make_indices_to_labels(labels: Set[str]) -> Dict[int, str]:\n    \"\"\" Creates a mapping from indices to labels. \"\"\"\n\n    return {index: label for index, label in\n            enumerate([\"pad\"] + sorted(list(labels)))}", "code_tokens": "def make_indices_to_labels ( labels : Set [ str ] ) -> Dict [ int , str ] : return { index : label for index , label in enumerate ( [ \"pad\" ] + sorted ( list ( labels ) ) ) }", "docstring_tokens": "Creates a mapping from indices to labels .", "label": 1}, {"idx": "cosqa-train-19923", "doc": "how to check if set is subset of another set python", "code": "def issubset(self, other):\n        \"\"\"\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        \"\"\"\n        if len(self) > len(other):  # Fast check for obvious cases\n            return False\n        return all(item in other for item in self)", "code_tokens": "def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "docstring_tokens": "Report whether another set contains this set .", "label": 1}, {"idx": "cosqa-train-19924", "doc": "python remove elements from a list not in another list", "code": "def without(seq1, seq2):\n    r\"\"\"Return a list with all elements in `seq2` removed from `seq1`, order\n    preserved.\n\n    Examples:\n\n    >>> without([1,2,3,1,2], [1])\n    [2, 3, 2]\n    \"\"\"\n    if isSet(seq2): d2 = seq2\n    else: d2 = set(seq2)\n    return [elt for elt in seq1 if elt not in d2]", "code_tokens": "def without ( seq1 , seq2 ) : if isSet ( seq2 ) : d2 = seq2 else : d2 = set ( seq2 ) return [ elt for elt in seq1 if elt not in d2 ]", "docstring_tokens": "r Return a list with all elements in seq2 removed from seq1 order preserved .", "label": 0}, {"idx": "cosqa-train-19925", "doc": "python int 8bit data type", "code": "def read32(bytestream):\n  \"\"\"Read 4 bytes from bytestream as an unsigned 32-bit integer.\"\"\"\n  dt = np.dtype(np.uint32).newbyteorder('>')\n  return np.frombuffer(bytestream.read(4), dtype=dt)[0]", "code_tokens": "def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "docstring_tokens": "Read 4 bytes from bytestream as an unsigned 32 - bit integer .", "label": 0}, {"idx": "cosqa-train-19926", "doc": "try catch block python time limit api", "code": "def _check_stream_timeout(started, timeout):\n    \"\"\"Check if the timeout has been reached and raise a `StopIteration` if so.\n    \"\"\"\n    if timeout:\n        elapsed = datetime.datetime.utcnow() - started\n        if elapsed.seconds > timeout:\n            raise StopIteration", "code_tokens": "def _check_stream_timeout ( started , timeout ) : if timeout : elapsed = datetime . datetime . utcnow ( ) - started if elapsed . seconds > timeout : raise StopIteration", "docstring_tokens": "Check if the timeout has been reached and raise a StopIteration if so .", "label": 0}, {"idx": "cosqa-train-19927", "doc": "sets and lists in python similarity", "code": "def tanimoto_set_similarity(x: Iterable[X], y: Iterable[X]) -> float:\n    \"\"\"Calculate the tanimoto set similarity.\"\"\"\n    a, b = set(x), set(y)\n    union = a | b\n\n    if not union:\n        return 0.0\n\n    return len(a & b) / len(union)", "code_tokens": "def tanimoto_set_similarity ( x : Iterable [ X ] , y : Iterable [ X ] ) -> float : a , b = set ( x ) , set ( y ) union = a | b if not union : return 0.0 return len ( a & b ) / len ( union )", "docstring_tokens": "Calculate the tanimoto set similarity .", "label": 1}, {"idx": "cosqa-train-19928", "doc": "python how to check if a file is empty or not", "code": "def _cnx_is_empty(in_file):\n    \"\"\"Check if cnr or cns files are empty (only have a header)\n    \"\"\"\n    with open(in_file) as in_handle:\n        for i, line in enumerate(in_handle):\n            if i > 0:\n                return False\n    return True", "code_tokens": "def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "docstring_tokens": "Check if cnr or cns files are empty ( only have a header )", "label": 0}, {"idx": "cosqa-train-19929", "doc": "get first character of string in a list python", "code": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1", "code_tokens": "def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "docstring_tokens": "Returns the index of the earliest occurence of an item from a list in a string", "label": 1}, {"idx": "cosqa-train-19930", "doc": "type quit to exit program python", "code": "def do_quit(self, _: argparse.Namespace) -> bool:\n        \"\"\"Exit this application\"\"\"\n        self._should_quit = True\n        return self._STOP_AND_EXIT", "code_tokens": "def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "docstring_tokens": "Exit this application", "label": 1}, {"idx": "cosqa-train-19931", "doc": "non blank lines python", "code": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))", "code_tokens": "def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "docstring_tokens": "Removes all blank lines in @string", "label": 0}, {"idx": "cosqa-train-19932", "doc": "python delete files wildcard", "code": "def rmglob(pattern: str) -> None:\n    \"\"\"\n    Deletes all files whose filename matches the glob ``pattern`` (via\n    :func:`glob.glob`).\n    \"\"\"\n    for f in glob.glob(pattern):\n        os.remove(f)", "code_tokens": "def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "docstring_tokens": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .", "label": 0}, {"idx": "cosqa-train-19933", "doc": "python remove word contains list", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 1}, {"idx": "cosqa-train-19934", "doc": "get cursor position python", "code": "def position(self) -> Position:\n        \"\"\"The current position of the cursor.\"\"\"\n        return Position(self._index, self._lineno, self._col_offset)", "code_tokens": "def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "docstring_tokens": "The current position of the cursor .", "label": 0}, {"idx": "cosqa-train-19935", "doc": "python remove all emptstrings from list", "code": "def remove_empty_text(utterances: List[Utterance]) -> List[Utterance]:\n    \"\"\"Remove empty utterances from a list of utterances\n    Args:\n        utterances: The list of utterance we are processing\n    \"\"\"\n    return [utter for utter in utterances if utter.text.strip() != \"\"]", "code_tokens": "def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "docstring_tokens": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing", "label": 1}, {"idx": "cosqa-train-19936", "doc": "python return index of list duplicates", "code": "def _duplicates(list_):\n    \"\"\"Return dict mapping item -> indices.\"\"\"\n    item_indices = {}\n    for i, item in enumerate(list_):\n        try:\n            item_indices[item].append(i)\n        except KeyError:  # First time seen\n            item_indices[item] = [i]\n    return item_indices", "code_tokens": "def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "docstring_tokens": "Return dict mapping item - > indices .", "label": 1}, {"idx": "cosqa-train-19937", "doc": "python set precision on string", "code": "def trim_decimals(s, precision=-3):\n        \"\"\"\n        Convert from scientific notation using precision\n        \"\"\"\n        encoded = s.encode('ascii', 'ignore')\n        str_val = \"\"\n        if six.PY3:\n            str_val = str(encoded, encoding='ascii', errors='ignore')[:precision]\n        else:\n            # If precision is 0, this must be handled seperately\n            if precision == 0:\n                str_val = str(encoded)\n            else:\n                str_val = str(encoded)[:precision]\n        if len(str_val) > 0:\n            return float(str_val)\n        else:\n            return 0", "code_tokens": "def trim_decimals ( s , precision = - 3 ) : encoded = s . encode ( 'ascii' , 'ignore' ) str_val = \"\" if six . PY3 : str_val = str ( encoded , encoding = 'ascii' , errors = 'ignore' ) [ : precision ] else : # If precision is 0, this must be handled seperately if precision == 0 : str_val = str ( encoded ) else : str_val = str ( encoded ) [ : precision ] if len ( str_val ) > 0 : return float ( str_val ) else : return 0", "docstring_tokens": "Convert from scientific notation using precision", "label": 1}, {"idx": "cosqa-train-19938", "doc": "calculate a sphere through data points with python", "code": "def arcball_map_to_sphere(point, center, radius):\n    \"\"\"Return unit sphere coordinates from window coordinates.\"\"\"\n    v0 = (point[0] - center[0]) / radius\n    v1 = (center[1] - point[1]) / radius\n    n = v0*v0 + v1*v1\n    if n > 1.0:\n        # position outside of sphere\n        n = math.sqrt(n)\n        return numpy.array([v0/n, v1/n, 0.0])\n    else:\n        return numpy.array([v0, v1, math.sqrt(1.0 - n)])", "code_tokens": "def arcball_map_to_sphere ( point , center , radius ) : v0 = ( point [ 0 ] - center [ 0 ] ) / radius v1 = ( center [ 1 ] - point [ 1 ] ) / radius n = v0 * v0 + v1 * v1 if n > 1.0 : # position outside of sphere n = math . sqrt ( n ) return numpy . array ( [ v0 / n , v1 / n , 0.0 ] ) else : return numpy . array ( [ v0 , v1 , math . sqrt ( 1.0 - n ) ] )", "docstring_tokens": "Return unit sphere coordinates from window coordinates .", "label": 1}, {"idx": "cosqa-train-19939", "doc": "python how to remove leading zeroes", "code": "def __remove_trailing_zeros(self, collection):\n        \"\"\"Removes trailing zeroes from indexable collection of numbers\"\"\"\n        index = len(collection) - 1\n        while index >= 0 and collection[index] == 0:\n            index -= 1\n\n        return collection[:index + 1]", "code_tokens": "def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "docstring_tokens": "Removes trailing zeroes from indexable collection of numbers", "label": 0}, {"idx": "cosqa-train-19940", "doc": "flatten dic of nested dict python", "code": "def flatten_multidict(multidict):\n    \"\"\"Return flattened dictionary from ``MultiDict``.\"\"\"\n    return dict([(key, value if len(value) > 1 else value[0])\n                 for (key, value) in multidict.iterlists()])", "code_tokens": "def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "docstring_tokens": "Return flattened dictionary from MultiDict .", "label": 1}, {"idx": "cosqa-train-19941", "doc": "if x is not equal to integer in python", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 1}, {"idx": "cosqa-train-19942", "doc": "how to split multiple tokens in python", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 0}, {"idx": "cosqa-train-19943", "doc": "how to do normal cdf in python", "code": "def normcdf(x, log=False):\n    \"\"\"Normal cumulative density function.\"\"\"\n    y = np.atleast_1d(x).copy()\n    flib.normcdf(y)\n    if log:\n        if (y>0).all():\n            return np.log(y)\n        return -np.inf\n    return y", "code_tokens": "def normcdf ( x , log = False ) : y = np . atleast_1d ( x ) . copy ( ) flib . normcdf ( y ) if log : if ( y > 0 ) . all ( ) : return np . log ( y ) return - np . inf return y", "docstring_tokens": "Normal cumulative density function .", "label": 0}, {"idx": "cosqa-train-19944", "doc": "python split sentence into words by spaces and comma", "code": "def split(text: str) -> List[str]:\n    \"\"\"Split a text into a list of tokens.\n\n    :param text: the text to split\n    :return: tokens\n    \"\"\"\n    return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]", "code_tokens": "def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "docstring_tokens": "Split a text into a list of tokens .", "label": 0}, {"idx": "cosqa-train-19945", "doc": "change dtype python to int64", "code": "def to_int64(a):\n    \"\"\"Return view of the recarray with all int32 cast to int64.\"\"\"\n    # build new dtype and replace i4 --> i8\n    def promote_i4(typestr):\n        if typestr[1:] == 'i4':\n            typestr = typestr[0]+'i8'\n        return typestr\n\n    dtype = [(name, promote_i4(typestr)) for name,typestr in a.dtype.descr]\n    return a.astype(dtype)", "code_tokens": "def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )", "docstring_tokens": "Return view of the recarray with all int32 cast to int64 .", "label": 1}, {"idx": "cosqa-train-19946", "doc": "python turning text file into set", "code": "def read_set_from_file(filename: str) -> Set[str]:\n    \"\"\"\n    Extract a de-duped collection (set) of text from a file.\n    Expected file format is one item per line.\n    \"\"\"\n    collection = set()\n    with open(filename, 'r') as file_:\n        for line in file_:\n            collection.add(line.rstrip())\n    return collection", "code_tokens": "def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "docstring_tokens": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .", "label": 1}, {"idx": "cosqa-train-19947", "doc": "denote not a number in python", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 0}, {"idx": "cosqa-train-19948", "doc": "datetime from string to datetime in python", "code": "def str_to_time(time_str: str) -> datetime.datetime:\n    \"\"\"\n    Convert human readable string to datetime.datetime.\n    \"\"\"\n    pieces: Any = [int(piece) for piece in time_str.split('-')]\n    return datetime.datetime(*pieces)", "code_tokens": "def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "docstring_tokens": "Convert human readable string to datetime . datetime .", "label": 0}, {"idx": "cosqa-train-19949", "doc": "python check for next character in a string", "code": "def test_string(self, string: str) -> bool:\n        \"\"\"If `string` comes next, return ``True`` and advance offset.\n\n        Args:\n            string: string to test\n        \"\"\"\n        if self.input.startswith(string, self.offset):\n            self.offset += len(string)\n            return True\n        return False", "code_tokens": "def test_string ( self , string : str ) -> bool : if self . input . startswith ( string , self . offset ) : self . offset += len ( string ) return True return False", "docstring_tokens": "If string comes next return True and advance offset .", "label": 0}, {"idx": "cosqa-train-19950", "doc": "how to print exit code python", "code": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)", "code_tokens": "def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "docstring_tokens": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting", "label": 0}, {"idx": "cosqa-train-19951", "doc": "how do you limit the number of decimals of a number in python", "code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "code_tokens": "def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "docstring_tokens": "Truncates a value to a number of decimals places", "label": 0}, {"idx": "cosqa-train-19952", "doc": "capture the standard output stream of a cell into a variable in local namespace ,python", "code": "def capture_stdout():\n    \"\"\"Intercept standard output in a with-context\n    :return: cStringIO instance\n\n    >>> with capture_stdout() as stdout:\n            ...\n        print stdout.getvalue()\n    \"\"\"\n    stdout = sys.stdout\n    sys.stdout = six.moves.cStringIO()\n    try:\n        yield sys.stdout\n    finally:\n        sys.stdout = stdout", "code_tokens": "def capture_stdout ( ) : stdout = sys . stdout sys . stdout = six . moves . cStringIO ( ) try : yield sys . stdout finally : sys . stdout = stdout", "docstring_tokens": "Intercept standard output in a with - context : return : cStringIO instance", "label": 1}, {"idx": "cosqa-train-19953", "doc": "how do you join a list into a string python", "code": "def list_to_str(lst):\n    \"\"\"\n    Turn a list into a comma- and/or and-separated string.\n\n    Parameters\n    ----------\n    lst : :obj:`list`\n        A list of strings to join into a single string.\n\n    Returns\n    -------\n    str_ : :obj:`str`\n        A string with commas and/or ands separating th elements from ``lst``.\n\n    \"\"\"\n    if len(lst) == 1:\n        str_ = lst[0]\n    elif len(lst) == 2:\n        str_ = ' and '.join(lst)\n    elif len(lst) > 2:\n        str_ = ', '.join(lst[:-1])\n        str_ += ', and {0}'.format(lst[-1])\n    else:\n        raise ValueError('List of length 0 provided.')\n    return str_", "code_tokens": "def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "docstring_tokens": "Turn a list into a comma - and / or and - separated string .", "label": 0}, {"idx": "cosqa-train-19954", "doc": "how to read file from s3 bucket using python", "code": "def s3_get(url: str, temp_file: IO) -> None:\n    \"\"\"Pull a file directly from S3.\"\"\"\n    s3_resource = boto3.resource(\"s3\")\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)", "code_tokens": "def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "docstring_tokens": "Pull a file directly from S3 .", "label": 0}, {"idx": "cosqa-train-19955", "doc": "python memoryview memory at", "code": "def memory_read(self, start_position: int, size: int) -> memoryview:\n        \"\"\"\n        Read and return a view of ``size`` bytes from memory starting at ``start_position``.\n        \"\"\"\n        return self._memory.read(start_position, size)", "code_tokens": "def memory_read ( self , start_position : int , size : int ) -> memoryview : return self . _memory . read ( start_position , size )", "docstring_tokens": "Read and return a view of size bytes from memory starting at start_position .", "label": 0}, {"idx": "cosqa-train-19956", "doc": "how to get degree of a node of a graph in python", "code": "def spanning_tree_count(graph: nx.Graph) -> int:\n    \"\"\"Return the number of unique spanning trees of a graph, using\n    Kirchhoff's matrix tree theorem.\n    \"\"\"\n    laplacian = nx.laplacian_matrix(graph).toarray()\n    comatrix = laplacian[:-1, :-1]\n    det = np.linalg.det(comatrix)\n    count = int(round(det))\n    return count", "code_tokens": "def spanning_tree_count ( graph : nx . Graph ) -> int : laplacian = nx . laplacian_matrix ( graph ) . toarray ( ) comatrix = laplacian [ : - 1 , : - 1 ] det = np . linalg . det ( comatrix ) count = int ( round ( det ) ) return count", "docstring_tokens": "Return the number of unique spanning trees of a graph using Kirchhoff s matrix tree theorem .", "label": 0}, {"idx": "cosqa-train-19957", "doc": "python strip illegal characters for file name", "code": "def get_valid_filename(s):\n    \"\"\"\n    Returns the given string converted to a string that can be used for a clean\n    filename. Specifically, leading and trailing spaces are removed; other\n    spaces are converted to underscores; and anything that is not a unicode\n    alphanumeric, dash, underscore, or dot, is removed.\n    >>> get_valid_filename(\"john's portrait in 2004.jpg\")\n    'johns_portrait_in_2004.jpg'\n    \"\"\"\n    s = s.strip().replace(\" \", \"_\")\n    return re.sub(r\"(?u)[^-\\w.]\", \"\", s)", "code_tokens": "def get_valid_filename ( s ) : s = s . strip ( ) . replace ( \" \" , \"_\" ) return re . sub ( r\"(?u)[^-\\w.]\" , \"\" , s )", "docstring_tokens": "Returns the given string converted to a string that can be used for a clean filename . Specifically leading and trailing spaces are removed ; other spaces are converted to underscores ; and anything that is not a unicode alphanumeric dash underscore or dot is removed . >>> get_valid_filename ( john s portrait in 2004 . jpg ) johns_portrait_in_2004 . jpg", "label": 0}, {"idx": "cosqa-train-19958", "doc": "python read tokens from line", "code": "def get_tokens(line: str) -> Iterator[str]:\n    \"\"\"\n    Yields tokens from input string.\n\n    :param line: Input string.\n    :return: Iterator over tokens.\n    \"\"\"\n    for token in line.rstrip().split():\n        if len(token) > 0:\n            yield token", "code_tokens": "def get_tokens ( line : str ) -> Iterator [ str ] : for token in line . rstrip ( ) . split ( ) : if len ( token ) > 0 : yield token", "docstring_tokens": "Yields tokens from input string .", "label": 1}, {"idx": "cosqa-train-19959", "doc": "none integer comparison python", "code": "def is_natural(x):\n    \"\"\"A non-negative integer.\"\"\"\n    try:\n        is_integer = int(x) == x\n    except (TypeError, ValueError):\n        return False\n    return is_integer and x >= 0", "code_tokens": "def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "docstring_tokens": "A non - negative integer .", "label": 0}, {"idx": "cosqa-train-19960", "doc": "test for duplicates in python lists", "code": "def find_duplicates(l: list) -> set:\n    \"\"\"\n    Return the duplicates in a list.\n\n    The function relies on\n    https://stackoverflow.com/questions/9835762/find-and-list-duplicates-in-a-list .\n    Parameters\n    ----------\n    l : list\n        Name\n\n    Returns\n    -------\n    set\n        Duplicated values\n\n    >>> find_duplicates([1,2,3])\n    set()\n    >>> find_duplicates([1,2,1])\n    {1}\n    \"\"\"\n    return set([x for x in l if l.count(x) > 1])", "code_tokens": "def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "docstring_tokens": "Return the duplicates in a list .", "label": 0}, {"idx": "cosqa-train-19961", "doc": "python read json as dictonary", "code": "def from_file(file_path) -> dict:\n        \"\"\" Load JSON file \"\"\"\n        with io.open(file_path, 'r', encoding='utf-8') as json_stream:\n            return Json.parse(json_stream, True)", "code_tokens": "def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "docstring_tokens": "Load JSON file", "label": 0}, {"idx": "cosqa-train-19962", "doc": "index of first non zero element in list python", "code": "def most_significant_bit(lst: np.ndarray) -> int:\n    \"\"\"\n    A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s,\n    i.e. the first position where a 1 appears, reading left to right.\n\n    :param lst: a 1d array of 0s and 1s with at least one 1\n    :return: the first position in lst that a 1 appears\n    \"\"\"\n    return np.argwhere(np.asarray(lst) == 1)[0][0]", "code_tokens": "def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "docstring_tokens": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .", "label": 1}, {"idx": "cosqa-train-19963", "doc": "python check most frequent in a list", "code": "def most_frequent(lst):\n    \"\"\"\n    Returns the item that appears most frequently in the given list.\n    \"\"\"\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "code_tokens": "def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "docstring_tokens": "Returns the item that appears most frequently in the given list .", "label": 1}, {"idx": "cosqa-train-19964", "doc": "python check if numerical value or not", "code": "def _is_numeric(self, values):\n        \"\"\"Check to be sure values are numbers before doing numerical operations.\"\"\"\n        if len(values) > 0:\n            assert isinstance(values[0], (float, int)), \\\n                \"values must be numbers to perform math operations. Got {}\".format(\n                    type(values[0]))\n        return True", "code_tokens": "def _is_numeric ( self , values ) : if len ( values ) > 0 : assert isinstance ( values [ 0 ] , ( float , int ) ) , \"values must be numbers to perform math operations. Got {}\" . format ( type ( values [ 0 ] ) ) return True", "docstring_tokens": "Check to be sure values are numbers before doing numerical operations .", "label": 0}, {"idx": "cosqa-train-19965", "doc": "check if whitespace exists python", "code": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)", "code_tokens": "def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "docstring_tokens": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected", "label": 1}, {"idx": "cosqa-train-19966", "doc": "how to check if a variable is integer using type in python", "code": "def _isint(string):\n    \"\"\"\n    >>> _isint(\"123\")\n    True\n    >>> _isint(\"123.45\")\n    False\n    \"\"\"\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "code_tokens": "def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "docstring_tokens": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False", "label": 0}, {"idx": "cosqa-train-19967", "doc": "how to make column right margin in python", "code": "def get_margin(length):\n    \"\"\"Add enough tabs to align in two columns\"\"\"\n    if length > 23:\n        margin_left = \"\\t\"\n        chars = 1\n    elif length > 15:\n        margin_left = \"\\t\\t\"\n        chars = 2\n    elif length > 7:\n        margin_left = \"\\t\\t\\t\"\n        chars = 3\n    else:\n        margin_left = \"\\t\\t\\t\\t\"\n        chars = 4\n    return margin_left", "code_tokens": "def get_margin ( length ) : if length > 23 : margin_left = \"\\t\" chars = 1 elif length > 15 : margin_left = \"\\t\\t\" chars = 2 elif length > 7 : margin_left = \"\\t\\t\\t\" chars = 3 else : margin_left = \"\\t\\t\\t\\t\" chars = 4 return margin_left", "docstring_tokens": "Add enough tabs to align in two columns", "label": 1}, {"idx": "cosqa-train-19968", "doc": "python value is not numeric", "code": "def is_integer(value: Any) -> bool:\n    \"\"\"Return true if a value is an integer number.\"\"\"\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "code_tokens": "def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "docstring_tokens": "Return true if a value is an integer number .", "label": 0}, {"idx": "cosqa-train-19969", "doc": "evaluating if two strings are equal python", "code": "def indexes_equal(a: Index, b: Index) -> bool:\n    \"\"\"\n    Are two indexes equal? Checks by comparing ``str()`` versions of them.\n    (AM UNSURE IF THIS IS ENOUGH.)\n    \"\"\"\n    return str(a) == str(b)", "code_tokens": "def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "docstring_tokens": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )", "label": 0}, {"idx": "cosqa-train-19970", "doc": "python how to check if an absolute path or relative path", "code": "def is_relative_url(url):\n    \"\"\" simple method to determine if a url is relative or absolute \"\"\"\n    if url.startswith(\"#\"):\n        return None\n    if url.find(\"://\") > 0 or url.startswith(\"//\"):\n        # either 'http(s)://...' or '//cdn...' and therefore absolute\n        return False\n    return True", "code_tokens": "def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "docstring_tokens": "simple method to determine if a url is relative or absolute", "label": 1}, {"idx": "cosqa-train-19971", "doc": "python dictionary get top 10 values", "code": "def get_keys_of_max_n(dict_obj, n):\n    \"\"\"Returns the keys that maps to the top n max values in the given dict.\n\n    Example:\n    --------\n    >>> dict_obj = {'a':2, 'b':1, 'c':5}\n    >>> get_keys_of_max_n(dict_obj, 2)\n    ['a', 'c']\n    \"\"\"\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "code_tokens": "def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "docstring_tokens": "Returns the keys that maps to the top n max values in the given dict .", "label": 0}, {"idx": "cosqa-train-19972", "doc": "how to tell python to print something x number of times", "code": "def nTimes(n, f, *args, **kwargs):\n    r\"\"\"Call `f` `n` times with `args` and `kwargs`.\n    Useful e.g. for simplistic timing.\n\n    Examples:\n\n    >>> nTimes(3, sys.stdout.write, 'hallo\\n')\n    hallo\n    hallo\n    hallo\n\n    \"\"\"\n    for i in xrange(n): f(*args, **kwargs)", "code_tokens": "def nTimes ( n , f , * args , * * kwargs ) : for i in xrange ( n ) : f ( * args , * * kwargs )", "docstring_tokens": "r Call f n times with args and kwargs . Useful e . g . for simplistic timing .", "label": 1}, {"idx": "cosqa-train-19973", "doc": "python create dict keys from list", "code": "def encode_list(key, list_):\n    # type: (str, Iterable) -> Dict[str, str]\n    \"\"\"\n    Converts a list into a space-separated string and puts it in a dictionary\n\n    :param key: Dictionary key to store the list\n    :param list_: A list of objects\n    :return: A dictionary key->string or an empty dictionary\n    \"\"\"\n    if not list_:\n        return {}\n    return {key: \" \".join(str(i) for i in list_)}", "code_tokens": "def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "docstring_tokens": "Converts a list into a space - separated string and puts it in a dictionary", "label": 0}, {"idx": "cosqa-train-19974", "doc": "how to check image size using size in python", "code": "def _width_is_big_enough(image, width):\n    \"\"\"Check that the image width is superior to `width`\"\"\"\n    if width > image.size[0]:\n        raise ImageSizeError(image.size[0], width)", "code_tokens": "def _width_is_big_enough ( image , width ) : if width > image . size [ 0 ] : raise ImageSizeError ( image . size [ 0 ] , width )", "docstring_tokens": "Check that the image width is superior to width", "label": 1}, {"idx": "cosqa-train-19975", "doc": "python assert to compare values", "code": "def assert_equal(first, second, msg_fmt=\"{msg}\"):\n    \"\"\"Fail unless first equals second, as determined by the '==' operator.\n\n    >>> assert_equal(5, 5.0)\n    >>> assert_equal(\"Hello World!\", \"Goodbye!\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'Hello World!' != 'Goodbye!'\n\n    The following msg_fmt arguments are supported:\n    * msg - the default error message\n    * first - the first argument\n    * second - the second argument\n    \"\"\"\n\n    if isinstance(first, dict) and isinstance(second, dict):\n        assert_dict_equal(first, second, msg_fmt)\n    elif not first == second:\n        msg = \"{!r} != {!r}\".format(first, second)\n        fail(msg_fmt.format(msg=msg, first=first, second=second))", "code_tokens": "def assert_equal ( first , second , msg_fmt = \"{msg}\" ) : if isinstance ( first , dict ) and isinstance ( second , dict ) : assert_dict_equal ( first , second , msg_fmt ) elif not first == second : msg = \"{!r} != {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "docstring_tokens": "Fail unless first equals second as determined by the == operator .", "label": 0}, {"idx": "cosqa-train-19976", "doc": "printing concatanated strigns python", "code": "def add_colons(s):\n    \"\"\"Add colons after every second digit.\n\n    This function is used in functions to prettify serials.\n\n    >>> add_colons('teststring')\n    'te:st:st:ri:ng'\n    \"\"\"\n    return ':'.join([s[i:i + 2] for i in range(0, len(s), 2)])", "code_tokens": "def add_colons ( s ) : return ':' . join ( [ s [ i : i + 2 ] for i in range ( 0 , len ( s ) , 2 ) ] )", "docstring_tokens": "Add colons after every second digit .", "label": 0}, {"idx": "cosqa-train-19977", "doc": "python unpack bac char in struct format", "code": "def label_from_bin(buf):\n    \"\"\"\n    Converts binary representation label to integer.\n\n    :param buf: Binary representation of label.\n    :return: MPLS Label and BoS bit.\n    \"\"\"\n\n    mpls_label = type_desc.Int3.to_user(six.binary_type(buf))\n    return mpls_label >> 4, mpls_label & 1", "code_tokens": "def label_from_bin ( buf ) : mpls_label = type_desc . Int3 . to_user ( six . binary_type ( buf ) ) return mpls_label >> 4 , mpls_label & 1", "docstring_tokens": "Converts binary representation label to integer .", "label": 1}, {"idx": "cosqa-train-19978", "doc": "python pad string with zeros left", "code": "def zfill(x, width):\n    \"\"\"zfill(x, width) -> string\n\n    Pad a numeric string x with zeros on the left, to fill a field\n    of the specified width.  The string x is never truncated.\n\n    \"\"\"\n    if not isinstance(x, basestring):\n        x = repr(x)\n    return x.zfill(width)", "code_tokens": "def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "docstring_tokens": "zfill ( x width ) - > string", "label": 1}, {"idx": "cosqa-train-19979", "doc": "python check if file exists and is file", "code": "def valid_file(path: str) -> bool:\n    \"\"\"\n    Verifies that a string path actually exists and is a file\n\n    :param path: The path to verify\n    :return: **True** if path exist and is a file\n    \"\"\"\n    path = Path(path).expanduser()\n    log.debug(\"checking if %s is a valid file\", path)\n    return path.exists() and path.is_file()", "code_tokens": "def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "docstring_tokens": "Verifies that a string path actually exists and is a file", "label": 0}, {"idx": "cosqa-train-19980", "doc": "calculating the midpoint between 2 data points in python", "code": "def _mid(pt1, pt2):\n    \"\"\"\n    (Point, Point) -> Point\n    Return the point that lies in between the two input points.\n    \"\"\"\n    (x0, y0), (x1, y1) = pt1, pt2\n    return 0.5 * (x0 + x1), 0.5 * (y0 + y1)", "code_tokens": "def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "docstring_tokens": "( Point Point ) - > Point Return the point that lies in between the two input points .", "label": 1}, {"idx": "cosqa-train-19981", "doc": "python open any file encoding", "code": "def copen(filepath, flag='r', encoding=None):\n\n    \"\"\"\n    FIXME: How to test this ?\n\n    >>> c = copen(__file__)\n    >>> c is not None\n    True\n    \"\"\"\n    if encoding is None:\n        encoding = locale.getdefaultlocale()[1]\n\n    return codecs.open(filepath, flag, encoding)", "code_tokens": "def copen ( filepath , flag = 'r' , encoding = None ) : if encoding is None : encoding = locale . getdefaultlocale ( ) [ 1 ] return codecs . open ( filepath , flag , encoding )", "docstring_tokens": "FIXME : How to test this ?", "label": 1}, {"idx": "cosqa-train-19982", "doc": "python get all dict keys filter by value", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-19983", "doc": "python limiting memory usage", "code": "def memory_full():\n    \"\"\"Check if the memory is too full for further caching.\"\"\"\n    current_process = psutil.Process(os.getpid())\n    return (current_process.memory_percent() >\n            config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)", "code_tokens": "def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "docstring_tokens": "Check if the memory is too full for further caching .", "label": 1}, {"idx": "cosqa-train-19984", "doc": "python longest path algorithm", "code": "def dag_longest_path(graph, source, target):\n    \"\"\"\n    Finds the longest path in a dag between two nodes\n    \"\"\"\n    if source == target:\n        return [source]\n    allpaths = nx.all_simple_paths(graph, source, target)\n    longest_path = []\n    for l in allpaths:\n        if len(l) > len(longest_path):\n            longest_path = l\n    return longest_path", "code_tokens": "def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "docstring_tokens": "Finds the longest path in a dag between two nodes", "label": 0}, {"idx": "cosqa-train-19985", "doc": "determine if a list of numbers contains duplicates python", "code": "def find_duplicates(l: list) -> set:\n    \"\"\"\n    Return the duplicates in a list.\n\n    The function relies on\n    https://stackoverflow.com/questions/9835762/find-and-list-duplicates-in-a-list .\n    Parameters\n    ----------\n    l : list\n        Name\n\n    Returns\n    -------\n    set\n        Duplicated values\n\n    >>> find_duplicates([1,2,3])\n    set()\n    >>> find_duplicates([1,2,1])\n    {1}\n    \"\"\"\n    return set([x for x in l if l.count(x) > 1])", "code_tokens": "def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "docstring_tokens": "Return the duplicates in a list .", "label": 1}, {"idx": "cosqa-train-19986", "doc": "do uppercase matter python", "code": "def uppercase_chars(string: any) -> str:\n        \"\"\"Return all (and only) the uppercase chars in the given string.\"\"\"\n        return ''.join([c if c.isupper() else '' for c in str(string)])", "code_tokens": "def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "docstring_tokens": "Return all ( and only ) the uppercase chars in the given string .", "label": 0}, {"idx": "cosqa-train-19987", "doc": "python , how to read 40 bytes from bytes array", "code": "def convert_bytes_to_ints(in_bytes, num):\n    \"\"\"Convert a byte array into an integer array. The number of bytes forming an integer\n    is defined by num\n\n    :param in_bytes: the input bytes\n    :param num: the number of bytes per int\n    :return the integer array\"\"\"\n    dt = numpy.dtype('>i' + str(num))\n    return numpy.frombuffer(in_bytes, dt)", "code_tokens": "def convert_bytes_to_ints ( in_bytes , num ) : dt = numpy . dtype ( '>i' + str ( num ) ) return numpy . frombuffer ( in_bytes , dt )", "docstring_tokens": "Convert a byte array into an integer array . The number of bytes forming an integer is defined by num", "label": 1}, {"idx": "cosqa-train-19988", "doc": "python code to covert matrix to tensorflow object", "code": "def astensor(array: TensorLike) -> BKTensor:\n    \"\"\"Covert numpy array to tensorflow tensor\"\"\"\n    tensor = tf.convert_to_tensor(value=array, dtype=CTYPE)\n    return tensor", "code_tokens": "def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "docstring_tokens": "Covert numpy array to tensorflow tensor", "label": 0}, {"idx": "cosqa-train-19989", "doc": "python snake or camel case", "code": "def camel_to_snake(s: str) -> str:\n    \"\"\"Convert string from camel case to snake case.\"\"\"\n\n    return CAMEL_CASE_RE.sub(r'_\\1', s).strip().lower()", "code_tokens": "def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "docstring_tokens": "Convert string from camel case to snake case .", "label": 1}, {"idx": "cosqa-train-19990", "doc": "python test whether file is empty", "code": "def isfile_notempty(inputfile: str) -> bool:\n        \"\"\"Check if the input filename with path is a file and is not empty.\"\"\"\n        try:\n            return isfile(inputfile) and getsize(inputfile) > 0\n        except TypeError:\n            raise TypeError('inputfile is not a valid type')", "code_tokens": "def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )", "docstring_tokens": "Check if the input filename with path is a file and is not empty .", "label": 0}, {"idx": "cosqa-train-19991", "doc": "python filter map on key values", "code": "def _(f, x):\n    \"\"\"\n    filter for dict, note `f` should have signature: `f::key->value->bool`\n    \"\"\"\n    return {k: v for k, v in x.items() if f(k, v)}", "code_tokens": "def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "docstring_tokens": "filter for dict note f should have signature : f :: key - > value - > bool", "label": 0}, {"idx": "cosqa-train-19992", "doc": "request python post api", "code": "def post(self, endpoint: str, **kwargs) -> dict:\n        \"\"\"HTTP POST operation to API endpoint.\"\"\"\n\n        return self._request('POST', endpoint, **kwargs)", "code_tokens": "def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "docstring_tokens": "HTTP POST operation to API endpoint .", "label": 0}, {"idx": "cosqa-train-19993", "doc": "how to turn js array into python list", "code": "def __as_list(value: List[JsonObjTypes]) -> List[JsonTypes]:\n        \"\"\" Return a json array as a list\n\n        :param value: array\n        :return: array with JsonObj instances removed\n        \"\"\"\n        return [e._as_dict if isinstance(e, JsonObj) else e for e in value]", "code_tokens": "def __as_list ( value : List [ JsonObjTypes ] ) -> List [ JsonTypes ] : return [ e . _as_dict if isinstance ( e , JsonObj ) else e for e in value ]", "docstring_tokens": "Return a json array as a list", "label": 0}, {"idx": "cosqa-train-19994", "doc": "python text to bool", "code": "def text_to_bool(value: str) -> bool:\n    \"\"\"\n    Tries to convert a text value to a bool. If unsuccessful returns if value is None or not\n\n    :param value: Value to check\n    \"\"\"\n    try:\n        return bool(strtobool(value))\n    except (ValueError, AttributeError):\n        return value is not None", "code_tokens": "def text_to_bool ( value : str ) -> bool : try : return bool ( strtobool ( value ) ) except ( ValueError , AttributeError ) : return value is not None", "docstring_tokens": "Tries to convert a text value to a bool . If unsuccessful returns if value is None or not", "label": 0}, {"idx": "cosqa-train-19995", "doc": "python call callback async", "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Utility method to run commands synchronously for testing.\n        \"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Event loop is already running.\")\n\n        if not self.is_connected:\n            self.loop.run_until_complete(self.connect())\n\n        task = asyncio.Task(method(*args, **kwargs), loop=self.loop)\n        result = self.loop.run_until_complete(task)\n\n        self.loop.run_until_complete(self.quit())\n\n        return result", "code_tokens": "def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "docstring_tokens": "Utility method to run commands synchronously for testing .", "label": 0}, {"idx": "cosqa-train-19996", "doc": "how to tell if a set is empty in python", "code": "def is_any_type_set(sett: Set[Type]) -> bool:\n    \"\"\"\n    Helper method to check if a set of types is the {AnyObject} singleton\n\n    :param sett:\n    :return:\n    \"\"\"\n    return len(sett) == 1 and is_any_type(min(sett))", "code_tokens": "def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )", "docstring_tokens": "Helper method to check if a set of types is the { AnyObject } singleton", "label": 1}, {"idx": "cosqa-train-19997", "doc": "python test if environment var is undefined or empty", "code": "def _check_env_var(envvar: str) -> bool:\n    \"\"\"Check Environment Variable to verify that it is set and not empty.\n\n    :param envvar: Environment Variable to Check.\n\n    :returns: True if Environment Variable is set and not empty.\n\n    :raises: KeyError if Environment Variable is not set or is empty.\n\n    .. versionadded:: 0.0.12\n    \"\"\"\n    if os.getenv(envvar) is None:\n        raise KeyError(\n            \"Required ENVVAR: {0} is not set\".format(envvar))\n    if not os.getenv(envvar):  # test if env var is empty\n        raise KeyError(\n            \"Required ENVVAR: {0} is empty\".format(envvar))\n    return True", "code_tokens": "def _check_env_var ( envvar : str ) -> bool : if os . getenv ( envvar ) is None : raise KeyError ( \"Required ENVVAR: {0} is not set\" . format ( envvar ) ) if not os . getenv ( envvar ) : # test if env var is empty raise KeyError ( \"Required ENVVAR: {0} is empty\" . format ( envvar ) ) return True", "docstring_tokens": "Check Environment Variable to verify that it is set and not empty .", "label": 0}, {"idx": "cosqa-train-19998", "doc": "python isnan how to check if an entire column is nan", "code": "def warn_if_nans_exist(X):\n    \"\"\"Warn if nans exist in a numpy array.\"\"\"\n    null_count = count_rows_with_nans(X)\n    total = len(X)\n    percent = 100 * null_count / total\n\n    if null_count > 0:\n        warning_message = \\\n            'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\\n            'complete rows will be plotted.'.format(null_count, total, percent)\n        warnings.warn(warning_message, DataWarning)", "code_tokens": "def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "docstring_tokens": "Warn if nans exist in a numpy array .", "label": 1}, {"idx": "cosqa-train-19999", "doc": "python 2 pyodbc executemany", "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None:\n        \"\"\"Execute the given multiquery.\"\"\"\n        await self._execute(self._cursor.executemany, sql, parameters)", "code_tokens": "async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "docstring_tokens": "Execute the given multiquery .", "label": 1}]